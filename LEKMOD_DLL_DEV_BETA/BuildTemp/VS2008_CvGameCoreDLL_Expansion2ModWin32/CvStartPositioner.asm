; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvStartPositioner.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG220244 DB	'Player Start Plot Draft Order', 00H
	ORG $+2
$SG220270 DB	'Trying to place major civ with full separation of %d', 00H
	ORG $+3
$SG220285 DB	'Trying to place major civ with reduced separation of %d', 00H
$SG220296 DB	'Trying to place minor civ with full separation of %d', 00H
	ORG $+3
$SG220314 DB	'Trying to place minor civ with reduced separation of %d', 00H
$SG220500 DB	'Adding player, id = %d, plot x = %d, y = %d, fertility ='
	DB	' %u', 00H
$SG220557 DB	'StartPositionLog.csv', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??0CvContinent@@QAE@XZ				; CvContinent::CvContinent
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.h
;	COMDAT ??0CvContinent@@QAE@XZ
_TEXT	SEGMENT
??0CvContinent@@QAE@XZ PROC				; CvContinent::CvContinent, COMDAT
; _this$ = ecx

; 24   : 	CvContinent()

	mov	eax, ecx

; 25   : 	{
; 26   : 		m_uiFertility = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 27   : 		m_iRegionsAssigned = 0;

	mov	DWORD PTR [eax+8], ecx

; 28   : 		m_uiFertilityNextRegion = 0;

	mov	DWORD PTR [eax+4], ecx

; 29   : 		m_iAreaID = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [eax+12], -1

; 30   : 	}

	ret	0
??0CvContinent@@QAE@XZ ENDP				; CvContinent::CvContinent
_TEXT	ENDS
PUBLIC	??0CvContinent@@QAE@ABV0@@Z			; CvContinent::CvContinent
; Function compile flags: /Ogtpy
;	COMDAT ??0CvContinent@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0CvContinent@@QAE@ABV0@@Z PROC			; CvContinent::CvContinent, COMDAT
; _this$ = ecx

; 32   : 	CvContinent(const CvContinent& source)

	mov	eax, ecx

; 33   : 	{
; 34   : 		m_uiFertility = source.m_uiFertility;

	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 		m_iRegionsAssigned = source.m_iRegionsAssigned;

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 36   : 		m_uiFertilityNextRegion = source.m_uiFertilityNextRegion;

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 37   : 		m_iAreaID = source.m_iAreaID;

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 38   : 	}

	ret	4
??0CvContinent@@QAE@ABV0@@Z ENDP			; CvContinent::CvContinent
_TEXT	ENDS
PUBLIC	??MCvContinent@@QAE_NABV0@@Z			; CvContinent::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvContinent@@QAE_NABV0@@Z
_TEXT	SEGMENT
_continent$ = 8						; size = 4
??MCvContinent@@QAE_NABV0@@Z PROC			; CvContinent::operator<, COMDAT
; _this$ = ecx

; 42   : 		return (m_uiFertilityNextRegion > continent.m_uiFertilityNextRegion);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _continent$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 43   : 	}

	ret	4
??MCvContinent@@QAE_NABV0@@Z ENDP			; CvContinent::operator<
_TEXT	ENDS
PUBLIC	?AddRegion@CvContinent@@QAEXXZ			; CvContinent::AddRegion
; Function compile flags: /Ogtpy
;	COMDAT ?AddRegion@CvContinent@@QAEXXZ
_TEXT	SEGMENT
?AddRegion@CvContinent@@QAEXXZ PROC			; CvContinent::AddRegion, COMDAT
; _this$ = ecx

; 47   : 		m_iRegionsAssigned++;

	inc	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+8]
	push	esi

; 48   : 		m_uiFertilityNextRegion = m_uiFertility / (m_iRegionsAssigned + 1);

	lea	esi, DWORD PTR [eax+1]
	mov	eax, DWORD PTR [ecx]
	cdq
	idiv	esi
	pop	esi
	mov	DWORD PTR [ecx+4], eax

; 49   : 	}

	ret	0
?AddRegion@CvContinent@@QAEXXZ ENDP			; CvContinent::AddRegion
_TEXT	ENDS
PUBLIC	?GetNumRegions@CvContinent@@QBEHXZ		; CvContinent::GetNumRegions
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumRegions@CvContinent@@QBEHXZ
_TEXT	SEGMENT
?GetNumRegions@CvContinent@@QBEHXZ PROC			; CvContinent::GetNumRegions, COMDAT
; _this$ = ecx

; 53   : 		return m_iRegionsAssigned;

	mov	eax, DWORD PTR [ecx+8]

; 54   : 	}

	ret	0
?GetNumRegions@CvContinent@@QBEHXZ ENDP			; CvContinent::GetNumRegions
_TEXT	ENDS
PUBLIC	?SetFertility@CvContinent@@QAEXH@Z		; CvContinent::SetFertility
; Function compile flags: /Ogtpy
;	COMDAT ?SetFertility@CvContinent@@QAEXH@Z
_TEXT	SEGMENT
_uiFertility$ = 8					; size = 4
?SetFertility@CvContinent@@QAEXH@Z PROC			; CvContinent::SetFertility, COMDAT
; _this$ = ecx

; 58   : 		m_uiFertility = uiFertility;

	mov	eax, DWORD PTR _uiFertility$[esp-4]
	mov	DWORD PTR [ecx], eax

; 59   : 		m_uiFertilityNextRegion = uiFertility;

	mov	DWORD PTR [ecx+4], eax

; 60   : 	}

	ret	4
?SetFertility@CvContinent@@QAEXH@Z ENDP			; CvContinent::SetFertility
_TEXT	ENDS
PUBLIC	?GetFertility@CvContinent@@QBEHXZ		; CvContinent::GetFertility
; Function compile flags: /Ogtpy
;	COMDAT ?GetFertility@CvContinent@@QBEHXZ
_TEXT	SEGMENT
?GetFertility@CvContinent@@QBEHXZ PROC			; CvContinent::GetFertility, COMDAT
; _this$ = ecx

; 64   : 		return m_uiFertility;

	mov	eax, DWORD PTR [ecx]

; 65   : 	}

	ret	0
?GetFertility@CvContinent@@QBEHXZ ENDP			; CvContinent::GetFertility
_TEXT	ENDS
PUBLIC	?SetArea@CvContinent@@QAEXH@Z			; CvContinent::SetArea
; Function compile flags: /Ogtpy
;	COMDAT ?SetArea@CvContinent@@QAEXH@Z
_TEXT	SEGMENT
_iAreaID$ = 8						; size = 4
?SetArea@CvContinent@@QAEXH@Z PROC			; CvContinent::SetArea, COMDAT
; _this$ = ecx

; 69   : 		m_iAreaID = iAreaID;

	mov	eax, DWORD PTR _iAreaID$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 70   : 	}

	ret	4
?SetArea@CvContinent@@QAEXH@Z ENDP			; CvContinent::SetArea
_TEXT	ENDS
PUBLIC	?GetArea@CvContinent@@QBEHXZ			; CvContinent::GetArea
; Function compile flags: /Ogtpy
;	COMDAT ?GetArea@CvContinent@@QBEHXZ
_TEXT	SEGMENT
?GetArea@CvContinent@@QBEHXZ PROC			; CvContinent::GetArea, COMDAT
; _this$ = ecx

; 74   : 		return m_iAreaID;

	mov	eax, DWORD PTR [ecx+12]

; 75   : 	}

	ret	0
?GetArea@CvContinent@@QBEHXZ ENDP			; CvContinent::GetArea
_TEXT	ENDS
PUBLIC	??MCvStartRegion@@QAE_NABV0@@Z			; CvStartRegion::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvStartRegion@@QAE_NABV0@@Z
_TEXT	SEGMENT
_continent$ = 8						; size = 4
??MCvStartRegion@@QAE_NABV0@@Z PROC			; CvStartRegion::operator<, COMDAT
; _this$ = ecx

; 117  : 		return (m_uiFertility / (m_iNumCivsPlaced + 1) >
; 118  : 		        continent.m_uiFertility / (continent.m_iNumCivsPlaced + 1));

	mov	eax, DWORD PTR _continent$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [eax+16]
	cdq
	inc	esi
	idiv	esi
	push	edi
	mov	edi, DWORD PTR [ecx+28]
	inc	edi
	mov	esi, eax
	mov	eax, DWORD PTR [ecx+16]
	cdq
	idiv	edi
	xor	ecx, ecx
	pop	edi
	cmp	eax, esi
	setg	cl
	mov	al, cl
	pop	esi

; 119  : 	}

	ret	4
??MCvStartRegion@@QAE_NABV0@@Z ENDP			; CvStartRegion::operator<
_TEXT	ENDS
PUBLIC	?Contains@CvStartRegion@@QAE_NHH@Z		; CvStartRegion::Contains
; Function compile flags: /Ogtpy
;	COMDAT ?Contains@CvStartRegion@@QAE_NHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?Contains@CvStartRegion@@QAE_NHH@Z PROC			; CvStartRegion::Contains, COMDAT
; _this$ = ecx

; 123  : 		if(iX > m_Boundaries.m_iEastEdge ||
; 124  : 		        iX < m_Boundaries.m_iWestEdge ||
; 125  : 		        iY > m_Boundaries.m_iNorthEdge ||
; 126  : 		        iY < m_Boundaries.m_iSouthEdge)

	mov	eax, DWORD PTR _iX$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jg	SHORT $LN1@Contains
	cmp	eax, DWORD PTR [ecx+12]
	jl	SHORT $LN1@Contains
	mov	eax, DWORD PTR _iY$[esp-4]
	cmp	eax, DWORD PTR [ecx]
	jg	SHORT $LN1@Contains
	cmp	eax, DWORD PTR [ecx+4]
	jl	SHORT $LN1@Contains

; 129  : 		}
; 130  : 		return true;

	mov	al, 1

; 131  : 	}

	ret	8
$LN1@Contains:

; 127  : 		{
; 128  : 			return false;

	xor	al, al

; 131  : 	}

	ret	8
?Contains@CvStartRegion@@QAE_NHH@Z ENDP			; CvStartRegion::Contains
_TEXT	ENDS
PUBLIC	??0CvPlayerStartRank@@QAE@XZ			; CvPlayerStartRank::CvPlayerStartRank
; Function compile flags: /Ogtpy
;	COMDAT ??0CvPlayerStartRank@@QAE@XZ
_TEXT	SEGMENT
??0CvPlayerStartRank@@QAE@XZ PROC			; CvPlayerStartRank::CvPlayerStartRank, COMDAT
; _this$ = ecx

; 152  : 	CvPlayerStartRank()

	mov	eax, ecx

; 153  : 	{
; 154  : 		m_iPlayerID = NO_PLAYER;

	mov	DWORD PTR [eax], -1

; 155  : 		m_iRank = 0;

	mov	DWORD PTR [eax+4], 0

; 156  : 	}

	ret	0
??0CvPlayerStartRank@@QAE@XZ ENDP			; CvPlayerStartRank::CvPlayerStartRank
_TEXT	ENDS
PUBLIC	??0CvPlayerStartRank@@QAE@ABV0@@Z		; CvPlayerStartRank::CvPlayerStartRank
; Function compile flags: /Ogtpy
;	COMDAT ??0CvPlayerStartRank@@QAE@ABV0@@Z
_TEXT	SEGMENT
_startRankObj$ = 8					; size = 4
??0CvPlayerStartRank@@QAE@ABV0@@Z PROC			; CvPlayerStartRank::CvPlayerStartRank, COMDAT
; _this$ = ecx

; 158  : 	CvPlayerStartRank(const CvPlayerStartRank& startRankObj)

	mov	eax, ecx

; 159  : 	{
; 160  : 		m_iPlayerID = startRankObj.m_iPlayerID;

	mov	ecx, DWORD PTR _startRankObj$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 161  : 		m_iRank = startRankObj.m_iRank;

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 162  : 	}

	ret	4
??0CvPlayerStartRank@@QAE@ABV0@@Z ENDP			; CvPlayerStartRank::CvPlayerStartRank
_TEXT	ENDS
PUBLIC	??MCvPlayerStartRank@@QAE_NABV0@@Z		; CvPlayerStartRank::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvPlayerStartRank@@QAE_NABV0@@Z
_TEXT	SEGMENT
_startRankObj$ = 8					; size = 4
??MCvPlayerStartRank@@QAE_NABV0@@Z PROC			; CvPlayerStartRank::operator<, COMDAT
; _this$ = ecx

; 166  : 		return (m_iRank < startRankObj.m_iRank);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _startRankObj$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	mov	al, cl

; 167  : 	}

	ret	4
??MCvPlayerStartRank@@QAE_NABV0@@Z ENDP			; CvPlayerStartRank::operator<
_TEXT	ENDS
PUBLIC	?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z ; CvStartPositioner::Init
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z
_TEXT	SEGMENT
_pSiteEvaluator$ = 8					; size = 4
?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z PROC ; CvStartPositioner::Init, COMDAT
; _this$ = ecx

; 37   : 	CvAssert(pSiteEvaluator);
; 38   : 	if(!pSiteEvaluator)

	mov	eax, DWORD PTR _pSiteEvaluator$[esp-4]
	test	eax, eax
	je	SHORT $LN2@Init

; 39   : 		return;
; 40   : 
; 41   : 	m_pSiteEvaluator = pSiteEvaluator;

	mov	DWORD PTR [ecx+4], eax

; 42   : 	m_pSiteEvaluator->ComputeFlavorMultipliers(NULL);  // Ignore flavors; this sets them to 1

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _pSiteEvaluator$[esp-4], 0
	jmp	eax
$LN2@Init:

; 43   : }

	ret	4
?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z ENDP ; CvStartPositioner::Init
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 727  : 		}

	ret	0
?size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAVCvContinent@@I@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAVCvContinent@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAVCvContinent@@I@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+4]

; 786  : 		}

	ret	4
??A?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAVCvContinent@@I@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 5

; 727  : 		}

	ret	0
?size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAVCvStartRegion@@I@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAVCvStartRegion@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAVCvStartRegion@@I@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+4]

; 786  : 		}

	ret	4
??A?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAVCvStartRegion@@I@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAVCvPlayerStartRank@@I@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAVCvPlayerStartRank@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAVCvPlayerStartRank@@I@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 786  : 		}

	ret	4
??A?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAVCvPlayerStartRank@@I@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 4

; 636  : 		}

	ret	0
?capacity@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >::~_Container_base_aux_alloc_empty<std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >::~_Container_base_aux_alloc_empty<std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >::~_Container_base_aux_alloc_empty<std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvContinent@@@std@@QAE@XZ	; std::allocator<CvContinent>::allocator<CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvContinent@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvContinent@@@std@@QAE@XZ PROC		; std::allocator<CvContinent>::allocator<CvContinent>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvContinent@@@std@@QAE@XZ ENDP		; std::allocator<CvContinent>::allocator<CvContinent>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 5

; 636  : 		}

	ret	0
?capacity@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >::~_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >::~_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >::~_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvStartRegion@@@std@@QAE@XZ	; std::allocator<CvStartRegion>::allocator<CvStartRegion>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvStartRegion@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvStartRegion@@@std@@QAE@XZ PROC	; std::allocator<CvStartRegion>::allocator<CvStartRegion>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvStartRegion@@@std@@QAE@XZ ENDP	; std::allocator<CvStartRegion>::allocator<CvStartRegion>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvPlayerStartRank@@@std@@QAE@XZ	; std::allocator<CvPlayerStartRank>::allocator<CvPlayerStartRank>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvPlayerStartRank@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvPlayerStartRank@@@std@@QAE@XZ PROC	; std::allocator<CvPlayerStartRank>::allocator<CvPlayerStartRank>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvPlayerStartRank@@@std@@QAE@XZ ENDP	; std::allocator<CvPlayerStartRank>::allocator<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T224418 = -80						; size = 28
$T224417 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T224418[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T224417[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T224418[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T224417[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T224417[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T224417[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T224417[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T224418[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T224417[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >::_Container_base_aux_alloc_empty<std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvContinent@@@std@@QAE@ABV01@@Z	; std::allocator<CvContinent>::allocator<CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvContinent@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvContinent@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvContinent>::allocator<CvContinent>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvContinent@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvContinent>::allocator<CvContinent>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@I@Z ; std::allocator<CvContinent>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@I@Z PROC ; std::allocator<CvContinent>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@I@Z ENDP ; std::allocator<CvContinent>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T224453 = -80						; size = 28
$T224452 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T224453[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T224452[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T224453[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T224452[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T224452[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T224452[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T224452[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T224453[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T224452[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >::_Container_base_aux_alloc_empty<std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvStartRegion@@@std@@QAE@ABV01@@Z ; std::allocator<CvStartRegion>::allocator<CvStartRegion>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvStartRegion@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvStartRegion@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvStartRegion>::allocator<CvStartRegion>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvStartRegion@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvStartRegion>::allocator<CvStartRegion>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@I@Z ; std::allocator<CvStartRegion>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@I@Z PROC ; std::allocator<CvStartRegion>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@I@Z ENDP ; std::allocator<CvStartRegion>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T224487 = -80						; size = 28
$T224486 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T224487[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T224486[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T224487[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T224486[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T224486[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T224486[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T224486[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T224487[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T224486[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvPlayerStartRank@@@std@@QAE@ABV01@@Z ; std::allocator<CvPlayerStartRank>::allocator<CvPlayerStartRank>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvPlayerStartRank@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvPlayerStartRank@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPlayerStartRank>::allocator<CvPlayerStartRank>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvPlayerStartRank@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPlayerStartRank>::allocator<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@I@Z ; std::allocator<CvPlayerStartRank>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@I@Z PROC ; std::allocator<CvPlayerStartRank>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@I@Z ENDP ; std::allocator<CvPlayerStartRank>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 5

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvContinent@@@std@@QBEIXZ ; std::allocator<CvContinent>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvContinent@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvContinent@@@std@@QBEIXZ PROC	; std::allocator<CvContinent>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvContinent@@@std@@QBEIXZ ENDP	; std::allocator<CvContinent>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvStartRegion@@@std@@QBEIXZ ; std::allocator<CvStartRegion>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvStartRegion@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvStartRegion@@@std@@QBEIXZ PROC	; std::allocator<CvStartRegion>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 134217727				; 07ffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvStartRegion@@@std@@QBEIXZ ENDP	; std::allocator<CvStartRegion>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvPlayerStartRank@@@std@@QBEIXZ ; std::allocator<CvPlayerStartRank>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvPlayerStartRank@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvPlayerStartRank@@@std@@QBEIXZ PROC ; std::allocator<CvPlayerStartRank>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvPlayerStartRank@@@std@@QBEIXZ ENDP ; std::allocator<CvPlayerStartRank>::max_size
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator==
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 5
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z
_TEXT	SEGMENT
$T224577 = -12						; size = 12
$T224581 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z PROC ; std::_Allocate<CvContinent>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T224581[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T224577[esp+16]
	mov	DWORD PTR $T224581[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T224577[esp+16]
	push	ecx
	mov	DWORD PTR $T224577[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ENDP ; std::_Allocate<CvContinent>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z
_TEXT	SEGMENT
$T224587 = -12						; size = 12
$T224591 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z PROC ; std::_Allocate<CvStartRegion>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T224591[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T224587[esp+16]
	mov	DWORD PTR $T224591[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T224587[esp+16]
	push	ecx
	mov	DWORD PTR $T224587[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ENDP ; std::_Allocate<CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z
_TEXT	SEGMENT
$T224597 = -12						; size = 12
$T224601 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z PROC ; std::_Allocate<CvPlayerStartRank>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T224601[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T224597[esp+16]
	mov	DWORD PTR $T224601[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T224597[esp+16]
	push	ecx
	mov	DWORD PTR $T224597[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ENDP ; std::_Allocate<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 5

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvContinent@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvContinent@@0@Z ; std::_Iter_random<CvContinent *,CvContinent *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvContinent@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvContinent@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvContinent@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvContinent@@0@Z PROC ; std::_Iter_random<CvContinent *,CvContinent *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvContinent@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvContinent@@0@Z ENDP ; std::_Iter_random<CvContinent *,CvContinent *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvContinent@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvContinent@@0@Z ; std::_Ptr_cat<CvContinent *,CvContinent *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvContinent@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvContinent@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvContinent@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvContinent@@0@Z PROC ; std::_Ptr_cat<CvContinent *,CvContinent *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvContinent@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvContinent@@0@Z ENDP ; std::_Ptr_cat<CvContinent *,CvContinent *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvStartRegion@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvStartRegion@@0@Z ; std::_Iter_random<CvStartRegion *,CvStartRegion *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvStartRegion@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvStartRegion@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvStartRegion@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvStartRegion@@0@Z PROC ; std::_Iter_random<CvStartRegion *,CvStartRegion *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvStartRegion@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvStartRegion@@0@Z ENDP ; std::_Iter_random<CvStartRegion *,CvStartRegion *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvStartRegion@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvStartRegion@@0@Z ; std::_Ptr_cat<CvStartRegion *,CvStartRegion *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvStartRegion@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvStartRegion@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvStartRegion@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvStartRegion@@0@Z PROC ; std::_Ptr_cat<CvStartRegion *,CvStartRegion *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvStartRegion@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvStartRegion@@0@Z ENDP ; std::_Ptr_cat<CvStartRegion *,CvStartRegion *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN1@Copy_opt@2
	push	esi
	push	edi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, edx
	mov	edi, eax
	add	edx, 32					; 00000020H
	mov	ecx, 8
	add	eax, 32					; 00000020H
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL3@Copy_opt@2
	pop	edi
	pop	esi
$LN1@Copy_opt@2:
	pop	ebx

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvPlayerStartRank@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPlayerStartRank@@0@Z ; std::_Iter_random<CvPlayerStartRank *,CvPlayerStartRank *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvPlayerStartRank@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPlayerStartRank@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvPlayerStartRank@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPlayerStartRank@@0@Z PROC ; std::_Iter_random<CvPlayerStartRank *,CvPlayerStartRank *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvPlayerStartRank@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPlayerStartRank@@0@Z ENDP ; std::_Iter_random<CvPlayerStartRank *,CvPlayerStartRank *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvPlayerStartRank@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPlayerStartRank@@0@Z ; std::_Ptr_cat<CvPlayerStartRank *,CvPlayerStartRank *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvPlayerStartRank@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPlayerStartRank@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvPlayerStartRank@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPlayerStartRank@@0@Z PROC ; std::_Ptr_cat<CvPlayerStartRank *,CvPlayerStartRank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvPlayerStartRank@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPlayerStartRank@@0@Z ENDP ; std::_Ptr_cat<CvPlayerStartRank *,CvPlayerStartRank *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@3
	push	esi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@3
	pop	esi
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z ; std::_Fill<CvContinent *,CvContinent>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z PROC ; std::_Fill<CvContinent *,CvContinent>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z ENDP ; std::_Fill<CvContinent *,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvContinent@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvContinent@@@Z ; std::_Move_cat<CvContinent *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvContinent@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvContinent@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvContinent@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvContinent@@@Z PROC ; std::_Move_cat<CvContinent *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvContinent@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvContinent@@@Z ENDP ; std::_Move_cat<CvContinent *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z ; std::_Fill<CvStartRegion *,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z PROC ; std::_Fill<CvStartRegion *,CvStartRegion>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@2
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	esi
	push	edi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	edi, eax
	add	eax, 32					; 00000020H
	mov	ecx, 8
	mov	esi, ebx
	rep movsd
	cmp	eax, edx
	jne	SHORT $LL3@Fill@2
	pop	edi
	pop	esi
	pop	ebx
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z ENDP ; std::_Fill<CvStartRegion *,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvStartRegion@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvStartRegion@@@Z ; std::_Move_cat<CvStartRegion *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvStartRegion@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvStartRegion@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvStartRegion@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvStartRegion@@@Z PROC ; std::_Move_cat<CvStartRegion *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvStartRegion@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvStartRegion@@@Z ENDP ; std::_Move_cat<CvStartRegion *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z ; std::_Fill<CvPlayerStartRank *,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z PROC ; std::_Fill<CvPlayerStartRank *,CvPlayerStartRank>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z ENDP ; std::_Fill<CvPlayerStartRank *,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvPlayerStartRank@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvPlayerStartRank@@@Z ; std::_Move_cat<CvPlayerStartRank *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvPlayerStartRank@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvPlayerStartRank@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvPlayerStartRank@@@Z PROC ; std::_Move_cat<CvPlayerStartRank *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvPlayerStartRank@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvPlayerStartRank@@@Z ENDP ; std::_Move_cat<CvPlayerStartRank *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN1@Copy_backw@2
	push	esi
	push	edi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	sub	edx, 32					; 00000020H
	sub	eax, 32					; 00000020H
	mov	ecx, 8
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL2@Copy_backw@2
	pop	edi
	pop	esi
$LN1@Copy_backw@2:
	pop	ebx

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@3
	push	esi
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@3
	pop	esi
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvContinent@@V1@@std@@YAXPAVCvContinent@@ABV1@@Z ; std::_Construct<CvContinent,CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvContinent@@V1@@std@@YAXPAVCvContinent@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvContinent@@V1@@std@@YAXPAVCvContinent@@ABV1@@Z PROC ; std::_Construct<CvContinent,CvContinent>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@VCvContinent@@V1@@std@@YAXPAVCvContinent@@ABV1@@Z ENDP ; std::_Construct<CvContinent,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvContinent@@@std@@YAXPAVCvContinent@@@Z ; std::_Destroy<CvContinent>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvContinent@@@std@@YAXPAVCvContinent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvContinent@@@std@@YAXPAVCvContinent@@@Z PROC ; std::_Destroy<CvContinent>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvContinent@@@std@@YAXPAVCvContinent@@@Z ENDP ; std::_Destroy<CvContinent>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvStartRegion@@@std@@YAXPAVCvStartRegion@@@Z ; std::_Destroy<CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvStartRegion@@@std@@YAXPAVCvStartRegion@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvStartRegion@@@std@@YAXPAVCvStartRegion@@@Z PROC ; std::_Destroy<CvStartRegion>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvStartRegion@@@std@@YAXPAVCvStartRegion@@@Z ENDP ; std::_Destroy<CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@ABV1@@Z ; std::_Construct<CvPlayerStartRank,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@ABV1@@Z PROC ; std::_Construct<CvPlayerStartRank,CvPlayerStartRank>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@VCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@ABV1@@Z ENDP ; std::_Construct<CvPlayerStartRank,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvPlayerStartRank@@@std@@YAXPAVCvPlayerStartRank@@@Z ; std::_Destroy<CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvPlayerStartRank@@@std@@YAXPAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvPlayerStartRank@@@std@@YAXPAVCvPlayerStartRank@@@Z PROC ; std::_Destroy<CvPlayerStartRank>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvPlayerStartRank@@@std@@YAXPAVCvPlayerStartRank@@@Z ENDP ; std::_Destroy<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??M?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator<
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator<, COMDAT
; _this$ = ecx

; 221  : 
; 222  :  #if _HAS_ITERATOR_DEBUGGING
; 223  : 		_Compat(_Right);
; 224  :  #else
; 225  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 226  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 227  : 
; 228  : 		return (_Myptr < _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 229  : 		}

	ret	4
??M?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator<
_TEXT	ENDS
PUBLIC	??M?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??M?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator<, COMDAT
; _this$ = ecx

; 221  : 
; 222  :  #if _HAS_ITERATOR_DEBUGGING
; 223  : 		_Compat(_Right);
; 224  :  #else
; 225  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 226  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 227  : 
; 228  : 		return (_Myptr < _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 229  : 		}

	ret	4
??M?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator<
_TEXT	ENDS
PUBLIC	??M?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??M?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator<, COMDAT
; _this$ = ecx

; 221  : 
; 222  :  #if _HAS_ITERATOR_DEBUGGING
; 223  : 		_Compat(_Right);
; 224  :  #else
; 225  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 226  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 227  : 
; 228  : 		return (_Myptr < _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 229  : 		}

	ret	4
??M?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@0@Z ; std::pair<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >::pair<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >::pair<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >::pair<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@0@Z ; std::pair<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >::pair<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >::pair<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >::pair<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@0@Z ; std::pair<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >::pair<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >::pair<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >::pair<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEABVCvPlayerStartRank@@XZ ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEABVCvPlayerStartRank@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEABVCvPlayerStartRank@@XZ PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEABVCvPlayerStartRank@@XZ ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -8			; fffffff8H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator--
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEABVCvContinent@@XZ ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEABVCvContinent@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEABVCvContinent@@XZ PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEABVCvContinent@@XZ ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 16			; 00000010H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -16			; fffffff0H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator--
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEABVCvStartRegion@@XZ ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEABVCvStartRegion@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEABVCvStartRegion@@XZ PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEABVCvStartRegion@@XZ ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 32			; 00000020H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -32			; ffffffe0H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator--
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAVCvContinent@@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAVCvContinent@@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAVCvContinent@@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAPAVCvContinent@@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAVCvStartRegion@@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAVCvStartRegion@@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAVCvStartRegion@@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAPAVCvStartRegion@@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAVCvPlayerStartRank@@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAVCvPlayerStartRank@@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAVCvPlayerStartRank@@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAPAVCvPlayerStartRank@@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z ; std::swap<CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z PROC	; std::swap<CvContinent>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+8]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
	pop	edi
	mov	DWORD PTR [ecx+8], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z ENDP	; std::swap<CvContinent>
_TEXT	ENDS
PUBLIC	??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z ; std::swap<CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z PROC ; std::swap<CvPlayerStartRank>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z ENDP ; std::swap<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getSTARTING_DISTANCE_PERCENT@CvGlobals@@QAEHXZ	; CvGlobals::getSTARTING_DISTANCE_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getSTARTING_DISTANCE_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSTARTING_DISTANCE_PERCENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSTARTING_DISTANCE_PERCENT, COMDAT
; _this$ = ecx

; 5316 : 		return m_iSTARTING_DISTANCE_PERCENT;

	mov	eax, DWORD PTR [ecx+6240]

; 5317 : 	}

	ret	0
?getSTARTING_DISTANCE_PERCENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSTARTING_DISTANCE_PERCENT
_TEXT	ENDS
PUBLIC	?getMIN_CIV_STARTING_DISTANCE@CvGlobals@@QAEHXZ	; CvGlobals::getMIN_CIV_STARTING_DISTANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getMIN_CIV_STARTING_DISTANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMIN_CIV_STARTING_DISTANCE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMIN_CIV_STARTING_DISTANCE, COMDAT
; _this$ = ecx

; 5320 : 		return m_iMIN_CIV_STARTING_DISTANCE;

	mov	eax, DWORD PTR [ecx+6244]

; 5321 : 	}

	ret	0
?getMIN_CIV_STARTING_DISTANCE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMIN_CIV_STARTING_DISTANCE
_TEXT	ENDS
PUBLIC	?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ	; CvGlobals::getLAKE_MAX_AREA_SIZE
; Function compile flags: /Ogtpy
;	COMDAT ?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getLAKE_MAX_AREA_SIZE, COMDAT
; _this$ = ecx

; 5584 : 		return m_iLAKE_MAX_AREA_SIZE;

	mov	eax, DWORD PTR [ecx+6508]

; 5585 : 	}

	ret	0
?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getLAKE_MAX_AREA_SIZE
_TEXT	ENDS
PUBLIC	?getMIN_START_AREA_TILES@CvGlobals@@QAEHXZ	; CvGlobals::getMIN_START_AREA_TILES
; Function compile flags: /Ogtpy
;	COMDAT ?getMIN_START_AREA_TILES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMIN_START_AREA_TILES@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMIN_START_AREA_TILES, COMDAT
; _this$ = ecx

; 6216 : 		return m_iMIN_START_AREA_TILES;

	mov	eax, DWORD PTR [ecx+7140]

; 6217 : 	}

	ret	0
?getMIN_START_AREA_TILES@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMIN_START_AREA_TILES
_TEXT	ENDS
PUBLIC	?getMIN_DISTANCE_OTHER_AREA_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getMIN_DISTANCE_OTHER_AREA_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getMIN_DISTANCE_OTHER_AREA_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMIN_DISTANCE_OTHER_AREA_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMIN_DISTANCE_OTHER_AREA_PERCENT, COMDAT
; _this$ = ecx

; 6220 : 		return m_iMIN_DISTANCE_OTHER_AREA_PERCENT;

	mov	eax, DWORD PTR [ecx+7144]

; 6221 : 	}

	ret	0
?getMIN_DISTANCE_OTHER_AREA_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMIN_DISTANCE_OTHER_AREA_PERCENT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_FOOD_REQUIREMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_FOOD_REQUIREMENT, COMDAT
; _this$ = ecx

; 6224 : 		return m_iMINOR_CIV_FOOD_REQUIREMENT;

	mov	eax, DWORD PTR [ecx+7148]

; 6225 : 	}

	ret	0
?getMINOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_FOOD_REQUIREMENT
_TEXT	ENDS
PUBLIC	?getMAJOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ ; CvGlobals::getMAJOR_CIV_FOOD_REQUIREMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getMAJOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAJOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMAJOR_CIV_FOOD_REQUIREMENT, COMDAT
; _this$ = ecx

; 6228 : 		return m_iMAJOR_CIV_FOOD_REQUIREMENT;

	mov	eax, DWORD PTR [ecx+7152]

; 6229 : 	}

	ret	0
?getMAJOR_CIV_FOOD_REQUIREMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMAJOR_CIV_FOOD_REQUIREMENT
_TEXT	ENDS
PUBLIC	?getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST@CvGlobals@@QAEHXZ ; CvGlobals::getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST
; Function compile flags: /Ogtpy
;	COMDAT ?getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST, COMDAT
; _this$ = ecx

; 6232 : 		return m_iMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST;

	mov	eax, DWORD PTR [ecx+7156]

; 6233 : 	}

	ret	0
?getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	??0CvAreaBoundaries@@QAE@XZ			; CvAreaBoundaries::CvAreaBoundaries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ??0CvAreaBoundaries@@QAE@XZ
_TEXT	SEGMENT
??0CvAreaBoundaries@@QAE@XZ PROC			; CvAreaBoundaries::CvAreaBoundaries, COMDAT
; _this$ = ecx

; 24   : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 25   : 	}

	ret	0
??0CvAreaBoundaries@@QAE@XZ ENDP			; CvAreaBoundaries::CvAreaBoundaries
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??0CvStartRegion@@QAE@XZ			; CvStartRegion::CvStartRegion
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.h
;	COMDAT ??0CvStartRegion@@QAE@XZ
_TEXT	SEGMENT
??0CvStartRegion@@QAE@XZ PROC				; CvStartRegion::CvStartRegion, COMDAT
; _this$ = ecx

; 98   : 	CvStartRegion()

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 99   : 	{
; 100  : 		m_uiFertility = 0;

	mov	DWORD PTR [eax+16], ecx

; 101  : 		m_iAreaID = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [eax+20], -1

; 102  : 		m_bLargeEnoughForMajorCiv = true;

	mov	BYTE PTR [eax+24], 1

; 103  : 		m_iNumCivsPlaced = 0;

	mov	DWORD PTR [eax+28], ecx

; 104  : 	}

	ret	0
??0CvStartRegion@@QAE@XZ ENDP				; CvStartRegion::CvStartRegion
_TEXT	ENDS
PUBLIC	??0CvStartRegion@@QAE@ABV0@@Z			; CvStartRegion::CvStartRegion
; Function compile flags: /Ogtpy
;	COMDAT ??0CvStartRegion@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0CvStartRegion@@QAE@ABV0@@Z PROC			; CvStartRegion::CvStartRegion, COMDAT
; _this$ = ecx

; 106  : 	CvStartRegion(const CvStartRegion& source)

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 107  : 	{
; 108  : 		m_Boundaries = source.m_Boundaries;

	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 109  : 		m_uiFertility = source.m_uiFertility;

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 110  : 		m_iAreaID = source.m_iAreaID;

	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 111  : 		m_bLargeEnoughForMajorCiv = source.m_bLargeEnoughForMajorCiv;

	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl

; 112  : 		m_iNumCivsPlaced = source.m_iNumCivsPlaced;

	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx

; 113  : 	}

	ret	4
??0CvStartRegion@@QAE@ABV0@@Z ENDP			; CvStartRegion::CvStartRegion
_TEXT	ENDS
PUBLIC	?ComputeFoundValues@CvStartPositioner@@QAEXXZ	; CvStartPositioner::ComputeFoundValues
EXTRN	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlot::setFoundValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?ComputeFoundValues@CvStartPositioner@@QAEXXZ
_TEXT	SEGMENT
tv196 = -4						; size = 4
?ComputeFoundValues@CvStartPositioner@@QAEXXZ PROC	; CvStartPositioner::ComputeFoundValues, COMDAT
; _this$ = ecx

; 97   : {

	push	ecx

; 98   : 	CvPlot* pLoopPlot(NULL);
; 99   : 
; 100  : 	// Progress through entire map
; 101  : #ifdef AUI_WARNING_FIXES
; 102  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 103  : #else
; 104  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	xor	ebp, ebp
	cmp	DWORD PTR [eax+4028], ebp
	mov	ebx, ecx
	jle	SHORT $LN3@ComputeFou
	push	esi
	mov	DWORD PTR tv196[esp+16], ebp
	push	edi
	npad	6
$LL19@ComputeFou:

; 105  : #endif
; 106  : 	{
; 107  : #ifdef AUI_STARTPOSITIONER_FLAVORED_STARTS
; 108  : 		// Since found values are now computed for each player when they're being positioned, there's no point in storing stuff in CvPlot
; 109  : #else
; 110  : 		// Store in player 1 slot for now
; 111  : 		//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 112  : 		//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 113  : #endif
; 114  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	edi, DWORD PTR [eax+4068]
	add	edi, DWORD PTR tv196[esp+20]

; 115  : 		CvAssert(pLoopPlot);
; 116  : 		if(!pLoopPlot) continue;

	je	SHORT $LN4@ComputeFou

; 117  : 		int iValue = m_pSiteEvaluator->PlotFoundValue(pLoopPlot, NULL);

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	1
	push	-1
	push	0
	push	edi
	call	edx
	mov	esi, eax

; 118  : #ifndef AUI_STARTPOSITIONER_FLAVORED_STARTS
; 119  : 		pLoopPlot->setFoundValue((PlayerTypes)1, iValue);

	push	esi
	push	1
	mov	ecx, edi
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 120  : #endif
; 121  : 
; 122  : 		if(iValue > m_iBestFoundValueOnMap)

	cmp	esi, DWORD PTR [ebx+64]
	jle	SHORT $LN4@ComputeFou

; 123  : 		{
; 124  : 			m_iBestFoundValueOnMap = iValue;

	mov	DWORD PTR [ebx+64], esi
$LN4@ComputeFou:

; 98   : 	CvPlot* pLoopPlot(NULL);
; 99   : 
; 100  : 	// Progress through entire map
; 101  : #ifdef AUI_WARNING_FIXES
; 102  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 103  : #else
; 104  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv196[esp+20], 484		; 000001e4H
	inc	ebp
	cmp	ebp, DWORD PTR [eax+4028]
	jl	SHORT $LL19@ComputeFou
	pop	edi
	pop	esi
$LN3@ComputeFou:
	pop	ebp
	pop	ebx

; 125  : 		}
; 126  : 	}
; 127  : }

	pop	ecx
	ret	0
?ComputeFoundValues@CvStartPositioner@@QAEXXZ ENDP	; CvStartPositioner::ComputeFoundValues
_TEXT	ENDS
PUBLIC	?GetRegion@CvStartPositioner@@QAEHHH@Z		; CvStartPositioner::GetRegion
; Function compile flags: /Ogtpy
;	COMDAT ?GetRegion@CvStartPositioner@@QAEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?GetRegion@CvStartPositioner@@QAEHHH@Z PROC		; CvStartPositioner::GetRegion, COMDAT
; _this$ = ecx

; 298  : 	int iRegion = 0;
; 299  : 
; 300  : 	while(iRegion < (int)m_StartRegionVector.size())

	mov	edx, DWORD PTR [ecx+32]
	sub	edx, DWORD PTR [ecx+28]
	push	esi
	xor	eax, eax
	push	edi
	test	edx, -32				; ffffffe0H
	jle	SHORT $LN2@GetRegion
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+28]
	mov	esi, DWORD PTR _iY$[esp+4]
	mov	edi, DWORD PTR _iX$[esp+4]
	sar	edx, 5
$LL3@GetRegion:

; 301  : 	{
; 302  : 		if(m_StartRegionVector[iRegion].Contains(iX, iY))

	cmp	edi, DWORD PTR [ecx+8]
	jg	SHORT $LN10@GetRegion
	cmp	edi, DWORD PTR [ecx+12]
	jl	SHORT $LN10@GetRegion
	cmp	esi, DWORD PTR [ecx]
	jg	SHORT $LN10@GetRegion
	cmp	esi, DWORD PTR [ecx+4]
	jge	SHORT $LN4@GetRegion
$LN10@GetRegion:

; 303  : 		{
; 304  : 			return iRegion;
; 305  : 		}
; 306  : 		iRegion++;

	inc	eax
	add	ecx, 32					; 00000020H
	cmp	eax, edx
	jl	SHORT $LL3@GetRegion
$LN2@GetRegion:

; 307  : 	}
; 308  : 
; 309  : 	return -1;

	or	eax, -1
$LN4@GetRegion:
	pop	edi
	pop	esi

; 310  : }

	ret	8
?GetRegion@CvStartPositioner@@QAEHHH@Z ENDP		; CvStartPositioner::GetRegion
_TEXT	ENDS
PUBLIC	?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ ; CvStartPositioner::ComputeTileFertilityValues
EXTRN	?getTotalFoundValue@CvArea@@QBEHXZ:PROC		; CvArea::getTotalFoundValue
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	?setTotalFoundValue@CvArea@@QAEXH@Z:PROC	; CvArea::setTotalFoundValue
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
; Function compile flags: /Ogtpy
;	COMDAT ?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ
_TEXT	SEGMENT
_iLoop$ = -8						; size = 4
_this$ = -4						; size = 4
?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ PROC ; CvStartPositioner::ComputeTileFertilityValues, COMDAT
; _this$ = ecx

; 340  : {

	sub	esp, 8

; 341  : 	CvArea* pLoopArea(NULL);
; 342  : 	int iLoop;
; 343  : 	CvPlot* pLoopPlot(NULL);
; 344  : #ifdef AUI_WARNING_FIXES
; 345  : 	uint iI;
; 346  : #else
; 347  : 	int iI;
; 348  : #endif
; 349  : 	int uiFertility;
; 350  : 
; 351  : 	// Set all area fertilities to 0
; 352  : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+12]
	mov	DWORD PTR _this$[esp+12], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	test	eax, eax
	je	SHORT $LN7@ComputeTil
	npad	3
$LL9@ComputeTil:

; 353  : 	{
; 354  : 		pLoopArea->setTotalFoundValue(0);

	push	0
	mov	ecx, eax
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	test	eax, eax
	jne	SHORT $LL9@ComputeTil
$LN7@ComputeTil:

; 355  : 	}
; 356  : 
; 357  : 	// Now process through the map
; 358  : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [eax+4028], ebx
	jle	SHORT $LN4@ComputeTil
	push	ebp
	push	esi
	push	edi
	xor	ebp, ebp
$LL33@ComputeTil:

; 359  : 	{
; 360  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [eax+4068]
	add	esi, ebp

; 361  : 		CvAssert(pLoopPlot);
; 362  : 		if(!pLoopPlot) continue;

	je	SHORT $LN5@ComputeTil

; 363  : 
; 364  : 		// Compute fertility and save off in player 0's found value slot
; 365  : 		//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 366  : 		//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 367  : 		uiFertility = m_pSiteEvaluator->PlotFertilityValue(pLoopPlot);

	mov	edx, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	esi
	call	edx
	mov	edi, eax

; 368  : 		pLoopPlot->setFoundValue((PlayerTypes)0, uiFertility);

	push	edi
	push	0
	mov	ecx, esi
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 369  : 
; 370  : 		if(uiFertility > 0)

	test	edi, edi
	jle	SHORT $LN5@ComputeTil

; 371  : 		{
; 372  : 			// Add to total for area
; 373  : 			CvArea* pArea = GC.getMap().getArea(pLoopPlot->getArea());

	mov	esi, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	esi, eax

; 374  : 			CvAssert(pArea);
; 375  : 			if(!pArea) continue;

	test	esi, esi
	je	SHORT $LN5@ComputeTil

; 376  : 			pArea->setTotalFoundValue(pArea->getTotalFoundValue() + uiFertility);

	mov	ecx, esi
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue
$LN5@ComputeTil:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ebx
	add	ebp, 484				; 000001e4H
	cmp	ebx, DWORD PTR [eax+4028]
	jl	SHORT $LL33@ComputeTil
	pop	edi
	pop	esi
	pop	ebp
$LN4@ComputeTil:
	pop	ebx

; 377  : 		}
; 378  : 	}
; 379  : }

	add	esp, 8
	ret	0
?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ ENDP ; CvStartPositioner::ComputeTileFertilityValues
_TEXT	ENDS
PUBLIC	?StartingPlotRange@CvStartPositioner@@ABEHXZ	; CvStartPositioner::StartingPlotRange
EXTRN	?getLandPlots@CvMap@@QAEHXZ:PROC		; CvMap::getLandPlots
EXTRN	?getTargetNumCities@CvWorldInfo@@QBEHXZ:PROC	; CvWorldInfo::getTargetNumCities
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?countCivPlayersAlive@CvGame@@QBEHXZ:PROC	; CvGame::countCivPlayersAlive
EXTRN	?countMajorCivsAlive@CvGame@@QBEHXZ:PROC	; CvGame::countMajorCivsAlive
EXTRN	?maxPlotDistance@CvMap@@QAEHXZ:PROC		; CvMap::maxPlotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?StartingPlotRange@CvStartPositioner@@ABEHXZ
_TEXT	SEGMENT
_iExpectedCities$ = -8					; size = 4
_iRange$ = -8						; size = 4
$T225262 = -4						; size = 4
$T225261 = -4						; size = 4
?StartingPlotRange@CvStartPositioner@@ABEHXZ PROC	; CvStartPositioner::StartingPlotRange, COMDAT
; _this$ = ecx

; 795  : {

	sub	esp, 8

; 796  : 	int iRange;
; 797  : 	int iNumMinors, iNumMajors;
; 798  : 	int iExpectedCities;
; 799  : 
; 800  : 	// Start with the range as a percentage of the maximum path length across the map
; 801  : 	iRange = (GC.getMap().maxPlotDistance() + 10);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	esi
	push	edi
	call	?maxPlotDistance@CvMap@@QAEHXZ		; CvMap::maxPlotDistance

; 802  : 	iRange *= GC.getSTARTING_DISTANCE_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6240
	add	eax, 10					; 0000000aH
	imul	ecx, eax

; 803  : 	iRange /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 804  : 
; 805  : 	// Now compute how many cities we expect on the map (we'll say just 1 for each minor civ)
; 806  : 	iNumMajors = GC.getGame().countMajorCivsAlive();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?countMajorCivsAlive@CvGame@@QBEHXZ	; CvGame::countMajorCivsAlive

; 807  : 	iNumMinors = GC.getGame().countCivPlayersAlive() - iNumMajors;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	call	?countCivPlayersAlive@CvGame@@QBEHXZ	; CvGame::countCivPlayersAlive

; 808  : 	iExpectedCities = GC.getMap().getWorldInfo().getTargetNumCities() * iNumMajors;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, eax
	sub	edi, ebx
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getTargetNumCities@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getTargetNumCities
	imul	eax, ebx

; 809  : 	iExpectedCities += iNumMinors;

	add	eax, edi
	mov	DWORD PTR _iExpectedCities$[esp+20], eax

; 810  : 	iExpectedCities = std::max(1,iExpectedCities);

	cmp	eax, 1
	mov	DWORD PTR $T225261[esp+20], 1
	lea	eax, DWORD PTR _iExpectedCities$[esp+20]
	jg	SHORT $LN16@StartingPl
	lea	eax, DWORD PTR $T225261[esp+20]
$LN16@StartingPl:

; 811  : 
; 812  : 	// Adjust range compared to how many plots we have per city
; 813  : 	iRange *= GC.getMap().getLandPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, DWORD PTR [eax]
	call	?getLandPlots@CvMap@@QAEHXZ		; CvMap::getLandPlots
	mov	ecx, eax
	imul	ecx, esi

; 814  : 	iRange /= (NUM_CITY_PLOTS / 2); // NUM_CITY_PLOTS; -- I am assuming that some tiles will be watter or unused

	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 815  : 	iRange /= iExpectedCities;

	cdq
	idiv	edi

; 816  : 
; 817  : 	// Used to be a Python hook (minStartingDistanceModifier) here
; 818  : 
; 819  : 	return std::max(iRange, GC.getMIN_CIV_STARTING_DISTANCE());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6244
	pop	edi
	pop	esi
	mov	DWORD PTR $T225262[esp+12], ecx
	pop	ebx
	mov	DWORD PTR _iRange$[esp+8], eax
	cmp	eax, ecx
	lea	eax, DWORD PTR $T225262[esp+8]
	jl	SHORT $LN25@StartingPl
	lea	eax, DWORD PTR _iRange$[esp+8]
$LN25@StartingPl:
	mov	eax, DWORD PTR [eax]

; 820  : }

	add	esp, 8
	ret	0
?StartingPlotRange@CvStartPositioner@@ABEHXZ ENDP	; CvStartPositioner::StartingPlotRange
_TEXT	ENDS
PUBLIC	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z$0
__ehfuncinfo$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 28
?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z PROC ; CvStartPositioner::LogStartPositionMessage, COMDAT
; _this$ = ecx

; 824  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 825  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@LogStartPo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@LogStartPo

; 826  : 	{
; 827  : 		FILogFile* pLog;
; 828  : 		pLog = LOGFILEMGR.GetLog("StartPositionLog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	1
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG220557
	call	eax

; 829  : 		pLog->Msg(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+12]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8
$LN1@LogStartPo:

; 830  : 	}
; 831  : }

	lea	ecx, DWORD PTR _strMsg$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ENDP ; CvStartPositioner::LogStartPositionMessage
PUBLIC	??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::~_Vector_val<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::~_Vector_val<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::~_Vector_val<CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::~_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::~_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::~_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::_Vector_val<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z PROC ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::_Vector_val<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE@V?$allocator@VCvContinent@@@1@@Z ENDP ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::_Vector_val<CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z PROC ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE@V?$allocator@VCvStartRegion@@@1@@Z ENDP ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z PROC ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE@V?$allocator@VCvPlayerStartRank@@@1@@Z ENDP ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@PAVCvPlayerStartRank@@@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::_Vector_iterator<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::_Vector_iterator<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@PAVCvContinent@@@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::_Vector_iterator<CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@PAVCvStartRegion@@@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvContinent@@@std@@QAEPAVCvContinent@@I@Z ; std::allocator<CvContinent>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvContinent@@@std@@QAEPAVCvContinent@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvContinent@@@std@@QAEPAVCvContinent@@I@Z PROC ; std::allocator<CvContinent>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvContinent@@@std@@QAEPAVCvContinent@@I@Z ENDP ; std::allocator<CvContinent>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 134217727				; 07ffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvStartRegion@@@std@@QAEPAVCvStartRegion@@I@Z ; std::allocator<CvStartRegion>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvStartRegion@@@std@@QAEPAVCvStartRegion@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvStartRegion@@@std@@QAEPAVCvStartRegion@@I@Z PROC ; std::allocator<CvStartRegion>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvStartRegion@@@std@@QAEPAVCvStartRegion@@I@Z ENDP ; std::allocator<CvStartRegion>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvPlayerStartRank@@@std@@QAEPAVCvPlayerStartRank@@I@Z ; std::allocator<CvPlayerStartRank>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvPlayerStartRank@@@std@@QAEPAVCvPlayerStartRank@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvPlayerStartRank@@@std@@QAEPAVCvPlayerStartRank@@I@Z PROC ; std::allocator<CvPlayerStartRank>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvPlayerStartRank@@@std@@QAEPAVCvPlayerStartRank@@I@Z ENDP ; std::allocator<CvPlayerStartRank>::allocate
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvContinent,std::allocator<CvContinent> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 5
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ; stdext::unchecked_copy<CvContinent *,CvContinent *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvContinent *,CvContinent *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvContinent *,CvContinent *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z ; stdext::unchecked_copy<CvStartRegion *,CvStartRegion *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvStartRegion *,CvStartRegion *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN7@unchecked_@2
	push	esi
	push	edi
$LL9@unchecked_@2:
	mov	esi, edx
	mov	edi, eax
	add	edx, 32					; 00000020H
	mov	ecx, 8
	add	eax, 32					; 00000020H
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL9@unchecked_@2
	pop	edi
	pop	esi
$LN7@unchecked_@2:
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvStartRegion *,CvStartRegion *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z ; stdext::unchecked_copy<CvPlayerStartRank *,CvPlayerStartRank *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvPlayerStartRank *,CvPlayerStartRank *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvPlayerStartRank *,CvPlayerStartRank *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z ; std::fill<CvContinent *,CvContinent>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z PROC ; std::fill<CvContinent *,CvContinent>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z ENDP ; std::fill<CvContinent *,CvContinent>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z ; std::fill<CvStartRegion *,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z PROC ; std::fill<CvStartRegion *,CvStartRegion>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill@2
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	esi
	push	edi
$LL5@fill@2:
	mov	edi, eax
	add	eax, 32					; 00000020H
	mov	ecx, 8
	mov	esi, ebx
	rep movsd
	cmp	eax, edx
	jne	SHORT $LL5@fill@2
	pop	edi
	pop	esi
	pop	ebx
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z ENDP ; std::fill<CvStartRegion *,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z ; std::fill<CvPlayerStartRank *,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z PROC ; std::fill<CvPlayerStartRank *,CvPlayerStartRank>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z ENDP ; std::fill<CvPlayerStartRank *,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvContinent@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvContinent *,CvContinent *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN5@Move_backw@2
	push	esi
	push	edi
$LL6@Move_backw@2:
	sub	edx, 32					; 00000020H
	sub	eax, 32					; 00000020H
	mov	ecx, 8
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL6@Move_backw@2
	pop	edi
	pop	esi
$LN5@Move_backw@2:
	pop	ebx

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvStartRegion@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvStartRegion *,CvStartRegion *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@3
	push	esi
$LL6@Move_backw@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@3
	pop	esi
$LN5@Move_backw@3:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvPlayerStartRank@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvPlayerStartRank *,CvPlayerStartRank *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@ABV3@@Z ; std::allocator<CvContinent>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@ABV3@@Z PROC ; std::allocator<CvContinent>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@ABV3@@Z ENDP ; std::allocator<CvContinent>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@@Z ; std::allocator<CvContinent>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@@Z PROC ; std::allocator<CvContinent>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvContinent@@@std@@QAEXPAVCvContinent@@@Z ENDP ; std::allocator<CvContinent>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@@Z ; std::allocator<CvStartRegion>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@@Z PROC ; std::allocator<CvStartRegion>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@@Z ENDP ; std::allocator<CvStartRegion>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@ABV3@@Z ; std::allocator<CvPlayerStartRank>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@ABV3@@Z PROC ; std::allocator<CvPlayerStartRank>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@ABV3@@Z ENDP ; std::allocator<CvPlayerStartRank>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@@Z ; std::allocator<CvPlayerStartRank>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@@Z PROC ; std::allocator<CvPlayerStartRank>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvPlayerStartRank@@@std@@QAEXPAVCvPlayerStartRank@@@Z ENDP ; std::allocator<CvPlayerStartRank>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z ; std::_Construct<CvStartRegion,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z PROC ; std::_Construct<CvStartRegion,CvStartRegion>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN3@Construct@3
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z ENDP ; std::_Construct<CvStartRegion,CvStartRegion>
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEAAVCvPlayerStartRank@@XZ ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEAAVCvPlayerStartRank@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEAAVCvPlayerStartRank@@XZ PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBEAAVCvPlayerStartRank@@XZ ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 8

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 8
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -8			; fffffff8H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator--
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEAAVCvContinent@@XZ ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEAAVCvContinent@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEAAVCvContinent@@XZ PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBEAAVCvContinent@@XZ ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 16			; 00000010H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 16					; 00000010H
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -16			; fffffff0H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator--
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEAAVCvStartRegion@@XZ ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEAAVCvStartRegion@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEAAVCvStartRegion@@XZ PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBEAAVCvStartRegion@@XZ ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 32			; 00000020H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 32					; 00000020H
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -32			; ffffffe0H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator--
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-=
; Function compile flags: /Ogtpy
;	COMDAT ??Z?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	mov	eax, ecx

; 387  : 		return (*this += -_Off);

	mov	ecx, DWORD PTR __Off$[esp-4]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 388  : 		}

	ret	4
??Z?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-=
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-=
; Function compile flags: /Ogtpy
;	COMDAT ??Z?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	mov	eax, ecx

; 387  : 		return (*this += -_Off);

	mov	ecx, DWORD PTR __Off$[esp-4]
	neg	ecx
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 388  : 		}

	ret	4
??Z?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-=
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-=
; Function compile flags: /Ogtpy
;	COMDAT ??Z?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	mov	eax, ecx

; 387  : 		return (*this += -_Off);

	mov	ecx, DWORD PTR __Off$[esp-4]
	neg	ecx
	shl	ecx, 5
	add	DWORD PTR [eax], ecx

; 388  : 		}

	ret	4
??Z?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-=
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, ecx
	cmp	ecx, eax
	je	SHORT $LN11@iter_swap
	push	ebx
	mov	ebx, DWORD PTR [ecx+4]
	push	ebp
	mov	ebp, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ebp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+12], ecx
	pop	ebx
$LN11@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	push	esi
	mov	edx, ecx
	mov	esi, eax
	cmp	eax, ecx
	je	SHORT $LN11@iter_swap@2
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [edx], edi
	pop	edi
	mov	DWORD PTR [edx+4], eax
	pop	ebx
$LN11@iter_swap@2:
	pop	esi

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp-4]
	cmp	edx, DWORD PTR [ecx+4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	jle	SHORT $LN26@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, eax
	cmp	eax, ecx
	je	SHORT $LN26@Med3
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebp
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Mid$[esp+12]
	mov	ecx, DWORD PTR __First$[esp+12]
$LN26@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+12]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN51@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	esi, edx
	cmp	edx, eax
	je	SHORT $LN51@Med3
	mov	ecx, DWORD PTR [edx]
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [esi], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Mid$[esp+12]
	mov	ecx, DWORD PTR __First$[esp+12]
$LN51@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN76@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	edx, eax
	cmp	eax, ecx
	je	SHORT $LN76@Med3
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebp
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], eax
$LN76@Med3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3005 : 	}

	ret	0
??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z
_TEXT	SEGMENT
__Tmp$223290 = -32					; size = 32
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z PROC ; std::swap<CvStartRegion>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	sub	esp, 32					; 00000020H
	push	edi
	mov	edi, DWORD PTR __Left$[esp+32]
	cmp	edi, eax
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$223290[esp+36], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$223290[esp+44], ecx
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$223290[esp+40], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$223290[esp+52], ecx
	mov	cl, BYTE PTR [edi+24]
	push	esi
	mov	DWORD PTR __Tmp$223290[esp+52], edx
	mov	edx, DWORD PTR [edi+20]
	mov	BYTE PTR __Tmp$223290[esp+64], cl
	mov	DWORD PTR __Tmp$223290[esp+60], edx
	mov	edx, DWORD PTR [edi+28]

; 21   : 
; 22   : 		_Left = _Right;

	mov	ecx, 8
	mov	esi, eax
	rep movsd

; 23   : 		_Right = _Tmp;

	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$223290[esp+40]
	mov	edi, eax
	mov	DWORD PTR __Tmp$223290[esp+68], edx
	rep movsd
	pop	esi
$LN1@swap@3:
	pop	edi

; 24   : 		}
; 25   : 	}

	add	esp, 32					; 00000020H
	ret	0
??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ENDP ; std::swap<CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp-4]
	cmp	edx, DWORD PTR [ecx+4]
	push	ebx
	push	esi
	push	edi
	jge	SHORT $LN26@Med3@2

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, ecx
	mov	esi, eax
	cmp	eax, ecx
	je	SHORT $LN26@Med3@2
	mov	ebx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR __Mid$[esp+8]
	mov	ecx, DWORD PTR __First$[esp+8]
$LN26@Med3@2:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+8]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jge	SHORT $LN51@Med3@2

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	esi, eax
	mov	edi, edx
	cmp	edx, eax
	je	SHORT $LN51@Med3@2
	mov	ebx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [edi], ebx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR __Mid$[esp+8]
	mov	ecx, DWORD PTR __First$[esp+8]
$LN51@Med3@2:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN76@Med3@2

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	edx, ecx
	mov	esi, eax
	cmp	eax, ecx
	je	SHORT $LN76@Med3@2
	mov	ebx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], eax
$LN76@Med3@2:
	pop	edi
	pop	esi
	pop	ebx

; 3005 : 	}

	ret	0
??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN18@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN18@Uninit_cop:
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL6@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN18@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN18@Uninit_cop@2:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@4
	npad	6
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __Last$[esp-4], eax
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@4

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	esi, DWORD PTR __Last$[esp]
	cmp	DWORD PTR __First$[esp], esi
	je	SHORT $LN27@Copy_backw@5
	push	edi
	npad	4
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	mov	edi, DWORD PTR __Dest$[esp+4]
	sub	esi, 32					; 00000020H
	sub	edi, 32					; 00000020H
	mov	DWORD PTR __Last$[esp+4], esi
	mov	ecx, 8
	mov	DWORD PTR __Dest$[esp+4], edi
	rep movsd
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	DWORD PTR __First$[esp+4], esi
	jne	SHORT $LL2@Copy_backw@5

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2678 : 	}

	ret	0
$LN27@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@6
	npad	6
$LL2@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last$[esp-4], eax
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@6

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::random_access_iterator_tag>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ; CvStartPositioner::ComputeRowFertility
EXTRN	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z:PROC ; CvPlot::getFoundValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_iAreaID$ = 8						; size = 4
_xMin$ = 12						; size = 4
_xMax$ = 16						; size = 4
_iRow$220440 = 20					; size = 4
_yMin$ = 20						; size = 4
_yMax$ = 24						; size = 4
?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z PROC ; CvStartPositioner::ComputeRowFertility, COMDAT
; _this$ = ecx

; 582  : {

	push	ecx

; 583  : 	int rtnValue = 0;
; 584  : 
; 585  : 	for(int iRow = yMin; iRow <= yMax; iRow++)

	mov	eax, DWORD PTR _yMin$[esp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _yMax$[esp]
	mov	DWORD PTR _rtnValue$[esp+4], ecx
	mov	edx, eax
	mov	DWORD PTR _iRow$220440[esp], eax
	jg	$LN57@ComputeRow
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	push	edi
	npad	12
$LL7@ComputeRow:

; 586  : 	{
; 587  : 		for(int iCol = xMin; iCol <= xMax; iCol++)

	mov	ebx, DWORD PTR _xMin$[esp+16]
	cmp	ebx, DWORD PTR _xMax$[esp+16]
	jg	$LN6@ComputeRow
	npad	2
$LL59@ComputeRow:

; 588  : 		{
; 589  : 			CvPlot* pPlot = GC.getMap().plot(iCol, iRow);

	cmp	ebx, -2147483647			; 80000001H
	je	$LN3@ComputeRow
	cmp	edx, -2147483647			; 80000001H
	je	$LN3@ComputeRow
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN22@ComputeRow
	test	ebx, ebx
	jge	SHORT $LN24@ComputeRow
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _iRow$220440[esp+16]
	add	esi, ecx
	jmp	SHORT $LN26@ComputeRow
$LN24@ComputeRow:
	cmp	ebx, ecx
	jl	SHORT $LN22@ComputeRow
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _iRow$220440[esp+16]
	jmp	SHORT $LN26@ComputeRow
$LN22@ComputeRow:
	mov	esi, ebx
$LN26@ComputeRow:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN32@ComputeRow
	test	edx, edx
	jge	SHORT $LN34@ComputeRow
	mov	eax, edx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN32@ComputeRow
$LN34@ComputeRow:
	cmp	edx, edi
	jl	SHORT $LN32@ComputeRow
	mov	eax, edx
	cdq
	idiv	edi
$LN32@ComputeRow:
	test	esi, esi
	jl	SHORT $LN58@ComputeRow
	cmp	esi, ecx
	jge	SHORT $LN58@ComputeRow
	test	edx, edx
	jl	SHORT $LN58@ComputeRow
	cmp	edx, edi
	jge	SHORT $LN58@ComputeRow
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 590  : 
; 591  : 			if(pPlot && pPlot->getArea() == iAreaID)

	test	ecx, ecx
	je	SHORT $LN58@ComputeRow
	mov	eax, DWORD PTR _iAreaID$[esp+16]
	cmp	DWORD PTR [ecx+356], eax
	jne	SHORT $LN58@ComputeRow

; 592  : 			{
; 593  : 				// Retrieve from player 0's found value slot
; 594  : 				//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 595  : 				//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 596  : 				rtnValue += pPlot->getFoundValue((PlayerTypes)0);

	push	0
	call	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ; CvPlot::getFoundValue
	add	DWORD PTR _rtnValue$[esp+20], eax
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
$LN58@ComputeRow:
	mov	edx, DWORD PTR _iRow$220440[esp+16]
$LN3@ComputeRow:

; 586  : 	{
; 587  : 		for(int iCol = xMin; iCol <= xMax; iCol++)

	inc	ebx
	cmp	ebx, DWORD PTR _xMax$[esp+16]
	jle	$LL59@ComputeRow
$LN6@ComputeRow:

; 583  : 	int rtnValue = 0;
; 584  : 
; 585  : 	for(int iRow = yMin; iRow <= yMax; iRow++)

	inc	edx
	cmp	edx, DWORD PTR _yMax$[esp+16]
	mov	DWORD PTR _iRow$220440[esp+16], edx
	jle	$LL7@ComputeRow

; 597  : 			}
; 598  : 		}
; 599  : 	}
; 600  : 
; 601  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 602  : }

	pop	ecx
	ret	20					; 00000014H
$LN57@ComputeRow:

; 597  : 			}
; 598  : 		}
; 599  : 	}
; 600  : 
; 601  : 	return rtnValue;

	mov	eax, ecx

; 602  : }

	pop	ecx
	ret	20					; 00000014H
?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ENDP ; CvStartPositioner::ComputeRowFertility
_TEXT	ENDS
PUBLIC	?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z ; CvStartPositioner::TooCloseToAnotherCiv
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z PROC ; CvStartPositioner::TooCloseToAnotherCiv, COMDAT
; _this$ = ecx

; 721  : {

	push	ebx
	push	esi

; 722  : 	int iI;
; 723  : 	bool rtnValue = false;
; 724  : 	CvPlot* pStartPlot(NULL);
; 725  : 
; 726  : 	CvAssert(pPlot);
; 727  : 	if(!pPlot)

	mov	esi, DWORD PTR _pPlot$[esp+4]
	mov	ebx, ecx
	test	esi, esi
	jne	SHORT $LN10@TooCloseTo
	pop	esi

; 728  : 		return rtnValue;

	xor	al, al
	pop	ebx

; 762  : }

	ret	4
$LN10@TooCloseTo:
	push	edi

; 729  : 
; 730  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	push	ebp
	npad	9
$LL9@TooCloseTo:

; 731  : 	{
; 732  : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+eax+2256], 0
	lea	ecx, DWORD PTR [edi+eax]
	je	SHORT $LN8@TooCloseTo

; 733  : 		{
; 734  : 			pStartPlot = GET_PLAYER((PlayerTypes)iI).getStartingPlot();

	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot

; 735  : 			if(pStartPlot != NULL)

	test	eax, eax
	je	SHORT $LN8@TooCloseTo

; 736  : 			{
; 737  : 				// If in same area, use full distance
; 738  : 				if(pStartPlot->getArea() == pPlot->getArea())

	mov	ecx, DWORD PTR [eax+356]
	cmp	ecx, DWORD PTR [esi+356]
	jne	SHORT $LN4@TooCloseTo

; 739  : 				{
; 740  : 					if(plotDistance(pPlot->getX(), pPlot->getY(),
; 741  : 					                pStartPlot->getX(), pStartPlot->getY()) < m_iRequiredSeparation)

	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	ecx, WORD PTR [esi+2]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR [ebx+60]

; 742  : 					{
; 743  : 						return true;
; 744  : 					}
; 745  : 				}
; 746  : 
; 747  : 				// If in another area, use a fraction of full distance
; 748  : 				else

	jmp	SHORT $LN50@TooCloseTo
$LN4@TooCloseTo:

; 749  : 				{
; 750  : 					int iSeparationIfOnAnotherContinent = m_iRequiredSeparation * GC.getMIN_DISTANCE_OTHER_AREA_PERCENT() / 100;
; 751  : 					if(plotDistance(pPlot->getX(), pPlot->getY(),
; 752  : 					                pStartPlot->getX(), pStartPlot->getY()) < iSeparationIfOnAnotherContinent)

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	movsx	eax, WORD PTR [esi+2]
	push	ecx
	movsx	ecx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ecx, DWORD PTR [ebx+60]
	imul	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7144
	mov	ebp, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esp, 16					; 00000010H
	cmp	ebp, eax
$LN50@TooCloseTo:
	jl	SHORT $LN45@TooCloseTo
$LN8@TooCloseTo:

; 729  : 
; 730  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	$LL9@TooCloseTo
	pop	ebp
	pop	edi
	pop	esi

; 755  : 					}
; 756  : 				}
; 757  : 			}
; 758  : 		}
; 759  : 	}
; 760  : 
; 761  : 	return rtnValue;

	xor	al, al
	pop	ebx

; 762  : }

	ret	4
$LN45@TooCloseTo:
	pop	ebp
	pop	edi
	pop	esi

; 753  : 					{
; 754  : 						return true;

	mov	al, 1
	pop	ebx

; 762  : }

	ret	4
?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z ENDP ; CvStartPositioner::TooCloseToAnotherCiv
_TEXT	ENDS
PUBLIC	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
_bFoundFoodPlot$ = -1					; size = 1
_pPlot$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_iFoodRequirement$ = 16					; size = 4
?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z PROC ; CvStartPositioner::MeetsFoodRequirement, COMDAT
; _this$ = ecx

; 766  : {

	push	ecx
	push	edi

; 767  : 	CvPlot* pLoopPlot(NULL);
; 768  : 	bool bFoundFoodPlot = false;
; 769  : 
; 770  : 	CvAssert(pPlot);
; 771  : 	if(!pPlot)

	mov	edi, DWORD PTR _pPlot$[esp+4]
	mov	BYTE PTR _bFoundFoodPlot$[esp+8], 0
	test	edi, edi
	jne	SHORT $LN7@MeetsFoodR

; 772  : 		return bFoundFoodPlot;

	xor	al, al
	pop	edi

; 786  : 				break;
; 787  : 			}
; 788  : 		}
; 789  : 	}
; 790  : 	return bFoundFoodPlot;
; 791  : }

	pop	ecx
	ret	12					; 0000000cH
$LN7@MeetsFoodR:
	push	ebx

; 773  : 
; 774  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	ebx, DWORD PTR _eTeam$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _iFoodRequirement$[esp+12]
	push	esi
	xor	esi, esi
$LL6@MeetsFoodR:

; 775  : 	{
; 776  : 		pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 777  : 		if(pLoopPlot == NULL)

	test	eax, eax
	je	SHORT $LN15@MeetsFoodR

; 780  : 		}
; 781  : 		else
; 782  : 		{
; 783  : 			if(pLoopPlot->calculateNatureYield(YIELD_FOOD, eTeam, false) >= iFoodRequirement)

	push	0
	push	ebx
	push	0
	mov	ecx, eax
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	cmp	eax, ebp
	jge	SHORT $LN16@MeetsFoodR
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL6@MeetsFoodR
	mov	al, BYTE PTR _bFoundFoodPlot$[esp+20]
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 786  : 				break;
; 787  : 			}
; 788  : 		}
; 789  : 	}
; 790  : 	return bFoundFoodPlot;
; 791  : }

	pop	ecx
	ret	12					; 0000000cH
$LN15@MeetsFoodR:
	pop	esi
	pop	ebp
	pop	ebx

; 778  : 		{
; 779  : 			return false;   // Right at map edge

	xor	al, al
	pop	edi

; 786  : 				break;
; 787  : 			}
; 788  : 		}
; 789  : 	}
; 790  : 	return bFoundFoodPlot;
; 791  : }

	pop	ecx
	ret	12					; 0000000cH
$LN16@MeetsFoodR:
	pop	esi
	pop	ebp
	pop	ebx

; 784  : 			{
; 785  : 				bFoundFoodPlot = true;

	mov	al, 1
	pop	edi

; 786  : 				break;
; 787  : 			}
; 788  : 		}
; 789  : 	}
; 790  : 	return bFoundFoodPlot;
; 791  : }

	pop	ecx
	ret	12					; 0000000cH
?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ENDP ; CvStartPositioner::MeetsFoodRequirement
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@XZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@XZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@XZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)

	mov	esi, DWORD PTR __Capacity$[esp]
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	cmp	esi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	esi
	call	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 4
	add	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)

	mov	esi, DWORD PTR __Capacity$[esp]
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	cmp	esi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 134217727				; 07ffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	esi
	call	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 5
	add	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	shl	edx, 4
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	shl	edx, 5
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvContinent *,CvContinent *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvContinent *,CvContinent *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvContinent *,CvContinent *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvStartRegion *,CvStartRegion *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvStartRegion *,CvStartRegion *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN11@Unchecked_@2
	push	esi
	push	edi
$LL12@Unchecked_@2:
	sub	edx, 32					; 00000020H
	sub	eax, 32					; 00000020H
	mov	ecx, 8
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL12@Unchecked_@2
	pop	edi
	pop	esi
$LN11@Unchecked_@2:
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvStartRegion *,CvStartRegion *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlayerStartRank *,CvPlayerStartRank *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvPlayerStartRank *,CvPlayerStartRank *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@3
	push	esi
$LL12@Unchecked_@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@3
	pop	esi
$LN11@Unchecked_@3:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPlayerStartRank *,CvPlayerStartRank *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN18@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], esi
$LN18@Uninit_fil:
	dec	ecx
	add	eax, 16					; 00000010H
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN18@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN18@Uninit_fil@2:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvContinent> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvStartRegion> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlayerStartRank> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@ABV3@@Z ; std::allocator<CvStartRegion>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@ABV3@@Z PROC ; std::allocator<CvStartRegion>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN5@construct@3
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvStartRegion@@@std@@QAEXPAVCvStartRegion@@ABV3@@Z ENDP ; std::allocator<CvStartRegion>::construct
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-, COMDAT
; _this$ = ecx

; 392  : 		_Myt _Tmp = *this;
; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	sub	ecx, edx
	mov	DWORD PTR [eax], ecx

; 394  : 		}

	ret	8
??G?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-, COMDAT
; _this$ = ecx

; 392  : 		_Myt _Tmp = *this;
; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	shl	eax, 4
	sub	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 394  : 		}

	ret	8
??G?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-, COMDAT
; _this$ = ecx

; 392  : 		_Myt _Tmp = *this;
; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	shl	eax, 5
	sub	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 394  : 		}

	ret	8
??G?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >::operator-
_TEXT	ENDS
PUBLIC	??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 4
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	add	eax, edx
	push	esi
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	eax, 4
	shl	edi, 5
	lea	edx, DWORD PTR [edi+ecx]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Mid$[esp+16]
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	mov	eax, ecx
	sub	eax, esi
	push	ecx
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[esp+28]
	mov	eax, edx
	push	edx
	sub	eax, esi
	mov	ecx, edx
	sub	ecx, edi
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	eax, DWORD PTR __Last$[esp+40]
	mov	ecx, DWORD PTR __First$[esp+40]
	mov	edx, DWORD PTR __Mid$[esp+40]
	sub	eax, esi
	push	eax
	add	ecx, esi
	push	edx
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 48					; 00000030H
	pop	edi
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Mid$[esp-4]
	push	edx
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3020 : 	}

	ret	0
??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	push	ecx
	call	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
	add	esp, 8

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@2

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	push	esi
	add	eax, edx
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	edx, DWORD PTR [edi+ecx]
	lea	esi, DWORD PTR [eax*8]
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Mid$[esp+16]
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	mov	eax, ecx
	sub	eax, esi
	push	ecx
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[esp+28]
	mov	eax, edx
	push	edx
	sub	eax, esi
	mov	ecx, edx
	sub	ecx, edi
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	eax, DWORD PTR __Last$[esp+40]
	mov	ecx, DWORD PTR __First$[esp+40]
	mov	edx, DWORD PTR __Mid$[esp+40]
	sub	eax, esi
	push	eax
	add	ecx, esi
	push	edx
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 48					; 00000030H
	pop	edi
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median@2:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Mid$[esp-4]
	push	edx
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3020 : 	}

	ret	0
??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z
_TEXT	SEGMENT
$T228108 = -4						; size = 1
__Cat$228113 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T228108[esp+4], 0
	mov	eax, DWORD PTR $T228108[esp+4]
	mov	ecx, DWORD PTR __Cat$228113[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z
_TEXT	SEGMENT
$T228117 = -4						; size = 1
__Cat$228122 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T228117[esp+4], 0
	mov	eax, DWORD PTR $T228117[esp+4]
	mov	ecx, DWORD PTR __Cat$228122[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T228126 = -4						; size = 1
__Cat$228131 = 8					; size = 1
$T228128 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$228131[esp]
	mov	edx, DWORD PTR $T228128[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T228126[esp+8], 0
	mov	eax, DWORD PTR $T228126[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebx
	push	esi

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	esi, DWORD PTR __First$[esp+4]
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+28]
	cdq
	inc	ecx
	idiv	ecx
	mov	ecx, DWORD PTR __Mid$[esp+4]
	mov	ebx, DWORD PTR [ecx+28]
	push	edi
	inc	ebx
	mov	edi, eax
	mov	eax, DWORD PTR [ecx+16]
	cdq
	idiv	ebx
	cmp	eax, edi
	jle	SHORT $LN16@Med3@3

; 3000 : 		std::iter_swap(_Mid, _First);

	push	esi
	push	ecx
	call	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
	mov	ecx, DWORD PTR __Mid$[esp+16]
	mov	esi, DWORD PTR __First$[esp+16]
	add	esp, 8
$LN16@Med3@3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [ecx+28]
	cdq
	inc	edi
	idiv	edi
	mov	edi, DWORD PTR __Last$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+28]
	inc	ebp
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+16]
	cdq
	idiv	ebp
	pop	ebp
	cmp	eax, ebx
	jle	SHORT $LN36@Med3@3

; 3002 : 		std::iter_swap(_Last, _Mid);

	push	ecx
	push	edi
	call	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
	mov	ecx, DWORD PTR __Mid$[esp+16]
	mov	esi, DWORD PTR __First$[esp+16]
	add	esp, 8
$LN36@Med3@3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [esi+28]
	cdq
	inc	edi
	idiv	edi
	mov	ebx, DWORD PTR [ecx+28]
	inc	ebx
	mov	edi, eax
	mov	eax, DWORD PTR [ecx+16]
	cdq
	idiv	ebx
	cmp	eax, edi
	jle	SHORT $LN56@Med3@3

; 3004 : 		std::iter_swap(_Mid, _First);

	push	esi
	push	ecx
	call	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
	add	esp, 8
$LN56@Med3@3:
	pop	edi
	pop	esi
	pop	ebx

; 3005 : 	}

	ret	0
??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T228287 = -4						; size = 1
__Cat$228292 = 8					; size = 1
$T228289 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$228292[esp]
	mov	edx, DWORD PTR $T228289[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T228287[esp+8], 0
	mov	eax, DWORD PTR $T228287[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T228301 = -4						; size = 1
__Cat$228306 = 8					; size = 1
$T228303 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$228306[esp]
	mov	edx, DWORD PTR $T228303[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T228301[esp+8], 0
	mov	eax, DWORD PTR $T228301[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	edi
	mov	edi, DWORD PTR __Last$[esp]
	cmp	ecx, edi
	je	SHORT $LN4@Uninit_cop@3
	push	esi
	xor	esi, esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	cmp	eax, esi
	je	SHORT $LN18@Uninit_cop@3
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
$LN18@Uninit_cop@3:
	add	ecx, 32					; 00000020H
	add	eax, 32					; 00000020H
	cmp	ecx, edi
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:
	pop	edi

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	sub	eax, edx
	push	edi

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN50@Push_heap
$LL3@Push_heap:
	mov	esi, DWORD PTR __First$[esp+8]
	mov	edx, eax
	shl	edx, 4
	mov	ebx, DWORD PTR [edx+esi+4]
	add	edx, esi
	cmp	ebx, DWORD PTR __Val$[esp+12]
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	shl	ecx, 4
	add	ecx, esi
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN50@Push_heap:

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	esi, DWORD PTR __First$[esp+8]
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	shl	ecx, 4
	add	ecx, esi
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR __Val$[esp+12]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR __Val$[esp+16]
	pop	edi
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR __Val$[esp+16]
	pop	esi
	mov	DWORD PTR [ecx+12], edx
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 32
??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 1972 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebx
	push	esi
	push	edi

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	edi, DWORD PTR __Hole$[esp+8]
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	cmp	DWORD PTR __Top$[esp+8], edi
	jge	SHORT $LN50@Push_heap@2
	push	ebp
	npad	8
$LL3@Push_heap@2:
	mov	ecx, DWORD PTR __First$[esp+12]
	mov	eax, ebx
	shl	eax, 5
	lea	esi, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+28]
	cdq
	inc	ecx
	idiv	ecx
	mov	edx, DWORD PTR __Val$[esp+40]
	lea	ebp, DWORD PTR [edx+1]
	mov	ecx, eax
	mov	eax, DWORD PTR __Val$[esp+28]
	cdq
	idiv	ebp
	cmp	ecx, eax
	jle	SHORT $LN52@Push_heap@2

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	shl	edi, 5
	add	edi, DWORD PTR __First$[esp+12]
	lea	eax, DWORD PTR [ebx-1]
	cdq
	mov	ecx, 8
	sub	eax, edx
	rep movsd

; 1978 : 		_Hole = _Idx;

	mov	edi, ebx
	sar	eax, 1
	cmp	DWORD PTR __Top$[esp+12], edi
	mov	ebx, eax
	jl	SHORT $LL3@Push_heap@2
$LN52@Push_heap@2:
	pop	ebp
$LN50@Push_heap@2:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	shl	edi, 5
	add	edi, DWORD PTR __First$[esp+8]
	mov	ecx, 8
	lea	esi, DWORD PTR __Val$[esp+8]
	rep movsd
	pop	edi
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	sub	eax, edx
	push	edi

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN50@Push_heap@3
	npad	9
$LL3@Push_heap@3:
	mov	esi, DWORD PTR __First$[esp+8]
	mov	ebx, DWORD PTR [esi+eax*8+4]
	cmp	ebx, DWORD PTR __Val$[esp+12]
	lea	edx, DWORD PTR [esi+eax*8]
	jge	SHORT $LN1@Push_heap@3

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap@3
$LN50@Push_heap@3:

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	esi, DWORD PTR __First$[esp+8]
$LN1@Push_heap@3:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	lea	eax, DWORD PTR [esi+ecx*8]
	mov	ecx, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$[esp+8]
	pop	esi
	mov	DWORD PTR [eax+4], edx
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bTaller$ = 8						; size = 1
_region$ = 12						; size = 4
_secondRegion$ = 16					; size = 4
_iChopPercent$ = 20					; size = 4
?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z PROC ; CvStartPositioner::ChopIntoTwoRegions, COMDAT
; _this$ = ecx

; 499  : {

	push	ecx
	push	esi

; 500  : 	CvAssert(region);
; 501  : 	if(!region) return;

	mov	esi, DWORD PTR _region$[esp+4]
	mov	DWORD PTR _this$[esp+8], ecx
	test	esi, esi
	je	$LN9@ChopIntoTw

; 502  : 	CvAssert(secondRegion);
; 503  : 	if(!secondRegion) return;

	mov	ecx, DWORD PTR _secondRegion$[esp+4]
	test	ecx, ecx
	je	$LN9@ChopIntoTw

; 504  : 
; 505  : 	int uiTargetFertility;
; 506  : 	int uiFertilitySoFar = 0;
; 507  : 
; 508  : 	// Do some initialization on second region
; 509  : 	secondRegion->m_iAreaID = region->m_iAreaID;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+20], eax

; 510  : 
; 511  : 	// How much fertility do we want in the first region?
; 512  : 	uiTargetFertility = region->m_uiFertility * iChopPercent / 100;

	mov	edx, DWORD PTR [esi+16]
	imul	edx, DWORD PTR _iChopPercent$[esp+4]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	push	ebx
	sar	edx, 5
	push	ebp
	push	edi
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	xor	ebx, ebx
	add	edi, edx

; 513  : 
; 514  : 	// Taller than wide
; 515  : 	if(bTaller)

	cmp	BYTE PTR _bTaller$[esp+16], bl
	je	SHORT $LN6@ChopIntoTw

; 516  : 	{
; 517  : 		// We know that the second region will have the same width and same north edge
; 518  : 		secondRegion->m_Boundaries.m_iEastEdge = region->m_Boundaries.m_iEastEdge;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], edx

; 519  : 		secondRegion->m_Boundaries.m_iWestEdge = region->m_Boundaries.m_iWestEdge;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 520  : 		secondRegion->m_Boundaries.m_iNorthEdge = region->m_Boundaries.m_iNorthEdge;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx

; 521  : 
; 522  : 		// Move up one row at a time until we have exceeded the target fertility
; 523  : 		int iNorthEdge = region->m_Boundaries.m_iSouthEdge;

	mov	ebp, DWORD PTR [esi+4]

; 524  : 		while(uiFertilitySoFar < uiTargetFertility)

	test	edi, edi
	jle	SHORT $LN4@ChopIntoTw
	npad	1
$LL5@ChopIntoTw:

; 525  : 		{
; 526  : 			uiFertilitySoFar += ComputeRowFertility(region->m_iAreaID,
; 527  : 			                                        region->m_Boundaries.m_iWestEdge, region->m_Boundaries.m_iEastEdge, iNorthEdge, iNorthEdge);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+20]
	push	ebp
	push	ebp
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+36]
	push	edx
	call	?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ; CvStartPositioner::ComputeRowFertility
	add	ebx, eax

; 528  : 			iNorthEdge++;

	inc	ebp
	cmp	ebx, edi
	jl	SHORT $LL5@ChopIntoTw

; 524  : 		while(uiFertilitySoFar < uiTargetFertility)

	mov	ecx, DWORD PTR _secondRegion$[esp+16]
$LN4@ChopIntoTw:

; 529  : 		}
; 530  : 
; 531  : 		// Set edges
; 532  : 		region->m_Boundaries.m_iNorthEdge = iNorthEdge - 1;

	lea	eax, DWORD PTR [ebp-1]
	mov	DWORD PTR [esi], eax

; 533  : 		secondRegion->m_Boundaries.m_iSouthEdge = iNorthEdge;

	mov	DWORD PTR [ecx+4], ebp

; 556  : 	}
; 557  : 
; 558  : 	// Finish initializing regions
; 559  : 	secondRegion->m_uiFertility = region->m_uiFertility - uiFertilitySoFar;

	mov	edx, DWORD PTR [esi+16]
	pop	edi
	sub	edx, ebx
	pop	ebp
	mov	DWORD PTR [ecx+16], edx

; 560  : 	region->m_uiFertility = uiFertilitySoFar;

	mov	DWORD PTR [esi+16], ebx
	pop	ebx
	pop	esi

; 561  : }

	pop	ecx
	ret	16					; 00000010H
$LN6@ChopIntoTw:

; 534  : 	}
; 535  : 
; 536  : 	// Wider than tall
; 537  : 	else
; 538  : 	{
; 539  : 		// We know that the second region will have the same height and same east edge
; 540  : 		secondRegion->m_Boundaries.m_iNorthEdge = region->m_Boundaries.m_iNorthEdge;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx

; 541  : 		secondRegion->m_Boundaries.m_iSouthEdge = region->m_Boundaries.m_iSouthEdge;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 542  : 		secondRegion->m_Boundaries.m_iEastEdge = region->m_Boundaries.m_iEastEdge;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], edx

; 543  : 
; 544  : 		// Move right one column at a time until we have exceeded the target fertility
; 545  : 		int iEastEdge = region->m_Boundaries.m_iWestEdge;

	mov	ebp, DWORD PTR [esi+12]

; 546  : 		while(uiFertilitySoFar < uiTargetFertility)

	test	edi, edi
	jle	SHORT $LN1@ChopIntoTw
$LL2@ChopIntoTw:

; 547  : 		{
; 548  : 			uiFertilitySoFar += ComputeRowFertility(region->m_iAreaID,
; 549  : 			                                        iEastEdge, iEastEdge, region->m_Boundaries.m_iSouthEdge, region->m_Boundaries.m_iNorthEdge);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+20]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+28]
	push	ebp
	push	ebp
	push	edx
	call	?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ; CvStartPositioner::ComputeRowFertility
	add	ebx, eax

; 550  : 			iEastEdge++;

	inc	ebp
	cmp	ebx, edi
	jl	SHORT $LL2@ChopIntoTw

; 546  : 		while(uiFertilitySoFar < uiTargetFertility)

	mov	ecx, DWORD PTR _secondRegion$[esp+16]
$LN1@ChopIntoTw:

; 551  : 		}
; 552  : 
; 553  : 		// Set edges
; 554  : 		region->m_Boundaries.m_iEastEdge = iEastEdge - 1;

	lea	eax, DWORD PTR [ebp-1]
	mov	DWORD PTR [esi+8], eax

; 555  : 		secondRegion->m_Boundaries.m_iWestEdge = iEastEdge;

	mov	DWORD PTR [ecx+12], ebp

; 556  : 	}
; 557  : 
; 558  : 	// Finish initializing regions
; 559  : 	secondRegion->m_uiFertility = region->m_uiFertility - uiFertilitySoFar;

	mov	edx, DWORD PTR [esi+16]
	sub	edx, ebx
	pop	edi
	mov	DWORD PTR [ecx+16], edx
	pop	ebp

; 560  : 	region->m_uiFertility = uiFertilitySoFar;

	mov	DWORD PTR [esi+16], ebx
	pop	ebx
$LN9@ChopIntoTw:
	pop	esi

; 561  : }

	pop	ecx
	ret	16					; 00000010H
?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ENDP ; CvStartPositioner::ChopIntoTwoRegions
_TEXT	ENDS
PUBLIC	?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z ; CvStartPositioner::ChopIntoThreeRegions
; Function compile flags: /Ogtpy
;	COMDAT ?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z
_TEXT	SEGMENT
_bTaller$ = 8						; size = 1
_region$ = 12						; size = 4
_secondRegion$ = 16					; size = 4
_thirdRegion$ = 20					; size = 4
?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z PROC ; CvStartPositioner::ChopIntoThreeRegions, COMDAT
; _this$ = ecx

; 566  : 	CvAssert(region);
; 567  : 	if(!region) return;

	mov	eax, DWORD PTR _region$[esp-4]
	push	edi
	mov	edi, ecx
	test	eax, eax
	je	SHORT $LN4@ChopIntoTh
	push	esi

; 568  : 	CvAssert(secondRegion);
; 569  : 	if(!secondRegion) return;

	mov	esi, DWORD PTR _secondRegion$[esp+4]
	test	esi, esi
	je	SHORT $LN6@ChopIntoTh
	push	ebp

; 570  : 	CvAssert(thirdRegion);
; 571  : 	if(!thirdRegion) return;

	mov	ebp, DWORD PTR _thirdRegion$[esp+8]
	test	ebp, ebp
	je	SHORT $LN7@ChopIntoTh
	push	ebx

; 572  : 
; 573  : 	// Chop off the first third
; 574  : 	ChopIntoTwoRegions(bTaller, region, secondRegion, 33);

	mov	ebx, DWORD PTR _bTaller$[esp+12]
	push	33					; 00000021H
	push	esi
	push	eax
	push	ebx
	call	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions

; 575  : 
; 576  : 	// Chop the bigger piece in half
; 577  : 	ChopIntoTwoRegions(bTaller, secondRegion, thirdRegion, 50);

	push	50					; 00000032H
	push	ebp
	push	esi
	push	ebx
	mov	ecx, edi
	call	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions
	pop	ebx
$LN7@ChopIntoTh:
	pop	ebp
$LN6@ChopIntoTh:
	pop	esi
$LN4@ChopIntoTh:
	pop	edi

; 578  : }

	ret	16					; 00000010H
?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z ENDP ; CvStartPositioner::ChopIntoThreeRegions
_TEXT	ENDS
PUBLIC	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion
EXTRN	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z:PROC ; CvPlayer::setStartingPlot
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ:PROC	; CvMinorCivInfo::GetMinorCivTrait
EXTRN	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z:PROC ; CvGlobals::getMinorCivInfo
EXTRN	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ:PROC ; CvMap::getWorldSize
EXTRN	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ:PROC ; CvMinorCivAI::GetMinorCivType
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z$0
__ehfuncinfo$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
_TEXT	SEGMENT
_bIsMinorCiv$ = -82					; size = 1
_bDebugMap$ = -81					; size = 1
_iRow$220474 = -80					; size = 4
_iCol$220478 = -76					; size = 4
$T228755 = -72						; size = 4
_iMinorFoodReq$ = -68					; size = 4
_uiBestFoundValue$ = -64				; size = 4
_iMajorFoodReq$ = -60					; size = 4
_eMinorCivType$ = -56					; size = 4
_pBestPlot$ = -52					; size = 4
_iPercentOfBest$ = -48					; size = 4
tv416 = -44						; size = 4
_strString$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_iPlayerIndex$ = 8					; size = 4
_region$ = 12						; size = 32
$T228719 = 44						; size = 4
_bRelaxFoodReq$ = 44					; size = 1
?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z PROC ; CvStartPositioner::AddCivToRegion, COMDAT
; _this$ = ecx

; 606  : {

	push	-1
	push	__ehhandler$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 607  : 	CvString strString;

	lea	ecx, DWORD PTR _strString$[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 608  : 	int uiBestFoundValue = 0;
; 609  : 	int uiPlotFoundValue;
; 610  : 	CvPlot* pBestPlot = NULL;
; 611  : 	CvPlot* pLoopPlot = NULL;
; 612  : 	int iMinorFoodReq = GC.getMINOR_CIV_FOOD_REQUIREMENT();
; 613  : 	int iMajorFoodReq = GC.getMAJOR_CIV_FOOD_REQUIREMENT();
; 614  : 	bool bIsMinorCiv = GET_PLAYER((PlayerTypes)iPlayerIndex).isMinorCiv();

	mov	edi, DWORD PTR _iPlayerIndex$[esp+96]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7152
	imul	edi, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7148
	xor	esi, esi
	mov	DWORD PTR _iMajorFoodReq$[esp+100], ecx
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR __$EHRec$[esp+108], esi
	mov	DWORD PTR _uiBestFoundValue$[esp+100], esi
	mov	DWORD PTR _pBestPlot$[esp+100], esi
	mov	DWORD PTR _iMinorFoodReq$[esp+100], eax
	mov	DWORD PTR tv416[esp+100], edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	dl, al

; 615  : 	TeamTypes eTeam = GET_PLAYER((PlayerTypes)iPlayerIndex).getTeam();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+44]
	mov	BYTE PTR _bIsMinorCiv$[esp+100], dl
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN43@AddCivToRe
	mov	ebp, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebp, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	mov	DWORD PTR $T228755[esp+100], eax
	jmp	SHORT $LN44@AddCivToRe
$LN43@AddCivToRe:
	mov	DWORD PTR $T228755[esp+100], -1
$LN44@AddCivToRe:

; 616  : 	int iPercentOfBest = GC.getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7156
	mov	DWORD PTR _iPercentOfBest$[esp+100], eax

; 617  : 
; 618  : 	MinorCivTypes eMinorCivType = NO_MINORCIV;

	mov	DWORD PTR _eMinorCivType$[esp+100], -1

; 619  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 620  : 	CvMinorCivInfo* pMinorCivInfo = NULL;
; 621  : #endif
; 622  : 	if(bIsMinorCiv)

	test	dl, dl
	je	SHORT $LN23@AddCivToRe

; 623  : 	{
; 624  : 		eMinorCivType =GET_PLAYER((PlayerTypes) iPlayerIndex).GetMinorCivAI()->GetMinorCivType();

	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ ; CvMinorCivAI::GetMinorCivType
	mov	DWORD PTR _eMinorCivType$[esp+100], eax
$LN23@AddCivToRe:

; 625  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 626  : 		pMinorCivInfo = GC.getMinorCivInfo(eMinorCivType);
; 627  : #endif
; 628  : 	}
; 629  : 
; 630  : 	bool bDebugMap = GC.getMap().getWorldSize() == WORLDSIZE_DEBUG;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ; CvMap::getWorldSize
	cmp	eax, 6
	sete	al
	mov	BYTE PTR _bDebugMap$[esp+100], al

; 631  : 
; 632  : 	// ***** Debug *****
; 633  : 	if(bDebugMap)

	test	al, al
	je	SHORT $LN22@AddCivToRe

; 634  : 	{
; 635  : 		iMinorFoodReq = 0;

	mov	DWORD PTR _iMinorFoodReq$[esp+100], esi

; 636  : 		iMajorFoodReq = 0;

	mov	DWORD PTR _iMajorFoodReq$[esp+100], esi
$LN22@AddCivToRe:

; 637  : 	}
; 638  : 
; 639  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 640  : 	CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iPlayerIndex).getCivilizationType());
; 641  : #endif
; 642  : 
; 643  : 	// Find best found value in region
; 644  : 	for(int iRow = region.m_Boundaries.m_iSouthEdge; iRow <= region.m_Boundaries.m_iNorthEdge; iRow++)

	mov	eax, DWORD PTR _region$[esp+100]
	cmp	eax, DWORD PTR _region$[esp+96]
	mov	edx, eax
	mov	DWORD PTR _iRow$220474[esp+100], eax
	jg	$LN125@AddCivToRe
	mov	eax, DWORD PTR _region$[esp+108]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	npad	6
$LL21@AddCivToRe:

; 645  : 	{
; 646  : 		for(int iCol = region.m_Boundaries.m_iWestEdge; iCol <= region.m_Boundaries.m_iEastEdge; iCol++)

	cmp	eax, DWORD PTR _region$[esp+104]
	mov	esi, eax
	mov	DWORD PTR _iCol$220478[esp+100], eax
	jg	$LN20@AddCivToRe
$LL18@AddCivToRe:

; 647  : 		{
; 648  : 			pLoopPlot = GC.getMap().plot(iCol, iRow);

	cmp	esi, -2147483647			; 80000001H
	je	$LN17@AddCivToRe
	cmp	edx, -2147483647			; 80000001H
	je	$LN17@AddCivToRe
	mov	al, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	al, al
	je	SHORT $LN66@AddCivToRe
	test	esi, esi
	jge	SHORT $LN68@AddCivToRe
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN127@AddCivToRe
$LN68@AddCivToRe:
	cmp	esi, ecx
	jl	SHORT $LN66@AddCivToRe
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN127@AddCivToRe:
	mov	edx, DWORD PTR _iRow$220474[esp+100]
$LN66@AddCivToRe:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN122@AddCivToRe
	test	edx, edx
	jge	SHORT $LN78@AddCivToRe
	mov	eax, edx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN122@AddCivToRe
$LN78@AddCivToRe:
	cmp	edx, edi
	jl	SHORT $LN122@AddCivToRe
	mov	eax, edx
	cdq
	idiv	edi
$LN122@AddCivToRe:
	test	esi, esi
	jl	$LN124@AddCivToRe
	cmp	esi, ecx
	jge	$LN124@AddCivToRe
	test	edx, edx
	jl	$LN124@AddCivToRe
	cmp	edx, edi
	jge	$LN124@AddCivToRe
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx

; 649  : 
; 650  : 			// Make sure it actually *is* in region
; 651  : 			if(pLoopPlot && pLoopPlot->getArea() == region.m_iAreaID)

	je	$LN124@AddCivToRe
	mov	eax, DWORD PTR [esi+356]
	cmp	eax, DWORD PTR _region$[esp+116]
	jne	$LN124@AddCivToRe

; 652  : 			{
; 653  : 				// Check food requirement
; 654  : 				if((bRelaxFoodReq && MeetsFoodRequirement(pLoopPlot, eTeam, iMinorFoodReq))
; 655  : 				        || (bIsMinorCiv && MeetsFoodRequirement(pLoopPlot, eTeam, iMinorFoodReq))
; 656  : 				        || MeetsFoodRequirement(pLoopPlot, eTeam, iMajorFoodReq))

	cmp	BYTE PTR _bRelaxFoodReq$[esp+96], 0
	mov	edi, DWORD PTR $T228755[esp+100]
	je	SHORT $LN12@AddCivToRe
	mov	ecx, DWORD PTR _iMinorFoodReq$[esp+100]
	push	ecx
	push	edi
	push	esi
	mov	ecx, ebx
	call	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
	test	al, al
	jne	SHORT $LN13@AddCivToRe
$LN12@AddCivToRe:
	cmp	BYTE PTR _bIsMinorCiv$[esp+100], 0
	je	SHORT $LN11@AddCivToRe
	mov	edx, DWORD PTR _iMinorFoodReq$[esp+100]
	push	edx
	push	edi
	push	esi
	mov	ecx, ebx
	call	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
	test	al, al
	jne	SHORT $LN13@AddCivToRe
$LN11@AddCivToRe:
	mov	eax, DWORD PTR _iMajorFoodReq$[esp+100]
	push	eax
	push	edi
	push	esi
	mov	ecx, ebx
	call	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
	test	al, al
	je	$LN121@AddCivToRe
$LN13@AddCivToRe:

; 657  : 				{
; 658  : #ifdef AUI_STARTPOSITIONER_FLAVORED_STARTS
; 659  : 					// Plot found values are now calculated for each player to account for flavoring
; 660  : 					uiPlotFoundValue = m_pSiteEvaluator->PlotFoundValue(pLoopPlot, &(GET_PLAYER((PlayerTypes)iPlayerIndex)));
; 661  : #else
; 662  : 					// Retrieve from player 1's found value slot
; 663  : 					//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 664  : 					//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 665  : 					uiPlotFoundValue = pLoopPlot->getFoundValue((PlayerTypes)1);

	push	1
	mov	ecx, esi
	call	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ; CvPlot::getFoundValue

; 666  : #endif
; 667  : 
; 668  : 					// If we're a Maritime Minor Civ then decrease the value of non-coastal starts
; 669  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 670  : 					if ((pMinorCivInfo && pMinorCivInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME) ||
; 671  : 						(!pMinorCivInfo && pCivInfo && pCivInfo->isCoastalCiv()))
; 672  : 					{
; 673  : #else
; 674  : 					if(bIsMinorCiv)

	cmp	BYTE PTR _bIsMinorCiv$[esp+100], 0
	mov	edi, eax
	je	SHORT $LN8@AddCivToRe

; 675  : 					{
; 676  : 						if(GC.getMinorCivInfo(eMinorCivType)->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME)

	mov	ecx, DWORD PTR _eMinorCivType$[esp+100]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	mov	ecx, eax
	call	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ ; CvMinorCivInfo::GetMinorCivTrait
	cmp	eax, 2
	jne	SHORT $LN8@AddCivToRe

; 677  : #endif
; 678  : 						{
; 679  : 							if(!pLoopPlot->isCoastalLand(GC.getLAKE_MAX_AREA_SIZE()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6508
	push	edx
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	jne	SHORT $LN8@AddCivToRe

; 680  : 							{
; 681  : 								uiPlotFoundValue /= 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
$LN8@AddCivToRe:

; 682  : 							}
; 683  : 						}
; 684  : 					}
; 685  : 
; 686  : 					// Above the minimum found value?
; 687  : 					if(bDebugMap || ((int)uiPlotFoundValue > (int)m_iBestFoundValueOnMap * iPercentOfBest / 100))

	cmp	BYTE PTR _bDebugMap$[esp+100], 0
	jne	SHORT $LN6@AddCivToRe
	mov	ecx, DWORD PTR [ebx+64]
	imul	ecx, DWORD PTR _iPercentOfBest$[esp+100]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jle	SHORT $LN121@AddCivToRe
$LN6@AddCivToRe:

; 688  : 					{
; 689  : 						// Check distance
; 690  : 						if(!TooCloseToAnotherCiv(pLoopPlot))

	push	esi
	mov	ecx, ebx
	call	?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z ; CvStartPositioner::TooCloseToAnotherCiv
	test	al, al
	jne	SHORT $LN121@AddCivToRe

; 691  : 						{
; 692  : 							// Best so far?
; 693  : 							if(bDebugMap || uiPlotFoundValue > uiBestFoundValue)

	cmp	BYTE PTR _bDebugMap$[esp+100], al
	jne	SHORT $LN3@AddCivToRe
	cmp	edi, DWORD PTR _uiBestFoundValue$[esp+100]
	jle	SHORT $LN121@AddCivToRe
$LN3@AddCivToRe:

; 694  : 							{
; 695  : 								uiBestFoundValue = uiPlotFoundValue;

	mov	DWORD PTR _uiBestFoundValue$[esp+100], edi

; 696  : 								pBestPlot = pLoopPlot;

	mov	DWORD PTR _pBestPlot$[esp+100], esi
$LN121@AddCivToRe:
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
$LN124@AddCivToRe:
	mov	edx, DWORD PTR _iRow$220474[esp+100]
	mov	esi, DWORD PTR _iCol$220478[esp+100]
$LN17@AddCivToRe:
	inc	esi
	cmp	esi, DWORD PTR _region$[esp+104]
	mov	DWORD PTR _iCol$220478[esp+100], esi
	jle	$LL18@AddCivToRe
	mov	eax, DWORD PTR _region$[esp+108]
	mov	edi, DWORD PTR tv416[esp+100]
$LN20@AddCivToRe:
	inc	edx
	cmp	edx, DWORD PTR _region$[esp+96]
	mov	DWORD PTR _iRow$220474[esp+100], edx
	jle	$LL21@AddCivToRe

; 697  : 							}
; 698  : 						}
; 699  : 					}
; 700  : 				}
; 701  : 			}
; 702  : 		}
; 703  : 	}
; 704  : 
; 705  : 	if(pBestPlot != NULL)

	mov	esi, DWORD PTR _pBestPlot$[esp+100]
	test	esi, esi
	je	SHORT $LN125@AddCivToRe

; 706  : 	{
; 707  : 		GET_PLAYER((PlayerTypes)iPlayerIndex).setStartingPlot(pBestPlot);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	add	ecx, edi
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot

; 708  : 		strString.Format("Adding player, id = %d, plot x = %d, y = %d, fertility = %u",
; 709  : 		                 iPlayerIndex, pBestPlot->getX(), pBestPlot->getY(), uiBestFoundValue);

	movsx	eax, WORD PTR [esi+2]
	mov	edx, DWORD PTR _uiBestFoundValue$[esp+100]
	movsx	ecx, WORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR _iPlayerIndex$[esp+100]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strString$[esp+116]
	push	OFFSET $SG220500
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 710  : 		LogStartPositionMessage(strString);

	push	ecx
	lea	edx, DWORD PTR _strString$[esp+128]
	mov	DWORD PTR $T228719[esp+124], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, ebx
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 711  : 		return true;

	lea	ecx, DWORD PTR _strString$[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, 1

; 716  : 	}
; 717  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	40					; 00000028H
$LN125@AddCivToRe:

; 712  : 	}
; 713  : 	else
; 714  : 	{
; 715  : 		return false;

	lea	ecx, DWORD PTR _strString$[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 716  : 	}
; 717  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z$0:
	lea	ecx, DWORD PTR _strString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ENDP ; CvStartPositioner::AddCivToRegion
PUBLIC	??0?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::vector<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::vector<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::vector<CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??0?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::vector<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::vector<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::vector<CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??0?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@std@@@Z
_TEXT	SEGMENT
$T229241 = -4						; size = 1
__Cat$229245 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T229241[esp+4], 0
	mov	eax, DWORD PTR $T229241[esp+4]
	mov	ecx, DWORD PTR __Cat$229245[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@std@@@Z
_TEXT	SEGMENT
$T229250 = -4						; size = 1
__Cat$229255 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T229250[esp+4], 0
	mov	eax, DWORD PTR $T229250[esp+4]
	mov	ecx, DWORD PTR __Cat$229255[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@@Z ; std::_Destroy_range<std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvContinent> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@0AAV?$allocator@VCvContinent@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@@Z ; std::_Destroy_range<std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvStartRegion> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@0AAV?$allocator@VCvStartRegion@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@@Z ; std::_Destroy_range<std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlayerStartRank> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@0AAV?$allocator@VCvPlayerStartRank@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	xor	edi, edi
	cmp	esi, edi
	jbe	SHORT $LN4@Uninit_fil@3
	mov	ecx, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR __First$[esp+4]
$LL6@Uninit_fil@3:

; 404  : 		_Al.construct(_First, _Val);

	cmp	eax, edi
	je	SHORT $LN18@Uninit_fil@3
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
$LN18@Uninit_fil@3:
	dec	esi
	add	eax, 32					; 00000020H
	cmp	esi, edi
	ja	SHORT $LL6@Uninit_fil@3
$LN4@Uninit_fil@3:
	pop	edi
	pop	esi

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__Tmp$230006 = -112					; size = 16
__Tmp$229672 = -96					; size = 16
__Tmp$229852 = -80					; size = 16
__Tmp$230207 = -64					; size = 16
__Tmp$229919 = -48					; size = 16
__Tmp$230081 = -32					; size = 16
__Tmp$230136 = -16					; size = 16
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 112				; 00000070H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last$[esp+120]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 4
	push	edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [esi-16]
	shl	edi, 4
	push	eax
	add	edi, ecx
	push	edi
	push	ecx
	call	??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >

; 3027 : 	_RanIt _Pfirst = _Mid;
; 3028 : 	_RanIt _Plast = _Pfirst + 1;
; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	ebx, DWORD PTR __First$[esp+136]
	add	esp, 12					; 0000000cH
	mov	ecx, edi
	lea	esi, DWORD PTR [edi+16]
	cmp	ebx, edi
	jae	SHORT $LN371@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-12]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN371@Unguarded_
	jg	SHORT $LN371@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 16					; 00000010H
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN371@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edi, DWORD PTR __Last$[esp+124]
	cmp	esi, edi
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 16					; 00000010H
	cmp	esi, edi
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	edi, ecx
	npad	8
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	edx, DWORD PTR __Last$[esp+124]
	jae	SHORT $LN382@Unguarded_
	npad	7
$LL124@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ecx+4]
	cmp	eax, ebx
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN382@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, esi
	add	esi, 16					; 00000010H
	cmp	eax, edx
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$229672[esp+136], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$229672[esp+132], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$229672[esp+140], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	eax, DWORD PTR __Tmp$229672[esp+132]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR __Tmp$229672[esp+136]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR __Tmp$229672[esp+140]
	mov	DWORD PTR [edx+12], eax
$LN20@Unguarded_:
	add	edx, 16					; 00000010H
	cmp	edx, DWORD PTR __Last$[esp+124]
	jb	SHORT $LL124@Unguarded_
$LN382@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	edi, DWORD PTR __First$[esp+124]
	jbe	SHORT $LN388@Unguarded_
	lea	eax, DWORD PTR [edi-16]
$LL171@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ebx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, ebx
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN386@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 16					; 00000010H
	cmp	ecx, eax
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$229852[esp+136], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$229852[esp+132], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$229852[esp+140], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], ebp
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR __Tmp$229852[esp+132]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR __Tmp$229852[esp+136]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR __Tmp$229852[esp+140]
	mov	DWORD PTR [eax+12], ebx
$LN13@Unguarded_:
	sub	edi, 16					; 00000010H
	sub	eax, 16					; 00000010H
	cmp	DWORD PTR __First$[esp+124], edi
	jb	SHORT $LL171@Unguarded_
$LN386@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	edi, DWORD PTR __First$[esp+124]
$LN388@Unguarded_:
	jne	$LN6@Unguarded_
	cmp	edx, DWORD PTR __Last$[esp+124]
	je	$LN377@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, edx
	je	SHORT $LN260@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN260@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$229919[esp+132], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$229919[esp+140], ebp
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], ebp
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Tmp$229919[esp+132]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __Tmp$229919[esp+140]
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], eax
$LN260@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, edx
	mov	ebx, ecx
	add	esi, 16					; 00000010H
	add	edx, 16					; 00000010H
	add	ecx, 16					; 00000010H
	cmp	ebx, eax
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR __Tmp$230006[esp+128], ebp
	mov	ebp, DWORD PTR [ebx+8]
	mov	DWORD PTR __Tmp$230006[esp+136], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR __Tmp$230006[esp+132], ebp
	mov	ebp, DWORD PTR [ebx+12]
	mov	DWORD PTR __Tmp$230006[esp+140], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], ebp
	mov	ebx, DWORD PTR __Tmp$230006[esp+128]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR __Tmp$230006[esp+132]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR __Tmp$230006[esp+136]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR __Tmp$230006[esp+140]
	mov	DWORD PTR [eax+12], ebx
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	edi, 16					; 00000010H
	cmp	edx, DWORD PTR __Last$[esp+124]
	jne	$LN3@Unguarded_
	sub	ecx, 16					; 00000010H
	cmp	edi, ecx
	je	SHORT $LN320@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$230081[esp+132], ebp
	mov	ebp, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$230081[esp+140], ebp
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [edi+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [edi+12], ebp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Tmp$230081[esp+132]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Tmp$230081[esp+140]
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], eax
$LN320@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 16					; 00000010H
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$230136[esp+132], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$230136[esp+140], ebp
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], ebp
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Tmp$230136[esp+132]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __Tmp$230136[esp+140]
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], eax

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, edx
	add	edx, 16					; 00000010H
	cmp	eax, edi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$230207[esp+136], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$230207[esp+132], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$230207[esp+140], ebp
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ebp
	mov	eax, DWORD PTR __Tmp$230207[esp+132]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Tmp$230207[esp+136]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR __Tmp$230207[esp+140]
	mov	DWORD PTR [edi+12], eax

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN377@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+124]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 112				; 00000070H
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__Tmp$230896 = -32					; size = 8
__Tmp$230565 = -24					; size = 8
__Tmp$230742 = -16					; size = 8
__Tmp$231096 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last$[esp+40]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cdq
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ecx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [esi-8]
	push	eax
	push	edi
	push	ecx
	call	??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >

; 3027 : 	_RanIt _Pfirst = _Mid;
; 3028 : 	_RanIt _Plast = _Pfirst + 1;
; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	ebx, DWORD PTR __First$[esp+56]
	add	esp, 12					; 0000000cH
	mov	ecx, edi
	lea	esi, DWORD PTR [edi+8]
	cmp	ebx, edi
	jae	SHORT $LN371@Unguarded_@2
	npad	7
$LL27@Unguarded_@2:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jg	SHORT $LN371@Unguarded_@2
	jl	SHORT $LN371@Unguarded_@2

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_@2
$LN371@Unguarded_@2:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edi, DWORD PTR __Last$[esp+44]
	cmp	esi, edi
	jae	SHORT $LN24@Unguarded_@2
	mov	edx, DWORD PTR [ecx+4]
	npad	2
$LL25@Unguarded_@2:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jg	SHORT $LN24@Unguarded_@2
	jl	SHORT $LN24@Unguarded_@2

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, edi
	jb	SHORT $LL25@Unguarded_@2
$LN24@Unguarded_@2:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_@2:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	edx, DWORD PTR __Last$[esp+44]
	jae	SHORT $LN382@Unguarded_@2
	npad	6
$LL124@Unguarded_@2:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	eax, edi
	jg	SHORT $LN20@Unguarded_@2

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jl	SHORT $LN382@Unguarded_@2

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, esi
	add	esi, 8
	cmp	eax, edx
	je	SHORT $LN20@Unguarded_@2
	mov	ebp, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$230565[esp+52], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	eax, DWORD PTR __Tmp$230565[esp+52]
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], eax
$LN20@Unguarded_@2:
	add	edx, 8
	cmp	edx, DWORD PTR __Last$[esp+44]
	jb	SHORT $LL124@Unguarded_@2
$LN382@Unguarded_@2:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+44]
	jbe	SHORT $LN388@Unguarded_@2
	lea	eax, DWORD PTR [ebx-8]
$LL171@Unguarded_@2:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jg	SHORT $LN13@Unguarded_@2

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jl	SHORT $LN386@Unguarded_@2

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN13@Unguarded_@2
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$230742[esp+52], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR __Tmp$230742[esp+52]
	mov	DWORD PTR [eax+4], edi
$LN13@Unguarded_@2:
	sub	ebx, 8
	sub	eax, 8
	cmp	DWORD PTR __First$[esp+44], ebx
	jb	SHORT $LL171@Unguarded_@2
$LN386@Unguarded_@2:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+44]
$LN388@Unguarded_@2:
	jne	SHORT $LN6@Unguarded_@2
	cmp	edx, DWORD PTR __Last$[esp+44]
	je	$LN377@Unguarded_@2

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, edx
	je	SHORT $LN260@Unguarded_@2

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN260@Unguarded_@2
	mov	ebp, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edi
$LN260@Unguarded_@2:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, edx
	mov	edi, ecx
	add	esi, 8
	add	edx, 8
	add	ecx, 8
	cmp	edi, eax
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$230896[esp+48], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$230896[esp+52], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$230896[esp+48]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR __Tmp$230896[esp+52]
	mov	DWORD PTR [eax+4], edi
	jmp	$LL23@Unguarded_@2
$LN6@Unguarded_@2:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	edx, DWORD PTR __Last$[esp+44]
	jne	SHORT $LN3@Unguarded_@2
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN320@Unguarded_@2

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edi
$LN320@Unguarded_@2:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_@2
$LN3@Unguarded_@2:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, edx
	add	edx, 8
	cmp	eax, ebx
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$231096[esp+52], ebp
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	eax, DWORD PTR __Tmp$231096[esp+52]
	mov	DWORD PTR [ebx], edi
	mov	DWORD PTR [ebx+4], eax

; 3076 : 		}

	jmp	$LL23@Unguarded_@2
$LN377@Unguarded_@2:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+44]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvContinent *,CvContinent *,std::allocator<CvContinent>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T231134 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$231138 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvContinent *,CvContinent *,std::allocator<CvContinent>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$231138[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T231134[esp+4], 0
	mov	eax, DWORD PTR $T231134[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvContinent *,CvContinent *,std::allocator<CvContinent>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T231153 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$231157 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$231157[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T231153[esp+4], 0
	mov	eax, DWORD PTR $T231153[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z
_TEXT	SEGMENT
$T231233 = -24						; size = 1
$T231164 = -20						; size = 4
__Val$222911 = -16					; size = 16
__Cat$231237 = 8					; size = 1
$T231235 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 24					; 00000018H
	cmp	ecx, eax
	je	$LN6@Insertion_
	push	esi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [ecx+16]
	cmp	esi, eax
	je	$LN75@Insertion_
	push	ebx
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_
$LL74@Insertion_:
	mov	ecx, DWORD PTR __First$[esp+36]
$LN7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	edi, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [esi+12]
	mov	ebp, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+8]
	mov	eax, esi
	mov	DWORD PTR __Val$222911[esp+52], edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T231233[esp+40], 0
	mov	edx, DWORD PTR $T231233[esp+40]
	push	edx
	mov	edx, DWORD PTR __Cat$231237[esp+40]
	push	edx
	mov	edx, DWORD PTR $T231235[esp+44]
	push	edx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	push	ecx
	lea	eax, DWORD PTR $T231164[esp+64]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[esp+64]
	mov	DWORD PTR [ecx], ebp
	mov	edx, DWORD PTR __First$[esp+64]
	mov	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __First$[esp+64]
	mov	edx, DWORD PTR __Val$222911[esp+80]
	mov	DWORD PTR [eax+8], ebx
	mov	ecx, DWORD PTR __First$[esp+64]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [ecx+12], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-12]
	lea	ecx, DWORD PTR [esi-16]
	jle	SHORT $LN1@Insertion_
	npad	2
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, ecx
	sub	ecx, 16					; 00000010H
	cmp	edi, DWORD PTR [ecx+4]
	jg	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$222911[esp+52]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ecx
$LN4@Insertion_:
	add	esi, 16					; 00000010H
	cmp	esi, DWORD PTR __Last$[esp+36]
	jne	$LL74@Insertion_
	pop	edi
	pop	ebp
	pop	ebx
$LN75@Insertion_:
	pop	esi
$LN6@Insertion_:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 5
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@3

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	add	eax, edx
	push	esi
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	eax, 5
	shl	edi, 6
	lea	edx, DWORD PTR [edi+ecx]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Mid$[esp+16]
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	mov	eax, ecx
	sub	eax, esi
	push	ecx
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[esp+28]
	mov	eax, edx
	push	edx
	sub	eax, esi
	mov	ecx, edx
	sub	ecx, edi
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	eax, DWORD PTR __Last$[esp+40]
	mov	ecx, DWORD PTR __First$[esp+40]
	mov	edx, DWORD PTR __Mid$[esp+40]
	sub	eax, esi
	push	eax
	add	ecx, esi
	push	edx
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 48					; 00000030H
	pop	edi
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median@3:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Mid$[esp-4]
	push	edx
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3020 : 	}

	ret	0
??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z
_TEXT	SEGMENT
$T231572 = -40						; size = 1
tv345 = -36						; size = 4
$T231497 = -36						; size = 4
__Val$222986 = -32					; size = 32
__Cat$231577 = 8					; size = 1
$T231574 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 40					; 00000028H
	cmp	ecx, eax
	je	$LN6@Insertion_@2
	push	ebp

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebp, DWORD PTR [ecx+32]
	cmp	ebp, eax
	je	$LN77@Insertion_@2
	push	ebx
	push	esi
	push	edi
	jmp	SHORT $LN7@Insertion_@2
$LL76@Insertion_@2:
	mov	ecx, DWORD PTR __First$[esp+52]
$LN7@Insertion_@2:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR __Val$222986[esp+60], edx
	mov	edx, DWORD PTR [ebp+12]
	mov	DWORD PTR __Val$222986[esp+68], edx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR __Val$222986[esp+56], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR __Val$222986[esp+76], edx
	mov	dl, BYTE PTR [ebp+24]
	mov	DWORD PTR __Val$222986[esp+64], eax
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR __Val$222986[esp+80], dl
	mov	edx, DWORD PTR [ebp+28]
	mov	DWORD PTR __Val$222986[esp+72], eax

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	lea	esi, DWORD PTR [edx+1]
	mov	DWORD PTR __Val$222986[esp+84], edx
	cdq
	idiv	esi
	mov	ebx, DWORD PTR [ecx+28]
	inc	ebx
	mov	edi, ebp
	mov	esi, eax
	mov	eax, DWORD PTR [ecx+16]
	cdq
	idiv	ebx
	mov	DWORD PTR tv345[esp+56], esi
	cmp	esi, eax
	jle	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T231572[esp+56], 0
	mov	edx, DWORD PTR $T231572[esp+56]
	push	edx
	mov	edx, DWORD PTR __Cat$231577[esp+56]
	push	edx
	mov	edx, DWORD PTR $T231574[esp+60]
	push	edx
	lea	eax, DWORD PTR [ebp+32]
	push	eax
	push	ebp
	push	ecx
	lea	eax, DWORD PTR $T231497[esp+80]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	edi, DWORD PTR __First$[esp+80]
	add	esp, 28					; 0000001cH

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN1@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	eax, DWORD PTR [ebp-16]
	mov	ecx, DWORD PTR [ebp-4]
	lea	ebx, DWORD PTR [ebp-32]
	inc	ecx
	cdq
	idiv	ecx
	cmp	esi, eax
	jle	SHORT $LN1@Insertion_@2
	npad	6
$LL3@Insertion_@2:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	esi, ebx
	mov	ecx, 8
	rep movsd
	mov	eax, DWORD PTR [ebx-16]
	mov	ecx, DWORD PTR [ebx-4]
	mov	edi, ebx
	sub	ebx, 32					; 00000020H
	inc	ecx
	cdq
	idiv	ecx
	cmp	DWORD PTR tv345[esp+56], eax
	jg	SHORT $LL3@Insertion_@2
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, 8
	lea	esi, DWORD PTR __Val$222986[esp+56]
	add	ebp, 32					; 00000020H
	rep movsd
	cmp	ebp, DWORD PTR __Last$[esp+52]
	jne	$LL76@Insertion_@2
	pop	edi
	pop	esi
	pop	ebx
$LN77@Insertion_@2:
	pop	ebp
$LN6@Insertion_@2:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 40					; 00000028H
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
$T231715 = -8						; size = 1
$T231645 = -4						; size = 4
__Cat$231720 = 8					; size = 1
$T231717 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	edx, eax
	je	SHORT $LN6@Insertion_@3
	push	esi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	je	SHORT $LN75@Insertion_@3
	push	ebx
	mov	ebx, DWORD PTR $T231717[esp+12]
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_@3
$LL74@Insertion_@3:
	mov	edx, DWORD PTR __First$[esp+20]
$LN7@Insertion_@3:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [esi]
	mov	ecx, esi
	jge	SHORT $LN5@Insertion_@3

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T231715[esp+24], 0
	mov	ecx, DWORD PTR $T231715[esp+24]
	push	ecx
	mov	ecx, DWORD PTR __Cat$231720[esp+24]
	push	ecx
	push	ebx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	esi
	push	edx
	lea	edx, DWORD PTR $T231645[esp+48]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN77@Insertion_@3
$LN5@Insertion_@3:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-4]
	lea	eax, DWORD PTR [esi-8]
	jge	SHORT $LN1@Insertion_@3
$LL3@Insertion_@3:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, eax
	sub	eax, 8
	cmp	edi, DWORD PTR [eax+4]
	jl	SHORT $LL3@Insertion_@3
$LN1@Insertion_@3:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebp
$LN77@Insertion_@3:

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	esi, 8

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx+4], edi
	cmp	esi, DWORD PTR __Last$[esp+20]
	jne	SHORT $LL74@Insertion_@3
	pop	edi
	pop	ebp
	pop	ebx
$LN75@Insertion_@3:
	pop	esi
$LN6@Insertion_@3:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z
_TEXT	SEGMENT
$T231788 = -4						; size = 1
__Cat$231793 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T231788[esp+4], 0
	mov	eax, DWORD PTR $T231788[esp+4]
	mov	ecx, DWORD PTR __Cat$231793[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	edi, DWORD PTR __Bottom$[esp+12]
	lea	edx, DWORD PTR [ecx+ecx+2]
	cmp	edx, edi
	mov	ebx, ecx
	jge	SHORT $LN74@Adjust_hea
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	esi, DWORD PTR __First$[esp+12]
	mov	eax, edx
	shl	eax, 4
	mov	ebp, DWORD PTR [eax+esi+4]
	add	eax, esi
	cmp	ebp, DWORD PTR [eax-12]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	edx
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	eax, edx
	shl	eax, 4
	add	eax, esi
	shl	ecx, 4
	add	ecx, esi
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], esi
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, edx
	lea	edx, DWORD PTR [edx+edx+2]
	cmp	edx, edi
	jl	SHORT $LL5@Adjust_hea
$LN74@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	esi, DWORD PTR __First$[esp+12]
	mov	eax, ecx
	mov	edx, edi
	shl	edx, 4
	mov	ecx, DWORD PTR [edx+esi-16]
	lea	edx, DWORD PTR [edx+esi-16]
	shl	eax, 4
	mov	DWORD PTR [eax+esi], ecx
	mov	ecx, DWORD PTR [edx+4]
	add	eax, esi
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 2069 : 		_Hole = _Bottom - 1;

	lea	ecx, DWORD PTR [edi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	edx, DWORD PTR __Val$[esp+12]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Val$[esp+36]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Val$[esp+32]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp+40]
	push	ebx
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __First$[esp+32]
	push	ecx
	push	eax
	call	??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 28					; 0000001cH

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z
_TEXT	SEGMENT
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
tv306 = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 32
??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ecx

; 2056 : 	_Diff _Top = _Hole;
; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	eax, DWORD PTR __Bottom$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Hole$[esp+16]
	lea	ebx, DWORD PTR [edi+edi+2]
	cmp	ebx, eax
	mov	DWORD PTR __Top$[esp+20], edi
	jge	SHORT $LN76@Adjust_hea@2
	npad	7
$LL5@Adjust_hea@2:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebp, DWORD PTR __First$[esp+16]
	mov	eax, ebx
	shl	eax, 5
	mov	esi, DWORD PTR [eax+ebp-4]
	lea	ecx, DWORD PTR [eax+ebp]
	mov	eax, DWORD PTR [ecx-16]
	cdq
	inc	esi
	idiv	esi
	mov	esi, eax
	mov	eax, DWORD PTR [ecx+28]
	inc	eax
	mov	DWORD PTR tv306[esp+16], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR tv306[esp+16]
	cdq
	idiv	ecx
	cmp	eax, esi
	jle	SHORT $LN2@Adjust_hea@2

; 2062 : 			--_Idx;

	dec	ebx
$LN2@Adjust_hea@2:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	esi, ebx
	shl	edi, 5
	shl	esi, 5
	add	edi, ebp
	add	esi, ebp
	mov	ecx, 8
	rep movsd
	mov	edi, ebx
	lea	ebx, DWORD PTR [ebx+ebx+2]
	cmp	ebx, DWORD PTR __Bottom$[esp+16]
	jl	SHORT $LL5@Adjust_hea@2
	mov	eax, DWORD PTR __Bottom$[esp+16]

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	cmp	ebx, eax
$LN76@Adjust_hea@2:
	jne	SHORT $LN1@Adjust_hea@2

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	ecx, DWORD PTR __First$[esp+16]
	mov	edx, eax
	shl	edi, 5
	shl	edx, 5
	add	edi, ecx
	lea	esi, DWORD PTR [edx+ecx-32]
	mov	ecx, 8
	rep movsd

; 2069 : 		_Hole = _Bottom - 1;

	lea	edi, DWORD PTR [eax-1]
$LN1@Adjust_hea@2:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	xor	ecx, ecx
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __Val$[esp+48]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$[esp+52]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$[esp+56]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$[esp+60]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Val$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Val$[esp+68]
	mov	DWORD PTR [eax+20], edx
	mov	cl, BYTE PTR __Val$[esp+72]
	mov	BYTE PTR [eax+24], cl
	mov	edx, DWORD PTR __Val$[esp+76]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR __Top$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+48]
	push	eax
	push	edi
	push	ecx
	call	??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 44					; 0000002cH

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx
	push	esi

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [ecx+ecx+2]
	cmp	eax, esi
	push	edi
	mov	edi, ecx
	jge	SHORT $LN74@Adjust_hea@3
	npad	11
$LL5@Adjust_hea@3:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	edx, DWORD PTR __First$[esp+8]
	mov	ebx, DWORD PTR [edx+eax*8+4]
	cmp	ebx, DWORD PTR [edx+eax*8-4]
	jge	SHORT $LN2@Adjust_hea@3

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea@3:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [ecx], ebx
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea@3
$LN74@Adjust_hea@3:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea@3

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __First$[esp+8]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, edx
	mov	edx, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [eax+4], ecx

; 2069 : 		_Hole = _Bottom - 1;

	lea	ecx, DWORD PTR [esi-1]
$LN1@Adjust_hea@3:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	edx, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Val$[esp+20]
	push	edi
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __First$[esp+20]
	push	ecx
	push	eax
	call	??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 16
___formal$ = 36						; size = 4
??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z PROC ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR __Val$[esp+20]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$[esp+16]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$[esp+24]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	mov	eax, DWORD PTR __Last$[esp+12]
	sub	eax, ecx
	sar	eax, 4
	push	eax
	push	0
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 28					; 0000001cH

; 2082 : 	}

	ret	0
??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ENDP ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00VCvStartRegion@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00VCvStartRegion@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 32
___formal$ = 52						; size = 4
??$_Pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00VCvStartRegion@@PAH@Z PROC ; std::_Pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 2079 : 	{	// pop *_First to *_Dest and reheap, using operator<

	push	esi

; 2080 : 	*_Dest = *_First;

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	sub	esp, 32					; 00000020H
	mov	eax, esp
	xor	edx, edx
	mov	ecx, 8
	rep movsd
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Val$[esp+40]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __Val$[esp+44]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp+48]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __Val$[esp+52]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Val$[esp+56]
	mov	DWORD PTR [eax+20], ecx
	mov	cl, BYTE PTR __Val$[esp+60]
	mov	BYTE PTR [eax+24], cl
	mov	ecx, DWORD PTR __Val$[esp+64]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR __First$[esp+36]
	mov	eax, DWORD PTR __Last$[esp+36]
	sub	eax, ecx
	sar	eax, 5
	push	eax
	push	edx
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 44					; 0000002cH

; 2082 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00VCvStartRegion@@PAH@Z ENDP ; std::_Pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00VCvPlayerStartRank@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00VCvPlayerStartRank@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00VCvPlayerStartRank@@PAH@Z PROC ; std::_Pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	mov	eax, DWORD PTR __Last$[esp+4]
	sub	eax, ecx
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00VCvPlayerStartRank@@PAH@Z ENDP ; std::_Pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV3@IABV3@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T232416 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$232419 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV3@IABV3@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$232419[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T232416[esp+12], 0
	mov	eax, DWORD PTR $T232416[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	add	esp, 24					; 00000018H
	shl	eax, 4
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV3@IABV3@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV3@IABV3@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T232434 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$232437 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV3@IABV3@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$232437[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T232434[esp+12], 0
	mov	eax, DWORD PTR $T232434[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV3@IABV3@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXPAVCvContinent@@0@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXPAVCvContinent@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXPAVCvContinent@@0@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXPAVCvContinent@@0@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXPAVCvStartRegion@@0@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXPAVCvStartRegion@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXPAVCvStartRegion@@0@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXPAVCvStartRegion@@0@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXPAVCvPlayerStartRank@@0@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXPAVCvPlayerStartRank@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXPAVCvPlayerStartRank@@0@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXPAVCvPlayerStartRank@@0@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@std@@@Z
_TEXT	SEGMENT
$T232452 = -4						; size = 1
__Cat$232457 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T232452[esp+4], 0
	mov	eax, DWORD PTR $T232452[esp+4]
	mov	ecx, DWORD PTR __Cat$232457[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvContinent *,CvContinent *,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z
_TEXT	SEGMENT
$T232486 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$232490 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvContinent *,CvContinent *,std::allocator<CvContinent> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$232490[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T232486[esp+4], 0
	mov	eax, DWORD PTR $T232486[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvContinent *,CvContinent *,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z
_TEXT	SEGMENT
$T232523 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$232527 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$232527[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T232523[esp+4], 0
	mov	eax, DWORD PTR $T232523[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__Plast$ = -48						; size = 4
__Glast$ = -44						; size = 4
tv1873 = -40						; size = 4
tv1097 = -36						; size = 4
__Tmp$233466 = -32					; size = 32
__Tmp$233386 = -32					; size = 32
__Tmp$233322 = -32					; size = 32
__Tmp$233239 = -32					; size = 32
__Tmp$233142 = -32					; size = 32
__Tmp$233066 = -32					; size = 32
__Tmp$232877 = -32					; size = 32
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 48					; 00000030H

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ecx, DWORD PTR __First$[esp+44]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last$[esp+56]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 5
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	push	edi

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [esi-32]
	shl	ebx, 5
	push	eax
	add	ebx, ecx
	push	ebx
	push	ecx
	call	??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;
; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR __Plast$[esp+64], ecx

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	DWORD PTR __First$[esp+60], ebx
	jae	SHORT $LN398@Unguarded_@3

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	lea	esi, DWORD PTR [ebx-16]
$LL27@Unguarded_@3:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	eax, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [ebx+28]
	cdq
	inc	edi
	idiv	edi
	mov	ebp, DWORD PTR [esi+12]
	inc	ebp
	mov	edi, eax
	mov	eax, DWORD PTR [esi]
	cdq
	idiv	ebp
	cmp	edi, eax
	jl	SHORT $LN398@Unguarded_@3
	jg	SHORT $LN398@Unguarded_@3

; 3033 : 		--_Pfirst;

	sub	ebx, 32					; 00000020H
	sub	esi, 32					; 00000020H
	cmp	DWORD PTR __First$[esp+60], ebx
	jb	SHORT $LL27@Unguarded_@3
$LN398@Unguarded_@3:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edi, DWORD PTR __Last$[esp+60]
	cmp	ecx, edi
	jae	SHORT $LN24@Unguarded_@3
	mov	eax, DWORD PTR [ebx+16]
	mov	esi, DWORD PTR [ebx+28]
	inc	esi
	cdq
	idiv	esi
	mov	esi, eax
	npad	5
$LL25@Unguarded_@3:
	mov	eax, DWORD PTR [ecx+16]
	mov	ebp, DWORD PTR [ecx+28]
	inc	ebp
	cdq
	idiv	ebp
	cmp	esi, eax
	jl	SHORT $LN411@Unguarded_@3
	jg	SHORT $LN411@Unguarded_@3

; 3037 : 		++_Plast;

	add	ecx, 32					; 00000020H
	cmp	ecx, edi
	jb	SHORT $LL25@Unguarded_@3
$LN411@Unguarded_@3:
	mov	DWORD PTR __Plast$[esp+64], ecx
$LN24@Unguarded_@3:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;
; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	esi, ebx
	mov	ebp, ecx
	mov	DWORD PTR __Glast$[esp+64], esi
$LL23@Unguarded_@3:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	ebp, DWORD PTR __Last$[esp+60]
	jae	$LN389@Unguarded_@3
	npad	3
$LL403@Unguarded_@3:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR [ebp+16]
	mov	ecx, DWORD PTR [ebp+28]
	cdq
	inc	ecx
	idiv	ecx
	mov	edi, DWORD PTR [ebx+28]
	inc	edi
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+16]
	cdq
	idiv	edi
	cmp	ecx, eax
	jl	SHORT $LN20@Unguarded_@3

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN396@Unguarded_@3

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, DWORD PTR __Plast$[esp+64]
	mov	edi, eax
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Plast$[esp+64], eax
	cmp	edi, ebp
	je	SHORT $LN20@Unguarded_@3
	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$232877[esp+72], ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __Tmp$232877[esp+64], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$232877[esp+68], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$232877[esp+84], ecx
	mov	DWORD PTR __Tmp$232877[esp+76], edx
	mov	dl, BYTE PTR [edi+24]
	mov	DWORD PTR __Tmp$232877[esp+80], eax
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, 8
	mov	esi, ebp
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$232877[esp+64]
	mov	edi, ebp
	mov	BYTE PTR __Tmp$232877[esp+88], dl
	mov	DWORD PTR __Tmp$232877[esp+92], eax
	rep movsd
	mov	esi, DWORD PTR __Glast$[esp+64]
$LN20@Unguarded_@3:
	add	ebp, 32					; 00000020H
	cmp	ebp, DWORD PTR __Last$[esp+60]
	jb	$LL403@Unguarded_@3
$LN396@Unguarded_@3:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	mov	ecx, DWORD PTR __Plast$[esp+64]
$LN389@Unguarded_@3:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	esi, DWORD PTR __First$[esp+60]
	jbe	$LN412@Unguarded_@3
	lea	edi, DWORD PTR [esi-16]
	mov	DWORD PTR tv1873[esp+64], edi
$LL404@Unguarded_@3:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+28]
	inc	ecx
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR [edi+12]
	inc	ecx
	mov	DWORD PTR tv1097[esp+64], eax
	mov	eax, DWORD PTR [edi]
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR tv1097[esp+64]
	cmp	ecx, eax
	jl	SHORT $LN13@Unguarded_@3

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN402@Unguarded_@3

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ebx, 32					; 00000020H
	lea	edx, DWORD PTR [edi-16]
	cmp	ebx, edx
	je	SHORT $LN13@Unguarded_@3
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR __Tmp$233066[esp+64], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __Tmp$233066[esp+68], ecx
	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR __Tmp$233066[esp+76], eax
	mov	al, BYTE PTR [ebx+24]
	mov	DWORD PTR __Tmp$233066[esp+80], ecx
	mov	ecx, DWORD PTR [ebx+28]
	mov	BYTE PTR __Tmp$233066[esp+88], al
	lea	eax, DWORD PTR [edi-16]
	mov	DWORD PTR __Tmp$233066[esp+92], ecx
	mov	DWORD PTR __Tmp$233066[esp+72], edx
	mov	edx, DWORD PTR [ebx+20]
	mov	ecx, 8
	mov	esi, eax
	mov	edi, ebx
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$233066[esp+64]
	mov	edi, eax
	mov	DWORD PTR __Tmp$233066[esp+84], edx
	rep movsd
	mov	esi, DWORD PTR __Glast$[esp+64]
	mov	edi, DWORD PTR tv1873[esp+64]
$LN13@Unguarded_@3:
	sub	esi, 32					; 00000020H
	sub	edi, 32					; 00000020H
	mov	DWORD PTR __Glast$[esp+64], esi
	mov	DWORD PTR tv1873[esp+64], edi
	cmp	DWORD PTR __First$[esp+60], esi
	jb	$LL404@Unguarded_@3
$LN402@Unguarded_@3:

; 3051 : 		for (; _First < _Glast; --_Glast)

	mov	ecx, DWORD PTR __Plast$[esp+64]

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	esi, DWORD PTR __First$[esp+60]
$LN412@Unguarded_@3:
	jne	$LN6@Unguarded_@3
	cmp	ebp, DWORD PTR __Last$[esp+60]
	je	$LN391@Unguarded_@3

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	ecx, ebp
	je	SHORT $LN264@Unguarded_@3

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ebx, ecx
	je	SHORT $LN264@Unguarded_@3
	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR __Plast$[esp+64]
	mov	DWORD PTR __Tmp$233142[esp+72], ecx
	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR __Tmp$233142[esp+64], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR __Tmp$233142[esp+68], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR __Tmp$233142[esp+84], ecx
	mov	DWORD PTR __Tmp$233142[esp+76], edx
	mov	dl, BYTE PTR [ebx+24]
	mov	DWORD PTR __Tmp$233142[esp+80], eax
	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, 8
	mov	edi, ebx
	rep movsd
	mov	edi, DWORD PTR __Plast$[esp+64]
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$233142[esp+64]
	mov	BYTE PTR __Tmp$233142[esp+88], dl
	mov	DWORD PTR __Tmp$233142[esp+92], eax
	rep movsd
	mov	esi, DWORD PTR __Glast$[esp+64]
	mov	ecx, DWORD PTR __Plast$[esp+64]
$LN264@Unguarded_@3:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, ebp
	mov	edi, ebx
	add	ecx, 32					; 00000020H
	add	ebp, 32					; 00000020H
	add	ebx, 32					; 00000020H
	mov	DWORD PTR __Plast$[esp+64], ecx
	cmp	edi, eax
	je	$LL23@Unguarded_@3
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$233239[esp+64], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$233239[esp+72], ecx
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$233239[esp+68], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$233239[esp+80], ecx
	mov	cl, BYTE PTR [edi+24]
	mov	DWORD PTR __Tmp$233239[esp+76], edx
	mov	edx, DWORD PTR [edi+20]
	mov	BYTE PTR __Tmp$233239[esp+88], cl
	mov	DWORD PTR __Tmp$233239[esp+84], edx
	mov	edx, DWORD PTR [edi+28]
	mov	ecx, 8
	mov	esi, eax
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$233239[esp+64]
	mov	edi, eax
	mov	DWORD PTR __Tmp$233239[esp+92], edx
	rep movsd
	mov	esi, DWORD PTR __Glast$[esp+64]
	mov	ecx, DWORD PTR __Plast$[esp+64]
	jmp	$LL23@Unguarded_@3
$LN6@Unguarded_@3:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	esi, 32					; 00000020H
	mov	DWORD PTR __Glast$[esp+64], esi
	cmp	ebp, DWORD PTR __Last$[esp+60]
	jne	$LN3@Unguarded_@3
	sub	ebx, 32					; 00000020H
	cmp	esi, ebx
	je	SHORT $LN328@Unguarded_@3

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR __Glast$[esp+64]
	mov	DWORD PTR __Tmp$233322[esp+68], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __Tmp$233322[esp+80], ecx
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR __Tmp$233322[esp+64], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __Tmp$233322[esp+92], ecx
	mov	DWORD PTR __Tmp$233322[esp+72], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR __Tmp$233322[esp+76], eax
	mov	al, BYTE PTR [esi+24]
	mov	ecx, 8
	mov	esi, ebx
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$233322[esp+64]
	mov	edi, ebx
	mov	DWORD PTR __Tmp$233322[esp+84], edx
	mov	BYTE PTR __Tmp$233322[esp+88], al
	rep movsd
	mov	esi, DWORD PTR __Glast$[esp+64]
	mov	ecx, DWORD PTR __Plast$[esp+64]
$LN328@Unguarded_@3:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __Plast$[esp+64], ecx
	cmp	ebx, ecx
	je	$LL23@Unguarded_@3
	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR __Plast$[esp+64]
	mov	DWORD PTR __Tmp$233386[esp+72], ecx
	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR __Tmp$233386[esp+64], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR __Tmp$233386[esp+68], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR __Tmp$233386[esp+84], ecx
	mov	DWORD PTR __Tmp$233386[esp+76], edx
	mov	dl, BYTE PTR [ebx+24]
	mov	DWORD PTR __Tmp$233386[esp+80], eax
	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, 8
	mov	edi, ebx
	rep movsd
	mov	edi, DWORD PTR __Plast$[esp+64]
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$233386[esp+64]
	mov	BYTE PTR __Tmp$233386[esp+88], dl
	mov	DWORD PTR __Tmp$233386[esp+92], eax
	rep movsd

; 3073 : 			}
; 3074 : 		else

	mov	esi, DWORD PTR __Glast$[esp+64]
	mov	ecx, DWORD PTR __Plast$[esp+64]
	jmp	$LL23@Unguarded_@3
$LN3@Unguarded_@3:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edi, ebp
	add	ebp, 32					; 00000020H
	cmp	edi, esi
	je	$LL23@Unguarded_@3
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$233466[esp+64], ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$233466[esp+76], ecx
	mov	cl, BYTE PTR [edi+24]
	mov	DWORD PTR __Tmp$233466[esp+68], edx
	mov	edx, DWORD PTR [edi+16]
	mov	BYTE PTR __Tmp$233466[esp+88], cl
	mov	DWORD PTR __Tmp$233466[esp+72], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR __Tmp$233466[esp+80], edx
	mov	edx, DWORD PTR [edi+28]
	mov	ecx, 8
	rep movsd
	mov	edi, DWORD PTR __Glast$[esp+64]
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$233466[esp+64]
	mov	DWORD PTR __Tmp$233466[esp+84], eax
	mov	DWORD PTR __Tmp$233466[esp+92], edx
	rep movsd

; 3076 : 		}

	mov	esi, DWORD PTR __Glast$[esp+64]
	mov	ecx, DWORD PTR __Plast$[esp+64]
	jmp	$LL23@Unguarded_@3
$LN391@Unguarded_@3:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+60]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 48					; 00000030H
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T233527 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$233531 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$233531[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T233527[esp+4], 0
	mov	eax, DWORD PTR $T233527[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	sub	ebx, DWORD PTR __First$[esp]
	push	esi
	sar	ebx, 4

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	push	edi
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	mov	edi, esi
	shl	edi, 4
$LL2@Make_heap:
	mov	eax, DWORD PTR __First$[esp+8]

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	sub	edi, 16					; 00000010H
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+12]
	push	ebx
	dec	esi
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __First$[esp+28]
	push	esi
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 28					; 0000001cH
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx
	push	ebp

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebp, DWORD PTR __Last$[esp+4]
	sub	ebp, DWORD PTR __First$[esp+4]
	push	esi
	sar	ebp, 5

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebp
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	xor	ebx, ebx
	cmp	esi, ebx
	push	edi
	jle	SHORT $LN1@Make_heap@2
	mov	edi, esi
	shl	edi, 5
$LL2@Make_heap@2:
	mov	eax, DWORD PTR __First$[esp+12]

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	sub	esp, 32					; 00000020H
	sub	edi, 32					; 00000020H
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	push	ebp
	dec	esi
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR __First$[esp+48]
	push	esi
	push	edx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 44					; 0000002cH
	cmp	esi, ebx
	jg	SHORT $LL2@Make_heap@2
$LN1@Make_heap@2:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	esi
	push	edi

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, DWORD PTR __First$[esp+4]
	sar	edi, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap@3
	npad	6
$LL2@Make_heap@3:
	mov	eax, DWORD PTR __First$[esp+4]

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	dec	esi

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR [eax+esi*8]
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR [eax+esi*8]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	push	edi
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR __First$[esp+16]
	push	esi
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap@3
$LN1@Make_heap@3:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [eax-16]
	add	eax, -16				; fffffff0H
	push	0
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Last$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+16]
	add	eax, -16				; fffffff0H
	push	eax
	push	eax
	push	ecx
	call	??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 32					; 00000020H

; 2090 : 	}

	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	xor	edx, edx
	push	edx
	add	ecx, -32				; ffffffe0H
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR __Last$[esp+32]
	mov	edx, DWORD PTR __First$[esp+32]
	add	eax, -32				; ffffffe0H
	push	eax
	push	eax
	push	edx
	call	??$_Pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00VCvStartRegion@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 48					; 00000030H

; 2090 : 	}

	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax-8]
	add	eax, -8					; fffffff8H
	push	edi
	mov	edi, DWORD PTR [eax+4]
	mov	edx, ecx
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 8
	mov	edx, esp
	sub	eax, ecx
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]
	push	esi
	mov	esi, ecx

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	ecx, DWORD PTR __Last_arg$[esp]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [edi], eax
	cmp	eax, ecx
	je	SHORT $LN20@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	push	eax
	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	ecx
	call	??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ; stdext::unchecked_copy<CvContinent *,CvContinent *>
	add	esp, 12					; 0000000cH

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], eax
$LN20@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First_arg$[esp]
	mov	eax, ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [ecx], ebx
	cmp	ebx, edx
	je	SHORT $LN33@erase@2
	push	ebp

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebp, DWORD PTR [eax+8]
	cmp	edx, ebp
	je	SHORT $LN26@erase@2
	push	esi
	push	edi
	npad	1
$LL28@erase@2:
	mov	esi, edx
	mov	edi, ebx
	add	edx, 32					; 00000020H
	mov	ecx, 8
	add	ebx, 32					; 00000020H
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL28@erase@2
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [eax+8], ebx
	pop	ebp
$LN33@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ecx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV3@IABV3@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T234181 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$234185 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV3@IABV3@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$234185[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T234181[esp+12], 0
	mov	eax, DWORD PTR $T234181[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	add	esp, 24					; 00000018H
	shl	eax, 5
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV3@IABV3@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Ufill
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@3
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@3
	push	ebx
	npad	4
$LL28@erase@3:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	add	edx, 8
	add	esi, 8
	cmp	edx, edi
	jne	SHORT $LL28@erase@3
	pop	ebx
$LN26@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@3:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvContinent@@@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV2@00@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Umove<CvContinent *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvContinent@@@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV2@00@Z
_TEXT	SEGMENT
$T234327 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$234331 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvContinent@@@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV2@00@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Umove<CvContinent *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$234331[esp]
	mov	BYTE PTR $T234327[esp+4], 0
	mov	eax, DWORD PTR $T234327[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvContinent@@@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV2@00@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Umove<CvContinent *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvPlayerStartRank@@@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV2@00@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Umove<CvPlayerStartRank *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvPlayerStartRank@@@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV2@00@Z
_TEXT	SEGMENT
$T234383 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$234387 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvPlayerStartRank@@@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV2@00@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Umove<CvPlayerStartRank *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$234387[esp]
	mov	BYTE PTR $T234383[esp+4], 0
	mov	eax, DWORD PTR $T234383[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvPlayerStartRank@@@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV2@00@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Umove<CvPlayerStartRank *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z
_TEXT	SEGMENT
$T234420 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$234423 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$234423[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T234420[esp+4], 0
	mov	eax, DWORD PTR $T234420[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	??$make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -16				; fffffff0H
	cmp	edx, 16					; 00000010H
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -32				; ffffffe0H
	cmp	edx, 32					; 00000020H
	jle	SHORT $LN1@make_heap@2

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 16					; 00000010H
$LN1@make_heap@2:

; 2182 : 	}

	ret	0
??$make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap@3

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 16					; 00000010H
$LN1@make_heap@3:

; 2182 : 	}

	ret	0
??$make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	mov	ecx, eax
	sub	ecx, esi
	and	ecx, -16				; fffffff0H
	cmp	ecx, 16					; 00000010H
	push	edi
	jle	SHORT $LN10@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	edi, DWORD PTR [eax-16]
	push	0
	mov	edx, eax
	add	eax, -16				; fffffff0H
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	lea	eax, DWORD PTR [edx-16]
	push	eax
	push	eax
	push	esi
	call	??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 32					; 00000020H
$LN10@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	ret	0
??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -32				; ffffffe0H
	cmp	edx, 32					; 00000020H
	jle	SHORT $LN1@pop_heap@2

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	push	0
	push	eax
	push	ecx
	call	??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
	add	esp, 12					; 0000000cH
$LN1@pop_heap@2:

; 2099 : 	}

	ret	0
??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	push	ebx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	push	esi
	push	edi
	jle	SHORT $LN44@pop_heap@3

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	add	eax, -8					; fffffff8H
	mov	edx, ecx
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 8
	mov	edx, esp
	sub	eax, ecx
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H
$LN44@pop_heap@3:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	mov	esi, ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN15@clear
	push	ecx
	push	eax
	push	eax
	call	??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ; stdext::unchecked_copy<CvContinent *,CvContinent *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], eax
$LN15@clear:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T235003 = -4						; size = 4
?clear@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T235003[esp+12]
	push	eax
	call	?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	je	SHORT $LN15@clear@2
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN40@clear@2
	push	edi
$LL42@clear@2:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL42@clear@2
	pop	edi
$LN40@clear@2:
	mov	DWORD PTR [ecx+8], edx
$LN15@clear@2:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
_TEXT	SEGMENT
__Tmp$220901 = -36					; size = 16
__Tmp$220891 = -36					; size = 16
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$235417 = 8					; size = 1
__Cat$235345 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$220876 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T235413 = 16						; size = 1
$T235341 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 4
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 4
	mov	edx, 268435455				; 0fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
$LN91@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 268435455				; 0fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	sar	ebx, 4
	push	ecx
	mov	edx, ebx
	shl	edx, 4
	push	edi
	add	edx, eax
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$220876[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV3@IABV3@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$235345[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T235341[ebp], 0
	mov	ecx, DWORD PTR $T235341[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$220876[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T235413[ebp], 0
	mov	edx, DWORD PTR $T235413[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$235417[ebp]
	push	edx
	lea	eax, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$220876[ebp]
	shl	eax, 4
	add	eax, ebx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 4
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	shl	eax, 4
	add	eax, ebx

; 1206 : 			_Mylast = _Newvec + _Count;

	shl	edi, 4
	add	edi, ebx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$220876[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	eax, ebx
	sub	eax, ecx
	sar	eax, 4
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	SHORT $LN3@Insert_n
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$220891[ebp], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$220891[ebp+8], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$220891[ebp+12], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, edi
	shl	eax, 4
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$220891[ebp+4], edx
	call	??$_Umove@PAVCvContinent@@@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV2@00@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Umove<CvContinent *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	edx, eax
	sub	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$220891[ebp]
	push	ecx
	sar	edx, 4
	sub	edi, edx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV3@IABV3@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$220891[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z ; std::fill<CvContinent *,CvContinent>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$220901[ebp], ecx
	mov	ecx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	shl	edi, 4
	mov	DWORD PTR __Tmp$220901[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, edi
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	mov	DWORD PTR __Tmp$220901[ebp+4], ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$220901[ebp+12], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAVCvContinent@@@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEPAVCvContinent@@PAV2@00@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Umove<CvContinent *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvContinent *,CvContinent *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$220901[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAVCvContinent@@V1@@std@@YAXPAVCvContinent@@0ABV1@@Z ; std::fill<CvContinent *,CvContinent>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Tmp$221051 = -24					; size = 8
__Tmp$221041 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$235657 = 8					; size = 1
__Cat$235582 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$221026 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T235653 = 16						; size = 1
$T235578 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
$LN91@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$221026[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV3@IABV3@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$235582[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T235578[ebp], 0
	mov	ecx, DWORD PTR $T235578[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$221026[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T235653[ebp], 0
	mov	edx, DWORD PTR $T235653[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$235657[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$221026[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$221026[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$221041[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$221041[ebp], edx
	call	??$_Umove@PAVCvPlayerStartRank@@@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV2@00@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Umove<CvPlayerStartRank *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$221041[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV3@IABV3@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$221041[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z ; std::fill<CvPlayerStartRank *,CvPlayerStartRank>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$221051[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$221051[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAVCvPlayerStartRank@@@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEPAVCvPlayerStartRank@@PAV2@00@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Umove<CvPlayerStartRank *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAVCvPlayerStartRank@@PAV1@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlayerStartRank *,CvPlayerStartRank *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$221051[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAVCvPlayerStartRank@@V1@@std@@YAXPAVCvPlayerStartRank@@0ABV1@@Z ; std::fill<CvPlayerStartRank *,CvPlayerStartRank>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n
PUBLIC	??$_Umove@PAVCvStartRegion@@@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV2@00@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Umove<CvStartRegion *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvStartRegion@@@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV2@00@Z
_TEXT	SEGMENT
$T235738 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$235742 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvStartRegion@@@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV2@00@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Umove<CvStartRegion *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$235742[esp]
	mov	BYTE PTR $T235738[esp+4], 0
	mov	eax, DWORD PTR $T235738[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvStartRegion@@@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV2@00@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Umove<CvStartRegion *>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::_Sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	eax, edx
	sub	eax, ecx
	push	ebp
	sar	eax, 4
	cmp	eax, 1
	push	esi
	push	edi
	jle	SHORT $LN1@Sort_heap
$LN76@Sort_heap:

; 2218 : 		std::pop_heap(_First, _Last);

	mov	esi, DWORD PTR [edx-16]
	mov	edi, DWORD PTR [edx-8]
	mov	ebx, DWORD PTR [edx-12]
	mov	ebp, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	sub	eax, ecx
	sar	eax, 4
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+8], edi
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+12], ebp
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	ecx, DWORD PTR __First$[esp+40]
	sub	edx, 16					; 00000010H
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 4
	add	esp, 28					; 0000001cH
	cmp	eax, 1
	mov	DWORD PTR __Last$[esp+12], edx
	jg	SHORT $LN76@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::_Sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::_Sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 5
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap@2
	xor	ebp, ebp

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	jle	SHORT $LN2@Sort_heap@2
$LN62@Sort_heap@2:
	push	ebp
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [ecx-32]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx-28]
	mov	esi, ecx
	add	ecx, -32				; ffffffe0H
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
	lea	eax, DWORD PTR [esi-32]
	push	eax
	push	eax
	push	edi
	call	??$_Pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00VCvStartRegion@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	mov	ecx, DWORD PTR __Last$[esp+56]
	mov	edi, DWORD PTR __First$[esp+56]
	add	esp, 48					; 00000030H
$LN2@Sort_heap@2:
	sub	ecx, 32					; 00000020H
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 5
	cmp	eax, 1
	mov	DWORD PTR __Last$[esp+8], ecx
	jg	SHORT $LN62@Sort_heap@2
$LN1@Sort_heap@2:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::_Sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::_Sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	push	ebx
	sar	eax, 3
	cmp	eax, 1
	push	esi
	push	edi
	jle	SHORT $LN1@Sort_heap@3
$LN76@Sort_heap@3:

; 2218 : 		std::pop_heap(_First, _Last);

	mov	esi, DWORD PTR [edx-8]
	mov	edi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	mov	edx, ecx
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 8
	mov	edx, esp
	sub	eax, ecx
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	mov	edx, DWORD PTR __Last$[esp+28]
	mov	ecx, DWORD PTR __First$[esp+28]
	sub	edx, 8
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	add	esp, 20					; 00000014H
	cmp	eax, 1
	mov	DWORD PTR __Last$[esp+8], edx
	jg	SHORT $LN76@Sort_heap@3
$LN1@Sort_heap@3:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::_Sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??_7CvStartPositioner@@6B@			; CvStartPositioner::`vftable'
PUBLIC	??0CvStartPositioner@@QAE@XZ			; CvStartPositioner::CvStartPositioner
PUBLIC	??_R4CvStartPositioner@@6B@			; CvStartPositioner::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvStartPositioner@@@8			; CvStartPositioner `RTTI Type Descriptor'
PUBLIC	??_R3CvStartPositioner@@8			; CvStartPositioner::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvStartPositioner@@8			; CvStartPositioner::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvStartPositioner@@8		; CvStartPositioner::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@CvStartPositioner@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
rdata$r	SEGMENT
??_R1A@?0A@EA@CvStartPositioner@@8 DD FLAT:??_R0?AVCvStartPositioner@@@8 ; CvStartPositioner::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvStartPositioner@@8
rdata$r	ENDS
;	COMDAT ??_R2CvStartPositioner@@8
rdata$r	SEGMENT
??_R2CvStartPositioner@@8 DD FLAT:??_R1A@?0A@EA@CvStartPositioner@@8 ; CvStartPositioner::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvStartPositioner@@8
rdata$r	SEGMENT
??_R3CvStartPositioner@@8 DD 00H			; CvStartPositioner::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvStartPositioner@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvStartPositioner@@@8
_DATA	SEGMENT
??_R0?AVCvStartPositioner@@@8 DD FLAT:??_7type_info@@6B@ ; CvStartPositioner `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvStartPositioner@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvStartPositioner@@6B@
rdata$r	SEGMENT
??_R4CvStartPositioner@@6B@ DD 00H			; CvStartPositioner::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvStartPositioner@@@8
	DD	FLAT:??_R3CvStartPositioner@@8
rdata$r	ENDS
;	COMDAT ??_7CvStartPositioner@@6B@
CONST	SEGMENT
??_7CvStartPositioner@@6B@ DD FLAT:??_R4CvStartPositioner@@6B@ ; CvStartPositioner::`vftable'
	DD	FLAT:?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvStartPositioner@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$1
__ehfuncinfo$??0CvStartPositioner@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvStartPositioner@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ??0CvStartPositioner@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvStartPositioner@@QAE@XZ PROC			; CvStartPositioner::CvStartPositioner, COMDAT
; _this$ = ecx

; 21   : {

	push	-1
	push	__ehhandler$??0CvStartPositioner@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CvStartPositioner@@6B@
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx

; 22   : #ifdef AUI_WARNING_FIXES
; 23   : 	m_pSiteEvaluator = NULL;
; 24   : #endif
; 25   : 	m_iRequiredSeparation = 0;

	mov	DWORD PTR [eax+60], ecx

; 26   : 	m_iBestFoundValueOnMap = 0;

	mov	DWORD PTR [eax+64], ecx

; 27   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
__ehhandler$??0CvStartPositioner@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvStartPositioner@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvStartPositioner@@QAE@XZ ENDP			; CvStartPositioner::CvStartPositioner
PUBLIC	??1CvStartPositioner@@QAE@XZ			; CvStartPositioner::~CvStartPositioner
; Function compile flags: /Ogtpy
;	COMDAT ??1CvStartPositioner@@QAE@XZ
_TEXT	SEGMENT
??1CvStartPositioner@@QAE@XZ PROC			; CvStartPositioner::~CvStartPositioner, COMDAT
; _this$ = ecx

; 31   : {

	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CvStartPositioner@@6B@

; 32   : }

	mov	eax, DWORD PTR [esi+44]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN11@CvStartPos
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@CvStartPos:
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+52], edi
	mov	eax, DWORD PTR [esi+28]
	cmp	eax, edi
	je	SHORT $LN18@CvStartPos
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@CvStartPos:
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], edi
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN25@CvStartPos
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@CvStartPos:
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	pop	edi
	pop	esi
	ret	0
??1CvStartPositioner@@QAE@XZ ENDP			; CvStartPositioner::~CvStartPositioner
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -16				; fffffff0H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 4
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	shl	esi, 4
	add	esi, DWORD PTR [edi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
_TEXT	SEGMENT
__Tmp$220976 = -52					; size = 32
__Tmp$220966 = -52					; size = 32
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$237437 = 8					; size = 1
__Cat$237365 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$220951 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T237433 = 16						; size = 1
$T237361 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 5
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 5
	mov	edx, 134217727				; 07ffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
$LN87@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 134217727				; 07ffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	sar	ebx, 5
	push	ecx
	mov	edx, ebx
	shl	edx, 5
	push	edi
	add	edx, eax
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$220951[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV3@IABV3@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$237365[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T237361[ebp], 0
	mov	ecx, DWORD PTR $T237361[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$220951[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T237433[ebp], 0
	mov	edx, DWORD PTR $T237433[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$237437[ebp]
	push	edx
	lea	eax, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$220951[ebp]
	shl	eax, 5
	add	eax, ebx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 5
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	shl	eax, 5
	add	eax, ebx

; 1206 : 			_Mylast = _Newvec + _Count;

	shl	edi, 5
	add	edi, ebx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$220951[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)
; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	eax, ebx
	sub	eax, DWORD PTR __Where$[ebp]
	push	ecx
	sar	eax, 5
	lea	ecx, DWORD PTR __Tmp$220966[ebp]
	cmp	eax, edi
	jae	SHORT $LN3@Insert_n@3
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	eax, edi
	shl	eax, 5
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	call	??$_Umove@PAVCvStartRegion@@@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV2@00@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Umove<CvStartRegion *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$220966[ebp]
	sar	ecx, 5
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV3@IABV3@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$220966[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z ; std::fill<CvStartRegion *,CvStartRegion>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	shl	edi, 5
	mov	eax, edi
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAVCvStartRegion@@@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEPAVCvStartRegion@@PAV2@00@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Umove<CvStartRegion *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvStartRegion@@PAV1@@stdext@@YAPAVCvStartRegion@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvStartRegion *,CvStartRegion *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR tv515[ebp]
	lea	eax, DWORD PTR __Tmp$220976[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ecx, eax
	push	ecx
	push	eax
	call	??$fill@PAVCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@0ABV1@@Z ; std::fill<CvStartRegion *,CvStartRegion>
	add	esp, 24					; 00000018H
$LN1@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n
PUBLIC	??$sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 8

; 2226 : 	}

	ret	0
??$sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 8

; 2226 : 	}

	ret	0
??$sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 8

; 2226 : 	}

	ret	0
??$sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z
_TEXT	SEGMENT
$T237510 = -4						; size = 1
__Cat$237513 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 4
$LN10@push_back:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 4
	cmp	edx, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$237513[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T237510[esp+12], 0
	mov	eax, DWORD PTR $T237510[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H
	add	edi, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
$T237656 = -4						; size = 1
__Cat$237660 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$237660[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T237656[esp+12], 0
	mov	eax, DWORD PTR $T237656[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -32				; ffffffe0H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 5
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	shl	esi, 5
	add	esi, DWORD PTR [edi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z
_TEXT	SEGMENT
__Mid$221874 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>, COMDAT

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	mov	eax, ecx
	sub	eax, edx
	push	ebp
	sar	eax, 4
	cmp	eax, 32					; 00000020H
	push	esi
	push	edi
	jle	$LN3@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LL7@Sort:
	test	esi, esi
	jle	$LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	ecx
	push	edx
	lea	eax, DWORD PTR __Mid$221874[esp+32]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebx, DWORD PTR __Mid$221874[esp+36]
	mov	edi, DWORD PTR __Mid$221874[esp+40]
	mov	ecx, DWORD PTR __First$[esp+32]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Last$[esp+32]
	mov	edx, eax
	mov	ebp, ebx
	sub	edx, edi
	sub	ebp, ecx
	add	esp, 12					; 0000000cH
	and	edx, -16				; fffffff0H
	and	ebp, -16				; fffffff0H
	cmp	ebp, edx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	ebx
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>

; 3093 : 			_First = _Mid.second;
; 3094 : 			}
; 3095 : 		else

	mov	ecx, DWORD PTR __Last$[esp+32]
	mov	edx, edi
	mov	DWORD PTR __First$[esp+32], edx
	jmp	SHORT $LN41@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	eax
	push	edi
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>

; 3098 : 			_Last = _Mid.first;

	mov	edx, DWORD PTR __First$[esp+32]
	mov	ecx, ebx
	mov	DWORD PTR __Last$[esp+32], ecx
$LN41@Sort:
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 4
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN3@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN35@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
	add	esp, 12					; 0000000cH
$LN35@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, ecx
	sub	eax, edx
	and	eax, -16				; fffffff0H
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN22@Sort
	push	0
	push	0
	push	ecx
	push	edx
	call	??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR __First$[esp+36]
	add	esp, 16					; 00000010H
$LN22@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	ecx
	push	edx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z
_TEXT	SEGMENT
__Mid$221945 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>, COMDAT

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	mov	eax, ecx
	sub	eax, edx
	push	ebp
	sar	eax, 5
	cmp	eax, 32					; 00000020H
	push	esi
	push	edi
	jle	$LN3@Sort@2
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LL7@Sort@2:
	test	esi, esi
	jle	$LN6@Sort@2

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	ecx
	push	edx
	lea	eax, DWORD PTR __Mid$221945[esp+32]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebx, DWORD PTR __Mid$221945[esp+36]
	mov	edi, DWORD PTR __Mid$221945[esp+40]
	mov	ecx, DWORD PTR __First$[esp+32]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Last$[esp+32]
	mov	edx, eax
	mov	ebp, ebx
	sub	edx, edi
	sub	ebp, ecx
	add	esp, 12					; 0000000cH
	and	edx, -32				; ffffffe0H
	and	ebp, -32				; ffffffe0H
	cmp	ebp, edx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort@2
	push	ebx
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>

; 3093 : 			_First = _Mid.second;
; 3094 : 			}
; 3095 : 		else

	mov	ecx, DWORD PTR __Last$[esp+32]
	mov	edx, edi
	mov	DWORD PTR __First$[esp+32], edx
	jmp	SHORT $LN41@Sort@2
$LN5@Sort@2:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	eax
	push	edi
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>

; 3098 : 			_Last = _Mid.first;

	mov	edx, DWORD PTR __First$[esp+32]
	mov	ecx, ebx
	mov	DWORD PTR __Last$[esp+32], ecx
$LN41@Sort@2:
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 5
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@2
$LN3@Sort@2:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN35@Sort@2

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
	add	esp, 12					; 0000000cH
$LN35@Sort@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@2:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort@2

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, ecx
	sub	eax, edx
	and	eax, -32				; ffffffe0H
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN22@Sort@2
	push	0
	push	0
	push	ecx
	push	edx
	call	??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR __First$[esp+36]
	add	esp, 16					; 00000010H
$LN22@Sort@2:

; 3105 : 		std::sort_heap(_First, _Last);

	push	ecx
	push	edx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z
_TEXT	SEGMENT
__Mid$222016 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>, COMDAT

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	mov	eax, ecx
	sub	eax, edx
	push	ebp
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	push	esi
	push	edi
	jle	$LN3@Sort@3
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LL7@Sort@3:
	test	esi, esi
	jle	$LN6@Sort@3

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	ecx
	push	edx
	lea	eax, DWORD PTR __Mid$222016[esp+32]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebx, DWORD PTR __Mid$222016[esp+36]
	mov	edi, DWORD PTR __Mid$222016[esp+40]
	mov	ecx, DWORD PTR __First$[esp+32]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Last$[esp+32]
	mov	edx, eax
	mov	ebp, ebx
	sub	edx, edi
	sub	ebp, ecx
	add	esp, 12					; 0000000cH
	and	edx, -8					; fffffff8H
	and	ebp, -8					; fffffff8H
	cmp	ebp, edx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort@3
	push	ebx
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>

; 3093 : 			_First = _Mid.second;
; 3094 : 			}
; 3095 : 		else

	mov	ecx, DWORD PTR __Last$[esp+32]
	mov	edx, edi
	mov	DWORD PTR __First$[esp+32], edx
	jmp	SHORT $LN41@Sort@3
$LN5@Sort@3:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	eax
	push	edi
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>

; 3098 : 			_Last = _Mid.first;

	mov	edx, DWORD PTR __First$[esp+32]
	mov	ecx, ebx
	mov	DWORD PTR __Last$[esp+32], ecx
$LN41@Sort@3:
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@3
$LN3@Sort@3:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN35@Sort@3

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
	add	esp, 12					; 0000000cH
$LN35@Sort@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@3:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort@3

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, ecx
	sub	eax, edx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN22@Sort@3
	push	0
	push	0
	push	ecx
	push	edx
	call	??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR __First$[esp+36]
	add	esp, 16					; 00000010H
$LN22@Sort@3:

; 3105 : 		std::sort_heap(_First, _Last);

	push	ecx
	push	edx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z
_TEXT	SEGMENT
$T238085 = -4						; size = 1
__Cat$238089 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 5
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 5
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$238089[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T238085[esp+12], 0
	mov	eax, DWORD PTR $T238085[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H
	add	edi, 32					; 00000020H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 4
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 5
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ	; CvStartPositioner::RankPlayerStartOrder
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getStartingLocationPercent
EXTRN	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvPlayer::getHandicapInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_playerRank$220242 = -8					; size = 8
?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ PROC	; CvStartPositioner::RankPlayerStartOrder, COMDAT
; _this$ = ecx

; 131  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 132  : 	// Clear rankings
; 133  : 	m_PlayerOrder.clear();

	mov	ecx, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [edi+48]
	mov	DWORD PTR _this$[esp+28], edi
	cmp	ecx, edx
	je	SHORT $LN23@RankPlayer
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN48@RankPlayer
	npad	3
$LL50@RankPlayer:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL50@RankPlayer
$LN48@RankPlayer:
	mov	DWORD PTR [edi+48], ecx
$LN23@RankPlayer:

; 134  : 
; 135  : 	// Add each player
; 136  : 	for(int iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	xor	ebp, ebp
	xor	ebx, ebx
	npad	5
$LL6@RankPlayer:

; 137  : 	{
; 138  : 		CvPlayerAI& player = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 139  : 
; 140  : 		if(player.isAlive())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	esi, DWORD PTR [ebx+eax]
	je	SHORT $LN5@RankPlayer

; 141  : 		{
; 142  : 			if(player.getStartingPlot() == NULL)

	mov	ecx, esi
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	jne	SHORT $LN5@RankPlayer

; 143  : 			{
; 144  : 				CvPlayerStartRank playerRank;
; 145  : 				playerRank.m_iPlayerID = iI;
; 146  : 
; 147  : 				// Following assumes that StartingLocationPercent in Handicap XML rises in increments of 10!
; 148  : 				//    We put all the major civs first (values 1 to 100), using a random number to rank players at the same handicap
; 149  : 				//    Then we put all the minor civs in next (values 100 to 1000).
; 150  : 				playerRank.m_iRank = player.getHandicapInfo().getStartingLocationPercent();

	mov	ecx, esi
	mov	DWORD PTR _playerRank$220242[esp+28], ebp
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	ecx, eax
	call	?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getStartingLocationPercent

; 151  : 				if(player.isMinorCiv())

	mov	ecx, esi
	mov	edi, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN1@RankPlayer

; 152  : 				{
; 153  : 					playerRank.m_iRank *= 10;

	lea	edi, DWORD PTR [edi+edi*4]
	add	edi, edi
$LN1@RankPlayer:

; 154  : 				}
; 155  : 				playerRank.m_iRank += GC.getGame().getJonRandNum(10, "Player Start Plot Draft Order");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG220244
	push	10					; 0000000aH
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 156  : 				m_PlayerOrder.push_back(playerRank);

	lea	ecx, DWORD PTR _playerRank$220242[esp+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+32]
	add	edi, eax
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _playerRank$220242[esp+36], edi
	call	?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back
	mov	edi, DWORD PTR _this$[esp+28]
$LN5@RankPlayer:
	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 3983868				; 003cc9fcH
	jl	SHORT $LL6@RankPlayer

; 157  : 			}
; 158  : 		}
; 159  : 	}
; 160  : 
; 161  : 	// Sort by rank
; 162  : 	std::sort(m_PlayerOrder.begin(), m_PlayerOrder.end());

	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [edi+44]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 163  : }

	add	esp, 12					; 0000000cH
	ret	0
?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ ENDP	; CvStartPositioner::RankPlayerStartOrder
_TEXT	ENDS
PUBLIC	?AssignStartingLocations@CvStartPositioner@@QAEXXZ ; CvStartPositioner::AssignStartingLocations
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AssignStartingLocations@CvStartPositioner@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignStartingLocations@CvStartPositioner@@QAEXXZ$0
__ehfuncinfo$?AssignStartingLocations@CvStartPositioner@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AssignStartingLocations@CvStartPositioner@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ?AssignStartingLocations@CvStartPositioner@@QAEXXZ
_TEXT	SEGMENT
_iNextRegion$ = -56					; size = 4
_iMajorCivs$ = -52					; size = 4
_iHalfMinimumDist$ = -48				; size = 4
$T238527 = -48						; size = 4
$T238526 = -48						; size = 4
$T238541 = -44						; size = 4
$T238540 = -44						; size = 4
$T238535 = -44						; size = 4
$T238534 = -44						; size = 4
$T238531 = -44						; size = 4
$T238530 = -44						; size = 4
_strString$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
?AssignStartingLocations@CvStartPositioner@@QAEXXZ PROC	; CvStartPositioner::AssignStartingLocations, COMDAT
; _this$ = ecx

; 167  : {

	push	-1
	push	__ehhandler$?AssignStartingLocations@CvStartPositioner@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 168  : 	CvString strString;

	lea	ecx, DWORD PTR _strString$[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 169  : 	unsigned int iNextRegion = 0;
; 170  : 	int iPlayersPlaced = 0;
; 171  : 	int iMajorCivs = 0;
; 172  : 	for(size_t i = 0; i < m_PlayerOrder.size(); ++i)

	mov	eax, DWORD PTR [esi+48]
	sub	eax, DWORD PTR [esi+44]
	xor	ebx, ebx
	sar	eax, 3
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+80], ebx
	mov	DWORD PTR _iNextRegion$[esp+72], ebx
	mov	DWORD PTR _iMajorCivs$[esp+72], ebx
	test	eax, eax
	jbe	SHORT $LN23@AssignStar
$LL25@AssignStar:
	mov	ecx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [ecx+ebp*8]

; 173  : 	{
; 174  : 		if(!GET_PLAYER((PlayerTypes)m_PlayerOrder[i].m_iPlayerID).isMinorCiv())

	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN24@AssignStar

; 175  : 			iMajorCivs++;

	inc	DWORD PTR _iMajorCivs$[esp+72]
$LN24@AssignStar:

; 169  : 	unsigned int iNextRegion = 0;
; 170  : 	int iPlayersPlaced = 0;
; 171  : 	int iMajorCivs = 0;
; 172  : 	for(size_t i = 0; i < m_PlayerOrder.size(); ++i)

	mov	edx, DWORD PTR [esi+48]
	sub	edx, DWORD PTR [esi+44]
	inc	ebp
	sar	edx, 3
	cmp	ebp, edx
	jb	SHORT $LL25@AssignStar
$LN23@AssignStar:

; 176  : 	}
; 177  : 
; 178  : 	// MAJOR CIVS
; 179  : 	m_iRequiredSeparation = StartingPlotRange();

	mov	ecx, esi
	call	?StartingPlotRange@CvStartPositioner@@ABEHXZ ; CvStartPositioner::StartingPlotRange
	mov	DWORD PTR [esi+60], eax

; 180  : 
; 181  : 	// ***** Debug *****
; 182  : 	if(GC.getMap().getWorldSize() == WORLDSIZE_DEBUG)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ; CvMap::getWorldSize
	cmp	eax, 6
	jne	SHORT $LN210@AssignStar

; 183  : 	{
; 184  : 		m_iRequiredSeparation = 1;

	mov	DWORD PTR [esi+60], 1
$LN210@AssignStar:

; 185  : 	}
; 186  : 
; 187  : 	while(iPlayersPlaced < iMajorCivs && iNextRegion < m_StartRegionVector.size())

	cmp	DWORD PTR _iMajorCivs$[esp+72], ebx
	jle	$LN19@AssignStar
	xor	ebp, ebp
$LL20@AssignStar:
	mov	eax, DWORD PTR [esi+32]
	sub	eax, DWORD PTR [esi+28]
	sar	eax, 5
	cmp	DWORD PTR _iNextRegion$[esp+72], eax
	jae	$LN19@AssignStar

; 188  : 	{
; 189  : 		if(m_StartRegionVector[iNextRegion].m_bLargeEnoughForMajorCiv)

	mov	ecx, DWORD PTR [esi+28]
	cmp	BYTE PTR [ecx+ebp+24], bl
	je	$LN17@AssignStar

; 190  : 		{
; 191  : 			strString.Format("Trying to place major civ with full separation of %d", m_iRequiredSeparation);

	mov	edx, DWORD PTR [esi+60]
	push	edx
	lea	eax, DWORD PTR _strString$[esp+76]
	push	OFFSET $SG220270
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 192  : 			LogStartPositionMessage(strString);

	sub	esp, 16					; 00000010H
	lea	edx, DWORD PTR _strString$[esp+100]
	mov	DWORD PTR $T238526[esp+100], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, esi
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 193  : 			bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], false);

	mov	ecx, DWORD PTR [esi+28]
	add	ecx, ebp
	push	ebx
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T238527[esp+108], esp
	push	eax
	mov	ecx, esi
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion

; 194  : 			if(success)

	cmp	al, bl
	je	SHORT $LN17@AssignStar

; 195  : 			{
; 196  : 				iPlayersPlaced++;
; 197  : 				m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	ecx, DWORD PTR [esi+28]
	lea	eax, DWORD PTR [ecx+ebp+28]
	inc	edi
	inc	DWORD PTR [eax]
$LN17@AssignStar:

; 198  : 			}
; 199  : 		}
; 200  : 		iNextRegion++;

	inc	DWORD PTR _iNextRegion$[esp+72]
	add	ebp, 32					; 00000020H
	cmp	edi, DWORD PTR _iMajorCivs$[esp+72]
	jl	$LL20@AssignStar
$LN19@AssignStar:

; 201  : 	}
; 202  : 
; 203  : 	// MAJOR CIVS AGAIN (those that couldn't be placed normal start distance apart)
; 204  : 
; 205  : 	int iHalfMinimumDist = GC.getMIN_CIV_STARTING_DISTANCE() / 2;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6244
	cdq
	sub	eax, edx
	sar	eax, 1

; 206  : 	while(iPlayersPlaced < iMajorCivs && m_iRequiredSeparation >= 0)

	cmp	edi, DWORD PTR _iMajorCivs$[esp+72]
	mov	DWORD PTR _iHalfMinimumDist$[esp+72], eax
	jge	$LN219@AssignStar
$LN16@AssignStar:
	cmp	DWORD PTR [esi+60], ebx
	jl	$LN219@AssignStar

; 207  : 	{
; 208  : 		// Resort by fertility (based on the fact that some of these regions are filling up)
; 209  : 		std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 5
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>

; 210  : 
; 211  : 		// Reduce start distance by 1 (the previous condition could get stuck)
; 212  : 		m_iRequiredSeparation--;

	dec	DWORD PTR [esi+60]
	add	esp, 12					; 0000000cH

; 213  : 		iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[esp+72], ebx
	xor	ebp, ebp
	npad	6
$LL14@AssignStar:

; 214  : 
; 215  : 		while(iPlayersPlaced < iMajorCivs && iNextRegion < m_StartRegionVector.size())

	mov	eax, DWORD PTR [esi+32]
	sub	eax, DWORD PTR [esi+28]
	sar	eax, 5
	cmp	DWORD PTR _iNextRegion$[esp+72], eax
	jae	$LN13@AssignStar

; 216  : 		{
; 217  : 			if(m_StartRegionVector[iNextRegion].m_bLargeEnoughForMajorCiv)

	mov	ecx, DWORD PTR [esi+28]
	cmp	BYTE PTR [ecx+ebp+24], bl
	je	$LN11@AssignStar

; 218  : 			{
; 219  : 				strString.Format("Trying to place major civ with reduced separation of %d", m_iRequiredSeparation);

	mov	edx, DWORD PTR [esi+60]
	push	edx
	lea	eax, DWORD PTR _strString$[esp+76]
	push	OFFSET $SG220285
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 220  : 				LogStartPositionMessage(strString);

	sub	esp, 16					; 00000010H
	lea	edx, DWORD PTR _strString$[esp+100]
	mov	DWORD PTR $T238530[esp+100], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, esi
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 221  : 				bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], m_iRequiredSeparation < iHalfMinimumDist);

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR _iHalfMinimumDist$[esp+72]
	add	ecx, ebp
	cmp	DWORD PTR [esi+60], eax
	setl	dl
	movzx	eax, dl
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T238531[esp+108], esp
	push	eax
	mov	ecx, esi
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion

; 222  : 				if(success)

	cmp	al, bl
	je	SHORT $LN11@AssignStar

; 223  : 				{
; 224  : 					iPlayersPlaced++;
; 225  : 					m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	ecx, DWORD PTR [esi+28]
	lea	eax, DWORD PTR [ecx+ebp+28]
	inc	edi
	inc	DWORD PTR [eax]
$LN11@AssignStar:

; 226  : 				}
; 227  : 			}
; 228  : 			iNextRegion++;

	inc	DWORD PTR _iNextRegion$[esp+72]
	add	ebp, 32					; 00000020H
	cmp	edi, DWORD PTR _iMajorCivs$[esp+72]
	jl	$LL14@AssignStar

; 214  : 
; 215  : 		while(iPlayersPlaced < iMajorCivs && iNextRegion < m_StartRegionVector.size())

	jmp	SHORT $LN219@AssignStar
$LN13@AssignStar:

; 206  : 	while(iPlayersPlaced < iMajorCivs && m_iRequiredSeparation >= 0)

	cmp	edi, DWORD PTR _iMajorCivs$[esp+72]
	jl	$LN16@AssignStar
$LN219@AssignStar:

; 229  : 		}
; 230  : 	}
; 231  : 
; 232  : 	CvAssertMsg(iPlayersPlaced == iMajorCivs, "AssignStartingLocations() can't find enough starting locations for major civs");
; 233  : 
; 234  : 	// MINOR CIVS
; 235  : 	m_iRequiredSeparation = StartingPlotRange();

	mov	ecx, esi
	call	?StartingPlotRange@CvStartPositioner@@ABEHXZ ; CvStartPositioner::StartingPlotRange

; 236  : 
; 237  : 	// Resort by fertility (based on the fact that some of these regions are filling up)
; 238  : 	std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR [esi+32]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 5
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>

; 239  : 	while(iPlayersPlaced < (int)m_PlayerOrder.size() && iNextRegion < m_StartRegionVector.size())

	mov	eax, DWORD PTR [esi+48]
	sub	eax, DWORD PTR [esi+44]
	add	esp, 12					; 0000000cH
	sar	eax, 3
	cmp	edi, eax
	jge	$LN214@AssignStar
$LN10@AssignStar:
	mov	ecx, DWORD PTR [esi+32]
	sub	ecx, DWORD PTR [esi+28]
	mov	ebp, DWORD PTR _iNextRegion$[esp+72]
	sar	ecx, 5
	cmp	ebp, ecx
	jae	$LN214@AssignStar

; 240  : 	{
; 241  : 		strString.Format("Trying to place minor civ with full separation of %d", m_iRequiredSeparation);

	mov	edx, DWORD PTR [esi+60]
	push	edx
	lea	eax, DWORD PTR _strString$[esp+76]
	push	OFFSET $SG220296
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 242  : 		LogStartPositionMessage(strString);

	sub	esp, 16					; 00000010H
	lea	edx, DWORD PTR _strString$[esp+100]
	mov	DWORD PTR $T238534[esp+100], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, esi
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 243  : 		bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], false);

	mov	ecx, DWORD PTR [esi+28]
	push	ebx
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	shl	ebp, 5
	mov	edx, DWORD PTR [ecx+ebp]
	add	ecx, ebp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T238535[esp+108], esp
	push	eax
	mov	ecx, esi
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion

; 244  : 		if(success)

	cmp	al, bl
	je	SHORT $LN8@AssignStar

; 245  : 		{
; 246  : 			iPlayersPlaced++;
; 247  : 			m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	ecx, DWORD PTR [esi+28]
	inc	DWORD PTR [ecx+ebp+28]
	lea	eax, DWORD PTR [ecx+ebp+28]

; 248  : 
; 249  : 			// Sort again, now that the region in slot 0 has another civ placed there
; 250  : 			std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 5
	push	edx
	push	eax
	push	ecx
	inc	edi
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 251  : 			iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[esp+72], ebx

; 252  : 		}
; 253  : 
; 254  : 		// Failed, proceed through list of regions
; 255  : 		else

	jmp	SHORT $LN7@AssignStar
$LN8@AssignStar:

; 256  : 		{
; 257  : 			iNextRegion++;

	inc	DWORD PTR _iNextRegion$[esp+72]
$LN7@AssignStar:

; 239  : 	while(iPlayersPlaced < (int)m_PlayerOrder.size() && iNextRegion < m_StartRegionVector.size())

	mov	eax, DWORD PTR [esi+48]
	sub	eax, DWORD PTR [esi+44]
	sar	eax, 3
	cmp	edi, eax
	jl	$LN10@AssignStar
$LN214@AssignStar:

; 258  : 		}
; 259  : 	}
; 260  : 
; 261  : 	// MINOR CIVS AGAIN (those that couldn't be placed normal start distance apart)
; 262  : 	while(iPlayersPlaced < (int)m_PlayerOrder.size() && m_iRequiredSeparation >= 0)

	mov	ecx, DWORD PTR [esi+48]
	sub	ecx, DWORD PTR [esi+44]
	sar	ecx, 3
	cmp	edi, ecx
	jge	$LN5@AssignStar
$LL6@AssignStar:
	cmp	DWORD PTR [esi+60], ebx
	jl	$LN5@AssignStar

; 263  : 	{
; 264  : 		// Resort by fertility (based on the fact that some of these regions are filling up)
; 265  : 		std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 5
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>

; 266  : 
; 267  : 		// Reduce start distance by 10%
; 268  : 		m_iRequiredSeparation--;

	dec	DWORD PTR [esi+60]

; 269  : 		iNextRegion = 0;
; 270  : 
; 271  : 		while(iPlayersPlaced < (int)m_PlayerOrder.size() && iNextRegion < m_StartRegionVector.size())

	mov	eax, DWORD PTR [esi+48]
	sub	eax, DWORD PTR [esi+44]
	xor	ebp, ebp
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	edi, eax
	mov	DWORD PTR _iNextRegion$[esp+72], ebp
	jge	$LN3@AssignStar
	jmp	SHORT $LN4@AssignStar
$LL226@AssignStar:
	mov	ebp, DWORD PTR _iNextRegion$[esp+72]
$LN4@AssignStar:
	mov	ecx, DWORD PTR [esi+32]
	sub	ecx, DWORD PTR [esi+28]
	sar	ecx, 5
	cmp	ebp, ecx
	jae	$LN3@AssignStar

; 272  : 		{
; 273  : 			strString.Format("Trying to place minor civ with reduced separation of %d", m_iRequiredSeparation);

	mov	edx, DWORD PTR [esi+60]
	push	edx
	lea	eax, DWORD PTR _strString$[esp+76]
	push	OFFSET $SG220314
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 274  : 			LogStartPositionMessage(strString);

	sub	esp, 16					; 00000010H
	lea	edx, DWORD PTR _strString$[esp+100]
	mov	DWORD PTR $T238540[esp+100], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, esi
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 275  : 			bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], false);

	mov	ecx, DWORD PTR [esi+28]
	push	ebx
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	shl	ebp, 5
	mov	edx, DWORD PTR [ecx+ebp]
	add	ecx, ebp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T238541[esp+108], esp
	push	eax
	mov	ecx, esi
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion

; 276  : 			if(success)

	cmp	al, bl
	je	SHORT $LN2@AssignStar

; 277  : 			{
; 278  : 				iPlayersPlaced++;
; 279  : 				m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	ecx, DWORD PTR [esi+28]
	inc	DWORD PTR [ecx+ebp+28]

; 280  : 
; 281  : 				// Sort again, now that the region in slot 0 has another civ placed there
; 282  : 				std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR [esi+32]
	lea	ebp, DWORD PTR [ecx+ebp+28]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 5
	push	edx
	push	eax
	push	ecx
	inc	edi
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 283  : 				iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[esp+72], ebx

; 284  : 			}
; 285  : 
; 286  : 			// Failed, proceed through list of regions
; 287  : 			else

	jmp	SHORT $LN1@AssignStar
$LN2@AssignStar:

; 288  : 			{
; 289  : 				iNextRegion++;

	inc	DWORD PTR _iNextRegion$[esp+72]
$LN1@AssignStar:

; 269  : 		iNextRegion = 0;
; 270  : 
; 271  : 		while(iPlayersPlaced < (int)m_PlayerOrder.size() && iNextRegion < m_StartRegionVector.size())

	mov	eax, DWORD PTR [esi+48]
	sub	eax, DWORD PTR [esi+44]
	sar	eax, 3
	cmp	edi, eax
	jl	$LL226@AssignStar
$LN3@AssignStar:

; 258  : 		}
; 259  : 	}
; 260  : 
; 261  : 	// MINOR CIVS AGAIN (those that couldn't be placed normal start distance apart)
; 262  : 	while(iPlayersPlaced < (int)m_PlayerOrder.size() && m_iRequiredSeparation >= 0)

	mov	ecx, DWORD PTR [esi+48]
	sub	ecx, DWORD PTR [esi+44]
	sar	ecx, 3
	cmp	edi, ecx
	jl	$LL6@AssignStar
$LN5@AssignStar:

; 290  : 			}
; 291  : 		}
; 292  : 	}
; 293  : }

	lea	ecx, DWORD PTR _strString$[esp+72]
	mov	DWORD PTR __$EHRec$[esp+80], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 56					; 00000038H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AssignStartingLocations@CvStartPositioner@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AssignStartingLocations@CvStartPositioner@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?AssignStartingLocations@CvStartPositioner@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignStartingLocations@CvStartPositioner@@QAEXXZ ENDP	; CvStartPositioner::AssignStartingLocations
PUBLIC	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion
; Function compile flags: /Ogtpy
;	COMDAT ?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z
_TEXT	SEGMENT
_secondRegion$220395 = -64				; size = 32
_secondRegion$220390 = -64				; size = 32
_thirdRegion$220396 = -32				; size = 32
_region$ = 8						; size = 32
_bTaller$220371 = 40					; size = 1
_iNumDivisions$ = 40					; size = 4
?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z PROC ; CvStartPositioner::SubdivideRegion, COMDAT
; _this$ = ecx

; 383  : {

	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	mov	esi, ecx

; 384  : 	int iNumDivides = 0;
; 385  : 	int iLaterSubdivisions = 0;
; 386  : 
; 387  : 	// Break recursion when number of divisions is down to 1
; 388  : 	if(iNumDivisions == 1)

	mov	ecx, DWORD PTR _iNumDivisions$[esp+68]
	mov	edx, 1
	push	edi
	cmp	ecx, edx
	jne	SHORT $LN39@SubdivideR

; 389  : 	{
; 390  : 		// Store this as a final region
; 391  : 		m_StartRegionVector.push_back(region);

	lea	eax, DWORD PTR _region$[esp+72]
	push	eax
	lea	ecx, DWORD PTR [esi+24]
	call	?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back

; 493  : 		}
; 494  : 	}
; 495  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 64					; 00000040H
	ret	36					; 00000024H
$LN39@SubdivideR:

; 392  : 	}
; 393  : 
; 394  : 	// Need to subdivide
; 395  : 	else if(iNumDivisions > 1)

	jle	$LN1@SubdivideR

; 396  : 	{
; 397  : 		// See if region is taller or wider
; 398  : 		bool bTaller = true;
; 399  : 		if((region.m_Boundaries.m_iNorthEdge - region.m_Boundaries.m_iSouthEdge) <
; 400  : 		        (region.m_Boundaries.m_iEastEdge - region.m_Boundaries.m_iWestEdge))

	mov	edi, DWORD PTR _region$[esp+80]
	mov	ebx, DWORD PTR _region$[esp+72]
	sub	edi, DWORD PTR _region$[esp+84]
	sub	ebx, DWORD PTR _region$[esp+76]
	xor	eax, eax
	cmp	ebx, edi
	mov	BYTE PTR _bTaller$220371[esp+72], dl
	jge	SHORT $LN18@SubdivideR

; 401  : 		{
; 402  : 			bTaller = false;

	mov	BYTE PTR _bTaller$220371[esp+72], al
$LN18@SubdivideR:

; 403  : 		}
; 404  : 
; 405  : 		// If number of divisions is greater than 3...
; 406  : 		//
; 407  : 		// Number       First Divide     Each Subdivision
; 408  : 		// ------       ------------     ----------------
; 409  : 		//   4                2                 2
; 410  : 		//  5-6               3                 2
; 411  : 		//  7-8               2                 4
; 412  : 		//   9                3                 3
; 413  : 		// 10-12              3                 4
; 414  : 		// 13-16              2                 8
; 415  : 		// 17-18              3                 6
; 416  : 		// 19-20              2                10
; 417  : 		// 21-22              3                 8
; 418  : 		switch(iNumDivisions)

	add	ecx, -2					; fffffffeH
	cmp	ecx, 20					; 00000014H
	ja	$LN1@SubdivideR
	movzx	ecx, BYTE PTR $LN38@SubdivideR[ecx]
	jmp	DWORD PTR $LN41@SubdivideR[ecx*4]
$LN15@SubdivideR:

; 419  : 		{
; 420  : 		case 2:
; 421  : 			iNumDivides = 2;
; 422  : 			iLaterSubdivisions = 1;

	mov	edi, edx
$LN36@SubdivideR:

; 479  : 		{
; 480  : 			CvStartRegion secondRegion;
; 481  : 			ChopIntoTwoRegions(bTaller, &region, &secondRegion, 50);

	mov	ecx, DWORD PTR _bTaller$220371[esp+72]
	push	50					; 00000032H
	mov	BYTE PTR _secondRegion$220390[esp+104], dl
	lea	edx, DWORD PTR _secondRegion$220390[esp+80]
	mov	DWORD PTR _secondRegion$220390[esp+80], eax
	mov	DWORD PTR _secondRegion$220390[esp+84], eax
	mov	DWORD PTR _secondRegion$220390[esp+88], eax
	mov	DWORD PTR _secondRegion$220390[esp+92], eax
	mov	DWORD PTR _secondRegion$220390[esp+96], eax
	mov	DWORD PTR _secondRegion$220390[esp+108], eax
	push	edx
	lea	eax, DWORD PTR _region$[esp+80]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _secondRegion$220390[esp+112], -1
	call	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions

; 482  : 			SubdivideRegion(region, iLaterSubdivisions);

	push	edi
	sub	esp, 32					; 00000020H
	lea	edx, DWORD PTR _region$[esp+108]
	mov	ecx, esp
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, esi
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 483  : 			SubdivideRegion(secondRegion, iLaterSubdivisions);

	push	edi
	sub	esp, 32					; 00000020H
	lea	eax, DWORD PTR _secondRegion$220390[esp+112]
	mov	ecx, esp
	push	eax
	jmp	$LN40@SubdivideR
$LN14@SubdivideR:

; 423  : 			break;
; 424  : 		case 3:
; 425  : 			iNumDivides = 3;
; 426  : 			iLaterSubdivisions = 1;

	mov	edi, edx
$LN37@SubdivideR:

; 484  : 		}
; 485  : 		else if(iNumDivides == 3)
; 486  : 		{
; 487  : 			CvStartRegion secondRegion;

	or	ecx, -1
	mov	DWORD PTR _secondRegion$220395[esp+96], ecx

; 488  : 			CvStartRegion thirdRegion;

	mov	DWORD PTR _thirdRegion$220396[esp+96], ecx

; 489  : 			ChopIntoThreeRegions(bTaller, &region, &secondRegion, &thirdRegion);

	lea	ecx, DWORD PTR _thirdRegion$220396[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _bTaller$220371[esp+76]
	mov	BYTE PTR _secondRegion$220395[esp+104], dl
	mov	BYTE PTR _thirdRegion$220396[esp+104], dl
	lea	edx, DWORD PTR _secondRegion$220395[esp+80]
	mov	DWORD PTR _secondRegion$220395[esp+80], eax
	mov	DWORD PTR _secondRegion$220395[esp+84], eax
	mov	DWORD PTR _secondRegion$220395[esp+88], eax
	mov	DWORD PTR _secondRegion$220395[esp+92], eax
	mov	DWORD PTR _secondRegion$220395[esp+96], eax
	mov	DWORD PTR _secondRegion$220395[esp+108], eax
	mov	DWORD PTR _thirdRegion$220396[esp+80], eax
	mov	DWORD PTR _thirdRegion$220396[esp+84], eax
	mov	DWORD PTR _thirdRegion$220396[esp+88], eax
	mov	DWORD PTR _thirdRegion$220396[esp+92], eax
	mov	DWORD PTR _thirdRegion$220396[esp+96], eax
	mov	DWORD PTR _thirdRegion$220396[esp+108], eax
	push	edx
	lea	eax, DWORD PTR _region$[esp+80]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z ; CvStartPositioner::ChopIntoThreeRegions

; 490  : 			SubdivideRegion(region, iLaterSubdivisions);

	push	edi
	sub	esp, 32					; 00000020H
	lea	edx, DWORD PTR _region$[esp+108]
	mov	ecx, esp
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, esi
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 491  : 			SubdivideRegion(secondRegion, iLaterSubdivisions);

	push	edi
	sub	esp, 32					; 00000020H
	lea	eax, DWORD PTR _secondRegion$220395[esp+112]
	mov	ecx, esp
	push	eax
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, esi
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 492  : 			SubdivideRegion(thirdRegion, iLaterSubdivisions);

	push	edi
	sub	esp, 32					; 00000020H
	lea	edx, DWORD PTR _thirdRegion$220396[esp+112]
	mov	ecx, esp
	push	edx
$LN40@SubdivideR:
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, esi
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion
$LN1@SubdivideR:

; 493  : 		}
; 494  : 	}
; 495  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 64					; 00000040H
	ret	36					; 00000024H
$LN13@SubdivideR:

; 427  : 			break;
; 428  : 		case 4:
; 429  : 			iNumDivides = 2;
; 430  : 			iLaterSubdivisions = 2;

	mov	edi, 2

; 431  : 			break;

	jmp	$LN36@SubdivideR
$LN12@SubdivideR:

; 432  : 		case 5:
; 433  : 		case 6:
; 434  : 			iNumDivides = 3;
; 435  : 			iLaterSubdivisions = 2;

	mov	edi, 2

; 436  : 			break;

	jmp	$LN37@SubdivideR
$LN11@SubdivideR:

; 437  : 		case 7:
; 438  : 		case 8:
; 439  : 			iNumDivides = 2;
; 440  : 			iLaterSubdivisions = 4;

	mov	edi, 4

; 441  : 			break;

	jmp	$LN36@SubdivideR
$LN10@SubdivideR:

; 442  : 		case 9:
; 443  : 			iNumDivides = 3;
; 444  : 			iLaterSubdivisions = 3;

	mov	edi, 3

; 445  : 			break;

	jmp	$LN37@SubdivideR
$LN9@SubdivideR:

; 446  : 		case 10:
; 447  : 		case 11:
; 448  : 		case 12:
; 449  : 			iNumDivides = 3;
; 450  : 			iLaterSubdivisions = 4;

	mov	edi, 4

; 451  : 			break;

	jmp	$LN37@SubdivideR
$LN8@SubdivideR:

; 452  : 		case 13:
; 453  : 		case 14:
; 454  : 		case 15:
; 455  : 		case 16:
; 456  : 			iNumDivides = 2;
; 457  : 			iLaterSubdivisions = 8;

	mov	edi, 8

; 458  : 			break;

	jmp	$LN36@SubdivideR
$LN7@SubdivideR:

; 459  : 		case 17:
; 460  : 		case 18:
; 461  : 			iNumDivides = 3;
; 462  : 			iLaterSubdivisions = 6;

	mov	edi, 6

; 463  : 			break;

	jmp	$LN37@SubdivideR
$LN6@SubdivideR:

; 464  : 		case 19:
; 465  : 		case 20:
; 466  : 			iNumDivides = 2;
; 467  : 			iLaterSubdivisions = 10;

	mov	edi, 10					; 0000000aH

; 468  : 			break;

	jmp	$LN36@SubdivideR
$LN5@SubdivideR:

; 469  : 		case 21:
; 470  : 		case 22:
; 471  : 			iNumDivides = 3;
; 472  : 			iLaterSubdivisions = 8;

	mov	edi, 8

; 473  : 			break;
; 474  : 		default:
; 475  : 			CvAssertMsg(false, "Trying to create regions for more than 18 major civs.");
; 476  : 		}
; 477  : 
; 478  : 		if(iNumDivides == 2)

	jmp	$LN37@SubdivideR
	npad	2
$LN41@SubdivideR:

; 493  : 		}
; 494  : 	}
; 495  : }

	DD	$LN15@SubdivideR
	DD	$LN14@SubdivideR
	DD	$LN13@SubdivideR
	DD	$LN12@SubdivideR
	DD	$LN11@SubdivideR
	DD	$LN10@SubdivideR
	DD	$LN9@SubdivideR
	DD	$LN8@SubdivideR
	DD	$LN7@SubdivideR
	DD	$LN6@SubdivideR
	DD	$LN5@SubdivideR
$LN38@SubdivideR:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	4
	DB	5
	DB	6
	DB	6
	DB	6
	DB	7
	DB	7
	DB	7
	DB	7
	DB	8
	DB	8
	DB	9
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ENDP ; CvStartPositioner::SubdivideRegion
_TEXT	ENDS
PUBLIC	?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z ; CvStartPositioner::DivideContinentIntoRegions
EXTRN	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ:PROC ; CvArea::getAreaBoundaries
; Function compile flags: /Ogtpy
;	COMDAT ?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z
_TEXT	SEGMENT
$T239025 = -48						; size = 16
_region$ = -32						; size = 32
_continent$ = 8						; size = 16
?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z PROC ; CvStartPositioner::DivideContinentIntoRegions, COMDAT
; _this$ = ecx

; 316  : {

	sub	esp, 48					; 00000030H

; 317  : 	// Create a start region out of the entire continent
; 318  : 	CvStartRegion region;
; 319  : 	region.m_uiFertility = continent.GetFertility();
; 320  : 	region.m_iAreaID = continent.GetArea();

	mov	eax, DWORD PTR _continent$[esp+56]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _continent$[esp+60]
	mov	esi, ecx

; 321  : 	region.m_Boundaries = GC.getMap().getArea(continent.GetArea())->getAreaBoundaries();

	lea	ecx, DWORD PTR $T239025[esp+64]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebp, eax
	xor	ebx, ebx
	push	eax
	mov	BYTE PTR _region$[esp+96], 1
	mov	DWORD PTR _region$[esp+100], ebx
	mov	DWORD PTR _region$[esp+88], edi
	mov	DWORD PTR _region$[esp+92], ebp
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _region$[esp+68], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _region$[esp+76], eax

; 322  : 
; 323  : 	// Make sure this is a continent that is getting a start region
; 324  : 	if(continent.GetNumRegions() > 0)

	mov	eax, DWORD PTR _continent$[esp+68]
	cmp	eax, ebx
	mov	DWORD PTR _region$[esp+64], ecx
	mov	DWORD PTR _region$[esp+72], edx
	jle	SHORT $LN2@DivideCont

; 325  : 	{
; 326  : 		// If so, call recursive routine to subdivide it appropriately
; 327  : 		SubdivideRegion(region, continent.GetNumRegions());

	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _region$[esp+104]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR _region$[esp+112]
	mov	ecx, esi
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edi
	mov	DWORD PTR [eax+20], ebp
	mov	BYTE PTR [eax+24], 1
	mov	DWORD PTR [eax+28], ebx
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 335  : 	}
; 336  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	16					; 00000010H
$LN2@DivideCont:

; 328  : 	}
; 329  : 
; 330  : 	// If the continent is too small for a major civ, it still could be useful for a minor
; 331  : 	else
; 332  : 	{
; 333  : 		region.m_bLargeEnoughForMajorCiv = false;
; 334  : 		m_StartRegionVector.push_back(region);

	lea	eax, DWORD PTR _region$[esp+64]
	push	eax
	lea	ecx, DWORD PTR [esi+24]
	mov	BYTE PTR _region$[esp+92], bl
	call	?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back

; 335  : 	}
; 336  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	16					; 00000010H
?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z ENDP ; CvStartPositioner::DivideContinentIntoRegions
_TEXT	ENDS
PUBLIC	?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z ; CvStartPositioner::DivideMapIntoRegions
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z
_TEXT	SEGMENT
_iLoop$ = -24						; size = 4
$T239260 = -20						; size = 4
_continent$219901 = -16					; size = 16
_iNumRegions$ = 8					; size = 4
?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z PROC	; CvStartPositioner::DivideMapIntoRegions, COMDAT
; _this$ = ecx

; 47   : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 48   : 	CvArea* pLoopArea(NULL);
; 49   : 	int iLoop;
; 50   : 	int iNumRegionsPlaced = 0;
; 51   : 
; 52   : 	// Initialize
; 53   : 	m_ContinentVector.clear();

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	push	edi
	lea	edi, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN27@DivideMapI
	push	ecx
	push	eax
	push	eax
	call	??$unchecked_copy@PAVCvContinent@@PAV1@@stdext@@YAPAVCvContinent@@PAV1@00@Z ; stdext::unchecked_copy<CvContinent *,CvContinent *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+8], eax
$LN27@DivideMapI:

; 54   : 	m_StartRegionVector.clear();

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [esi+24]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T239260[esp+48]
	push	eax
	call	?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase

; 55   : 
; 56   : 	// Compute fertility for each plot
; 57   : 	ComputeTileFertilityValues();

	mov	ecx, esi
	call	?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ ; CvStartPositioner::ComputeTileFertilityValues

; 58   : 
; 59   : 	// Loop through each continent adding it to our list
; 60   : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN8@DivideMapI
$LL10@DivideMapI:

; 61   : 	{
; 62   : 		// Throw out oceans and desert islands
; 63   : 		if(pLoopArea->getTotalFoundValue() > 0 && pLoopArea->getNumTiles() >= GC.getMIN_START_AREA_TILES())

	mov	ecx, ebx
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	test	eax, eax
	jle	SHORT $LN9@DivideMapI
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7140
	mov	ecx, ebx
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, ebp
	jl	SHORT $LN9@DivideMapI

; 64   : 		{
; 65   : 			CvContinent continent;
; 66   : 			continent.SetFertility(pLoopArea->getTotalFoundValue());

	mov	ecx, ebx
	mov	DWORD PTR _continent$219901[esp+48], 0
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue

; 67   : 			continent.SetArea(pLoopArea->GetID());

	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR _continent$219901[esp+40], eax
	mov	DWORD PTR _continent$219901[esp+44], eax

; 68   : 			m_ContinentVector.push_back(continent);

	lea	eax, DWORD PTR _continent$219901[esp+40]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _continent$219901[esp+56], edx
	call	?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back
$LN9@DivideMapI:
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL10@DivideMapI
$LN8@DivideMapI:

; 69   : 		}
; 70   : 	}
; 71   : 
; 72   : 	if(m_ContinentVector.size() > 0)

	mov	edx, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+4]
	sar	edx, 4
	test	edx, edx
	jbe	SHORT $LN4@DivideMapI

; 73   : 	{
; 74   : 		// Assign all the regions to continents
; 75   : 		while(iNumRegionsPlaced < iNumRegions)

	mov	ebx, DWORD PTR _iNumRegions$[esp+36]
	test	ebx, ebx
	jle	SHORT $LN4@DivideMapI
	npad	5
$LL5@DivideMapI:

; 76   : 		{
; 77   : 			std::sort(m_ContinentVector.begin(), m_ContinentVector.end());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 4
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>

; 78   : 
; 79   : 			// Add a region to the first in our list
; 80   : 			m_ContinentVector[0].AddRegion();

	mov	ecx, DWORD PTR [esi+12]
	inc	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+8]
	lea	ebp, DWORD PTR [eax+1]
	mov	eax, DWORD PTR [ecx]
	cdq
	idiv	ebp
	add	esp, 12					; 0000000cH
	sub	ebx, 1
	mov	DWORD PTR [ecx+4], eax
	jne	SHORT $LL5@DivideMapI
$LN4@DivideMapI:

; 81   : 			iNumRegionsPlaced++;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	// Divide the continents according to our algorithm
; 86   : 	for(unsigned int iI=0; iI < m_ContinentVector.size(); iI++)

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	xor	ebx, ebx
	sar	eax, 4
	test	eax, eax
	jbe	SHORT $LN1@DivideMapI
	xor	ebp, ebp
$LL3@DivideMapI:
	mov	eax, DWORD PTR [esi+12]

; 87   : 	{
; 88   : 		DivideContinentIntoRegions(m_ContinentVector[iI]);

	mov	edx, DWORD PTR [eax+ebp]
	add	eax, ebp
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, esi
	call	?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z ; CvStartPositioner::DivideContinentIntoRegions
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	inc	ebx
	sar	ecx, 4
	add	ebp, 16					; 00000010H
	cmp	ebx, ecx
	jb	SHORT $LL3@DivideMapI
$LN1@DivideMapI:

; 89   : 	}
; 90   : 
; 91   : 	// Sort the regions by fertility
; 92   : 	std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR [esi+32]
	mov	esi, DWORD PTR [esi+28]
	mov	edx, eax
	sub	edx, esi
	sar	edx, 5
	push	edx
	push	eax
	push	esi
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 93   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z ENDP	; CvStartPositioner::DivideMapIntoRegions
_TEXT	ENDS
END
