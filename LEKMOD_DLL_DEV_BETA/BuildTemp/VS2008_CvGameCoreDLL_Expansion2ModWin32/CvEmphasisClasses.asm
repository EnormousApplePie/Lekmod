; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvEmphasisClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217540 DB	'AvoidGrowth', 00H
$SG217541 DB	'GreatPeople', 00H
$SG217543 DB	'EmphasizeType', 00H
	ORG $+2
$SG217544 DB	'EmphasizeInfo_Yields', 00H
CONST	ENDS
PUBLIC	?IsAvoidGrowth@CvEmphasisEntry@@QBE_NXZ		; CvEmphasisEntry::IsAvoidGrowth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvemphasisclasses.cpp
;	COMDAT ?IsAvoidGrowth@CvEmphasisEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAvoidGrowth@CvEmphasisEntry@@QBE_NXZ PROC		; CvEmphasisEntry::IsAvoidGrowth, COMDAT
; _this$ = ecx

; 48   : 	return m_bAvoidGrowth;

	mov	al, BYTE PTR [ecx+260]

; 49   : }

	ret	0
?IsAvoidGrowth@CvEmphasisEntry@@QBE_NXZ ENDP		; CvEmphasisEntry::IsAvoidGrowth
_TEXT	ENDS
PUBLIC	?IsGreatPeople@CvEmphasisEntry@@QBE_NXZ		; CvEmphasisEntry::IsGreatPeople
; Function compile flags: /Ogtpy
;	COMDAT ?IsGreatPeople@CvEmphasisEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGreatPeople@CvEmphasisEntry@@QBE_NXZ PROC		; CvEmphasisEntry::IsGreatPeople, COMDAT
; _this$ = ecx

; 53   : 	return m_bGreatPeople;

	mov	al, BYTE PTR [ecx+261]

; 54   : }

	ret	0
?IsGreatPeople@CvEmphasisEntry@@QBE_NXZ ENDP		; CvEmphasisEntry::IsGreatPeople
_TEXT	ENDS
PUBLIC	?GetYieldChange@CvEmphasisEntry@@QBEHH@Z	; CvEmphasisEntry::GetYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChange@CvEmphasisEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChange@CvEmphasisEntry@@QBEHH@Z PROC		; CvEmphasisEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 58   : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 59   : 	CvAssertMsg(i > -1, "Index out of bounds");
; 60   : 	return m_piYieldModifiers ? m_piYieldModifiers[i] : -1;

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 61   : }

	ret	4
$LN3@GetYieldCh:

; 58   : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 59   : 	CvAssertMsg(i > -1, "Index out of bounds");
; 60   : 	return m_piYieldModifiers ? m_piYieldModifiers[i] : -1;

	or	eax, -1

; 61   : }

	ret	4
?GetYieldChange@CvEmphasisEntry@@QBEHH@Z ENDP		; CvEmphasisEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ; CvEmphasisXMLEntries::GetEmphasisEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ PROC ; CvEmphasisXMLEntries::GetEmphasisEntries, COMDAT
; _this$ = ecx

; 80   : {

	mov	eax, ecx

; 81   : 	return m_paEmphasisEntries;
; 82   : }

	ret	0
?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ENDP ; CvEmphasisXMLEntries::GetEmphasisEntries
_TEXT	ENDS
PUBLIC	??0CvCityEmphases@@QAE@XZ			; CvCityEmphases::CvCityEmphases
; Function compile flags: /Ogtpy
;	COMDAT ??0CvCityEmphases@@QAE@XZ
_TEXT	SEGMENT
??0CvCityEmphases@@QAE@XZ PROC				; CvCityEmphases::CvCityEmphases, COMDAT
; _this$ = ecx

; 128  : {

	mov	eax, ecx

; 129  : 	m_pbEmphasize = NULL;

	mov	DWORD PTR [eax+32], 0

; 130  : }

	ret	0
??0CvCityEmphases@@QAE@XZ ENDP				; CvCityEmphases::CvCityEmphases
_TEXT	ENDS
PUBLIC	??1CvCityEmphases@@QAE@XZ			; CvCityEmphases::~CvCityEmphases
; Function compile flags: /Ogtpy
;	COMDAT ??1CvCityEmphases@@QAE@XZ
_TEXT	SEGMENT
??1CvCityEmphases@@QAE@XZ PROC				; CvCityEmphases::~CvCityEmphases, COMDAT
; _this$ = ecx

; 135  : 
; 136  : }

	ret	0
??1CvCityEmphases@@QAE@XZ ENDP				; CvCityEmphases::~CvCityEmphases
_TEXT	ENDS
PUBLIC	?GetEmphasizeAvoidGrowthCount@CvCityEmphases@@QAEHXZ ; CvCityEmphases::GetEmphasizeAvoidGrowthCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmphasizeAvoidGrowthCount@CvCityEmphases@@QAEHXZ
_TEXT	SEGMENT
?GetEmphasizeAvoidGrowthCount@CvCityEmphases@@QAEHXZ PROC ; CvCityEmphases::GetEmphasizeAvoidGrowthCount, COMDAT
; _this$ = ecx

; 186  : 	return m_iEmphasizeAvoidGrowthCount;

	mov	eax, DWORD PTR [ecx]

; 187  : }

	ret	0
?GetEmphasizeAvoidGrowthCount@CvCityEmphases@@QAEHXZ ENDP ; CvCityEmphases::GetEmphasizeAvoidGrowthCount
_TEXT	ENDS
PUBLIC	?IsEmphasizeAvoidGrowth@CvCityEmphases@@QAE_NXZ	; CvCityEmphases::IsEmphasizeAvoidGrowth
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmphasizeAvoidGrowth@CvCityEmphases@@QAE_NXZ
_TEXT	SEGMENT
?IsEmphasizeAvoidGrowth@CvCityEmphases@@QAE_NXZ PROC	; CvCityEmphases::IsEmphasizeAvoidGrowth, COMDAT
; _this$ = ecx

; 192  : 	return (GetEmphasizeAvoidGrowthCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setg	al

; 193  : }

	ret	0
?IsEmphasizeAvoidGrowth@CvCityEmphases@@QAE_NXZ ENDP	; CvCityEmphases::IsEmphasizeAvoidGrowth
_TEXT	ENDS
PUBLIC	?GetEmphasizeYieldCount@CvCityEmphases@@QAEHW4YieldTypes@@@Z ; CvCityEmphases::GetEmphasizeYieldCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmphasizeYieldCount@CvCityEmphases@@QAEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetEmphasizeYieldCount@CvCityEmphases@@QAEHW4YieldTypes@@@Z PROC ; CvCityEmphases::GetEmphasizeYieldCount, COMDAT
; _this$ = ecx

; 198  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 199  : 	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 200  : 	if(eIndex >= 0 && eIndex < NUM_YIELD_TYPES)

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 5
	ja	SHORT $LN1@GetEmphasi

; 201  : 		return m_aiEmphasizeYieldCount[eIndex];

	mov	eax, DWORD PTR [ecx+eax*4+8]

; 203  : }

	ret	4
$LN1@GetEmphasi:

; 202  : 	return 0; // default set during "reset"

	xor	eax, eax

; 203  : }

	ret	4
?GetEmphasizeYieldCount@CvCityEmphases@@QAEHW4YieldTypes@@@Z ENDP ; CvCityEmphases::GetEmphasizeYieldCount
_TEXT	ENDS
PUBLIC	?IsEmphasizeYield@CvCityEmphases@@QAE_NW4YieldTypes@@@Z ; CvCityEmphases::IsEmphasizeYield
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmphasizeYield@CvCityEmphases@@QAE_NW4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsEmphasizeYield@CvCityEmphases@@QAE_NW4YieldTypes@@@Z PROC ; CvCityEmphases::IsEmphasizeYield, COMDAT
; _this$ = ecx

; 208  : 	return (GetEmphasizeYieldCount(eIndex) > 0);

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 5
	ja	SHORT $LN3@IsEmphasiz
	mov	eax, DWORD PTR [ecx+eax*4+8]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 209  : }

	ret	4

; 208  : 	return (GetEmphasizeYieldCount(eIndex) > 0);

$LN3@IsEmphasiz:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 209  : }

	ret	4
?IsEmphasizeYield@CvCityEmphases@@QAE_NW4YieldTypes@@@Z ENDP ; CvCityEmphases::IsEmphasizeYield
_TEXT	ENDS
PUBLIC	?IsEmphasize@CvCityEmphases@@QAE_NW4EmphasizeTypes@@@Z ; CvCityEmphases::IsEmphasize
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmphasize@CvCityEmphases@@QAE_NW4EmphasizeTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsEmphasize@CvCityEmphases@@QAE_NW4EmphasizeTypes@@@Z PROC ; CvCityEmphases::IsEmphasize, COMDAT
; _this$ = ecx

; 214  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 215  : 	CvAssertMsg(eIndex < GC.getNumEmphasisInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 216  : 	CvAssertMsg(m_pbEmphasize != NULL, "m_pbEmphasize is not expected to be equal with NULL");
; 217  : 
; 218  : 	if(!m_pbEmphasize) return false;

	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	jne	SHORT $LN1@IsEmphasiz@2
	xor	al, al

; 221  : }

	ret	4
$LN1@IsEmphasiz@2:

; 219  : 
; 220  : 	return m_pbEmphasize[eIndex];

	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 221  : }

	ret	4
?IsEmphasize@CvCityEmphases@@QAE_NW4EmphasizeTypes@@@Z ENDP ; CvCityEmphases::IsEmphasize
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@XZ	; std::allocator<CvEmphasisEntry *>::allocator<CvEmphasisEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@XZ PROC	; std::allocator<CvEmphasisEntry *>::allocator<CvEmphasisEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvEmphasisEntry *>::allocator<CvEmphasisEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEABQAVCvEmphasisEntry@@XZ ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEABQAVCvEmphasisEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEABQAVCvEmphasisEntry@@XZ PROC ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEABQAVCvEmphasisEntry@@XZ ENDP ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvEmphasisEntry *>::allocator<CvEmphasisEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvEmphasisEntry *>::allocator<CvEmphasisEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvEmphasisEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvEmphasisEntry *>::allocator<CvEmphasisEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEXPAPAVCvEmphasisEntry@@I@Z ; std::allocator<CvEmphasisEntry *>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEXPAPAVCvEmphasisEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEXPAPAVCvEmphasisEntry@@I@Z PROC ; std::allocator<CvEmphasisEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEXPAPAVCvEmphasisEntry@@I@Z ENDP ; std::allocator<CvEmphasisEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z PROC ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z ENDP ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvEmphasisEntry@@@std@@QBEIXZ ; std::allocator<CvEmphasisEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvEmphasisEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvEmphasisEntry@@@std@@QBEIXZ PROC ; std::allocator<CvEmphasisEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvEmphasisEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvEmphasisEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEmphasisEntry@@0@Z ; std::_Iter_random<CvEmphasisEntry * *,CvEmphasisEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEmphasisEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEmphasisEntry@@0@Z PROC ; std::_Iter_random<CvEmphasisEntry * *,CvEmphasisEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEmphasisEntry@@0@Z ENDP ; std::_Iter_random<CvEmphasisEntry * *,CvEmphasisEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEmphasisEntry@@0@Z ; std::_Ptr_cat<CvEmphasisEntry * *,CvEmphasisEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEmphasisEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEmphasisEntry@@0@Z PROC ; std::_Ptr_cat<CvEmphasisEntry * *,CvEmphasisEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvEmphasisEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEmphasisEntry@@0@Z ENDP ; std::_Ptr_cat<CvEmphasisEntry * *,CvEmphasisEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvEmphasisEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEmphasisEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvEmphasisEntry * *,CvEmphasisEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvEmphasisEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEmphasisEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvEmphasisEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEmphasisEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvEmphasisEntry * *,CvEmphasisEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvEmphasisEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEmphasisEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvEmphasisEntry * *,CvEmphasisEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEmphasisEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvEmphasisEntry@@6B@			; CvEmphasisEntry::`vftable'
PUBLIC	??1CvEmphasisEntry@@QAE@XZ			; CvEmphasisEntry::~CvEmphasisEntry
PUBLIC	??_R4CvEmphasisEntry@@6B@			; CvEmphasisEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvEmphasisEntry@@@8			; CvEmphasisEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvEmphasisEntry@@8				; CvEmphasisEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvEmphasisEntry@@8				; CvEmphasisEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvEmphasisEntry@@8		; CvEmphasisEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvEmphasisEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvEmphasisEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvEmphasisEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvEmphasisEntry@@8 DD FLAT:??_R0?AVCvEmphasisEntry@@@8 ; CvEmphasisEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvEmphasisEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvEmphasisEntry@@8
rdata$r	SEGMENT
??_R2CvEmphasisEntry@@8 DD FLAT:??_R1A@?0A@EA@CvEmphasisEntry@@8 ; CvEmphasisEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvEmphasisEntry@@8
rdata$r	SEGMENT
??_R3CvEmphasisEntry@@8 DD 00H				; CvEmphasisEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvEmphasisEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvEmphasisEntry@@@8
_DATA	SEGMENT
??_R0?AVCvEmphasisEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvEmphasisEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvEmphasisEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvEmphasisEntry@@6B@
rdata$r	SEGMENT
??_R4CvEmphasisEntry@@6B@ DD 00H			; CvEmphasisEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvEmphasisEntry@@@8
	DD	FLAT:??_R3CvEmphasisEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvEmphasisEntry@@6B@
CONST	SEGMENT
??_7CvEmphasisEntry@@6B@ DD FLAT:??_R4CvEmphasisEntry@@6B@ ; CvEmphasisEntry::`vftable'
	DD	FLAT:?CacheResults@CvEmphasisEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvemphasisclasses.cpp
CONST	ENDS
;	COMDAT ??1CvEmphasisEntry@@QAE@XZ
_TEXT	SEGMENT
??1CvEmphasisEntry@@QAE@XZ PROC				; CvEmphasisEntry::~CvEmphasisEntry, COMDAT
; _this$ = ecx

; 26   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvEmphasisEntry@@6B@

; 27   : 	SAFE_DELETE_ARRAY(m_piYieldModifiers);

	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+264], 0

; 28   : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvEmphasisEntry@@QAE@XZ ENDP				; CvEmphasisEntry::~CvEmphasisEntry
_TEXT	ENDS
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvEmphasisEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvEmphasisEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvEmphasisEntry::CacheResults, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp

; 33   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul
	pop	edi
	pop	esi
	pop	ebp

; 43   : }

	ret	8
$LN1@CacheResul:
	push	ebx

; 34   : 		return false;
; 35   : 
; 36   : 	m_bAvoidGrowth = kResults.GetBool("AvoidGrowth");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG217540
	mov	ecx, edi
	call	ebx

; 37   : 	m_bGreatPeople = kResults.GetBool("GreatPeople");

	push	OFFSET $SG217541
	mov	ecx, edi
	mov	BYTE PTR [esi+260], al
	call	ebx

; 38   : 
; 39   : 	const char* szEmphasizeType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR [esi+261], al
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 40   : 	kUtility.SetYields(m_piYieldModifiers, "EmphasizeInfo_Yields", "EmphasizeType", szEmphasizeType);

	push	eax
	push	OFFSET $SG217543
	push	OFFSET $SG217544
	add	esi, 264				; 00000108H
	push	esi
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields
	pop	ebx
	pop	edi
	pop	esi

; 41   : 
; 42   : 	return true;

	mov	al, 1
	pop	ebp

; 43   : }

	ret	8
?CacheResults@CvEmphasisEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvEmphasisEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetNumEmphases@CvEmphasisXMLEntries@@QAEHXZ	; CvEmphasisXMLEntries::GetNumEmphases
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumEmphases@CvEmphasisXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumEmphases@CvEmphasisXMLEntries@@QAEHXZ PROC	; CvEmphasisXMLEntries::GetNumEmphases, COMDAT
; _this$ = ecx

; 91   : 	return m_paEmphasisEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 92   : }

	ret	0
?GetNumEmphases@CvEmphasisXMLEntries@@QAEHXZ ENDP	; CvEmphasisXMLEntries::GetNumEmphases
_TEXT	ENDS
PUBLIC	?GetEntry@CvEmphasisXMLEntries@@QAEPAVCvEmphasisEntry@@H@Z ; CvEmphasisXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvEmphasisXMLEntries@@QAEPAVCvEmphasisEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvEmphasisXMLEntries@@QAEPAVCvEmphasisEntry@@H@Z PROC ; CvEmphasisXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 112  : 	return m_paEmphasisEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 113  : }

	ret	4
?GetEntry@CvEmphasisXMLEntries@@QAEPAVCvEmphasisEntry@@H@Z ENDP ; CvEmphasisXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvCityEmphases@@QAEXXZ			; CvCityEmphases::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvCityEmphases@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvCityEmphases@@QAEXXZ PROC			; CvCityEmphases::Uninit, COMDAT
; _this$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	SAFE_DELETE_ARRAY(m_pbEmphasize);

	mov	eax, DWORD PTR [esi+32]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+32], 0
	pop	esi

; 152  : }

	ret	0
?Uninit@CvCityEmphases@@QAEXXZ ENDP			; CvCityEmphases::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvCityEmphases@@QAEXXZ			; CvCityEmphases::Reset
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?getNumEmphasisInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumEmphasisInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvCityEmphases@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvCityEmphases@@QAEXXZ PROC			; CvCityEmphases::Reset, COMDAT
; _this$ = ecx

; 156  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 157  : 	Uninit();

	mov	eax, DWORD PTR [esi+32]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+32], ebx

; 158  : 
; 159  : 	m_iEmphasizeAvoidGrowthCount = 0;

	mov	DWORD PTR [esi], ebx

; 160  : 	m_iEmphasizeGreatPeopleCount = 0;

	mov	DWORD PTR [esi+4], ebx
	add	esp, 4

; 161  : 
; 162  : 	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
; 163  : 	{
; 164  : 		m_aiEmphasizeYieldCount[iI] = 0;
; 165  : 	}
; 166  : 
; 167  : 	CvAssertMsg(m_pbEmphasize == NULL, "m_pbEmphasize not NULL!!!");
; 168  : 	CvAssertMsg(GC.getNumEmphasisInfos() > 0,  "GC.getNumEmphasizeInfos() is not greater than zero but an array is being allocated in CvCityEmphases::Reset");
; 169  : #ifdef AUI_WARNING_FIXES
; 170  : 	SAFE_DELETE_ARRAY(m_pbEmphasize);
; 171  : #endif
; 172  : 	m_pbEmphasize = FNEW(bool[GC.getNumEmphasisInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	call	?getNumEmphasisInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEmphasisInfos
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 173  : #ifdef AUI_WARNING_FIXES
; 174  : 	for (uint iI = 0; iI < GC.getNumEmphasisInfos(); iI++)
; 175  : #else
; 176  : 	for(int iI = 0; iI < GC.getNumEmphasisInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+32], eax
	xor	edi, edi
	call	?getNumEmphasisInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEmphasisInfos
	test	eax, eax
	jle	SHORT $LN1@Reset
$LL3@Reset:

; 177  : #endif
; 178  : 	{
; 179  : 		m_pbEmphasize[iI] = false;

	mov	ecx, DWORD PTR [esi+32]
	mov	BYTE PTR [edi+ecx], bl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumEmphasisInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEmphasisInfos
	cmp	edi, eax
	jl	SHORT $LL3@Reset
$LN1@Reset:
	pop	edi
	pop	esi
	pop	ebx

; 180  : 	}
; 181  : }

	ret	0
?Reset@CvCityEmphases@@QAEXXZ ENDP			; CvCityEmphases::Reset
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEAAPAVCvEmphasisEntry@@XZ ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEAAPAVCvEmphasisEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEAAPAVCvEmphasisEntry@@XZ PROC ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEAAPAVCvEmphasisEntry@@XZ ENDP ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z ; std::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z PROC ; std::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEmphasisEntry@@@1@@Z ENDP ; std::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_val<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z PROC ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@PAPAVCvEmphasisEntry@@@Z ENDP ; std::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Vector_iterator<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@@Z ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@@Z PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@@Z ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::max_size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T218759 = -80						; size = 28
$T218758 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T218759[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T218758[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T218759[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T218758[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T218758[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T218758[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T218758[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T218759[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T218758[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z	; operator>><int,6>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z PROC		; operator>><int,6>, COMDAT

; 234  : {

	push	ebx
	push	esi

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	mov	ebx, 6
$LL3@operator:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z ENDP		; operator>><int,6>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$217999 = -7					; size = 1
_bValid$217996 = -6					; size = 1
_tValue$218004 = -5					; size = 1
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	sub	esp, 8
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiNumEntries$[esp+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+16], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+16]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$217996[esp+24]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$217999[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	al, BYTE PTR _tValue$217999[esp+24]
	mov	ecx, DWORD PTR _paArray$[esp+20]
	mov	BYTE PTR [esi+ecx], al

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$217996[esp+24], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$218004[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+24]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 8
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
_TEXT	ENDS
PUBLIC	??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z	; operator<<<int,6>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z PROC	; operator<<<int,6>, COMDAT

; 223  : {

	push	ebx
	push	esi

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	mov	ebx, 6
$LL3@operator@2:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@2

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z ENDP	; operator<<<int,6>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4EmphasizeTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum EmphasizeTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4EmphasizeTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4EmphasizeTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4EmphasizeTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum EmphasizeTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4EmphasizeTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	ebx
$LN2@WriteHashe:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4EmphasizeTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum EmphasizeTypes,bool>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvEmphasisEntry@@PAPAV1@@stdext@@YAPAPAVCvEmphasisEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvEmphasisEntry * *,CvEmphasisEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvEmphasisEntry@@PAPAV1@@stdext@@YAPAPAVCvEmphasisEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvEmphasisEntry@@PAPAV1@@stdext@@YAPAPAVCvEmphasisEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvEmphasisEntry * *,CvEmphasisEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvEmphasisEntry@@PAPAV1@@stdext@@YAPAPAVCvEmphasisEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvEmphasisEntry * *,CvEmphasisEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEmphasisEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@YAXPAPAVCvEmphasisEntry@@0AAV?$allocator@PAVCvEmphasisEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvEmphasisEntry@@@std@@YAPAPAVCvEmphasisEntry@@IPAPAV1@@Z ; std::_Allocate<CvEmphasisEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvEmphasisEntry@@@std@@YAPAPAVCvEmphasisEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T218876 = -12						; size = 12
$T218880 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvEmphasisEntry@@@std@@YAPAPAVCvEmphasisEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvEmphasisEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T218880[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T218876[esp+16]
	mov	DWORD PTR $T218880[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T218876[esp+16]
	push	ecx
	mov	DWORD PTR $T218876[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvEmphasisEntry@@@std@@YAPAPAVCvEmphasisEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvEmphasisEntry *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??_GCvEmphasisEntry@@QAEPAXI@Z			; CvEmphasisEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvEmphasisEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvEmphasisEntry@@QAEPAXI@Z PROC			; CvEmphasisEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvEmphasisEntry@@6B@
	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+264], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN9@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvEmphasisEntry@@QAEPAXI@Z ENDP			; CvEmphasisEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	??0CvEmphasisEntry@@QAE@XZ			; CvEmphasisEntry::CvEmphasisEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvemphasisclasses.cpp
;	COMDAT ??0CvEmphasisEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvEmphasisEntry@@QAE@XZ PROC				; CvEmphasisEntry::CvEmphasisEntry, COMDAT
; _this$ = ecx

; 21   : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	BYTE PTR [esi+260], al
	mov	BYTE PTR [esi+261], al
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvEmphasisEntry@@6B@

; 22   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvEmphasisEntry@@QAE@XZ ENDP				; CvEmphasisEntry::CvEmphasisEntry
_TEXT	ENDS
PUBLIC	?Init@CvCityEmphases@@QAEXPAVCvEmphasisXMLEntries@@PAVCvCity@@@Z ; CvCityEmphases::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvCityEmphases@@QAEXPAVCvEmphasisXMLEntries@@PAVCvCity@@@Z
_TEXT	SEGMENT
_pEmphases$ = 8						; size = 4
_pCity$ = 12						; size = 4
?Init@CvCityEmphases@@QAEXPAVCvEmphasisXMLEntries@@PAVCvCity@@@Z PROC ; CvCityEmphases::Init, COMDAT
; _this$ = ecx

; 141  : 	// Store off the pointers to objects we'll need later
; 142  : 	m_pEmphases = pEmphases;

	mov	eax, DWORD PTR _pEmphases$[esp-4]

; 143  : 	m_pCity = pCity;

	mov	edx, DWORD PTR _pCity$[esp-4]
	mov	DWORD PTR [ecx+36], eax
	mov	DWORD PTR [ecx+40], edx

; 144  : 
; 145  : 	Reset();

	call	?Reset@CvCityEmphases@@QAEXXZ		; CvCityEmphases::Reset

; 146  : }

	ret	8
?Init@CvCityEmphases@@QAEXPAVCvEmphasisXMLEntries@@PAVCvCity@@@Z ENDP ; CvCityEmphases::Init
_TEXT	ENDS
PUBLIC	?SetEmphasize@CvCityEmphases@@QAEXW4EmphasizeTypes@@_N@Z ; CvCityEmphases::SetEmphasize
EXTRN	?isCitySelected@CvCity@@QAE_NXZ:PROC		; CvCity::isCitySelected
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?getEmphasisInfo@CvGlobals@@QAEPAVCvEmphasisEntry@@W4EmphasizeTypes@@@Z:PROC ; CvGlobals::getEmphasisInfo
; Function compile flags: /Ogtpy
;	COMDAT ?SetEmphasize@CvCityEmphases@@QAEXW4EmphasizeTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_pkEmphasis$217799 = 12					; size = 4
?SetEmphasize@CvCityEmphases@@QAEXW4EmphasizeTypes@@_N@Z PROC ; CvCityEmphases::SetEmphasize, COMDAT
; _this$ = ecx

; 225  : {

	push	ebx

; 226  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 227  : 	CvAssertMsg(eIndex < GC.getNumEmphasisInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 228  : 
; 229  : 	if(IsEmphasize(eIndex) != bNewValue)

	mov	ebx, DWORD PTR _eIndex$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN11@SetEmphasi
	xor	dl, dl
	jmp	SHORT $LN12@SetEmphasi
$LN11@SetEmphasi:
	mov	dl, BYTE PTR [eax+ebx]
$LN12@SetEmphasi:
	mov	cl, BYTE PTR _bNewValue$[esp+4]
	cmp	dl, cl
	je	$LN1@SetEmphasi

; 230  : 	{
; 231  : 		m_pbEmphasize[eIndex] = bNewValue;

	mov	BYTE PTR [eax+ebx], cl

; 232  : 
; 233  : 		CvEmphasisEntry* pkEmphasis = GC.getEmphasisInfo(eIndex);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEmphasisInfo@CvGlobals@@QAEPAVCvEmphasisEntry@@W4EmphasizeTypes@@@Z ; CvGlobals::getEmphasisInfo
	mov	ecx, eax

; 234  : 
; 235  : #ifdef AUI_WARNING_FIXES
; 236  : 		if (!pkEmphasis)
; 237  : 			return;
; 238  : #endif
; 239  : 
; 240  : 		if(pkEmphasis->IsAvoidGrowth())

	cmp	BYTE PTR [ecx+260], 0
	mov	DWORD PTR _pkEmphasis$217799[esp+4], ecx
	je	SHORT $LN7@SetEmphasi

; 241  : 		{
; 242  : 			m_iEmphasizeAvoidGrowthCount += ((IsEmphasize(eIndex)) ? 1 : -1);

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN16@SetEmphasi
	xor	al, al
	jmp	SHORT $LN17@SetEmphasi
$LN16@SetEmphasi:
	mov	al, BYTE PTR [eax+ebx]
$LN17@SetEmphasi:
	xor	edx, edx
	test	al, al
	setne	dl
	lea	edx, DWORD PTR [edx+edx-1]
	add	DWORD PTR [esi], edx
$LN7@SetEmphasi:

; 243  : 			CvAssert(GetEmphasizeAvoidGrowthCount() >= 0);
; 244  : 		}
; 245  : 
; 246  : 		if(pkEmphasis->IsGreatPeople())

	cmp	BYTE PTR [ecx+261], 0
	je	SHORT $LN6@SetEmphasi

; 247  : 		{
; 248  : 			m_iEmphasizeGreatPeopleCount += ((IsEmphasize(eIndex)) ? 1 : -1);

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN21@SetEmphasi
	xor	al, al
	jmp	SHORT $LN22@SetEmphasi
$LN21@SetEmphasi:
	mov	al, BYTE PTR [eax+ebx]
$LN22@SetEmphasi:
	xor	edx, edx
	test	al, al
	setne	dl
	lea	edx, DWORD PTR [edx+edx-1]
	add	DWORD PTR [esi+4], edx
$LN6@SetEmphasi:
	push	ebp
	push	edi

; 249  : 		}
; 250  : 
; 251  : 		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)

	mov	edi, -8					; fffffff8H
	lea	edx, DWORD PTR [esi+8]
	sub	edi, esi
	mov	ebp, 6
	jmp	SHORT $LN5@SetEmphasi
$LL39@SetEmphasi:
	mov	ecx, DWORD PTR _pkEmphasis$217799[esp+12]
$LN5@SetEmphasi:

; 252  : 		{
; 253  : 			if(pkEmphasis->GetYieldChange(iI))

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN38@SetEmphasi
	lea	ecx, DWORD PTR [edi+edx]
	cmp	DWORD PTR [ecx+eax], 0
	je	SHORT $LN4@SetEmphasi
$LN38@SetEmphasi:

; 254  : 			{
; 255  : 				m_aiEmphasizeYieldCount[iI] += ((IsEmphasize(eIndex)) ? 1 : -1);

	push	ebx
	mov	ecx, esi
	call	?IsEmphasize@CvCityEmphases@@QAE_NW4EmphasizeTypes@@@Z ; CvCityEmphases::IsEmphasize
	xor	ecx, ecx
	test	al, al
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	add	DWORD PTR [edx], ecx
$LN4@SetEmphasi:
	add	edx, 4
	sub	ebp, 1
	jne	SHORT $LL39@SetEmphasi

; 256  : 				CvAssert(GetEmphasizeYieldCount((YieldTypes)iI) >= 0);
; 257  : 			}
; 258  : 		}
; 259  : 
; 260  : 		if((m_pCity->getOwner() == GC.getGame().getActivePlayer()) && m_pCity->isCitySelected())

	mov	edx, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [edx+84]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	pop	edi
	pop	ebp
	jne	SHORT $LN1@SetEmphasi
	mov	ecx, DWORD PTR [esi+40]
	call	?isCitySelected@CvCity@@QAE_NXZ		; CvCity::isCitySelected
	test	al, al
	je	SHORT $LN1@SetEmphasi

; 261  : 		{
; 262  : 			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	pop	esi
	pop	ebx
	mov	DWORD PTR _bNewValue$[esp-4], 1
	mov	DWORD PTR _eIndex$[esp-4], 6
	mov	edx, DWORD PTR [eax+260]
	jmp	edx
$LN1@SetEmphasi:
	pop	esi
	pop	ebx

; 263  : 		}
; 264  : 	}
; 265  : }

	ret	8
?SetEmphasize@CvCityEmphases@@QAEXW4EmphasizeTypes@@_N@Z ENDP ; CvCityEmphases::SetEmphasize
_TEXT	ENDS
PUBLIC	?Read@CvCityEmphases@@QAEXAAVFDataStream@@@Z	; CvCityEmphases::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvCityEmphases@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityEmphases@@QAEXAAVFDataStream@@@Z PROC	; CvCityEmphases::Read, COMDAT
; _this$ = ecx

; 269  : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 270  : 	// Version number to maintain backwards compatibility
; 271  : 	uint uiVersion;
; 272  : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	ebp, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 273  : 
; 274  : 	kStream >> m_iEmphasizeAvoidGrowthCount;

	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 275  : 	kStream >> m_iEmphasizeGreatPeopleCount;

	lea	ecx, DWORD PTR [ebp+4]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	esi, DWORD PTR [ebp+8]
	mov	ebx, 6

; 276  : 
; 277  : 	kStream >> m_aiEmphasizeYieldCount;

$LL11@Read:
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL11@Read

; 278  : 
; 279  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pbEmphasize, GC.getNumEmphasisInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumEmphasisInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEmphasisInfos
	mov	edx, DWORD PTR [ebp+32]
	push	eax
	push	edx
	push	edi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 280  : }

	ret	4
?Read@CvCityEmphases@@QAEXAAVFDataStream@@@Z ENDP	; CvCityEmphases::Read
_TEXT	ENDS
PUBLIC	?Write@CvCityEmphases@@QAEXAAVFDataStream@@@Z	; CvCityEmphases::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvCityEmphases@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityEmphases@@QAEXAAVFDataStream@@@Z PROC	; CvCityEmphases::Write, COMDAT
; _this$ = ecx

; 284  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 285  : 	// Current version number
; 286  : 	uint uiVersion = 1;
; 287  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	ebx, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 288  : 
; 289  : 	kStream << m_iEmphasizeAvoidGrowthCount;

	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 290  : 	kStream << m_iEmphasizeGreatPeopleCount;

	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+8]
	mov	ebp, 6
	npad	6

; 291  : 
; 292  : 	kStream << m_aiEmphasizeYieldCount;

$LL11@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL11@Write

; 293  : 
; 294  : 	CvInfosSerializationHelper::WriteHashedDataArray<EmphasizeTypes, bool>(kStream, m_pbEmphasize, GC.getNumEmphasisInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumEmphasisInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEmphasisInfos
	mov	edx, DWORD PTR [ebx+32]
	push	eax
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4EmphasizeTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum EmphasizeTypes,bool>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 295  : }

	pop	ecx
	ret	4
?Write@CvCityEmphases@@QAEXAAVFDataStream@@@Z ENDP	; CvCityEmphases::Write
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@XZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXPAPAVCvEmphasisEntry@@0@Z ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXPAPAVCvEmphasisEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXPAPAVCvEmphasisEntry@@0@Z PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXPAPAVCvEmphasisEntry@@0@Z ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEPAPAVCvEmphasisEntry@@I@Z ; std::allocator<CvEmphasisEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEPAPAVCvEmphasisEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEPAPAVCvEmphasisEntry@@I@Z PROC ; std::allocator<CvEmphasisEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvEmphasisEntry@@@std@@YAPAPAVCvEmphasisEntry@@IPAPAV1@@Z ; std::_Allocate<CvEmphasisEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvEmphasisEntry@@@std@@QAEPAPAVCvEmphasisEntry@@I@Z ENDP ; std::allocator<CvEmphasisEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvEmphasisEntry@@@@YAXAAPAVCvEmphasisEntry@@@Z ; SAFE_DELETE<CvEmphasisEntry>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvEmphasisEntry@@@@YAXAAPAVCvEmphasisEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvEmphasisEntry@@@@YAXAAPAVCvEmphasisEntry@@@Z PROC ; SAFE_DELETE<CvEmphasisEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN13@SAFE_DELET
	mov	DWORD PTR [esi], OFFSET ??_7CvEmphasisEntry@@6B@
	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+264], 0
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvEmphasisEntry@@@@YAXAAPAVCvEmphasisEntry@@@Z ENDP ; SAFE_DELETE<CvEmphasisEntry>
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@0@Z ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@0@Z PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@2@0@Z ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@KAXXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvEmphasisEntry@@@std@@YAPAPAVCvEmphasisEntry@@IPAPAV1@@Z ; std::_Allocate<CvEmphasisEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEXXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::clear
_TEXT	ENDS
PUBLIC	??0CvEmphasisXMLEntries@@QAE@XZ			; CvEmphasisXMLEntries::CvEmphasisXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvemphasisclasses.cpp
;	COMDAT ??0CvEmphasisXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvEmphasisXMLEntries@@QAE@XZ PROC			; CvEmphasisXMLEntries::CvEmphasisXMLEntries, COMDAT
; _this$ = ecx

; 68   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 69   : 
; 70   : }

	ret	0
??0CvEmphasisXMLEntries@@QAE@XZ ENDP			; CvEmphasisXMLEntries::CvEmphasisXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvEmphasisXMLEntries@@QAEXXZ	; CvEmphasisXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvEmphasisXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvEmphasisXMLEntries@@QAEXXZ PROC		; CvEmphasisXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 96   : {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 97   : 	for(std::vector<CvEmphasisEntry*>::iterator it = m_paEmphasisEntries.begin(); it != m_paEmphasisEntries.end(); ++it)

	mov	edi, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 98   : 	{
; 99   : 		SAFE_DELETE(*it);

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN32@DeleteArra
	mov	DWORD PTR [esi], OFFSET ??_7CvEmphasisEntry@@6B@
	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+264], 0
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [edi], 0
	add	edi, 4
	cmp	edi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 100  : 	}
; 101  : 
; 102  : 	m_paEmphasisEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN56@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN81@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN81@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN56@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 103  : }

	ret	0
?DeleteArray@CvEmphasisXMLEntries@@QAEXXZ ENDP		; CvEmphasisXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??1CvEmphasisXMLEntries@@QAE@XZ			; CvEmphasisXMLEntries::~CvEmphasisXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvEmphasisXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEmphasisXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvEmphasisXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvEmphasisXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvemphasisclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvEmphasisXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEmphasisXMLEntries@@QAE@XZ PROC			; CvEmphasisXMLEntries::~CvEmphasisXMLEntries, COMDAT
; _this$ = ecx

; 74   : {

	push	-1
	push	__ehhandler$??1CvEmphasisXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 75   : 	DeleteArray();

	call	?DeleteArray@CvEmphasisXMLEntries@@QAEXXZ ; CvEmphasisXMLEntries::DeleteArray

; 76   : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvEmphasis
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvEmphasis:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEmphasisXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::~vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >
__ehhandler$??1CvEmphasisXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvEmphasisXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEmphasisXMLEntries@@QAE@XZ ENDP			; CvEmphasisXMLEntries::~CvEmphasisXMLEntries
END
