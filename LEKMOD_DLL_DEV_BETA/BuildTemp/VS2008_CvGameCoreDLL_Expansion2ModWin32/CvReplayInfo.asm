; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvReplayInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?REPLAY_VERSION@CvReplayInfo@@1HA		; CvReplayInfo::REPLAY_VERSION
_DATA	SEGMENT
?REPLAY_VERSION@CvReplayInfo@@1HA DD 01H		; CvReplayInfo::REPLAY_VERSION
_DATA	ENDS
PUBLIC	?isValidTurn@CvReplayInfo@@IBE_NH@Z		; CvReplayInfo::isValidTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?isValidTurn@CvReplayInfo@@IBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isValidTurn@CvReplayInfo@@IBE_NH@Z PROC		; CvReplayInfo::isValidTurn, COMDAT
; _this$ = ecx

; 261  : 	return (i >= m_iInitialTurn && i <= m_iFinalTurn);

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, DWORD PTR [ecx+96]
	jl	SHORT $LN3@isValidTur
	cmp	eax, DWORD PTR [ecx+100]
	jg	SHORT $LN3@isValidTur
	mov	eax, 1

; 262  : }

	ret	4
$LN3@isValidTur:

; 261  : 	return (i >= m_iInitialTurn && i <= m_iFinalTurn);

	xor	eax, eax

; 262  : }

	ret	4
?isValidTurn@CvReplayInfo@@IBE_NH@Z ENDP		; CvReplayInfo::isValidTurn
_TEXT	ENDS
PUBLIC	?getActivePlayer@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getActivePlayer
; Function compile flags: /Ogtpy
;	COMDAT ?getActivePlayer@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getActivePlayer@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getActivePlayer, COMDAT
; _this$ = ecx

; 266  : 	return m_iActivePlayer;

	mov	eax, DWORD PTR [ecx+4]

; 267  : }

	ret	0
?getActivePlayer@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getActivePlayer
_TEXT	ENDS
PUBLIC	?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z	; std::_Container_base::_Swap_aux
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z PROC	; std::_Container_base::_Swap_aux, COMDAT
; _this$ = ecx

; 602  : 		// Do nothing: we don't have an aux object.
; 603  : 		}

	ret	4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z ENDP	; std::_Container_base::_Swap_aux
_TEXT	ENDS
PUBLIC	?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ ; CvReplayInfo::getMapScriptName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ
_TEXT	SEGMENT
?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ PROC	; CvReplayInfo::getMapScriptName, COMDAT
; _this$ = ecx

; 351  : 	return m_strMapScriptName;

	lea	eax, DWORD PTR [ecx+8]

; 352  : }

	ret	0
?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ ENDP	; CvReplayInfo::getMapScriptName
_TEXT	ENDS
PUBLIC	?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ ; CvReplayInfo::getWorldSize
; Function compile flags: /Ogtpy
;	COMDAT ?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ
_TEXT	SEGMENT
?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ PROC ; CvReplayInfo::getWorldSize, COMDAT
; _this$ = ecx

; 356  : 	return m_eWorldSize;

	mov	eax, DWORD PTR [ecx+36]

; 357  : }

	ret	0
?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ ENDP ; CvReplayInfo::getWorldSize
_TEXT	ENDS
PUBLIC	?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ ; CvReplayInfo::getClimate
; Function compile flags: /Ogtpy
;	COMDAT ?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ
_TEXT	SEGMENT
?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ PROC	; CvReplayInfo::getClimate, COMDAT
; _this$ = ecx

; 361  : 	return m_eClimate;

	mov	eax, DWORD PTR [ecx+40]

; 362  : }

	ret	0
?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ ENDP	; CvReplayInfo::getClimate
_TEXT	ENDS
PUBLIC	?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ ; CvReplayInfo::getSeaLevel
; Function compile flags: /Ogtpy
;	COMDAT ?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ
_TEXT	SEGMENT
?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ PROC ; CvReplayInfo::getSeaLevel, COMDAT
; _this$ = ecx

; 366  : 	return m_eSeaLevel;

	mov	eax, DWORD PTR [ecx+44]

; 367  : }

	ret	0
?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ ENDP ; CvReplayInfo::getSeaLevel
_TEXT	ENDS
PUBLIC	?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ	; CvReplayInfo::getEra
; Function compile flags: /Ogtpy
;	COMDAT ?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ
_TEXT	SEGMENT
?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ PROC		; CvReplayInfo::getEra, COMDAT
; _this$ = ecx

; 371  : 	return m_eEra;

	mov	eax, DWORD PTR [ecx+48]

; 372  : }

	ret	0
?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ ENDP		; CvReplayInfo::getEra
_TEXT	ENDS
PUBLIC	?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ ; CvReplayInfo::getGameSpeed
; Function compile flags: /Ogtpy
;	COMDAT ?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ
_TEXT	SEGMENT
?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ PROC ; CvReplayInfo::getGameSpeed, COMDAT
; _this$ = ecx

; 376  : 	return m_eGameSpeed;

	mov	eax, DWORD PTR [ecx+52]

; 377  : }

	ret	0
?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ ENDP ; CvReplayInfo::getGameSpeed
_TEXT	ENDS
PUBLIC	?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ ; CvReplayInfo::getVictoryType
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ
_TEXT	SEGMENT
?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ PROC ; CvReplayInfo::getVictoryType, COMDAT
; _this$ = ecx

; 405  : 	return m_eVictoryType;

	mov	eax, DWORD PTR [ecx+88]

; 406  : }

	ret	0
?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ ENDP ; CvReplayInfo::getVictoryType
_TEXT	ENDS
PUBLIC	?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ	; CvReplayInfo::getGameType
; Function compile flags: /Ogtpy
;	COMDAT ?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ
_TEXT	SEGMENT
?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ PROC	; CvReplayInfo::getGameType, COMDAT
; _this$ = ecx

; 410  : 	return m_eGameType;

	mov	eax, DWORD PTR [ecx+92]

; 411  : }

	ret	0
?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ ENDP	; CvReplayInfo::getGameType
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?getInitialTurn@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getInitialTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?getInitialTurn@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getInitialTurn@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getInitialTurn, COMDAT
; _this$ = ecx

; 440  : 	return m_iInitialTurn;

	mov	eax, DWORD PTR [ecx+96]

; 441  : }

	ret	0
?getInitialTurn@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getInitialTurn
_TEXT	ENDS
PUBLIC	?getStartYear@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getStartYear
; Function compile flags: /Ogtpy
;	COMDAT ?getStartYear@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartYear@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getStartYear, COMDAT
; _this$ = ecx

; 445  : 	return m_iStartYear;

	mov	eax, DWORD PTR [ecx+104]

; 446  : }

	ret	0
?getStartYear@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getStartYear
_TEXT	ENDS
PUBLIC	?getFinalTurn@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getFinalTurn
; Function compile flags: /Ogtpy
;	COMDAT ?getFinalTurn@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getFinalTurn@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getFinalTurn, COMDAT
; _this$ = ecx

; 450  : 	return m_iFinalTurn;

	mov	eax, DWORD PTR [ecx+100]

; 451  : }

	ret	0
?getFinalTurn@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getFinalTurn
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ ; CvReplayInfo::getCalendar
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ
_TEXT	SEGMENT
?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ PROC ; CvReplayInfo::getCalendar, COMDAT
; _this$ = ecx

; 460  : 	return m_eCalendar;

	mov	eax, DWORD PTR [ecx+136]

; 461  : }

	ret	0
?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ ENDP ; CvReplayInfo::getCalendar
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?getNormalizedScore@CvReplayInfo@@QBEHXZ	; CvReplayInfo::getNormalizedScore
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?getNormalizedScore@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getNormalizedScore@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getNormalizedScore, COMDAT
; _this$ = ecx

; 497  : 	return m_iNormalizedScore;

	mov	eax, DWORD PTR [ecx+140]

; 498  : }

	ret	0
?getNormalizedScore@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getNormalizedScore
_TEXT	ENDS
PUBLIC	?getMapHeight@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getMapHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getMapHeight@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getMapHeight@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getMapHeight, COMDAT
; _this$ = ecx

; 502  : 	return m_iMapHeight;

	mov	eax, DWORD PTR [ecx+208]

; 503  : }

	ret	0
?getMapHeight@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getMapHeight
_TEXT	ENDS
PUBLIC	?getMapWidth@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getMapWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getMapWidth@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getMapWidth@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getMapWidth, COMDAT
; _this$ = ecx

; 507  : 	return m_iMapWidth;

	mov	eax, DWORD PTR [ecx+212]

; 508  : }

	ret	0
?getMapWidth@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getMapWidth
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 771  : 		}

	ret	4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 786  : 		}

	ret	4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -2004318071			; 88888889H
	imul	esi
	add	edx, esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@I@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@I@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 771  : 		}

	ret	4
??A?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@I@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 771  : 		}

	ret	4
??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 786  : 		}

	ret	4
??A?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@I@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@I@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@I@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@I@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@I@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@I@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@I@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 7

; 727  : 		}

	ret	0
?size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@I@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@I@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	shl	eax, 7
	add	eax, DWORD PTR [ecx+4]

; 771  : 		}

	ret	4
??A?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@I@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@I@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@I@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+4]

; 771  : 		}

	ret	4
??A?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@I@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::size
_TEXT	ENDS
PUBLIC	??A?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@I@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@I@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 771  : 		}

	ret	4
??A?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@I@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@XZ ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@XZ PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEABVCvReplayMessage@@XZ ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 60			; 0000003cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator++
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 144  : 		}

	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@2

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::capacity
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T232669 = -80						; size = 28
$T232668 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232669[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232668[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232669[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232668[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232668[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232668[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232668[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232669[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232668[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >::~_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >::~_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >::~_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvReplayMessage@@@std@@QAE@XZ	; std::allocator<CvReplayMessage>::allocator<CvReplayMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvReplayMessage@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvReplayMessage@@@std@@QAE@XZ PROC	; std::allocator<CvReplayMessage>::allocator<CvReplayMessage>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvReplayMessage@@@std@@QAE@XZ ENDP	; std::allocator<CvReplayMessage>::allocator<CvReplayMessage>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@I@Z ; std::allocator<CvReplayMessage>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@I@Z PROC ; std::allocator<CvReplayMessage>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@I@Z ENDP ; std::allocator<CvReplayMessage>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@3

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@XZ ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4GameOptionTypes@@@std@@QAE@XZ	; std::allocator<enum GameOptionTypes>::allocator<enum GameOptionTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4GameOptionTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4GameOptionTypes@@@std@@QAE@XZ PROC	; std::allocator<enum GameOptionTypes>::allocator<enum GameOptionTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4GameOptionTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum GameOptionTypes>::allocator<enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@5
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4VictoryTypes@@@std@@QAE@XZ	; std::allocator<enum VictoryTypes>::allocator<enum VictoryTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4VictoryTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4VictoryTypes@@@std@@QAE@XZ PROC	; std::allocator<enum VictoryTypes>::allocator<enum VictoryTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4VictoryTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum VictoryTypes>::allocator<enum VictoryTypes>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@6
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@6:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 7

; 636  : 		}

	ret	0
?capacity@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >::~_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >::~_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >::~_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@XZ ; std::allocator<CvReplayInfo::PlayerInfo>::allocator<CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@XZ PROC ; std::allocator<CvReplayInfo::PlayerInfo>::allocator<CvReplayInfo::PlayerInfo>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@XZ ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::allocator<CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@7
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@7:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 4

; 636  : 		}

	ret	0
?capacity@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 727  : 		}

	ret	0
?size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@XZ ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@8

; 636  : 		}

	ret	0
$LN3@capacity@8:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T232776 = -80						; size = 28
$T232775 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232776[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232775[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232776[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232775[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232775[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232775[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232775[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232776[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232775[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@XZ ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@XZ PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::deallocate
_TEXT	ENDS
PUBLIC	?size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@FF@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<short,short> >::allocator<std::pair<short,short> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@FF@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@FF@std@@@std@@QAE@ABV01@@Z PROC	; std::allocator<std::pair<short,short> >::allocator<std::pair<short,short> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@FF@std@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<std::pair<short,short> >::allocator<std::pair<short,short> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBIH@std@@QAE@ABIABH@Z		; std::pair<unsigned int const ,int>::pair<unsigned int const ,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBIH@std@@QAE@ABIABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBIH@std@@QAE@ABIABH@Z PROC			; std::pair<unsigned int const ,int>::pair<unsigned int const ,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@$$CBIH@std@@QAE@ABIABH@Z ENDP			; std::pair<unsigned int const ,int>::pair<unsigned int const ,int>
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABIABUPlotState@CvReplayInfo@@@Z ; std::pair<unsigned int const ,CvReplayInfo::PlotState>::pair<unsigned int const ,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABIABUPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABIABUPlotState@CvReplayInfo@@@Z PROC ; std::pair<unsigned int const ,CvReplayInfo::PlotState>::pair<unsigned int const ,CvReplayInfo::PlotState>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+16], ecx

; 51   : 		}

	ret	8
??0?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABIABUPlotState@CvReplayInfo@@@Z ENDP ; std::pair<unsigned int const ,CvReplayInfo::PlotState>::pair<unsigned int const ,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator==
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBHH@std@@QAE@ABH0@Z		; std::pair<int const ,int>::pair<int const ,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBHH@std@@QAE@ABH0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBHH@std@@QAE@ABH0@Z PROC			; std::pair<int const ,int>::pair<int const ,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@$$CBHH@std@@QAE@ABH0@Z ENDP			; std::pair<int const ,int>::pair<int const ,int>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Container_base_aux_alloc_empty<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T232939 = -80						; size = 28
$T232938 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232939[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232938[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232939[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232938[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232938[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232938[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232938[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232939[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232938[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >::_Container_base_aux_alloc_empty<std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvReplayMessage@@@std@@QAE@ABV01@@Z ; std::allocator<CvReplayMessage>::allocator<CvReplayMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvReplayMessage@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvReplayMessage@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvReplayMessage>::allocator<CvReplayMessage>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvReplayMessage@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvReplayMessage>::allocator<CvReplayMessage>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvReplayMessage@@@std@@QBEIXZ ; std::allocator<CvReplayMessage>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvReplayMessage@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvReplayMessage@@@std@@QBEIXZ PROC ; std::allocator<CvReplayMessage>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 71582788				; 04444444H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvReplayMessage@@@std@@QBEIXZ ENDP ; std::allocator<CvReplayMessage>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T232987 = -80						; size = 28
$T232986 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232987[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232986[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232987[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232986[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232986[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232986[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232986[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232987[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232986[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4GameOptionTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum GameOptionTypes>::allocator<enum GameOptionTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4GameOptionTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4GameOptionTypes@@@std@@QAE@ABV01@@Z PROC ; std::allocator<enum GameOptionTypes>::allocator<enum GameOptionTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4GameOptionTypes@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<enum GameOptionTypes>::allocator<enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@I@Z ; std::allocator<enum GameOptionTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@I@Z PROC ; std::allocator<enum GameOptionTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@I@Z ENDP ; std::allocator<enum GameOptionTypes>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233021 = -80						; size = 28
$T233020 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233021[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233020[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233021[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233020[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233020[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233020[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233020[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233021[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233020[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4VictoryTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum VictoryTypes>::allocator<enum VictoryTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4VictoryTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4VictoryTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum VictoryTypes>::allocator<enum VictoryTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4VictoryTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum VictoryTypes>::allocator<enum VictoryTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@I@Z ; std::allocator<enum VictoryTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@I@Z PROC ; std::allocator<enum VictoryTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@I@Z ENDP ; std::allocator<enum VictoryTypes>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233055 = -80						; size = 28
$T233054 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233055[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233054[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233055[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233054[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233054[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233054[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233054[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233055[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233054[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >::_Container_base_aux_alloc_empty<std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvReplayInfo::PlayerInfo>::allocator<CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvReplayInfo::PlayerInfo>::allocator<CvReplayInfo::PlayerInfo>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::allocator<CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@I@Z ; std::allocator<CvReplayInfo::PlayerInfo>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@I@Z PROC ; std::allocator<CvReplayInfo::PlayerInfo>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@I@Z ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T233089 = -80						; size = 28
$T233088 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233089[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233088[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233089[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233088[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233088[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233088[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233088[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@7:
$LN12@Xlen@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233089[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233088[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Container_base_aux_alloc_empty<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QBEIXZ ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QBEIXZ PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::max_size
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T233134 = -80						; size = 28
$T233133 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233134[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233133[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233134[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233133[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233133[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233133[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233133[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@8:
$LN12@Xlen@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233134[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233133[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@FF@std@@@std@@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@I@Z ; std::allocator<std::pair<short,short> >::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@I@Z PROC ; std::allocator<std::pair<short,short> >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@I@Z ENDP ; std::allocator<std::pair<short,short> >::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Isnil
; Function compile flags: /Ogtpy
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 33					; 00000021H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z PROC ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@PAVCvReplayMessage@@@Z ENDP ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 7

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z PROC ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z ENDP ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T233443 = -80						; size = 28
$T233442 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233443[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233442[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233443[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233442[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233442[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233442[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233442[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@9:
$LN12@Xlen@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233443[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233442[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
PUBLIC	?max_size@?$allocator@W4GameOptionTypes@@@std@@QBEIXZ ; std::allocator<enum GameOptionTypes>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@W4GameOptionTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4GameOptionTypes@@@std@@QBEIXZ PROC ; std::allocator<enum GameOptionTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4GameOptionTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum GameOptionTypes>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4VictoryTypes@@@std@@QBEIXZ ; std::allocator<enum VictoryTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4VictoryTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4VictoryTypes@@@std@@QBEIXZ PROC	; std::allocator<enum VictoryTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4VictoryTypes@@@std@@QBEIXZ ENDP	; std::allocator<enum VictoryTypes>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QBEIXZ ; std::allocator<CvReplayInfo::PlayerInfo>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QBEIXZ PROC ; std::allocator<CvReplayInfo::PlayerInfo>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 33554431				; 01ffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QBEIXZ ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@FF@std@@@std@@QBEIXZ ; std::allocator<std::pair<short,short> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@U?$pair@FF@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@FF@std@@@std@@QBEIXZ PROC	; std::allocator<std::pair<short,short> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@FF@std@@@std@@QBEIXZ ENDP	; std::allocator<std::pair<short,short> >::max_size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate@2:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@2:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@2:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Color
; Function compile flags: /Ogtpy
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 32					; 00000020H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN5@Rrotate@3

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate@3:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate@3

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@3:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate@3

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@3:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator==
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp
; Function compile flags: /Ogtpy
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,int> >::max_size
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QBEIXZ ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,int> >::max_size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max@2
	npad	3
$LL2@Max@2:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max@2
$LN1@Max@2:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min@2
	npad	4
$LL2@Min@2:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min@2
$LN1@Min@2:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::get_allocator
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::key_comp
; Function compile flags: /Ogtpy
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN1@Max@3
	npad	3
$LL2@Max@3:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL2@Max@3
$LN1@Max@3:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN1@Min@3
	npad	4
$LL2@Min@3:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL2@Min@3
$LN1@Min@3:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 214748364				; 0cccccccH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	edx, ecx
	shl	edx, 4
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 7
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+=
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+28], ecx
	mov	BYTE PTR [eax+32], dl
	mov	BYTE PTR [eax+33], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??$?6E@FDataStream@@QAEAAV0@ABE@Z		; FDataStream::operator<<<unsigned char>
EXTRN	?Write@FDataStream@@IAEXABE@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6E@FDataStream@@QAEAAV0@ABE@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6E@FDataStream@@QAEAAV0@ABE@Z PROC			; FDataStream::operator<<<unsigned char>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6E@FDataStream@@QAEAAV0@ABE@Z ENDP			; FDataStream::operator<<<unsigned char>
_TEXT	ENDS
PUBLIC	??$?5E@FDataStream@@QAEAAV0@AAE@Z		; FDataStream::operator>><unsigned char>
EXTRN	?Read@FDataStream@@IAEXAAE@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5E@FDataStream@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5E@FDataStream@@QAEAAV0@AAE@Z PROC			; FDataStream::operator>><unsigned char>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5E@FDataStream@@QAEAAV0@AAE@Z ENDP			; FDataStream::operator>><unsigned char>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z
_TEXT	SEGMENT
$T233974 = -12						; size = 12
$T233978 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z PROC ; std::_Allocate<CvReplayMessage>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, ecx
	shl	edx, 4
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 60					; 0000003cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233978[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233974[esp+16]
	mov	DWORD PTR $T233978[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233974[esp+16]
	push	ecx
	mov	DWORD PTR $T233974[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ENDP ; std::_Allocate<CvReplayMessage>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z
_TEXT	SEGMENT
$T233984 = -12						; size = 12
$T233988 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z PROC ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233988[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233984[esp+16]
	mov	DWORD PTR $T233988[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233984[esp+16]
	push	ecx
	mov	DWORD PTR $T233984[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ENDP ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T233994 = -12						; size = 12
$T233998 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233998[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233994[esp+16]
	mov	DWORD PTR $T233998[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233994[esp+16]
	push	ecx
	mov	DWORD PTR $T233994[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T234007 = -12						; size = 12
$T234011 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z PROC ; std::_Allocate<enum GameOptionTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234011[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234007[esp+16]
	mov	DWORD PTR $T234011[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234007[esp+16]
	push	ecx
	mov	DWORD PTR $T234007[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T234017 = -12						; size = 12
$T234021 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z PROC ; std::_Allocate<enum VictoryTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234021[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234017[esp+16]
	mov	DWORD PTR $T234021[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234017[esp+16]
	push	ecx
	mov	DWORD PTR $T234017[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z
_TEXT	SEGMENT
$T234027 = -12						; size = 12
$T234031 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z PROC ; std::_Allocate<CvReplayInfo::PlayerInfo>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 7
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 128				; 00000080H
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234031[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234027[esp+16]
	mov	DWORD PTR $T234031[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234027[esp+16]
	push	ecx
	mov	DWORD PTR $T234027[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ENDP ; std::_Allocate<CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T234037 = -12						; size = 12
$T234041 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234041[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234037[esp+16]
	mov	DWORD PTR $T234041[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234037[esp+16]
	push	ecx
	mov	DWORD PTR $T234037[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@7:
$LN8@Allocate@7:
	int	3
??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z
_TEXT	SEGMENT
$T234047 = -12						; size = 12
$T234051 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<short,short> >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234051[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234047[esp+16]
	mov	DWORD PTR $T234051[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234047[esp+16]
	push	ecx
	mov	DWORD PTR $T234047[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@8:
$LN8@Allocate@8:
	int	3
??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<short,short> >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T234069 = -12						; size = 12
$T234073 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234073[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234069[esp+16]
	mov	DWORD PTR $T234073[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234069[esp+16]
	push	ecx
	mov	DWORD PTR $T234069[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@9:
$LN8@Allocate@9:
	int	3
??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *><std::pair<unsigned int const ,CvReplayInfo::PlotState> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *><std::pair<unsigned int const ,CvReplayInfo::PlotState> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *><std::pair<unsigned int const ,CvReplayInfo::PlotState> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T234088 = -12						; size = 12
$T234092 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234092[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234088[esp+16]
	mov	DWORD PTR $T234092[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234088[esp+16]
	push	ecx
	mov	DWORD PTR $T234088[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@10:
$LN8@Allocate@10:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T234110 = -12						; size = 12
$T234114 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@11

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@11:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@11:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@11

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234114[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234110[esp+16]
	mov	DWORD PTR $T234114[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234110[esp+16]
	push	ecx
	mov	DWORD PTR $T234110[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@11:
$LN8@Allocate@11:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node><std::pair<unsigned int const ,CvReplayInfo::PlotState> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node><std::pair<unsigned int const ,CvReplayInfo::PlotState> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node><std::pair<unsigned int const ,CvReplayInfo::PlotState> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T234135 = -12						; size = 12
$T234139 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@12

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@12:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*8]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@12:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN1@Allocate@12

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234139[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234135[esp+16]
	mov	DWORD PTR $T234139[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234135[esp+16]
	push	ecx
	mov	DWORD PTR $T234135[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@12:
$LN8@Allocate@12:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::end
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::random_access_iterator_tag>
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@Copy_opt
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN8@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvReplayMessage@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvReplayMessage@@0@Z ; std::_Iter_random<CvReplayMessage *,CvReplayMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvReplayMessage@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvReplayMessage@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvReplayMessage@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvReplayMessage@@0@Z PROC ; std::_Iter_random<CvReplayMessage *,CvReplayMessage *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvReplayMessage@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvReplayMessage@@0@Z ENDP ; std::_Iter_random<CvReplayMessage *,CvReplayMessage *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvReplayMessage@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvReplayMessage@@0@Z ; std::_Ptr_cat<CvReplayMessage *,CvReplayMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvReplayMessage@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvReplayMessage@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvReplayMessage@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvReplayMessage@@0@Z PROC ; std::_Ptr_cat<CvReplayMessage *,CvReplayMessage *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvReplayMessage@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvReplayMessage@@0@Z ENDP ; std::_Ptr_cat<CvReplayMessage *,CvReplayMessage *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ; std::_Ptr_cat<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z PROC ; std::_Ptr_cat<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ENDP ; std::_Ptr_cat<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4GameOptionTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4GameOptionTypes@@0@Z ; std::_Iter_random<enum GameOptionTypes *,enum GameOptionTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4GameOptionTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4GameOptionTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4GameOptionTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4GameOptionTypes@@0@Z PROC ; std::_Iter_random<enum GameOptionTypes *,enum GameOptionTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4GameOptionTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4GameOptionTypes@@0@Z ENDP ; std::_Iter_random<enum GameOptionTypes *,enum GameOptionTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4GameOptionTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4GameOptionTypes@@0@Z ; std::_Ptr_cat<enum GameOptionTypes *,enum GameOptionTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4GameOptionTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4GameOptionTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4GameOptionTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4GameOptionTypes@@0@Z PROC ; std::_Ptr_cat<enum GameOptionTypes *,enum GameOptionTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4GameOptionTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4GameOptionTypes@@0@Z ENDP ; std::_Ptr_cat<enum GameOptionTypes *,enum GameOptionTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4VictoryTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VictoryTypes@@0@Z ; std::_Iter_random<enum VictoryTypes *,enum VictoryTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4VictoryTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VictoryTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4VictoryTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VictoryTypes@@0@Z PROC ; std::_Iter_random<enum VictoryTypes *,enum VictoryTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4VictoryTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VictoryTypes@@0@Z ENDP ; std::_Iter_random<enum VictoryTypes *,enum VictoryTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4VictoryTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VictoryTypes@@0@Z ; std::_Ptr_cat<enum VictoryTypes *,enum VictoryTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4VictoryTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VictoryTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4VictoryTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VictoryTypes@@0@Z PROC ; std::_Ptr_cat<enum VictoryTypes *,enum VictoryTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4VictoryTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VictoryTypes@@0@Z ENDP ; std::_Ptr_cat<enum VictoryTypes *,enum VictoryTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@3
	push	esi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@3
	pop	esi
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPlayerInfo@CvReplayInfo@@0@Z ; std::_Iter_random<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPlayerInfo@CvReplayInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPlayerInfo@CvReplayInfo@@0@Z PROC ; std::_Iter_random<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPlayerInfo@CvReplayInfo@@0@Z ENDP ; std::_Iter_random<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPlayerInfo@CvReplayInfo@@0@Z ; std::_Ptr_cat<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPlayerInfo@CvReplayInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPlayerInfo@CvReplayInfo@@0@Z PROC ; std::_Ptr_cat<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUPlayerInfo@CvReplayInfo@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPlayerInfo@CvReplayInfo@@0@Z ENDP ; std::_Ptr_cat<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ; std::_Iter_random<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z PROC ; std::_Iter_random<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ENDP ; std::_Iter_random<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ; std::_Ptr_cat<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z PROC ; std::_Ptr_cat<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ENDP ; std::_Ptr_cat<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ; std::_Iter_random<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z PROC ; std::_Iter_random<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ENDP ; std::_Iter_random<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ; std::_Ptr_cat<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z PROC ; std::_Ptr_cat<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ENDP ; std::_Ptr_cat<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Fill
	pop	ebx
$LN1@Fill:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvReplayMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvReplayMessage@@@Z ; std::_Move_cat<CvReplayMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvReplayMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvReplayMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvReplayMessage@@@Z PROC ; std::_Move_cat<CvReplayMessage *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvReplayMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvReplayMessage@@@Z ENDP ; std::_Move_cat<CvReplayMessage *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ; std::_Iter_random<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z PROC ; std::_Iter_random<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ENDP ; std::_Iter_random<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z ; std::_Move_cat<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z PROC ; std::_Move_cat<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z ENDP ; std::_Move_cat<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z ; std::_Fill<enum GameOptionTypes *,enum GameOptionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z PROC ; std::_Fill<enum GameOptionTypes *,enum GameOptionTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z ENDP ; std::_Fill<enum GameOptionTypes *,enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4GameOptionTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4GameOptionTypes@@@Z ; std::_Move_cat<enum GameOptionTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4GameOptionTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4GameOptionTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4GameOptionTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4GameOptionTypes@@@Z PROC ; std::_Move_cat<enum GameOptionTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4GameOptionTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4GameOptionTypes@@@Z ENDP ; std::_Move_cat<enum GameOptionTypes *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z ; std::_Fill<enum VictoryTypes *,enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z PROC ; std::_Fill<enum VictoryTypes *,enum VictoryTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z ENDP ; std::_Fill<enum VictoryTypes *,enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4VictoryTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VictoryTypes@@@Z ; std::_Move_cat<enum VictoryTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4VictoryTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VictoryTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4VictoryTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VictoryTypes@@@Z PROC ; std::_Move_cat<enum VictoryTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4VictoryTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VictoryTypes@@@Z ENDP ; std::_Move_cat<enum VictoryTypes *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUPlayerInfo@CvReplayInfo@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPlayerInfo@CvReplayInfo@@@Z ; std::_Move_cat<CvReplayInfo::PlayerInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUPlayerInfo@CvReplayInfo@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUPlayerInfo@CvReplayInfo@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPlayerInfo@CvReplayInfo@@@Z PROC ; std::_Move_cat<CvReplayInfo::PlayerInfo *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUPlayerInfo@CvReplayInfo@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::_Move_cat<CvReplayInfo::PlayerInfo *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z ; std::_Move_cat<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z PROC ; std::_Move_cat<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z ENDP ; std::_Move_cat<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z ; std::_Move_cat<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z PROC ; std::_Move_cat<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z ENDP ; std::_Move_cat<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU?$pair@FF@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@FF@0@0@Z ; std::_Ptr_cat<std::pair<short,short> *,std::pair<short,short> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAU?$pair@FF@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@FF@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU?$pair@FF@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@FF@0@0@Z PROC ; std::_Ptr_cat<std::pair<short,short> *,std::pair<short,short> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAU?$pair@FF@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@FF@0@0@Z ENDP ; std::_Ptr_cat<std::pair<short,short> *,std::pair<short,short> *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 28			; 0000001cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@XZ ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@XZ PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEABW4GameOptionTypes@@XZ ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@XZ ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@XZ PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEABW4VictoryTypes@@XZ ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@XZ ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@XZ PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEABUPlayerInfo@CvReplayInfo@@XZ ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	sub	DWORD PTR [eax], -128			; ffffff80H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@XZ ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@XZ PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 16			; 00000010H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator++
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAEXABW4GameOptionTypes@@@Z ; SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >::operator()
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameOptionTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAEXABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAEXABW4GameOptionTypes@@@Z PROC ; SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameOptionTypes@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAEXABW4GameOptionTypes@@@Z ENDP ; SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >::operator()
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAEXABW4VictoryTypes@@@Z ; SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >::operator()
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAEXABW4VictoryTypes@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAEXABW4VictoryTypes@@@Z PROC ; SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAEXABW4VictoryTypes@@@Z ENDP ; SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >::operator()
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >::operator()
EXTRN	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >::operator()
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@9
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@9:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z ; std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z PROC ; std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@PAU?$pair@FF@1@@Z ENDP ; std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@AAPAU?$pair@FF@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@AAPAU?$pair@FF@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@AAPAU?$pair@FF@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@AAPAU?$pair@FF@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@AAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
$T234430 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T234430[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@4
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN3@Construct@4:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T234430[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Destroy@VCvReplayMessage@@@std@@YAXPAVCvReplayMessage@@@Z ; std::_Destroy<CvReplayMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvReplayMessage@@@std@@YAXPAVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvReplayMessage@@@std@@YAXPAVCvReplayMessage@@@Z PROC ; std::_Destroy<CvReplayMessage>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	0
	call	edx

; 60   : 	}

	ret	0
??$_Destroy@VCvReplayMessage@@@std@@YAXPAVCvReplayMessage@@@Z ENDP ; std::_Destroy<CvReplayMessage>
_TEXT	ENDS
PUBLIC	??$_Construct@W4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@ABW41@@Z ; std::_Construct<enum GameOptionTypes,enum GameOptionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@ABW41@@Z PROC ; std::_Construct<enum GameOptionTypes,enum GameOptionTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@W4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@ABW41@@Z ENDP ; std::_Construct<enum GameOptionTypes,enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4GameOptionTypes@@@std@@YAXPAW4GameOptionTypes@@@Z ; std::_Destroy<enum GameOptionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4GameOptionTypes@@@std@@YAXPAW4GameOptionTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4GameOptionTypes@@@std@@YAXPAW4GameOptionTypes@@@Z PROC ; std::_Destroy<enum GameOptionTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4GameOptionTypes@@@std@@YAXPAW4GameOptionTypes@@@Z ENDP ; std::_Destroy<enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$_Construct@W4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@ABW41@@Z ; std::_Construct<enum VictoryTypes,enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@ABW41@@Z PROC ; std::_Construct<enum VictoryTypes,enum VictoryTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@6
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@6:

; 53   : 	}

	ret	0
??$_Construct@W4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@ABW41@@Z ENDP ; std::_Construct<enum VictoryTypes,enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4VictoryTypes@@@std@@YAXPAW4VictoryTypes@@@Z ; std::_Destroy<enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4VictoryTypes@@@std@@YAXPAW4VictoryTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4VictoryTypes@@@std@@YAXPAW4VictoryTypes@@@Z PROC ; std::_Destroy<enum VictoryTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4VictoryTypes@@@std@@YAXPAW4VictoryTypes@@@Z ENDP ; std::_Destroy<enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@FF@std@@@std@@YAXPAU?$pair@FF@0@@Z ; std::_Destroy<std::pair<short,short> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U?$pair@FF@std@@@std@@YAXPAU?$pair@FF@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@FF@std@@@std@@YAXPAU?$pair@FF@0@@Z PROC ; std::_Destroy<std::pair<short,short> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U?$pair@FF@std@@@std@@YAXPAU?$pair@FF@0@@Z ENDP ; std::_Destroy<std::pair<short,short> >
_TEXT	ENDS
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::begin, COMDAT
; _this$ = ecx

; 561  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 562  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::begin
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@XZ ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@XZ PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ PROC ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@XZ ENDP ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 12			; 0000000cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator++
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEABU?$pair@FF@1@XZ ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEABU?$pair@FF@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEABU?$pair@FF@1@XZ PROC ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEABU?$pair@FF@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator++
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::swap<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::swap<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2206 : 	_Left.swap(_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z

; 2207 : 	}

	ret	0
??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::swap<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAU?$pair@FF@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@FF@0@0@Z ; std::_Iter_random<std::pair<short,short> *,std::pair<short,short> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAU?$pair@FF@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@FF@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAU?$pair@FF@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@FF@0@0@Z PROC ; std::_Iter_random<std::pair<short,short> *,std::pair<short,short> *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAU?$pair@FF@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@FF@0@0@Z ENDP ; std::_Iter_random<std::pair<short,short> *,std::pair<short,short> *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAU?$pair@FF@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@FF@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::pair<short,short> *,std::pair<short,short> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAU?$pair@FF@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@FF@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAU?$pair@FF@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@FF@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::pair<short,short> *,std::pair<short,short> *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@4
	push	esi
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@4
	pop	esi
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAU?$pair@FF@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@FF@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::pair<short,short> *,std::pair<short,short> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@U?$pair@FF@std@@U12@@std@@YAXPAU?$pair@FF@0@ABU10@@Z ; std::_Construct<std::pair<short,short>,std::pair<short,short> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@U?$pair@FF@std@@U12@@std@@YAXPAU?$pair@FF@0@ABU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U?$pair@FF@std@@U12@@std@@YAXPAU?$pair@FF@0@ABU10@@Z PROC ; std::_Construct<std::pair<short,short>,std::pair<short,short> >, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@7
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@7:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@FF@std@@U12@@std@@YAXPAU?$pair@FF@0@ABU10@@Z ENDP ; std::_Construct<std::pair<short,short>,std::pair<short,short> >
_TEXT	ENDS
PUBLIC	??0?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@XZ ; std::pair<unsigned int,CvReplayInfo::PlotState>::pair<unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@XZ PROC	; std::pair<unsigned int,CvReplayInfo::PlotState>::pair<unsigned int,CvReplayInfo::PlotState>, COMDAT
; _this$ = ecx

; 45   : 		{	// construct from defaults

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+16], ecx

; 46   : 		}

	ret	0
??0?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@XZ ENDP	; std::pair<unsigned int,CvReplayInfo::PlotState>::pair<unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??$?0IUPlotState@CvReplayInfo@@@?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@IUPlotState@CvReplayInfo@@@1@@Z ; std::pair<unsigned int const ,CvReplayInfo::PlotState>::pair<unsigned int const ,CvReplayInfo::PlotState><unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0IUPlotState@CvReplayInfo@@@?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@IUPlotState@CvReplayInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0IUPlotState@CvReplayInfo@@@?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@IUPlotState@CvReplayInfo@@@1@@Z PROC ; std::pair<unsigned int const ,CvReplayInfo::PlotState>::pair<unsigned int const ,CvReplayInfo::PlotState><unsigned int,CvReplayInfo::PlotState>, COMDAT
; _this$ = ecx

; 57   : 		{	// construct from compatible pair

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	lea	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+16], edx

; 58   : 		}

	ret	4
??$?0IUPlotState@CvReplayInfo@@@?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@IUPlotState@CvReplayInfo@@@1@@Z ENDP ; std::pair<unsigned int const ,CvReplayInfo::PlotState>::pair<unsigned int const ,CvReplayInfo::PlotState><unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@AAPAVCvReplayMessage@@@Z ; std::_Ptr_cat<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@AAPAVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@AAPAVCvReplayMessage@@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@AAPAVCvReplayMessage@@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *>
_TEXT	ENDS
PUBLIC	??$?0$$CBIUPlotState@CvReplayInfo@@@?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@1@@Z ; std::pair<unsigned int,CvReplayInfo::PlotState>::pair<unsigned int,CvReplayInfo::PlotState><unsigned int const ,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$?0$$CBIUPlotState@CvReplayInfo@@@?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBIUPlotState@CvReplayInfo@@@?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@1@@Z PROC ; std::pair<unsigned int,CvReplayInfo::PlotState>::pair<unsigned int,CvReplayInfo::PlotState><unsigned int const ,CvReplayInfo::PlotState>, COMDAT
; _this$ = ecx

; 57   : 		{	// construct from compatible pair

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	lea	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+16], edx

; 58   : 		}

	ret	4
??$?0$$CBIUPlotState@CvReplayInfo@@@?$pair@IUPlotState@CvReplayInfo@@@std@@QAE@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@1@@Z ENDP ; std::pair<unsigned int,CvReplayInfo::PlotState>::pair<unsigned int,CvReplayInfo::PlotState><unsigned int const ,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??$?8U?$pair@$$CBIH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIH@std@@@0@0@Z ; std::operator==<std::pair<unsigned int const ,int>,std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?8U?$pair@$$CBIH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIH@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBIH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIH@std@@@0@0@Z PROC ; std::operator==<std::pair<unsigned int const ,int>,std::pair<unsigned int const ,int> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBIH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIH@std@@@0@0@Z ENDP ; std::operator==<std::pair<unsigned int const ,int>,std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@0@Z ; std::swap<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@0@Z PROC ; std::swap<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::swap<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
_TEXT	ENDS
PUBLIC	??$?8V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V01@@std@@YA_NABV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@0@Z ; std::operator==<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?8V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V01@@std@@YA_NABV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V01@@std@@YA_NABV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@0@Z PROC ; std::operator==<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V01@@std@@YA_NABV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@0@Z ENDP ; std::operator==<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$swap@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ; std::swap<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z PROC ; std::swap<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ENDP ; std::swap<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$?8U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@0@0@Z ; std::operator==<std::pair<unsigned int const ,CvReplayInfo::PlotState>,std::pair<unsigned int const ,CvReplayInfo::PlotState> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?8U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@0@0@Z PROC ; std::operator==<std::pair<unsigned int const ,CvReplayInfo::PlotState>,std::pair<unsigned int const ,CvReplayInfo::PlotState> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@0@0@Z ENDP ; std::operator==<std::pair<unsigned int const ,CvReplayInfo::PlotState>,std::pair<unsigned int const ,CvReplayInfo::PlotState> >
_TEXT	ENDS
PUBLIC	??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0@Z ; std::swap<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0@Z PROC ; std::swap<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@4

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@4:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0@Z ENDP ; std::swap<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEAAVCvReplayMessage@@XZ ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEAAVCvReplayMessage@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEAAVCvReplayMessage@@XZ PROC ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEAAVCvReplayMessage@@XZ ENDP ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 60			; 0000003cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator++
_TEXT	ENDS
PUBLIC	??$swap@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z ; std::swap<std::less<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z PROC	; std::swap<std::less<unsigned int> >, COMDAT

; 18   : 	if (&_Left != &_Right)
; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;
; 21   : 
; 22   : 		_Left = _Right;
; 23   : 		_Right = _Tmp;
; 24   : 		}
; 25   : 	}

	ret	0
??$swap@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z ENDP	; std::swap<std::less<unsigned int> >
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ	; CvPlot::getPlotType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ
_TEXT	SEGMENT
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ PROC		; CvPlot::getPlotType, COMDAT
; _this$ = ecx

; 405  : 		return (PlotTypes)m_ePlotType;

	movsx	eax, BYTE PTR [ecx+5]

; 406  : 	}

	ret	0
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ENDP		; CvPlot::getPlotType
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@5

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@5:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??0PlayerInfo@CvReplayInfo@@QAE@XZ		; CvReplayInfo::PlayerInfo::PlayerInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$2
__ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0PlayerInfo@CvReplayInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0PlayerInfo@CvReplayInfo@@QAE@XZ PROC			; CvReplayInfo::PlayerInfo::PlayerInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+72]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+100]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PlayerInfo@CvReplayInfo@@QAE@XZ ENDP			; CvReplayInfo::PlayerInfo::PlayerInfo
PUBLIC	??1PlayerInfo@CvReplayInfo@@QAE@XZ		; CvReplayInfo::PlayerInfo::~PlayerInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1PlayerInfo@CvReplayInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$2
__ehfuncinfo$??1PlayerInfo@CvReplayInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1PlayerInfo@CvReplayInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1PlayerInfo@CvReplayInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1PlayerInfo@CvReplayInfo@@QAE@XZ PROC			; CvReplayInfo::PlayerInfo::~PlayerInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+72]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+44]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1PlayerInfo@CvReplayInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1PlayerInfo@CvReplayInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PlayerInfo@CvReplayInfo@@QAE@XZ ENDP			; CvReplayInfo::PlayerInfo::~PlayerInfo
PUBLIC	?getNumPlayers@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getNumPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?getNumPlayers@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumPlayers@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getNumPlayers, COMDAT
; _this$ = ecx

; 250  : 	return (int)m_listPlayerInfo.size();

	mov	eax, DWORD PTR [ecx+152]
	sub	eax, DWORD PTR [ecx+148]
	sar	eax, 7

; 251  : }

	ret	0
?getNumPlayers@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getNumPlayers
_TEXT	ENDS
PUBLIC	?isValidPlayer@CvReplayInfo@@IBE_NH@Z		; CvReplayInfo::isValidPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?isValidPlayer@CvReplayInfo@@IBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isValidPlayer@CvReplayInfo@@IBE_NH@Z PROC		; CvReplayInfo::isValidPlayer, COMDAT
; _this$ = ecx

; 256  : 	return (i >= 0 && i < (int)m_listPlayerInfo.size());

	mov	eax, DWORD PTR _i$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isValidPla
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN3@isValidPla
	mov	eax, 1

; 257  : }

	ret	4
$LN3@isValidPla:

; 256  : 	return (i >= 0 && i < (int)m_listPlayerInfo.size());

	xor	eax, eax

; 257  : }

	ret	4
?isValidPlayer@CvReplayInfo@@IBE_NH@Z ENDP		; CvReplayInfo::isValidPlayer
_TEXT	ENDS
PUBLIC	?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z ; CvReplayInfo::getPlayerCivilization
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z PROC ; CvReplayInfo::getPlayerCivilization, COMDAT
; _this$ = ecx

; 271  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerC
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerC

; 272  : 	{
; 273  : 		return m_listPlayerInfo[iPlayer].m_eCivilization;

	mov	ecx, DWORD PTR [ecx+148]
	shl	eax, 7
	mov	eax, DWORD PTR [eax+ecx]

; 277  : }

	ret	4
$LN1@getPlayerC:

; 274  : 	}
; 275  : 
; 276  : 	return NO_CIVILIZATION;

	or	eax, -1

; 277  : }

	ret	4
?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z ENDP ; CvReplayInfo::getPlayerCivilization
_TEXT	ENDS
PUBLIC	?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z ; CvReplayInfo::getPlayerLeader
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z PROC ; CvReplayInfo::getPlayerLeader, COMDAT
; _this$ = ecx

; 281  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerL
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerL

; 282  : 	{
; 283  : 		return m_listPlayerInfo[iPlayer].m_eLeader;

	mov	ecx, DWORD PTR [ecx+148]
	shl	eax, 7
	mov	eax, DWORD PTR [ecx+eax+4]

; 287  : }

	ret	4
$LN1@getPlayerL:

; 284  : 	}
; 285  : 
; 286  : 	return NO_LEADER;

	or	eax, -1

; 287  : }

	ret	4
?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z ENDP ; CvReplayInfo::getPlayerLeader
_TEXT	ENDS
PUBLIC	?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z ; CvReplayInfo::getPlayerColor
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z PROC ; CvReplayInfo::getPlayerColor, COMDAT
; _this$ = ecx

; 291  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerC@2
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerC@2

; 292  : 	{
; 293  : 		return m_listPlayerInfo[iPlayer].m_ePlayerColor;

	mov	ecx, DWORD PTR [ecx+148]
	shl	eax, 7
	mov	eax, DWORD PTR [ecx+eax+8]

; 297  : }

	ret	4
$LN1@getPlayerC@2:

; 294  : 	}
; 295  : 
; 296  : 	return NO_PLAYERCOLOR;

	or	eax, -1

; 297  : }

	ret	4
?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z ENDP ; CvReplayInfo::getPlayerColor
_TEXT	ENDS
PUBLIC	?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z ; CvReplayInfo::getPlayerDifficulty
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z PROC ; CvReplayInfo::getPlayerDifficulty, COMDAT
; _this$ = ecx

; 301  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerD
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerD

; 302  : 	{
; 303  : 		return m_listPlayerInfo[iPlayer].m_eDifficulty;

	mov	ecx, DWORD PTR [ecx+148]
	shl	eax, 7
	mov	eax, DWORD PTR [ecx+eax+12]

; 307  : }

	ret	4
$LN1@getPlayerD:

; 304  : 	}
; 305  : 
; 306  : 	return NO_HANDICAP;

	or	eax, -1

; 307  : }

	ret	4
?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z ENDP ; CvReplayInfo::getPlayerDifficulty
_TEXT	ENDS
PUBLIC	?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z	; CvReplayInfo::getPlayerLeaderName
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z PROC	; CvReplayInfo::getPlayerLeaderName, COMDAT
; _this$ = ecx

; 311  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerL@2
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerL@2

; 312  : 	{
; 313  : 		return m_listPlayerInfo[iPlayer].m_strCustomLeaderName;

	shl	eax, 7
	add	eax, DWORD PTR [ecx+148]
	lea	ecx, DWORD PTR [eax+16]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 317  : }

	ret	4
$LN1@getPlayerL@2:

; 314  : 	}
; 315  : 
; 316  : 	return NULL;

	xor	eax, eax

; 317  : }

	ret	4
?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z ENDP	; CvReplayInfo::getPlayerLeaderName
_TEXT	ENDS
PUBLIC	?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z ; CvReplayInfo::getPlayerCivDescription
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z PROC	; CvReplayInfo::getPlayerCivDescription, COMDAT
; _this$ = ecx

; 321  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerC@3
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerC@3

; 322  : 	{
; 323  : 		return m_listPlayerInfo[iPlayer].m_strCustomCivilizationName;

	shl	eax, 7
	add	eax, DWORD PTR [ecx+148]
	lea	ecx, DWORD PTR [eax+44]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 327  : }

	ret	4
$LN1@getPlayerC@3:

; 324  : 	}
; 325  : 
; 326  : 	return NULL;

	xor	eax, eax

; 327  : }

	ret	4
?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z ENDP	; CvReplayInfo::getPlayerCivDescription
_TEXT	ENDS
PUBLIC	?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z ; CvReplayInfo::getPlayerShortCivDescription
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z PROC ; CvReplayInfo::getPlayerShortCivDescription, COMDAT
; _this$ = ecx

; 331  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerS
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerS

; 332  : 	{
; 333  : 		return m_listPlayerInfo[iPlayer].m_strCustomCivilizationShortName;

	shl	eax, 7
	add	eax, DWORD PTR [ecx+148]
	lea	ecx, DWORD PTR [eax+72]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 337  : }

	ret	4
$LN1@getPlayerS:

; 334  : 	}
; 335  : 
; 336  : 	return NULL;

	xor	eax, eax

; 337  : }

	ret	4
?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z ENDP ; CvReplayInfo::getPlayerShortCivDescription
_TEXT	ENDS
PUBLIC	?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z	; CvReplayInfo::getPlayerCivAdjective
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z PROC	; CvReplayInfo::getPlayerCivAdjective, COMDAT
; _this$ = ecx

; 341  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	mov	eax, DWORD PTR _iPlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getPlayerC@4
	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	sar	edx, 7
	cmp	eax, edx
	jge	SHORT $LN1@getPlayerC@4

; 342  : 	{
; 343  : 		return m_listPlayerInfo[iPlayer].m_strCustomCivilizationAdjective;

	shl	eax, 7
	add	eax, DWORD PTR [ecx+148]
	lea	ecx, DWORD PTR [eax+100]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 347  : }

	ret	4
$LN1@getPlayerC@4:

; 344  : 	}
; 345  : 
; 346  : 	return NULL;

	xor	eax, eax

; 347  : }

	ret	4
?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z ENDP	; CvReplayInfo::getPlayerCivAdjective
_TEXT	ENDS
PUBLIC	?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z ; CvReplayInfo::isGameOption
; Function compile flags: /Ogtpy
;	COMDAT ?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z
_TEXT	SEGMENT
_eOption$ = 8						; size = 4
?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z PROC ; CvReplayInfo::isGameOption, COMDAT
; _this$ = ecx

; 381  : 	for(uint i = 0; i < m_listGameOptions.size(); i++)

	mov	eax, DWORD PTR [ecx+64]
	sub	eax, DWORD PTR [ecx+60]
	xor	edx, edx
	sar	eax, 2
	push	esi
	test	eax, eax
	jbe	SHORT $LN2@isGameOpti
	mov	eax, DWORD PTR [ecx+64]
	sub	eax, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [ecx+60]
	mov	esi, DWORD PTR _eOption$[esp]
	sar	eax, 2
$LL4@isGameOpti:

; 382  : 	{
; 383  : 		if(m_listGameOptions[i] == eOption)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN12@isGameOpti
	inc	edx
	add	ecx, 4
	cmp	edx, eax
	jb	SHORT $LL4@isGameOpti
$LN2@isGameOpti:

; 386  : 		}
; 387  : 	}
; 388  : 	return false;

	xor	al, al
	pop	esi

; 389  : }

	ret	4
$LN12@isGameOpti:

; 384  : 		{
; 385  : 			return true;

	mov	al, 1
	pop	esi

; 389  : }

	ret	4
?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z ENDP ; CvReplayInfo::isGameOption
_TEXT	ENDS
PUBLIC	?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z ; CvReplayInfo::isVictoryCondition
; Function compile flags: /Ogtpy
;	COMDAT ?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z
_TEXT	SEGMENT
_eVictory$ = 8						; size = 4
?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z PROC ; CvReplayInfo::isVictoryCondition, COMDAT
; _this$ = ecx

; 393  : 	for(uint i = 0; i < m_listVictoryTypes.size(); i++)

	mov	eax, DWORD PTR [ecx+80]
	sub	eax, DWORD PTR [ecx+76]
	xor	edx, edx
	sar	eax, 2
	push	esi
	test	eax, eax
	jbe	SHORT $LN2@isVictoryC
	mov	eax, DWORD PTR [ecx+80]
	sub	eax, DWORD PTR [ecx+76]
	mov	ecx, DWORD PTR [ecx+76]
	mov	esi, DWORD PTR _eVictory$[esp]
	sar	eax, 2
$LL4@isVictoryC:

; 394  : 	{
; 395  : 		if(m_listVictoryTypes[i] == eVictory)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN12@isVictoryC
	inc	edx
	add	ecx, 4
	cmp	edx, eax
	jb	SHORT $LL4@isVictoryC
$LN2@isVictoryC:

; 398  : 		}
; 399  : 	}
; 400  : 	return false;

	xor	al, al
	pop	esi

; 401  : }

	ret	4
$LN12@isVictoryC:

; 396  : 		{
; 397  : 			return true;

	mov	al, 1
	pop	esi

; 401  : }

	ret	4
?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z ENDP ; CvReplayInfo::isVictoryCondition
_TEXT	ENDS
PUBLIC	?getNumReplayMessages@CvReplayInfo@@QBEIXZ	; CvReplayInfo::getNumReplayMessages
; Function compile flags: /Ogtpy
;	COMDAT ?getNumReplayMessages@CvReplayInfo@@QBEIXZ
_TEXT	SEGMENT
?getNumReplayMessages@CvReplayInfo@@QBEIXZ PROC		; CvReplayInfo::getNumReplayMessages, COMDAT
; _this$ = ecx

; 424  : {

	push	esi

; 425  : 	return m_listReplayMessages.size();

	mov	esi, DWORD PTR [ecx+168]
	sub	esi, DWORD PTR [ecx+164]
	mov	eax, -2004318071			; 88888889H
	imul	esi
	add	edx, esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 426  : }

	ret	0
?getNumReplayMessages@CvReplayInfo@@QBEIXZ ENDP		; CvReplayInfo::getNumReplayMessages
_TEXT	ENDS
PUBLIC	?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z ; CvReplayInfo::getReplayMessage
; Function compile flags: /Ogtpy
;	COMDAT ?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z PROC ; CvReplayInfo::getReplayMessage, COMDAT
; _this$ = ecx

; 429  : {

	push	esi

; 430  : 	if(i < m_listReplayMessages.size())

	mov	esi, DWORD PTR [ecx+168]
	sub	esi, DWORD PTR [ecx+164]
	mov	eax, -2004318071			; 88888889H
	imul	esi
	mov	eax, DWORD PTR _i$[esp]
	add	edx, esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	cmp	eax, esi
	pop	esi
	jae	SHORT $LN1@getReplayM

; 431  : 	{
; 432  : 		return &(m_listReplayMessages[i]);

	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+164]
	lea	eax, DWORD PTR [eax+edx*4]

; 436  : }

	ret	4
$LN1@getReplayM:

; 433  : 	}
; 434  : 
; 435  : 	return NULL;

	xor	eax, eax

; 436  : }

	ret	4
?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z ENDP ; CvReplayInfo::getReplayMessage
_TEXT	ENDS
PUBLIC	?getFinalDate@CvReplayInfo@@QBEPBDXZ		; CvReplayInfo::getFinalDate
; Function compile flags: /Ogtpy
;	COMDAT ?getFinalDate@CvReplayInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getFinalDate@CvReplayInfo@@QBEPBDXZ PROC		; CvReplayInfo::getFinalDate, COMDAT
; _this$ = ecx

; 455  : 	return m_strFinalDate;

	add	ecx, 108				; 0000006cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getFinalDate@CvReplayInfo@@QBEPBDXZ ENDP		; CvReplayInfo::getFinalDate
_TEXT	ENDS
PUBLIC	?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ	; CvReplayInfo::getNumPlayerDataSets
; Function compile flags: /Ogtpy
;	COMDAT ?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ
_TEXT	SEGMENT
?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ PROC		; CvReplayInfo::getNumPlayerDataSets, COMDAT
; _this$ = ecx

; 464  : {

	push	esi

; 465  : 	return m_dataSetMap.size();

	mov	esi, DWORD PTR [ecx+184]
	sub	esi, DWORD PTR [ecx+180]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 466  : }

	ret	0
?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ ENDP		; CvReplayInfo::getNumPlayerDataSets
_TEXT	ENDS
PUBLIC	?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z	; CvReplayInfo::getPlayerDataSetName
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z PROC	; CvReplayInfo::getPlayerDataSetName, COMDAT
; _this$ = ecx

; 469  : {

	push	esi

; 470  : 	if(idx < m_dataSetMap.size())

	mov	esi, DWORD PTR [ecx+184]
	sub	esi, DWORD PTR [ecx+180]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	mov	eax, DWORD PTR _idx$[esp]
	add	edx, esi
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	cmp	eax, esi
	pop	esi
	jae	SHORT $LN1@getPlayerD@2

; 471  : 	{
; 472  : 		return m_dataSetMap[idx].c_str();

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+180]
	lea	ecx, DWORD PTR [eax+edx*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 476  : }

	ret	4
$LN1@getPlayerD@2:

; 473  : 	}
; 474  : 
; 475  : 	return NULL;

	xor	eax, eax

; 476  : }

	ret	4
?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z ENDP	; CvReplayInfo::getPlayerDataSetName
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4HandicapTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerColorTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4LeaderHeadTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CivilizationTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z PROC ; operator<<, COMDAT

; 617  : {

	push	esi

; 618  : 	saveTo << readFrom.m_eCivilization;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CivilizationTypes@@@Z ; operator<<

; 619  : 	saveTo << readFrom.m_eLeader;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4LeaderHeadTypes@@@Z ; operator<<

; 620  : 	saveTo << readFrom.m_ePlayerColor;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerColorTypes@@@Z ; operator<<

; 621  : 	saveTo << readFrom.m_eDifficulty;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4HandicapTypes@@@Z ; operator<<
	add	esp, 32					; 00000020H

; 622  : 	saveTo << readFrom.m_strCustomLeaderName;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 623  : 	saveTo << readFrom.m_strCustomCivilizationName;

	lea	ecx, DWORD PTR [edi+44]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 624  : 	saveTo << readFrom.m_strCustomCivilizationShortName;

	lea	edx, DWORD PTR [edi+72]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 625  : 	saveTo << readFrom.m_strCustomCivilizationAdjective;

	add	edi, 100				; 00000064H
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	pop	edi

; 626  : 
; 627  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 628  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4HandicapTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerColorTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4LeaderHeadTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CivilizationTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z PROC ; operator>>, COMDAT

; 631  : {

	push	esi

; 632  : 	loadFrom >> writeTo.m_eCivilization;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4CivilizationTypes@@@Z ; operator>>

; 633  : 	loadFrom >> writeTo.m_eLeader;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4LeaderHeadTypes@@@Z ; operator>>

; 634  : 	loadFrom >> writeTo.m_ePlayerColor;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerColorTypes@@@Z ; operator>>

; 635  : 	loadFrom >> writeTo.m_eDifficulty;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4HandicapTypes@@@Z ; operator>>
	add	esp, 32					; 00000020H

; 636  : 	loadFrom >> writeTo.m_strCustomLeaderName;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 637  : 	loadFrom >> writeTo.m_strCustomCivilizationName;

	lea	ecx, DWORD PTR [edi+44]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 638  : 	loadFrom >> writeTo.m_strCustomCivilizationShortName;

	lea	edx, DWORD PTR [edi+72]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 639  : 	loadFrom >> writeTo.m_strCustomCivilizationAdjective;

	add	edi, 100				; 00000064H
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read
	pop	edi

; 640  : 
; 641  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 642  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
_uiRiverData$ = 8					; size = 1
_saveTo$ = 8						; size = 4
$T234947 = 12						; size = 1
$T234946 = 12						; size = 1
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z PROC ; operator<<, COMDAT

; 645  : {

	push	esi

; 646  : 	saveTo << (unsigned char)readFrom.m_eTerrain;

	mov	esi, DWORD PTR _readFrom$[esp]
	mov	al, BYTE PTR [esi]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+4]
	lea	ecx, DWORD PTR $T234946[esp+4]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR $T234946[esp+8], al
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 647  : 	saveTo << (unsigned char)readFrom.m_eFeature;

	mov	dl, BYTE PTR [esi+4]
	lea	eax, DWORD PTR $T234947[esp+4]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR $T234947[esp+8], dl
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 648  : 
; 649  : 	unsigned char uiRiverData = 0;
; 650  : 	uiRiverData |= (readFrom.m_bNWOfRiver) << 1;
; 651  : 	uiRiverData |= (readFrom.m_bWOfRiver) << 2;
; 652  : 	uiRiverData |= (readFrom.m_bNEOfRiver) << 3;

	mov	cl, BYTE PTR [esi+8]
	add	cl, cl
	or	cl, BYTE PTR [esi+9]

; 653  : 
; 654  : 	saveTo << uiRiverData;

	lea	edx, DWORD PTR _uiRiverData$[esp+4]
	add	cl, cl
	or	cl, BYTE PTR [esi+10]
	push	edx
	add	cl, cl
	mov	BYTE PTR _uiRiverData$[esp+8], cl
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 655  : 
; 656  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi

; 657  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
_ucTempVal$ = 8						; size = 1
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z PROC ; operator>>, COMDAT

; 660  : {

	push	esi
	push	edi

; 661  : 	unsigned char ucTempVal;
; 662  : 	loadFrom >> ucTempVal;

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	lea	eax, DWORD PTR _ucTempVal$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 663  : 	writeTo.m_eTerrain = (TerrainTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[esp+4]
	mov	esi, DWORD PTR _writeTo$[esp+4]

; 664  : 
; 665  : 	loadFrom >> ucTempVal;

	lea	edx, DWORD PTR _ucTempVal$[esp+4]
	mov	DWORD PTR [esi], ecx
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 666  : 	writeTo.m_eFeature = (FeatureTypes)ucTempVal;

	movzx	eax, BYTE PTR _ucTempVal$[esp+4]

; 667  : 
; 668  : 	loadFrom >> ucTempVal;

	lea	ecx, DWORD PTR _ucTempVal$[esp+4]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR [esi+4], eax
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 669  : 	writeTo.m_bNWOfRiver = (ucTempVal & (1 << 1)) != 0;

	mov	al, BYTE PTR _ucTempVal$[esp+4]
	mov	dl, al

; 670  : 	writeTo.m_bWOfRiver = (ucTempVal & (1 << 2)) != 0;

	mov	cl, al

; 671  : 	writeTo.m_bNEOfRiver = (ucTempVal & (1 << 3)) != 0;

	shr	al, 3
	and	al, 1
	shr	dl, 1
	shr	cl, 2
	mov	BYTE PTR [esi+8], al
	and	dl, 1
	and	cl, 1

; 672  : 
; 673  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	mov	BYTE PTR [esi+10], dl
	mov	BYTE PTR [esi+9], cl
	pop	esi

; 674  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
_uiRiverData$ = 8					; size = 1
_saveTo$ = 8						; size = 4
$T234974 = 12						; size = 1
$T234973 = 12						; size = 1
$T234972 = 12						; size = 1
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z PROC ; operator<<, COMDAT

; 677  : {

	push	esi

; 678  : 	saveTo << (unsigned char)readFrom.m_ePlotType;

	mov	esi, DWORD PTR _readFrom$[esp]
	movzx	eax, BYTE PTR [esi]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+4]
	lea	ecx, DWORD PTR $T234972[esp+4]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR $T234972[esp+8], al
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 679  : 	saveTo << (unsigned char)readFrom.m_eTerrain;

	mov	dl, BYTE PTR [esi+4]
	lea	eax, DWORD PTR $T234973[esp+4]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR $T234973[esp+8], dl
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 680  : 	saveTo << (unsigned char)readFrom.m_eFeature;

	mov	cl, BYTE PTR [esi+8]
	lea	edx, DWORD PTR $T234974[esp+4]
	mov	BYTE PTR $T234974[esp+4], cl
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 681  : 
; 682  : 	unsigned char uiRiverData = 0;
; 683  : 	uiRiverData |= (readFrom.m_bNWOfRiver) << 1;
; 684  : 	uiRiverData |= (readFrom.m_bWOfRiver) << 2;
; 685  : 	uiRiverData |= (readFrom.m_bNEOfRiver) << 3;

	movzx	eax, BYTE PTR [esi+12]
	add	al, al
	or	al, BYTE PTR [esi+13]

; 686  : 
; 687  : 	saveTo << uiRiverData;

	lea	ecx, DWORD PTR _uiRiverData$[esp+4]
	add	al, al
	or	al, BYTE PTR [esi+14]
	push	ecx
	add	al, al
	mov	ecx, edi
	mov	BYTE PTR _uiRiverData$[esp+8], al
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 688  : 
; 689  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi

; 690  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
_ucTempVal$ = 8						; size = 1
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z PROC ; operator>>, COMDAT

; 693  : {

	push	esi
	push	edi

; 694  : 	unsigned char ucTempVal;
; 695  : 
; 696  : 	loadFrom >> ucTempVal;

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	lea	eax, DWORD PTR _ucTempVal$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 697  : 	writeTo.m_ePlotType = (PlotTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[esp+4]
	mov	esi, DWORD PTR _writeTo$[esp+4]

; 698  : 
; 699  : 	loadFrom >> ucTempVal;

	lea	edx, DWORD PTR _ucTempVal$[esp+4]
	mov	DWORD PTR [esi], ecx
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 700  : 	writeTo.m_eTerrain = (TerrainTypes)ucTempVal;

	movzx	eax, BYTE PTR _ucTempVal$[esp+4]

; 701  : 
; 702  : 	loadFrom >> ucTempVal;

	lea	ecx, DWORD PTR _ucTempVal$[esp+4]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR [esi+4], eax
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 703  : 	writeTo.m_eFeature = (FeatureTypes)ucTempVal;

	movzx	edx, BYTE PTR _ucTempVal$[esp+4]

; 704  : 
; 705  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[esp+4]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi+8], edx
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 706  : 	writeTo.m_bNWOfRiver = (ucTempVal & (1 << 1)) != 0;

	mov	al, BYTE PTR _ucTempVal$[esp+4]
	mov	cl, al

; 707  : 	writeTo.m_bWOfRiver = (ucTempVal & (1 << 2)) != 0;

	mov	dl, al

; 708  : 	writeTo.m_bNEOfRiver = (ucTempVal & (1 << 3)) != 0;

	shr	al, 3
	and	al, 1
	shr	cl, 1
	shr	dl, 2
	mov	BYTE PTR [esi+12], al
	and	cl, 1
	and	dl, 1

; 709  : 
; 710  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	mov	BYTE PTR [esi+14], cl
	mov	BYTE PTR [esi+13], dl
	pop	esi

; 711  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::~_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::~_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::~_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::~_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::~_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::~_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 71582788				; 04444444H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z PROC ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE@V?$allocator@VCvReplayMessage@@@1@@Z ENDP ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvReplayMessage@@@std@@QAEPAVCvReplayMessage@@I@Z ; std::allocator<CvReplayMessage>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvReplayMessage@@@std@@QAEPAVCvReplayMessage@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvReplayMessage@@@std@@QAEPAVCvReplayMessage@@I@Z PROC ; std::allocator<CvReplayMessage>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvReplayMessage@@@std@@QAEPAVCvReplayMessage@@I@Z ENDP ; std::allocator<CvReplayMessage>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z PROC ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z PROC ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE@V?$allocator@W4GameOptionTypes@@@1@@Z ENDP ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z PROC ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE@V?$allocator@W4VictoryTypes@@@1@@Z ENDP ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z PROC ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE@V?$allocator@UPlayerInfo@CvReplayInfo@@@1@@Z ENDP ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z PROC ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z PROC ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@1@@Z ENDP ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@I@Z ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::allocate
_TEXT	ENDS
PUBLIC	?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z PROC ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE@V?$allocator@U?$pair@FF@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Key
; Function compile flags: /Ogtpy
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jae	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 732  : 		}

	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4GameOptionTypes@@@std@@QAEPAW4GameOptionTypes@@I@Z ; std::allocator<enum GameOptionTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4GameOptionTypes@@@std@@QAEPAW4GameOptionTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4GameOptionTypes@@@std@@QAEPAW4GameOptionTypes@@I@Z PROC ; std::allocator<enum GameOptionTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4GameOptionTypes@@@std@@QAEPAW4GameOptionTypes@@I@Z ENDP ; std::allocator<enum GameOptionTypes>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4VictoryTypes@@@std@@QAEPAW4VictoryTypes@@I@Z ; std::allocator<enum VictoryTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4VictoryTypes@@@std@@QAEPAW4VictoryTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4VictoryTypes@@@std@@QAEPAW4VictoryTypes@@I@Z PROC ; std::allocator<enum VictoryTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4VictoryTypes@@@std@@QAEPAW4VictoryTypes@@I@Z ENDP ; std::allocator<enum VictoryTypes>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 33554431				; 01ffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEPAUPlayerInfo@CvReplayInfo@@I@Z ; std::allocator<CvReplayInfo::PlayerInfo>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEPAUPlayerInfo@CvReplayInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEPAUPlayerInfo@CvReplayInfo@@I@Z PROC ; std::allocator<CvReplayInfo::PlayerInfo>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEPAUPlayerInfo@CvReplayInfo@@I@Z ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@I@Z ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U?$pair@FF@std@@@std@@QAEPAU?$pair@FF@2@I@Z ; std::allocator<std::pair<short,short> >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@FF@std@@@std@@QAEPAU?$pair@FF@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@FF@std@@@std@@QAEPAU?$pair@FF@2@I@Z PROC ; std::allocator<std::pair<short,short> >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U?$pair@FF@std@@@std@@QAEPAU?$pair@FF@2@I@Z ENDP ; std::allocator<std::pair<short,short> >::allocate
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Lbound@2
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound@2:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound@2

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@2:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Lbound@2
$LN3@Lbound@2:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN3@Lbound@3
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound@3:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jae	SHORT $LN2@Lbound@3

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@3:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL4@Lbound@3
$LN3@Lbound@3:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z PROC ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@@Z ENDP ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z PROC ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@PAW4GameOptionTypes@@@Z ENDP ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z PROC ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@PAW4VictoryTypes@@@Z ENDP ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z PROC ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@PAUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z PROC ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@@Z ENDP ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z PROC ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@@Z ENDP ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator!=
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z	; CvReplayInfo::PlayerInfo::PlayerInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$2
__ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z PROC		; CvReplayInfo::PlayerInfo::PlayerInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [esi+16]
	push	edx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR [edi+44]
	lea	ecx, DWORD PTR [esi+44]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	edx, DWORD PTR [edi+72]
	lea	ecx, DWORD PTR [esi+72]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	add	edi, 100				; 00000064H
	push	edi
	lea	ecx, DWORD PTR [esi+100]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z ENDP		; CvReplayInfo::PlayerInfo::PlayerInfo
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@I@Z ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate@2:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@2:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@2:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 214748364				; 0cccccccH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN5@Lrotate@3

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate@3:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate@3

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@3:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate@3

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@3:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec@2:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN43@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN24@Dec@2
	npad	1
$LL25@Dec@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL25@Dec@2
$LN24@Dec@2:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec@2:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Dec@2
$LL4@Dec@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL4@Dec@2
$LN3@Dec@2:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN1@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec@2:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN34@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN17@Inc@2
	npad	7
$LL18@Inc@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL18@Inc@2
$LN17@Inc@2:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc@2:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN1@Inc@2
$LL2@Inc@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc@2:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	edx, ecx
	shl	edx, 4
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 7
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+=
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN9@Dec@3

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec@3:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN43@Dec@3

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN24@Dec@3
	npad	1
$LL25@Dec@3:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL25@Dec@3
$LN24@Dec@3:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec@3:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Dec@3
$LL4@Dec@3:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@3

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL4@Dec@3
$LN3@Dec@3:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN1@Dec@3

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec@3:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc@3

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc@3

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc@3
	npad	7
$LL18@Inc@3:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc@3
$LN17@Inc@3:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc@3:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc@3
$LL2@Inc@3:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@3

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc@3
$LN1@Inc@3:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc@3:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z PROC ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	esi, ebx
	je	SHORT $LN14@unchecked_
$LL9@unchecked_:
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL9@unchecked_
$LN14@unchecked_:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ENDP ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum GameOptionTypes *,enum GameOptionTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum GameOptionTypes *,enum GameOptionTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL9@unchecked_@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum GameOptionTypes *,enum GameOptionTypes *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum VictoryTypes *,enum VictoryTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum VictoryTypes *,enum VictoryTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum VictoryTypes *,enum VictoryTypes *>
_TEXT	ENDS
PUBLIC	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill:
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL5@fill
	pop	ebx
$LN3@fill:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z ; std::fill<enum GameOptionTypes *,enum GameOptionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z PROC ; std::fill<enum GameOptionTypes *,enum GameOptionTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z ENDP ; std::fill<enum GameOptionTypes *,enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z ; std::fill<enum VictoryTypes *,enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z PROC ; std::fill<enum VictoryTypes *,enum VictoryTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z ENDP ; std::fill<enum VictoryTypes *,enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >::SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T236552 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >::SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T236552[esp]
	sar	edx, 2
	push	eax
	mov	DWORD PTR $T236552[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >::SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >::SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T236563 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >::SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T236563[esp]
	sar	edx, 2
	push	eax
	mov	DWORD PTR $T236563[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >::SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >::SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
$T236574 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >::SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T236574[esp]
	sar	edx, 7
	push	eax
	mov	DWORD PTR $T236574[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >::SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >::SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T236585 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >::SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp+4]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi], ecx

; 70   : 		m_saveTo << container.size();

	mov	esi, DWORD PTR [eax+8]
	sub	esi, DWORD PTR [eax+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T236585[esp+4]
	push	edx
	mov	DWORD PTR $T236585[esp+8], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, edi
	pop	edi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >::SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >::SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T236596 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >::SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T236596[esp]
	sar	edx, 4
	push	eax
	mov	DWORD PTR $T236596[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >::SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >::SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T236607 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >::SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T236607[esp]
	push	edx
	mov	DWORD PTR $T236607[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >::SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >,SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >,SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each
	npad	2
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameOptionTypes@@@Z ; operator<<
	add	esi, 4
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4GameOptionTypes@@$$CBV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >,SerializeFromSequenceContainer<enum GameOptionTypes const ,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > const > >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >,SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const > >
; Function compile flags: /Ogtpy
;	COMDAT ??$for_each@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >,SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each@2
	npad	2
$LL6@for_each@2:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z ; operator<<
	add	esi, 4
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each@2
$LN1@for_each@2:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBW4VictoryTypes@@$$CBV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >,SerializeFromSequenceContainer<enum VictoryTypes const ,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > const > >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const > >
; Function compile flags: /Ogtpy
;	COMDAT ??$for_each@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each@3
	npad	2
$LL6@for_each@3:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator<<
	add	esi, 28					; 0000001cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each@3
$LN1@for_each@3:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,SerializeFromSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const > >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4GameOptionTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum GameOptionTypes *,enum GameOptionTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@2
	push	esi
$LL6@Move_backw@2:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@2
	pop	esi
$LN5@Move_backw@2:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4VictoryTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum VictoryTypes *,enum VictoryTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z	; CvReplayInfo::PlayerInfo::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z PROC	; CvReplayInfo::PlayerInfo::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	push	ecx
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	edx, DWORD PTR [edi+44]
	push	edx
	lea	ecx, DWORD PTR [esi+44]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	eax, DWORD PTR [edi+72]
	push	eax
	lea	ecx, DWORD PTR [esi+72]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	edi, 100				; 00000064H
	push	edi
	lea	ecx, DWORD PTR [esi+100]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z ENDP	; CvReplayInfo::PlayerInfo::operator=
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT
$T236759 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$236765 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$236765[esp+12], ecx
	mov	DWORD PTR $T236759[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@4
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN5@construct@4:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$236765[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T236759[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
PUBLIC	?destroy@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@@Z ; std::allocator<CvReplayMessage>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@@Z PROC ; std::allocator<CvReplayMessage>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr$[esp-4], 0
	jmp	edx
?destroy@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@@Z ENDP ; std::allocator<CvReplayMessage>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@ABW43@@Z ; std::allocator<enum GameOptionTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@ABW43@@Z PROC ; std::allocator<enum GameOptionTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@5:

; 156  : 		}

	ret	8
?construct@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@ABW43@@Z ENDP ; std::allocator<enum GameOptionTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@@Z ; std::allocator<enum GameOptionTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@@Z PROC ; std::allocator<enum GameOptionTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4GameOptionTypes@@@std@@QAEXPAW4GameOptionTypes@@@Z ENDP ; std::allocator<enum GameOptionTypes>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@ABW43@@Z ; std::allocator<enum VictoryTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@ABW43@@Z PROC ; std::allocator<enum VictoryTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@6
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@6:

; 156  : 		}

	ret	8
?construct@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@ABW43@@Z ENDP ; std::allocator<enum VictoryTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@@Z ; std::allocator<enum VictoryTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@@Z PROC ; std::allocator<enum VictoryTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4VictoryTypes@@@std@@QAEXPAW4VictoryTypes@@@Z ENDP ; std::allocator<enum VictoryTypes>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@@Z ; std::allocator<std::pair<short,short> >::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@@Z PROC ; std::allocator<std::pair<short,short> >::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@@Z ENDP ; std::allocator<std::pair<short,short> >::destroy
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ; SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAEXABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAEXABUPlayerInfo@CvReplayInfo@@@Z PROC ; SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ENDP ; SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const >::operator()
_TEXT	ENDS
PUBLIC	?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Make_iter
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Swap_adl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Swap_adl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Swap_adl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z

; 32   : 	}

	ret	0
??$_Swap_adl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Swap_adl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN17@Copy_backw@3
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR [esi-128]
	add	esi, -128				; ffffff80H
	add	edi, -128				; ffffff80H
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], ecx
	mov	edx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [esi+12]
	push	ecx
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	edx, DWORD PTR [esi+44]
	push	edx
	lea	ecx, DWORD PTR [edi+44]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	eax, DWORD PTR [esi+72]
	push	eax
	lea	ecx, DWORD PTR [edi+72]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	lea	ecx, DWORD PTR [edi+100]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@3

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN17@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z ; std::_Construct<CvReplayInfo::PlayerInfo,CvReplayInfo::PlayerInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z$0
__ehfuncinfo$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z
_TEXT	SEGMENT
$T236943 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z PROC ; std::_Construct<CvReplayInfo::PlayerInfo,CvReplayInfo::PlayerInfo>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T236943[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@8
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
$LN3@Construct@8:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T236943[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@UPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@ABU12@@Z ENDP ; std::_Construct<CvReplayInfo::PlayerInfo,CvReplayInfo::PlayerInfo>
PUBLIC	??$unchecked_copy@PAU?$pair@FF@std@@PAU12@@stdext@@YAPAU?$pair@FF@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<short,short> *,std::pair<short,short> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAU?$pair@FF@std@@PAU12@@stdext@@YAPAU?$pair@FF@std@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAU?$pair@FF@std@@PAU12@@stdext@@YAPAU?$pair@FF@std@@PAU12@00@Z PROC ; stdext::unchecked_copy<std::pair<short,short> *,std::pair<short,short> *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAU?$pair@FF@std@@PAU12@@stdext@@YAPAU?$pair@FF@std@@PAU12@00@Z ENDP ; stdext::unchecked_copy<std::pair<short,short> *,std::pair<short,short> *>
_TEXT	ENDS
PUBLIC	??_GPlayerInfo@CvReplayInfo@@QAEPAXI@Z		; CvReplayInfo::PlayerInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GPlayerInfo@CvReplayInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPlayerInfo@CvReplayInfo@@QAEPAXI@Z PROC		; CvReplayInfo::PlayerInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GPlayerInfo@CvReplayInfo@@QAEPAXI@Z ENDP		; CvReplayInfo::PlayerInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@ABU32@@Z ; std::allocator<std::pair<short,short> >::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@ABU32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@ABU32@@Z PROC ; std::allocator<std::pair<short,short> >::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@7
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@7:

; 156  : 		}

	ret	8
?construct@?$allocator@U?$pair@FF@std@@@std@@QAEXPAU?$pair@FF@2@ABU32@@Z ENDP ; std::allocator<std::pair<short,short> >::construct
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >::SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T237008 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >::SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T237008[esp]
	push	edx
	mov	DWORD PTR $T237008[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAE@AAVFDataStream@@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >::SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAE@AAVFDataStream@@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >::SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAE@AAVFDataStream@@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAE@AAVFDataStream@@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >::SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >, COMDAT
; _this$ = ecx

; 125  : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], eax

; 126  : 		size_t count = container.size();

	mov	eax, DWORD PTR [eax+8]

; 127  : 		m_saveTo << count;

	lea	edx, DWORD PTR _count$[esp]
	push	edx
	mov	DWORD PTR _count$[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 128  : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAE@AAVFDataStream@@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >::SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >
_TEXT	ENDS
PUBLIC	??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; operator>><unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z PROC ; operator>><unsigned int,CvReplayInfo::PlotState>, COMDAT

; 53   : {

	push	esi

; 54   : 	loadFrom >> writeTo.first;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 55   : 	loadFrom >> writeTo.second;

	add	edi, 4
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ; operator>>
	add	esp, 8
	pop	edi

; 56   : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 57   : }

	ret	0
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ENDP ; operator>><unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL6@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@3:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??$_Swap_adl@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z ; std::_Swap_adl<std::less<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z PROC ; std::_Swap_adl<std::less<unsigned int> >, COMDAT

; 31   : 	swap(_Left, _Right);
; 32   : 	}

	ret	0
??$_Swap_adl@U?$less@I@std@@@std@@YAXAAU?$less@I@0@0@Z ENDP ; std::_Swap_adl<std::less<unsigned int> >
_TEXT	ENDS
PUBLIC	??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; operator<<<unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z PROC ; operator<<<unsigned int,CvReplayInfo::PlotState>, COMDAT

; 45   : {

	push	esi

; 46   : 	saveTo << readFrom.first;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 47   : 	saveTo << readFrom.second;

	add	edi, 4
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ; operator<<
	add	esp, 8
	pop	edi

; 48   : 	return saveTo;

	mov	eax, esi
	pop	esi

; 49   : }

	ret	0
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ENDP ; operator<<<unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?isEverAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isEverAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isEverAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isEverAlive@CvPlayer@@QBE_NXZ PROC			; CvPlayer::isEverAlive, COMDAT
; _this$ = ecx

; 1097 : 		return m_bEverAlive;

	mov	al, BYTE PTR [ecx+2268]

; 1098 : 	}

	ret	0
?isEverAlive@CvPlayer@@QBE_NXZ ENDP			; CvPlayer::isEverAlive
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 561  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 562  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@lower_boun@2
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@2:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun@2
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@2:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun@2
$LN30@lower_boun@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 153391689				; 09249249H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 71582788				; 04444444H
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	ecx, edi
	shl	ecx, 4
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)

	mov	esi, DWORD PTR __Capacity$[esp]
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	cmp	esi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 33554431				; 01ffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	esi
	call	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 7
	add	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)

	mov	esi, DWORD PTR __Capacity$[esp]
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	cmp	esi, eax
	jne	SHORT $LN4@Buy@6
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
$LN16@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	esi
	call	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 4
	add	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@6:
?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@7
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
$LN16@Buy@7:
$LN2@Buy@7:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@7:
?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@8
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
$LN16@Buy@8:
$LN2@Buy@8:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@8:
?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN32@lower_boun@3
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@3:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun@3
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@3
$LN4@lower_boun@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@3:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun@3
$LN32@lower_boun@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN32@lower_boun@4
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@4:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun@4
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@4
$LN4@lower_boun@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@4:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL6@lower_boun@4
$LN32@lower_boun@4:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN30@lower_boun@5
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@5:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun@5
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@5
$LN4@lower_boun@5:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@5:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL6@lower_boun@5
$LN30@lower_boun@5:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T237990 = -80						; size = 28
$T237989 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T237990[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T237989[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T237990[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T237989[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T237989[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T237989[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T237989[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase:
$LN40@erase:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+21], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN288@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase
	mov	eax, esi
	jmp	SHORT $LN44@erase
$LN43@erase:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
	add	esp, 4
$LN44@erase:
	mov	DWORD PTR [ebx], eax
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN173@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	6
$LL18@erase:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+20], bl
	je	SHORT $LN292@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN4@erase
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase
$LN292@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+20], 0
$LN291@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T237990[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T237989[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Make_iter
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::begin
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@9
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
$LN16@Buy@9:
$LN2@Buy@9:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@9:
?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Make_iter
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum VictoryTypes,std::allocator<enum VictoryTypes> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	shl	edx, 7
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	shl	edx, 4
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::operator+
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode
	mov	DWORD PTR [eax], 0
$LN27@Buynode:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode
	mov	DWORD PTR [ecx], 0
$LN37@Buynode:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode
	mov	DWORD PTR [ecx], 0
$LN47@Buynode:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+21], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0
$LN4@Buynode@2:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T238852 = -80						; size = 28
$T238851 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase@2

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T238852[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238851[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238852[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T238851[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T238851[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T238851[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T238851[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase@2:
$LN40@erase@2:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase@2

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase@2
$LN39@erase@2:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+21], 0
	je	SHORT $LN37@erase@2

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase@2
$LN37@erase@2:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase@2
$LN288@erase@2:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase@2

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@2:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase@2

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@2
$LN33@erase@2:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase@2

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@2
$LN31@erase@2:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@2:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase@2

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase@2
	mov	eax, esi
	jmp	SHORT $LN44@erase@2
$LN43@erase@2:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
	add	esp, 4
$LN44@erase@2:
	mov	DWORD PTR [ebx], eax
$LN29@erase@2:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase@2

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase@2
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@2
$LN45@erase@2:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@2
$LN35@erase@2:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase@2

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@2
$LN26@erase@2:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@2

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@2:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@2:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase@2

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@2
$LN23@erase@2:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase@2

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@2
$LN21@erase@2:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN173@erase@2
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@2:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase@2
	npad	6
$LL18@erase@2:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase@2

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@2

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN14@erase@2

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase@2:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase@2

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN11@erase@2
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+20], bl
	je	SHORT $LN292@erase@2
$LN11@erase@2:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN9@erase@2

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase@2:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@2
$LN15@erase@2:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN7@erase@2

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase@2:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase@2

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN4@erase@2
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase@2
$LN292@erase@2:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+20], 0
$LN291@erase@2:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@2
$LN4@erase@2:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN2@erase@2

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase@2:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN16@erase@2:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase@2:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase@2

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase@2:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T238852[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T238851[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@3
	mov	DWORD PTR [eax], 0
$LN27@Buynode@3:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@3:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@3:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+21], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@4
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0
$LN4@Buynode@4:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T239464 = -80						; size = 28
$T239463 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+33], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase@3

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T239464[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T239463[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T239464[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T239463[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T239463[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T239463[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T239463[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase@3:
$LN40@erase@3:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LN39@erase@3

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase@3
$LN39@erase@3:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+33], 0
	je	SHORT $LN37@erase@3

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase@3
$LN37@erase@3:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase@3
$LN288@erase@3:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+33], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase@3

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@3:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase@3

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@3
$LN33@erase@3:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase@3

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@3
$LN31@erase@3:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@3:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase@3

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+33], 0
	je	SHORT $LN43@erase@3
	mov	eax, esi
	jmp	SHORT $LN44@erase@3
$LN43@erase@3:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Min
	add	esp, 4
$LN44@erase@3:
	mov	DWORD PTR [ebx], eax
$LN29@erase@3:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase@3

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+33], 0
	je	SHORT $LN45@erase@3
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@3
$LN45@erase@3:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@3
$LN35@erase@3:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase@3

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@3
$LN26@erase@3:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+33], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@3

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@3:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@3:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase@3

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@3
$LN23@erase@3:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase@3

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@3
$LN21@erase@3:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@3:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+32]
	add	eax, 32					; 00000020H
	cmp	eax, ecx
	je	SHORT $LN173@erase@3
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@3:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+32], bl
	jne	$LN19@erase@3

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase@3
	npad	6
$LL18@erase@3:
	cmp	BYTE PTR [edi+32], bl
	jne	$LN16@erase@3

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@3

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN14@erase@3

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+32], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+32], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase@3:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+33], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase@3

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+32], bl
	jne	SHORT $LN11@erase@3
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	je	SHORT $LN292@erase@3
$LN11@erase@3:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+32], bl
	jne	SHORT $LN9@erase@3

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+32], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+32], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase@3:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+32]
	mov	BYTE PTR [eax+32], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+32], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+32], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@3
$LN15@erase@3:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN7@erase@3

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+32], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+32], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase@3:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+33], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase@3

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+32], bl
	jne	SHORT $LN4@erase@3
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN4@erase@3
$LN292@erase@3:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+32], 0
$LN291@erase@3:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@3

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@3
$LN4@erase@3:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+32], bl
	jne	SHORT $LN2@erase@3

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+32], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+32], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase@3:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+32]
	mov	BYTE PTR [eax+32], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+32], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+32], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
$LN16@erase@3:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+32], bl
$LN19@erase@3:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase@3

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase@3:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T239464[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T239463[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@5
	mov	DWORD PTR [eax], 0
$LN27@Buynode@5:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@5:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@5:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+33], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@6
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+28], ecx
	mov	BYTE PTR [eax+32], dl
	mov	BYTE PTR [eax+33], 0
$LN4@Buynode@6:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase@2
$LL3@Erase@2:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase@2
$LN1@Erase@2:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+33], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase@3
$LL3@Erase@3:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+33], 0
	mov	edi, esi
	je	SHORT $LL3@Erase@3
$LN1@Erase@3:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+33], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+32]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+33], 0
	mov	edi, eax
	je	SHORT $LN2@Copy

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy:
$LN28@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
PUBLIC	??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator<<<enum GameOptionTypes>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T240276 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; operator<<<enum GameOptionTypes>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T240276[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T240276[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@2
	npad	2
$LL22@operator@2:
	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameOptionTypes@@@Z ; operator<<
	add	esi, 4
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@2
$LN34@operator@2:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; operator<<<enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator<<<enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T240359 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; operator<<<enum VictoryTypes>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T240359[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T240359[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@3
	npad	2
$LL22@operator@3:
	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z ; operator<<
	add	esi, 4
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@3
$LN34@operator@3:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; operator<<<enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T240442 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T240442[esp+8]
	add	eax, edx
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T240442[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@4
	npad	2
$LL22@operator@4:
	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator<<
	add	esi, 28					; 0000001cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@4
$LN34@operator@4:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum GameOptionTypes *,enum GameOptionTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum GameOptionTypes *,enum GameOptionTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum GameOptionTypes *,enum GameOptionTypes *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum VictoryTypes *,enum VictoryTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum VictoryTypes *,enum VictoryTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@2
	push	esi
$LL12@Unchecked_@2:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@2
	pop	esi
$LN11@Unchecked_@2:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum VictoryTypes *,enum VictoryTypes *>
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >,SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >,SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const > >, COMDAT

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));
; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));
; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	mov	eax, DWORD PTR __First$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN1@for_each@4
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+8]
$LL6@for_each@4:

; 29   : 		_Func(*_ChkFirst);

	mov	edi, DWORD PTR __Func$[esp+8]
	lea	eax, DWORD PTR [esi-8]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CivilizationTypes@@@Z ; operator<<
	lea	ecx, DWORD PTR [esi-4]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4LeaderHeadTypes@@@Z ; operator<<
	push	esi
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerColorTypes@@@Z ; operator<<
	lea	edx, DWORD PTR [esi+4]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4HandicapTypes@@@Z ; operator<<
	add	esp, 32					; 00000020H
	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	lea	ecx, DWORD PTR [esi+36]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	lea	edx, DWORD PTR [esi+64]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	lea	eax, DWORD PTR [esi+92]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	sub	esi, -128				; ffffff80H
	lea	ecx, DWORD PTR [esi-8]
	cmp	ecx, ebx
	jne	SHORT $LL6@for_each@4
	pop	edi
	pop	esi
$LN1@for_each@4:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Func$[esp]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >,SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvReplayMessage> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:

; 234  : 		_Al.destroy(_First);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN18@Copy_opt@5
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@5:

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], ecx
	mov	edx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [esi+12]
	push	ecx
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	edx, DWORD PTR [esi+44]
	push	edx
	lea	ecx, DWORD PTR [edi+44]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	eax, DWORD PTR [esi+72]
	push	eax
	lea	ecx, DWORD PTR [edi+72]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	lea	ecx, DWORD PTR [edi+100]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	sub	esi, -128				; ffffff80H
	sub	edi, -128				; ffffff80H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@5

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN18@Copy_opt@5:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::random_access_iterator_tag>, COMDAT

; 2761 : 	{	// use swap instead of the copy constructor

	push	ebx

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN11@Move_backw@3
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Move_backw@3:

; 2764 : 		_STD _Swap_adl(*--_Dest, *--_Last);

	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Move_backw@3

; 2765 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2766 : 	}

	ret	0
$LN11@Move_backw@3:

; 2765 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2766 : 	}

	ret	0
??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum GameOptionTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum VictoryTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ; std::_Fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z PROC ; std::_Fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	cmp	esi, DWORD PTR __Last$[esp]
	je	SHORT $LN1@Fill@4
	push	ebx
	push	ebp
	push	edi
	mov	edi, DWORD PTR __Val$[esp+12]
	lea	ebx, DWORD PTR [edi+16]
	lea	ebp, DWORD PTR [edi+44]
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	push	ebx
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	push	ebp
	lea	ecx, DWORD PTR [esi+44]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	eax, DWORD PTR [edi+72]
	push	eax
	lea	ecx, DWORD PTR [esi+72]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	eax, DWORD PTR [edi+100]
	push	eax
	lea	ecx, DWORD PTR [esi+100]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	sub	esi, -128				; ffffff80H
	cmp	esi, DWORD PTR __Last$[esp+12]
	jne	SHORT $LL3@Fill@4
	pop	edi
	pop	ebp
	pop	ebx
$LN1@Fill@4:
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ENDP ; std::_Fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240841 = -4						; size = 1
__Cat$240846 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T240841[esp+4], 0
	mov	eax, DWORD PTR $T240841[esp+4]
	mov	ecx, DWORD PTR __Cat$240846[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<short,short> > >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
_TEXT	ENDS
PUBLIC	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z ; std::allocator<CvReplayInfo::PlayerInfo>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z$0
__ehfuncinfo$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z
_TEXT	SEGMENT
$T240981 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$240987 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z PROC ; std::allocator<CvReplayInfo::PlayerInfo>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$240987[esp+12], ecx
	mov	DWORD PTR $T240981[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@8
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
$LN5@construct@8:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z$0:
	mov	eax, DWORD PTR __Vptr$240987[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T240981[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@ABU34@@Z ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::construct
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL14@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@4:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3
	DD	00H
	DD	00H
__ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = -48						; size = 28
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T241080 = 8						; size = 4
__First$ = 8						; size = 4
__Vptr$241086 = 12					; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	ebx, DWORD PTR __Last$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	npad	3
$LL6@Uninit_mov:

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, ebx
	je	SHORT $LN4@Uninit_mov

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	DWORD PTR __Vptr$241086[ebp], esi
	mov	DWORD PTR $T241080[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	test	esi, esi
	je	SHORT $LN19@Uninit_mov
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN19@Uninit_mov:

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	push	edi
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z
	add	esi, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $LL6@Uninit_mov
__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 226  : 		}
; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_mov
$LL3@Uninit_mov:

; 229  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_mov
$LN1@Uninit_mov:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN41@Uninit_mov:
$LN4@Uninit_mov:

; 231  : 	_CATCH_END
; 232  : 	return (_Dest);

	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3:
	mov	eax, DWORD PTR __Vptr$241086[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241080[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy@UPlayerInfo@CvReplayInfo@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@@Z ; std::_Destroy<CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UPlayerInfo@CvReplayInfo@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UPlayerInfo@CvReplayInfo@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@@Z PROC ; std::_Destroy<CvReplayInfo::PlayerInfo>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
??$_Destroy@UPlayerInfo@CvReplayInfo@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::_Destroy<CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z
_TEXT	SEGMENT
$T241137 = -4						; size = 1
__Cat$241142 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241137[esp+4], 0
	mov	eax, DWORD PTR $T241137[esp+4]
	mov	ecx, DWORD PTR __Cat$241142[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z
_TEXT	SEGMENT
$T241146 = -4						; size = 1
__Cat$241151 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241146[esp+4], 0
	mov	eax, DWORD PTR $T241146[esp+4]
	mov	ecx, DWORD PTR __Cat$241151[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z
_TEXT	SEGMENT
$T241155 = -4						; size = 1
__Cat$241159 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241155[esp+4], 0
	mov	eax, DWORD PTR $T241155[esp+4]
	mov	ecx, DWORD PTR __Cat$241159[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??R?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAEXABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAEXABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAEXABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z PROC ; SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >::operator(), COMDAT
; _this$ = ecx

; 131  : 	{

	push	esi

; 132  : 		m_saveTo << i;

	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR _i$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	add	edi, 4
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ; operator<<
	add	esp, 8
	pop	edi
	pop	esi

; 133  : 	}

	ret	4
??R?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@QAEXABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ENDP ; SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const >::operator()
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_count$ = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z PROC ; operator<<, COMDAT

; 715  : {

	push	ebx

; 716  : 	const size_t count = readFrom.size();

	mov	ebx, DWORD PTR _readFrom$[esp]
	mov	eax, DWORD PTR [ebx+8]
	push	esi
	push	edi

; 717  : 	saveTo << count;

	mov	edi, DWORD PTR _saveTo$[esp+8]
	lea	ecx, DWORD PTR _count$[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _count$[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 718  : 	for(CvReplayInfo::TurnData::const_iterator it = readFrom.begin(); it != readFrom.end(); ++it)

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax]
	cmp	esi, eax
	je	SHORT $LN78@operator@5
$LL22@operator@5:

; 719  : 	{
; 720  : 		saveTo << (*it).first;

	lea	edx, DWORD PTR [esi+12]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 721  : 		saveTo << (*it).second;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN77@operator@5
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN74@operator@5
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN77@operator@5

; 718  : 	for(CvReplayInfo::TurnData::const_iterator it = readFrom.begin(); it != readFrom.end(); ++it)

$LL37@operator@5:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL37@operator@5
	jmp	SHORT $LN77@operator@5
$LN74@operator@5:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN20@operator@5
	npad	5
$LL21@operator@5:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN20@operator@5
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL21@operator@5
$LN20@operator@5:
	mov	esi, eax
$LN77@operator@5:
	cmp	esi, DWORD PTR [ebx+4]
	jne	SHORT $LL22@operator@5
$LN78@operator@5:

; 722  : 	}
; 723  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 724  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
$T241372 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jae	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T241372[esp+8], eax
	lea	eax, DWORD PTR $T241372[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::vector<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::vector<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::vector<CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 475  : 			++(*(const_iterator *)this);

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 476  : 			return (*this);

	mov	eax, esi
	pop	esi

; 477  : 			}

	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find
; Function compile flags: /Ogtpy
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
$T242235 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find@2
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find@2:
	cmp	DWORD PTR [eax+12], esi
	jae	SHORT $LN8@find@2
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find@2
$LN8@find@2:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find@2:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@find@2
	pop	esi
$LN9@find@2:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find@2
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN3@find@2
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find@2:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T242235[esp+8], eax
	lea	eax, DWORD PTR $T242235[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+21], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy@2

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+20]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+21], 0
	mov	edi, eax
	je	SHORT $LN2@Copy@2

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy@2:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy@2:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy@2:
$LN28@Copy@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
$T242493 = -80						; size = 28
$T242492 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 536870910		; 1ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T242493[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T242492[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T242493[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T242492[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T242492[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T242492[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T242492[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+20], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+20], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$0:
	lea	ecx, DWORD PTR $T242493[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$2:
	lea	ecx, DWORD PTR $T242492[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T242924 = -80						; size = 28
$T242923 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 536870910		; 1ffffffeH
	jb	SHORT $LN17@Insert@2

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T242924[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T242923[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T242924[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T242923[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T242923[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T242923[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T242923[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert@2:
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@2
$LN14@Insert@2:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@2

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+20], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert@2
	npad	5
$LL10@Insert@2:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN7@Insert@2

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert@2
$LN7@Insert@2:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN5@Insert@2:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert@2
$LN8@Insert@2:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN3@Insert@2

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert@2
$LN3@Insert@2:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN1@Insert@2:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN170@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN170@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert@2
$LN169@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert@2
$LN167@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert@2:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert@2
$LN9@Insert@2:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+20], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T242924[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$2:
	lea	ecx, DWORD PTR $T242923[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
$T243355 = -80						; size = 28
$T243354 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 214748363		; 0ccccccbH
	jb	SHORT $LN17@Insert@3

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T243355[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T243354[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T243355[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T243354[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T243354[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T243354[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T243354[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert@3:
$LN17@Insert@3:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert@3

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert@3
$LN16@Insert@3:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert@3

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@3

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@3
$LN14@Insert@3:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@3

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert@3:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+32], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert@3
	npad	5
$LL10@Insert@3:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert@3

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN7@Insert@3

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert@3
$LN7@Insert@3:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert@3

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate
$LN5@Insert@3:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert@3
$LN8@Insert@3:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN3@Insert@3

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert@3
$LN3@Insert@3:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@3

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
$LN1@Insert@3:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN170@Insert@3
	mov	DWORD PTR [edx+4], eax
$LN170@Insert@3:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert@3
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert@3
$LN169@Insert@3:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert@3
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert@3
$LN167@Insert@3:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert@3:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert@3:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert@3
$LN9@Insert@3:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+32], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z$0:
	lea	ecx, DWORD PTR $T243355[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z$2:
	lea	ecx, DWORD PTR $T243354[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN2@Copy@3

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN25@Copy@3
$LL26@Copy@3:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL26@Copy@3
$LN25@Copy@3:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN43@Copy@3
$LL44@Copy@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL44@Copy@3
$LN43@Copy@3:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@3:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; operator<<<CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
$T244120 = -8						; size = 8
$T244132 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; operator<<<CvReplayInfo::PlayerInfo>, COMDAT

; 198  : {

	sub	esp, 8
	push	esi

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	esi, DWORD PTR _readFrom$[esp+8]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+12]
	lea	ecx, DWORD PTR $T244132[esp+12]
	sar	eax, 7
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T244132[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T244120[esp+32]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >,SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const > >
	add	esp, 20					; 00000014H

; 200  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi

; 201  : }

	add	esp, 8
	ret	0
??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; operator<<<CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@@Z ; std::_Destroy_range<std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvReplayMessage> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@0AAV?$allocator@VCvReplayMessage@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@std@@@Z
_TEXT	SEGMENT
$T244188 = -4						; size = 1
__Cat$244193 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244188[esp+4], 0
	mov	eax, DWORD PTR $T244188[esp+4]
	mov	ecx, DWORD PTR __Cat$244193[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@std@@@Z
_TEXT	SEGMENT
$T244197 = -4						; size = 1
__Cat$244202 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244197[esp+4], 0
	mov	eax, DWORD PTR $T244197[esp+4]
	mov	ecx, DWORD PTR __Cat$244202[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z ; stdext::unchecked_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z
_TEXT	SEGMENT
$T244206 = -4						; size = 1
__Cat$244212 = -4					; size = 1
$T244208 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z PROC ; stdext::unchecked_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T244206[esp+4], 0
	mov	eax, DWORD PTR $T244206[esp+4]
	mov	ecx, DWORD PTR __Cat$244212[esp+4]
	mov	edx, DWORD PTR $T244208[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z ENDP ; stdext::unchecked_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN17@Unchecked_@3
$LL8@Unchecked_@3:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z
	cmp	esi, ebx
	jne	SHORT $LL8@Unchecked_@3
$LN17@Unchecked_@3:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum GameOptionTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@0AAV?$allocator@W4GameOptionTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum VictoryTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@0AAV?$allocator@W4VictoryTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ; std::fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z PROC ; std::fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ; std::_Fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
??$fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ENDP ; std::fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z ; stdext::_Unchecked_move_backward<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z
_TEXT	SEGMENT
$T244299 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244303 = 16					; size = 1
$T244281 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z PROC ; stdext::_Unchecked_move_backward<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244303[esp]
	mov	edx, DWORD PTR $T244281[esp]
	mov	BYTE PTR $T244299[esp+4], 0
	mov	eax, DWORD PTR $T244299[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<short,short> > >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U?$pair@FF@std@@@std@@@std@@YAXPAU?$pair@FF@0@0AAV?$allocator@U?$pair@FF@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@FF@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@FF@std@@@2@@Z
_TEXT	SEGMENT
$T244319 = -4						; size = 1
__Cat$244324 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@FF@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244319[esp+4], 0
	mov	eax, DWORD PTR $T244319[esp+4]
	mov	ecx, DWORD PTR __Cat$244324[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@FF@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244355 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$244361 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@3:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$244361[ebp], esi
	mov	DWORD PTR $T244355[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@3
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_fil@3:
	dec	edi
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@3
$LL3@Uninit_fil@3:

; 407  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_fil@3:
$LN4@Uninit_fil@3:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_fil@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$244361[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244355[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@3
	npad	2
$LL3@Destroy_ra@3:

; 234  : 		_Al.destroy(_First);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@3
$LN1@Destroy_ra@3:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T244419 = -4						; size = 1
__Cat$244424 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244419[esp+4], 0
	mov	eax, DWORD PTR $T244419[esp+4]
	mov	ecx, DWORD PTR __Cat$244424[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@@Z ; std::allocator<CvReplayInfo::PlayerInfo>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@@Z PROC ; std::allocator<CvReplayInfo::PlayerInfo>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@UPlayerInfo@CvReplayInfo@@@std@@QAEXPAUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::allocator<CvReplayInfo::PlayerInfo>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244450 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244453 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$244453[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244450[esp+4], 0
	mov	eax, DWORD PTR $T244450[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244469 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244472 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$244472[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244469[esp+4], 0
	mov	eax, DWORD PTR $T244469[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU?$pair@FF@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@PAU21@00@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::pair<short,short> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAU?$pair@FF@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@PAU21@00@Z
_TEXT	SEGMENT
$T244488 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244491 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU?$pair@FF@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@PAU21@00@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::pair<short,short> *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$244491[esp]
	mov	BYTE PTR $T244488[esp+4], 0
	mov	eax, DWORD PTR $T244488[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAU?$pair@FF@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@PAU21@00@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::pair<short,short> *>
_TEXT	ENDS
PUBLIC	??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z
_TEXT	SEGMENT
$T244697 = -22						; size = 1
$T244696 = -22						; size = 1
$T244695 = -22						; size = 1
_uiRiverData$244693 = -21				; size = 1
$T244498 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >, COMDAT

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));
; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First$[esp+28]
	mov	ebx, eax

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, eax
	je	$LN1@for_each@5
	push	edi
	npad	8
$LL10@for_each@5:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR $T244498[esp+40], ecx
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR $T244498[esp+44], edx
	mov	DWORD PTR $T244498[esp+36], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR $T244498[esp+52], ecx
	mov	ecx, DWORD PTR __Func$[esp+32]
	lea	edx, DWORD PTR $T244498[esp+36]
	push	edx
	mov	DWORD PTR $T244498[esp+52], eax
	mov	edi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	al, BYTE PTR $T244498[esp+40]
	lea	ecx, DWORD PTR $T244695[esp+36]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR $T244695[esp+40], al
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write
	mov	dl, BYTE PTR $T244498[esp+44]
	lea	eax, DWORD PTR $T244696[esp+36]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR $T244696[esp+40], dl
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write
	mov	cl, BYTE PTR $T244498[esp+48]
	lea	edx, DWORD PTR $T244697[esp+36]
	mov	BYTE PTR $T244697[esp+36], cl
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write
	mov	eax, DWORD PTR $T244498[esp+52]
	mov	cl, al
	add	cl, cl
	or	cl, ah
	add	cl, cl
	or	cl, BYTE PTR $T244498[esp+54]
	lea	edx, DWORD PTR _uiRiverData$244693[esp+36]
	add	cl, cl
	mov	BYTE PTR _uiRiverData$244693[esp+36], cl
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN71@for_each@5
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN68@for_each@5
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN71@for_each@5
	npad	6

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

$LL25@for_each@5:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL25@for_each@5
	jmp	SHORT $LN71@for_each@5
$LN68@for_each@5:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN8@for_each@5
$LL9@for_each@5:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN8@for_each@5
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL9@for_each@5
$LN8@for_each@5:
	mov	esi, eax
$LN71@for_each@5:
	cmp	esi, ebx
	jne	$LL10@for_each@5
	pop	edi
$LN1@for_each@5:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ecx, DWORD PTR __Func$[esp+28]
	mov	edx, DWORD PTR __Func$[esp+32]
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	ebx

; 31   : 	}

	add	esp, 24					; 00000018H
	ret	0
??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const >::operator()
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244741 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$244749 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@5:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$244749[ebp], esi
	mov	DWORD PTR $T244741[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@5
	push	edi
	mov	ecx, esi
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
$LN18@Uninit_cop@5:
	sub	esi, -128				; ffffff80H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	sub	edi, -128				; ffffff80H
	jmp	SHORT $LL6@Uninit_cop@5
__catch$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@5
$LL3@Uninit_cop@5:

; 134  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_cop@5:
$LN4@Uninit_cop@5:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_cop@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$244749[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244741[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
PUBLIC	?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z ; CvReplayInfo::getPlayerDataSetValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z
_TEXT	SEGMENT
_it$221132 = 8						; size = 4
_uiPlayer$ = 8						; size = 4
_uiDataSet$ = 12					; size = 4
_uiAdjustedTurn$ = 16					; size = 4
_iTurn$ = 16						; size = 4
_outValue$ = 20						; size = 4
?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z PROC	; CvReplayInfo::getPlayerDataSetValue, COMDAT
; _this$ = ecx

; 480  : 	const unsigned int uiAdjustedTurn = iTurn - m_iInitialTurn;
; 481  : 	if(uiPlayer < m_listPlayerInfo.size() && uiDataSet < m_dataSetMap.size())

	mov	edx, DWORD PTR [ecx+152]
	sub	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR _iTurn$[esp-4]
	sub	eax, DWORD PTR [ecx+96]
	push	esi
	push	edi
	mov	edi, DWORD PTR _uiPlayer$[esp+4]
	sar	edx, 7
	mov	DWORD PTR _uiAdjustedTurn$[esp+4], eax
	cmp	edi, edx
	jae	SHORT $LN1@getPlayerD@3
	mov	esi, DWORD PTR [ecx+184]
	sub	esi, DWORD PTR [ecx+180]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	mov	eax, DWORD PTR _uiDataSet$[esp+4]
	add	edx, esi
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	cmp	eax, esi
	jae	SHORT $LN1@getPlayerD@3

; 482  : 	{
; 483  : 		const TurnData& data = m_listPlayerDataSets[uiPlayer][uiDataSet];

	mov	ecx, DWORD PTR [ecx+196]
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edi, 4
	mov	eax, DWORD PTR [ecx+edi+4]
	lea	esi, DWORD PTR [eax+edx*4]

; 484  : 		TurnData::const_iterator it = data.find(uiAdjustedTurn);

	lea	ecx, DWORD PTR _uiAdjustedTurn$[esp+4]
	push	ecx
	lea	edx, DWORD PTR _it$221132[esp+8]
	push	edx
	mov	ecx, esi
	call	?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find

; 485  : 		if(it != data.end())

	mov	eax, DWORD PTR _it$221132[esp+4]
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN1@getPlayerD@3

; 486  : 		{
; 487  : 			outValue = (*it).second;

	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _outValue$[esp+4]
	pop	edi
	mov	DWORD PTR [ecx], eax

; 488  : 			return true;

	mov	al, 1
	pop	esi

; 493  : }

	ret	16					; 00000010H
$LN1@getPlayerD@3:
	pop	edi

; 489  : 		}
; 490  : 	}
; 491  : 
; 492  : 	return false;

	xor	al, al
	pop	esi

; 493  : }

	ret	16					; 00000010H
?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z ENDP	; CvReplayInfo::getPlayerDataSetValue
_TEXT	ENDS
PUBLIC	?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z ; CvReplayInfo::getPlotState
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_match$221229 = 12					; size = 4
_y$ = 12						; size = 4
_uiTurn$ = 16						; size = 4
_plotState$ = 20					; size = 4
?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z PROC ; CvReplayInfo::getPlotState, COMDAT
; _this$ = ecx

; 512  : 	size_t idx = x + y * m_iMapWidth;
; 513  : 	if(idx < m_listPlots.size())

	mov	edx, DWORD PTR [ecx+224]
	sub	edx, DWORD PTR [ecx+220]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	push	esi
	mov	esi, DWORD PTR [ecx+212]
	imul	esi, DWORD PTR _y$[esp]
	add	esi, DWORD PTR _x$[esp]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jae	SHORT $LN1@getPlotSta

; 514  : 	{
; 515  : 		const PlotStatePerTurn& plotStatePerTurn = m_listPlots[idx];

	mov	eax, DWORD PTR [ecx+220]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	esi, DWORD PTR [eax+edx*4]

; 516  : 		PlotStatePerTurn::const_iterator match = plotStatePerTurn.find(uiTurn);

	lea	ecx, DWORD PTR _uiTurn$[esp]
	push	ecx
	lea	edx, DWORD PTR _match$221229[esp+4]
	push	edx
	mov	ecx, esi
	call	?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find

; 517  : 		if(match != plotStatePerTurn.end())

	mov	eax, DWORD PTR _match$221229[esp]
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN1@getPlotSta

; 518  : 		{
; 519  : 			plotState = (*match).second;

	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _plotState$[esp]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+12], eax

; 520  : 			return true;

	mov	al, 1
	pop	esi

; 525  : }

	ret	16					; 00000010H
$LN1@getPlotSta:

; 521  : 		}
; 522  : 	}
; 523  : 
; 524  : 	return false;

	xor	al, al
	pop	esi

; 525  : }

	ret	16					; 00000010H
?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z ENDP ; CvReplayInfo::getPlotState
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T244877 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@4
	cmp	edx, eax
	jne	SHORT $LN101@erase@4

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@4:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@4
	npad	2
$LL2@erase@4:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+21], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@4
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN103@erase@4
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN79@erase@4
	npad	5
$LL80@erase@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL80@erase@4
$LN79@erase@4:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@4
$LN103@erase@4:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN63@erase@4
	npad	7
$LL64@erase@4:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@4
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL64@erase@4
$LN63@erase@4:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@4:
	push	edx
	lea	eax, DWORD PTR $T244877[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@4
$LN1@erase@4:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN2@Copy@4

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN25@Copy@4
$LL26@Copy@4:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL26@Copy@4
$LN25@Copy@4:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN43@Copy@4
$LL44@Copy@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL44@Copy@4
$LN43@Copy@4:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@4:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T245332 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T245332[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy
	npad	2
$LL9@Destroy:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy
$LN7@Destroy:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN19@Tidy
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy
$LL12@Tidy:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL12@Tidy
$LN10@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN19@Tidy:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW43@IABW43@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T245524 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$245527 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$245527[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T245524[esp+12], 0
	mov	eax, DWORD PTR $T245524[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW43@IABW43@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T245542 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$245545 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$245545[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T245542[esp+12], 0
	mov	eax, DWORD PTR $T245542[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T245560 = 12						; size = 4
$T245558 = 12						; size = 4
__Where$224598 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$224598[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T245558[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$224598[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T245560[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXPAW4GameOptionTypes@@0@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXPAW4GameOptionTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXPAW4GameOptionTypes@@0@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXPAW4GameOptionTypes@@0@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXPAW4VictoryTypes@@0@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXPAW4VictoryTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXPAW4VictoryTypes@@0@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXPAW4VictoryTypes@@0@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXPAU?$pair@FF@2@0@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXPAU?$pair@FF@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXPAU?$pair@FF@2@0@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXPAU?$pair@FF@2@0@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Destroy
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T245790 = 12						; size = 4
$T245788 = 12						; size = 4
__Where$225361 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@2
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@2:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setl	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@2
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@2
$LN13@insert@2:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@2:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@insert@2
$LN9@insert@2:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$225361[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@2

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T245788[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@2
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@2:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$225361[esp+12]
$LN57@insert@2:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jge	SHORT $LN2@insert@2

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T245790[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@2:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T245922 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@5
	cmp	edx, eax
	jne	SHORT $LN101@erase@5

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@5:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@5
	npad	2
$LL2@erase@5:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+21], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@5
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN103@erase@5
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN79@erase@5
	npad	5
$LL80@erase@5:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL80@erase@5
$LN79@erase@5:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@5
$LN103@erase@5:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN63@erase@5
	npad	7
$LL64@erase@5:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@5
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL64@erase@5
$LN63@erase@5:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@5:
	push	edx
	lea	eax, DWORD PTR $T245922[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@5
$LN1@erase@5:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T246333 = 12						; size = 4
$T246331 = 12						; size = 4
__Where$225489 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@3
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@3:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@3
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@3
$LN13@insert@3:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@3:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@insert@3
$LN9@insert@3:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$225489[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@3

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T246331[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@3
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@3:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$225489[esp+12]
$LN57@insert@3:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert@3

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T246333[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@3:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T246465 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@6
	cmp	edx, eax
	jne	SHORT $LN101@erase@6

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@6:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@6
	npad	2
$LL2@erase@6:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+33], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@6
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN103@erase@6
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN79@erase@6
	npad	5
$LL80@erase@6:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL80@erase@6
$LN79@erase@6:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@6
$LN103@erase@6:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN63@erase@6
	npad	7
$LL64@erase@6:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@6
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL64@erase@6
$LN63@erase@6:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@6:
	push	edx
	lea	eax, DWORD PTR $T246465[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@6
$LN1@erase@6:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree:
$LN56@Tree:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@1@0PAU21@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@1@0PAU21@@Z
_TEXT	SEGMENT
$T247063 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247067 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@1@0PAU21@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$247067[esp]
	mov	BYTE PTR $T247063[esp+4], 0
	mov	eax, DWORD PTR $T247063[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@1@0PAU21@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T247074 = -4						; size = 1
__Cat$247079 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247074[esp+4], 0
	mov	eax, DWORD PTR $T247074[esp+4]
	mov	ecx, DWORD PTR __Cat$247079[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@4
	npad	2
$LL7@Destroy_ra@4:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@4
$LN5@Destroy_ra@4:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
$T247134 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247138 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$247138[esp]
	mov	BYTE PTR $T247134[esp+4], 0
	mov	eax, DWORD PTR $T247134[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T247171 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$247177 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@4:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$247177[ebp], esi
	mov	DWORD PTR $T247171[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@4
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
$LN18@Uninit_fil@4:
	dec	edi
	sub	esi, -128				; ffffff80H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@4
$LL3@Uninit_fil@4:

; 407  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_fil@4:
$LN4@Uninit_fil@4:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_fil@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$247177[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247171[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
PUBLIC	??$_Unchecked_uninitialized_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z
_TEXT	SEGMENT
$T247238 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247242 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$247242[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247238[esp+4], 0
	mov	eax, DWORD PTR $T247238[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z
_TEXT	SEGMENT
$T247275 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247279 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$247279[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247275[esp+4], 0
	mov	eax, DWORD PTR $T247275[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@5
	npad	2
$LL3@Destroy_ra@5:

; 234  : 		_Al.destroy(_First);

	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@5
$LN1@Destroy_ra@5:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T247313 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	esi
	push	edi

; 545  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN20@operator@6

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T247313[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
$LN20@operator@6:
	pop	edi

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, esi
	pop	esi

; 552  : 		}

	ret	4
??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@7
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@7
	push	ebx
	npad	4
$LL28@erase@7:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@7
	pop	ebx
$LN26@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@7:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase
_TEXT	ENDS
PUBLIC	??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; operator<<<unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
$T247451 = -8						; size = 8
_count$247462 = 8					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; operator<<<unsigned int,CvReplayInfo::PlotState>, COMDAT

; 156  : {

	sub	esp, 8
	push	esi

; 157  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromAssociativeContainer<std::pair<KeyType, ElementType>, const std::map<KeyType, ElementType> >(saveTo, readFrom));

	mov	esi, DWORD PTR _saveTo$[esp+8]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+12]
	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR _count$247462[esp+12]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _count$247462[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T247451[esp+32]
	push	edx
	call	??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
	add	esp, 20					; 00000014H
	pop	edi

; 158  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 159  : }

	add	esp, 8
	ret	0
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; operator<<<unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
$T247503 = -48						; size = 8
_e$230646 = -40						; size = 20
$T247502 = -20						; size = 20
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 141  : {

	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi

; 142  : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+56]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]

; 143  : 	size_t count = 0;
; 144  : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+60]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	xor	ebp, ebp
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR _count$[esp+60]
	mov	DWORD PTR [eax+8], eax
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+64], ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 145  : 	size_t i = 0;
; 146  : 	for(i = 0; i < count; ++i)

	xor	edi, edi
	cmp	DWORD PTR _count$[esp+60], ebp
	jbe	SHORT $LN1@SerializeT
	npad	5
$LL3@SerializeT:

; 147  : 	{
; 148  : 		ElementType e;

	xor	eax, eax
	mov	DWORD PTR _e$230646[esp+68], eax
	mov	DWORD PTR _e$230646[esp+72], eax
	mov	DWORD PTR _e$230646[esp+76], eax
	mov	DWORD PTR _e$230646[esp+80], eax

; 149  : 		loadFrom >> e;

	lea	eax, DWORD PTR _e$230646[esp+64]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _e$230646[esp+68], ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _e$230646[esp+68]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ; operator>>

; 150  : 		container.insert(e);

	mov	edx, DWORD PTR _e$230646[esp+72]
	mov	ecx, DWORD PTR _e$230646[esp+80]
	mov	eax, DWORD PTR _e$230646[esp+76]
	mov	DWORD PTR $T247502[esp+72], edx
	mov	edx, DWORD PTR _e$230646[esp+84]
	mov	DWORD PTR $T247502[esp+80], ecx
	add	esp, 8
	lea	ecx, DWORD PTR $T247502[esp+64]
	mov	DWORD PTR $T247502[esp+76], edx
	push	ecx
	mov	DWORD PTR $T247502[esp+72], eax
	mov	eax, DWORD PTR _e$230646[esp+84]
	lea	edx, DWORD PTR $T247503[esp+68]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T247502[esp+88], eax
	call	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
	inc	edi
	cmp	edi, DWORD PTR _count$[esp+60]
	jb	SHORT $LL3@SerializeT
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 151  : 	}
; 152  : }

	add	esp, 48					; 00000030H
	ret	0
??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
$T247580 = -4						; size = 1
__Cat$247584 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247580[esp+4], 0
	mov	eax, DWORD PTR $T247580[esp+4]
	mov	ecx, DWORD PTR __Cat$247584[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each@6
	npad	2
$LL6@for_each@6:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator<<
	add	esi, 12					; 0000000cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each@6
$LN1@for_each@6:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > const ,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const > >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T247683 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T247683[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T247715 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	esi
	push	edi

; 545  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN20@operator@7

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T247715[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN20@operator@7:
	pop	edi

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, esi
	pop	esi

; 552  : 		}

	ret	4
??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
$T247939 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@4

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@4:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@4
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jae	$LN1@insert@4

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@4:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@4

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jae	$LN1@insert@4

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@4:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN305@insert@4
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jae	SHORT $LN8@insert@4

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@4
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@4:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@4:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@4:
	jae	SHORT $LN1@insert@4
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@4
	cmp	ebp, DWORD PTR [eax+12]
	jae	SHORT $LN1@insert@4
$LN3@insert@4:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+21], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@4
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@4:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@4:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T247939[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T248470 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$248473 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$248473[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T248470[esp+12], 0
	mov	eax, DWORD PTR $T248470[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@8
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@8
	push	ebx
	npad	4
$LL28@erase@8:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@8
	pop	ebx
$LN26@erase@8:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@8:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@9
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@9
	push	ebx
	npad	4
$LL28@erase@9:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@9
	pop	ebx
$LN26@erase@9:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@9:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T248843 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@5

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@5:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@5
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jge	$LN1@insert@5

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@5:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@5

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jge	$LN1@insert@5

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@5:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jle	SHORT $LN305@insert@5
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jge	SHORT $LN8@insert@5

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@5
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@5:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@5:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@5:
	jge	SHORT $LN1@insert@5
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@5
	cmp	ebp, DWORD PTR [eax+12]
	jge	SHORT $LN1@insert@5
$LN3@insert@5:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+21], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@5
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@5:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@5:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T248843[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T249369 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T249369[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
$T249602 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@6

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@6:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@6
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jae	$LN1@insert@6

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@6:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@6

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jae	$LN1@insert@6

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@6:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN305@insert@6
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jae	SHORT $LN8@insert@6

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@6
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@6:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@6:
	jae	SHORT $LN1@insert@6
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@6
	cmp	ebp, DWORD PTR [eax+12]
	jae	SHORT $LN1@insert@6
$LN3@insert@6:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+33], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@6
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@6:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T249602[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T250128 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T250128[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy@2
	npad	2
$LL9@Destroy@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@2
$LN7@Destroy@2:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$6
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$7
__unwindtable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Tmp$224788 = -92					; size = 28
__Tmp$224778 = -64					; size = 28
__Whereoff$224764 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$224765 = -28					; size = 4
__Newvec$224763 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$250370 = 8					; size = 1
__Cat$250344 = 8					; size = 1
__Where$ = 8						; size = 4
tv461 = 12						; size = 4
__Count$ = 12						; size = 4
$T250366 = 16						; size = 1
$T250340 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n
$LN31@Insert_n:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 153391689				; 09249249H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$LN79@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 153391689				; 09249249H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	add	esp, 8
	mov	DWORD PTR __Ncopied$224765[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	lea	eax, DWORD PTR [ebx*8]
	mov	DWORD PTR __Newvec$224763[ebp], ecx
	sub	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$224764[ebp], ebx
	call	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$250344[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T250340[ebp], 0
	mov	edx, DWORD PTR $T250340[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$224763[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224765[ebp], 1
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$224763[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T250366[ebp], 0
	mov	edx, DWORD PTR $T250366[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$250370[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$224765[ebp], 2
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN71@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN71@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Newvec$224763[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$224765[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$224764[ebp]
	mov	edi, DWORD PTR __Newvec$224763[ebp]
	jle	SHORT $LN7@Insert_n
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edx, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN80@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224778[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224778[ebp]
	push	edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224778[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$224778[ebp]

; 1233 : 		else

	jmp	$LN78@Insert_n
__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN81@Insert_n:
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224788[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv461[ebp], eax
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv461[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224788[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$224788[ebp]
$LN78@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN77@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224778[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224788[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
PUBLIC	??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree@2:
$LN56@Tree@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
$T250594 = -4						; size = 1
__Cat$250598 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T250594[esp+4], 0
	mov	eax, DWORD PTR $T250594[esp+4]
	mov	ecx, DWORD PTR __Cat$250598[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4GameOptionTypes@@@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW42@00@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Umove<enum GameOptionTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAW4GameOptionTypes@@@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T250647 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$250650 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4GameOptionTypes@@@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW42@00@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Umove<enum GameOptionTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$250650[esp]
	mov	BYTE PTR $T250647[esp+4], 0
	mov	eax, DWORD PTR $T250647[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4GameOptionTypes@@@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW42@00@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Umove<enum GameOptionTypes *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4VictoryTypes@@@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW42@00@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Umove<enum VictoryTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4VictoryTypes@@@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T250702 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$250705 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4VictoryTypes@@@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW42@00@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Umove<enum VictoryTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$250705[esp]
	mov	BYTE PTR $T250702[esp+4], 0
	mov	eax, DWORD PTR $T250702[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4VictoryTypes@@@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW42@00@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Umove<enum VictoryTypes *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@6
	npad	2
$LL7@Destroy_ra@6:
	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@6
$LN5@Destroy_ra@6:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??4?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T250814 = 8						; size = 4
___that$ = 8						; size = 4
??4?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator=, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN22@operator@8
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T250814[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
$LN22@operator@8:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??4?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator=
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
$T250899 = -8						; size = 8
_count$250901 = 8					; size = 4
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >::operator(), COMDAT
; _this$ = ecx

; 74   : 	{

	sub	esp, 8
	push	esi

; 75   : 		m_saveTo << i;

	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR _i$[esp+12]
	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR _count$250901[esp+12]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _count$250901[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T250899[esp+32]
	push	edx
	call	??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 76   : 	}

	add	esp, 8
	ret	4
??R?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const >::operator()
_TEXT	ENDS
PUBLIC	?clear@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear
	push	edi
$LL42@clear:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear
	pop	edi
$LN40@clear:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::clear
_TEXT	ENDS
PUBLIC	??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; operator>><unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; operator>><unsigned int,CvReplayInfo::PlotState>, COMDAT

; 238  : 	SerializeToAssociativeContainer<std::pair<KeyType, ElementType>, std::map<KeyType, ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8

; 239  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 240  : }

	ret	0
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; operator>><unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251087 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$251091 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$251091[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T251087[esp+4], 0
	mov	eax, DWORD PTR $T251087[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z ; std::_Construct<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z
_TEXT	SEGMENT
$T251099 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z PROC ; std::_Construct<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T251099[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@9
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
$LN3@Construct@9:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T251099[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@ABV10@@Z ENDP ; std::_Construct<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
PUBLIC	??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T251134 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T251134[esp+8]
	add	eax, edx
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T251134[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@9
	npad	5
$LL22@operator@9:
	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator<<
	add	esi, 12					; 0000000cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@9
$LN34@operator@9:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 1034 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp+16]
	push	edi
	cmp	ecx, esi
	je	SHORT $LN23@swap@6

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())
; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	je	SHORT $LN20@swap@6
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN20@swap@6:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	lea	eax, DWORD PTR [esi+8]
	add	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN23@swap@6
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN23@swap@6:

; 1048 : 			}
; 1049 : 		else
; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);
; 1052 : 
; 1053 : 			_Myt _Tmp = *this;
; 1054 : 
; 1055 : 			*this = _Right;
; 1056 : 			_Right = _Tmp;
; 1057 : 			}
; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap
PUBLIC	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T251639 = -4						; size = 4
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T251639[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T251725 = 8						; size = 4
___that$ = 8						; size = 4
??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN22@operator@10
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T251725[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN22@operator@10:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=
_TEXT	ENDS
PUBLIC	??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z
_TEXT	SEGMENT
$T251967 = -8						; size = 8
$T251970 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	esp, 8
	cmp	BYTE PTR [eax+21], 0
	push	esi
	mov	esi, DWORD PTR __Keyval$[esp+8]
	jne	SHORT $LN9@operator@11
	push	edi
	mov	edi, DWORD PTR [esi]
$LL10@operator@11:
	cmp	DWORD PTR [eax+12], edi
	jae	SHORT $LN8@operator@11
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@operator@11
$LN8@operator@11:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@operator@11:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@operator@11
	pop	edi
$LN9@operator@11:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@operator@11
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+12]
	jae	SHORT $LN62@operator@11
$LN1@operator@11:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T251967[esp+12], eax
	lea	eax, DWORD PTR $T251967[esp+12]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T251970[esp+16]
	push	edx
	mov	DWORD PTR $T251967[esp+28], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 174  : 		return ((*_Where).second);

	add	eax, 16					; 00000010H
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
$LN62@operator@11:

; 174  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [edx+16]
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear@2
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear@2
	push	edi
$LL42@clear@2:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear@2
	pop	edi
$LN40@clear@2:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear@2:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear@3
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear@3
	push	edi
$LL42@clear@3:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear@3
	pop	edi
$LN40@clear@3:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear@3:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::clear
_TEXT	ENDS
PUBLIC	??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T252595 = 8						; size = 1
__Cat$252599 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@3
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@3
	call	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
$LN54@vector@3:
$LN22@vector@3:
	push	eax
	push	edi
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T252595[ebp], 0
	mov	edx, DWORD PTR $T252595[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$252599[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@3:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@3:
$LN53@vector@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
$T252633 = -8						; size = 8
$T252636 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	esp, 8
	cmp	BYTE PTR [eax+21], 0
	push	esi
	mov	esi, DWORD PTR __Keyval$[esp+8]
	jne	SHORT $LN9@operator@12
	push	edi
	mov	edi, DWORD PTR [esi]
$LL10@operator@12:
	cmp	DWORD PTR [eax+12], edi
	jge	SHORT $LN8@operator@12
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@operator@12
$LN8@operator@12:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@operator@12:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@operator@12
	pop	edi
$LN9@operator@12:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@operator@12
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $LN62@operator@12
$LN1@operator@12:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T252633[esp+12], eax
	lea	eax, DWORD PTR $T252633[esp+12]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T252636[esp+16]
	push	edx
	mov	DWORD PTR $T252633[esp+28], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 174  : 		return ((*_Where).second);

	add	eax, 16					; 00000010H
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
$LN62@operator@12:

; 174  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [edx+16]
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T252870 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T252870[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z
_TEXT	SEGMENT
$T252899 = -20						; size = 20
$T252902 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[], COMDAT
; _this$ = ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR [eax+33], 0
	push	esi
	mov	esi, DWORD PTR __Keyval$[esp+20]
	jne	SHORT $LN9@operator@13
	push	edi
	mov	edi, DWORD PTR [esi]
$LL10@operator@13:
	cmp	DWORD PTR [eax+12], edi
	jae	SHORT $LN8@operator@13
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@operator@13
$LN8@operator@13:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@operator@13:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@operator@13
	pop	edi
$LN9@operator@13:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@operator@13
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+12]
	jae	SHORT $LN62@operator@13
$LN1@operator@13:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	esi, DWORD PTR [esi]
	xor	eax, eax
	mov	DWORD PTR $T252899[esp+28], eax
	mov	DWORD PTR $T252899[esp+32], eax
	mov	DWORD PTR $T252899[esp+36], eax
	mov	DWORD PTR $T252899[esp+40], eax
	lea	eax, DWORD PTR $T252899[esp+24]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T252902[esp+28]
	push	edx
	mov	DWORD PTR $T252899[esp+36], esi
	call	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 174  : 		return ((*_Where).second);

	add	eax, 16					; 00000010H
	pop	esi

; 175  : 		}

	add	esp, 20					; 00000014H
	ret	4
$LN62@operator@13:

; 174  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [edx+16]
	pop	esi

; 175  : 		}

	add	esp, 20					; 00000014H
	ret	4
??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T253135 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T253135[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@7
	xor	esi, esi
	jmp	SHORT $LN4@insert@7
$LN3@insert@7:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@7:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp+4]
	push	edi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ebp, ecx
	mov	DWORD PTR [eax], esi
	cmp	esi, edi
	je	SHORT $LN1@erase@10
	push	ebx

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebx, DWORD PTR [ebp+8]
	cmp	edi, ebx
	je	SHORT $LN26@erase@10
	npad	1
$LL28@erase@10:
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	edi, 28					; 0000001cH
	add	esi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL28@erase@10
$LN26@erase@10:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebx, DWORD PTR [ebp+8]
	mov	edi, esi
	cmp	esi, ebx
	je	SHORT $LN37@erase@10
	npad	4
$LL39@erase@10:
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	edi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL39@erase@10
$LN37@erase@10:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [ebp+8], esi
	pop	ebx
$LN1@erase@10:
	pop	edi
	pop	esi
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN22@Tidy@5
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@5
$LL12@Tidy@5:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@5
$LN10@Tidy@5:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN22@Tidy@5:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU34@IABU34@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU34@IABU34@@Z
_TEXT	SEGMENT
$T253494 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$253498 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU34@IABU34@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$253498[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T253494[esp+12], 0
	mov	eax, DWORD PTR $T253494[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	add	esp, 24					; 00000018H
	shl	eax, 7
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU34@IABU34@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$253706 = 8					; size = 1
__Cat$253633 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$224974 = 12					; size = 4
__Tmp$224964 = 12					; size = 4
__Newvec$224949 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T253703 = 16						; size = 1
$T253630 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$224949[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW43@IABW43@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$253633[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T253630[ebp], 0
	mov	ecx, DWORD PTR $T253630[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$224949[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T253703[ebp], 0
	mov	edx, DWORD PTR $T253703[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$253706[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$224949[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224949[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$224964[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4GameOptionTypes@@@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW42@00@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Umove<enum GameOptionTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224964[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW43@IABW43@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$224964[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z ; std::fill<enum GameOptionTypes *,enum GameOptionTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224974[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4GameOptionTypes@@@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEPAW4GameOptionTypes@@PAW42@00@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Umove<enum GameOptionTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4GameOptionTypes@@PAW41@@stdext@@YAPAW4GameOptionTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum GameOptionTypes *,enum GameOptionTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$224974[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4GameOptionTypes@@W41@@std@@YAXPAW4GameOptionTypes@@0ABW41@@Z ; std::fill<enum GameOptionTypes *,enum GameOptionTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$253942 = 8					; size = 1
__Cat$253870 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$225049 = 12					; size = 4
__Tmp$225039 = 12					; size = 4
__Newvec$225024 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T253939 = 16						; size = 1
$T253867 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
$LN87@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$225024[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW43@IABW43@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$253870[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T253867[ebp], 0
	mov	ecx, DWORD PTR $T253867[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$225024[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T253939[ebp], 0
	mov	edx, DWORD PTR $T253939[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$253942[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$225024[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$225024[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225039[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4VictoryTypes@@@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW42@00@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Umove<enum VictoryTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$225039[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW43@IABW43@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$225039[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z ; std::fill<enum VictoryTypes *,enum VictoryTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$225049[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4VictoryTypes@@@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEPAW4VictoryTypes@@PAW42@00@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Umove<enum VictoryTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4VictoryTypes@@PAW41@@stdext@@YAPAW4VictoryTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum VictoryTypes *,enum VictoryTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$225049[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4VictoryTypes@@W41@@std@@YAXPAW4VictoryTypes@@0ABW41@@Z ; std::fill<enum VictoryTypes *,enum VictoryTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
PUBLIC	?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy@3
	npad	2
$LL9@Destroy@3:
	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@3
$LN7@Destroy@3:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy
_TEXT	ENDS
PUBLIC	??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@ABV01@@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0U1@@Z
_TEXT	SEGMENT
_count$254147 = -12					; size = 4
$T254140 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const > >, COMDAT

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));
; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));
; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 12					; 0000000cH
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+12]
	cmp	eax, ebp
	je	SHORT $LN1@for_each@7
	push	ebx
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+4]
	npad	10
$LL6@for_each@7:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, DWORD PTR __Func$[esp+24]
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR _count$254147[esp+28]
	push	edx
	mov	edi, ecx
	lea	ebx, DWORD PTR [esi-4]
	mov	DWORD PTR _count$254147[esp+32], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	edi
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T254140[esp+44]
	push	eax
	call	??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
	add	esi, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi-4]
	add	esp, 20					; 00000014H
	cmp	ecx, ebp
	jne	SHORT $LL6@for_each@7
	pop	edi
	pop	esi
	pop	ebx
$LN1@for_each@7:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	edx, DWORD PTR __Func$[esp+12]
	mov	ecx, DWORD PTR __Func$[esp+16]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp

; 31   : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$for_each@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T254250 = 16						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebx
	je	SHORT $LN29@Copy_opt@6
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@6:

; 2472 : 		*_Dest = *_First;

	cmp	esi, edi
	je	SHORT $LN2@Copy_opt@6
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T254250[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
$LN2@Copy_opt@6:
	add	edi, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edi, ebx
	jne	SHORT $LL3@Copy_opt@6

; 2473 : 	return (_Dest);

	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebx

; 2474 : 	}

	ret	0
$LN29@Copy_opt@6:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	edi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z
_TEXT	SEGMENT
$T254357 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z PROC ; std::_Fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN1@Fill@5
	push	edi
	mov	edi, DWORD PTR __Val$[esp+8]
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	cmp	esi, edi
	je	SHORT $LN2@Fill@5
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T254357[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN2@Fill@5:
	add	esi, 12					; 0000000cH
	cmp	esi, ebx
	jne	SHORT $LL3@Fill@5
	pop	edi
$LN1@Fill@5:
	pop	esi
	pop	ebx

; 3160 : 	}

	ret	0
??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ENDP ; std::_Fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
$T254408 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$254412 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$254412[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T254408[esp+4], 0
	mov	eax, DWORD PTR $T254408[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z
_TEXT	SEGMENT
$T254504 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z PROC ; std::_Fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN1@Fill@6
	push	edi
	mov	edi, DWORD PTR __Val$[esp+8]
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	cmp	esi, edi
	je	SHORT $LN2@Fill@6
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T254504[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
$LN2@Fill@6:
	add	esi, 12					; 0000000cH
	cmp	esi, ebx
	jne	SHORT $LL3@Fill@6
	pop	edi
$LN1@Fill@6:
	pop	esi
	pop	ebx

; 3160 : 	}

	ret	0
??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ENDP ; std::_Fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z
_TEXT	SEGMENT
$T254541 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$254549 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$254549[esp+12], ecx
	mov	DWORD PTR $T254541[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@9
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
$LN5@construct@9:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$254549[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T254541[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@ABV32@@Z ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::construct
PUBLIC	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN79@operator@14
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@14

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	edx, ecx
	je	SHORT $LN80@operator@14
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN53@operator@14
	npad	1
$LL55@operator@14:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL55@operator@14
$LN53@operator@14:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	DWORD PTR [esi+8], edx
$LN80@operator@14:
	pop	ebp
	pop	ebx
$LN79@operator@14:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@14:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@14

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAU?$pair@FF@std@@PAU12@@stdext@@YAPAU?$pair@FF@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<short,short> *,std::pair<short,short> *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@14:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN68@operator@14
	xor	ebx, ebx
	jmp	SHORT $LN69@operator@14
$LN68@operator@14:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN69@operator@14:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@14

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAU?$pair@FF@std@@PAU12@@stdext@@YAPAU?$pair@FF@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<short,short> *,std::pair<short,short> *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAU?$pair@FF@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@PAU21@00@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::pair<short,short> *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@14:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN72@operator@14

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@operator@14:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
	test	al, al
	je	$LN80@operator@14

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAU?$pair@FF@std@@@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEPAU?$pair@FF@1@PAU21@00@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Ucopy<std::pair<short,short> *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const >::operator()
_TEXT	ENDS
PUBLIC	??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z ; std::_Construct<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z
_TEXT	SEGMENT
$T254820 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z PROC ; std::_Construct<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T254820[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@10
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
$LN3@Construct@10:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T254820[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@ABV10@@Z ENDP ; std::_Construct<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
PUBLIC	??_G?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEPAXI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T254982 = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEPAXI@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T254982[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	test	BYTE PTR ___flags$[esp+4], 1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN35@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@scalar@7:
	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??_G?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEPAXI@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$swap@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ; std::swap<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??$swap@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z PROC ; std::swap<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT

; 193  : 	_Left.swap(_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	call	?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap

; 194  : 	}

	ret	0
??$swap@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ENDP ; std::swap<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T255096 = 16						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebx
	je	SHORT $LN29@Copy_opt@7
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@7:

; 2472 : 		*_Dest = *_First;

	cmp	esi, edi
	je	SHORT $LN2@Copy_opt@7
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T255096[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN2@Copy_opt@7:
	add	edi, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edi, ebx
	jne	SHORT $LL3@Copy_opt@7

; 2473 : 	return (_Dest);

	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebx

; 2474 : 	}

	ret	0
$LN29@Copy_opt@7:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	edi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 1034 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp+16]
	push	edi
	cmp	ecx, esi
	je	SHORT $LN23@swap@7

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())
; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	je	SHORT $LN20@swap@7
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN20@swap@7:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	lea	eax, DWORD PTR [esi+8]
	add	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN23@swap@7
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN23@swap@7:

; 1048 : 			}
; 1049 : 		else
; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);
; 1052 : 
; 1053 : 			_Myt _Tmp = *this;
; 1054 : 
; 1055 : 			*this = _Right;
; 1056 : 			_Right = _Tmp;
; 1057 : 			}
; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T255559 = -4						; size = 4
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T255559[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??_7CvReplayMessage@@6B@			; CvReplayMessage::`vftable'
PUBLIC	??0CvReplayMessage@@QAE@ABV0@@Z			; CvReplayMessage::CvReplayMessage
PUBLIC	??_R4CvReplayMessage@@6B@			; CvReplayMessage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvReplayMessage@@@8			; CvReplayMessage `RTTI Type Descriptor'
PUBLIC	??_R3CvReplayMessage@@8				; CvReplayMessage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvReplayMessage@@8				; CvReplayMessage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvReplayMessage@@8		; CvReplayMessage::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECvReplayMessage@@UAEPAXI@Z:PROC		; CvReplayMessage::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvReplayMessage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvReplayMessage@@8 DD FLAT:??_R0?AVCvReplayMessage@@@8 ; CvReplayMessage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvReplayMessage@@8
rdata$r	ENDS
;	COMDAT ??_R2CvReplayMessage@@8
rdata$r	SEGMENT
??_R2CvReplayMessage@@8 DD FLAT:??_R1A@?0A@EA@CvReplayMessage@@8 ; CvReplayMessage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvReplayMessage@@8
rdata$r	SEGMENT
??_R3CvReplayMessage@@8 DD 00H				; CvReplayMessage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvReplayMessage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvReplayMessage@@@8
_DATA	SEGMENT
??_R0?AVCvReplayMessage@@@8 DD FLAT:??_7type_info@@6B@	; CvReplayMessage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvReplayMessage@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvReplayMessage@@6B@
rdata$r	SEGMENT
??_R4CvReplayMessage@@6B@ DD 00H			; CvReplayMessage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvReplayMessage@@@8
	DD	FLAT:??_R3CvReplayMessage@@8
rdata$r	ENDS
;	COMDAT ??_7CvReplayMessage@@6B@
CONST	SEGMENT
??_7CvReplayMessage@@6B@ DD FLAT:??_R4CvReplayMessage@@6B@ ; CvReplayMessage::`vftable'
	DD	FLAT:??_ECvReplayMessage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvReplayMessage@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayMessage@@QAE@ABV0@@Z$0
__ehfuncinfo$??0CvReplayMessage@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvReplayMessage@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0CvReplayMessage@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0CvReplayMessage@@QAE@ABV0@@Z PROC			; CvReplayMessage::CvReplayMessage, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0CvReplayMessage@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	DWORD PTR [esi], OFFSET ??_7CvReplayMessage@@6B@
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+8], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _this$[esp+28], esi
	call	??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
	mov	eax, DWORD PTR [edi+28]
	add	edi, 32					; 00000020H
	push	edi
	lea	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi+28], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReplayMessage@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
__ehhandler$??0CvReplayMessage@@QAE@ABV0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvReplayMessage@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReplayMessage@@QAE@ABV0@@Z ENDP			; CvReplayMessage::CvReplayMessage
EXTRN	??1CvReplayMessage@@UAE@XZ:PROC			; CvReplayMessage::~CvReplayMessage
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvReplayMessage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvReplayMessage@@UAEPAXI@Z PROC			; CvReplayMessage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvReplayMessage@@UAEPAXI@Z ENDP			; CvReplayMessage::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
$T255713 = -4						; size = 4
??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T255713[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z
_TEXT	SEGMENT
_uiTurn$ = -8						; size = 4
_iValue$ = -4						; size = 4
_uiSize$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z PROC ; operator>>, COMDAT

; 727  : {

	sub	esp, 8
	push	esi

; 728  : 	size_t uiSize;
; 729  : 	loadFrom >> uiSize;

	mov	esi, DWORD PTR _loadFrom$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiSize$[esp+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 730  : 
; 731  : 	unsigned int uiTurn;
; 732  : 	int iValue;
; 733  : 
; 734  : 	for(unsigned int i = 0; i < uiSize; ++i)

	xor	edi, edi
	cmp	DWORD PTR _uiSize$[esp+12], edi
	jbe	SHORT $LN14@operator@15
	push	ebx
	mov	ebx, DWORD PTR _writeTo$[esp+16]
$LL3@operator@15:

; 735  : 	{
; 736  : 		loadFrom >> uiTurn;

	lea	ecx, DWORD PTR _uiTurn$[esp+20]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 737  : 		loadFrom >> iValue;

	lea	edx, DWORD PTR _iValue$[esp+20]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 738  : 		writeTo[uiTurn] = iValue;

	lea	eax, DWORD PTR _uiTurn$[esp+20]
	push	eax
	mov	ecx, ebx
	call	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
	mov	ecx, DWORD PTR _iValue$[esp+20]
	inc	edi
	mov	DWORD PTR [eax], ecx
	cmp	edi, DWORD PTR _uiSize$[esp+16]
	jb	SHORT $LL3@operator@15
	pop	ebx
$LN14@operator@15:
	pop	edi

; 739  : 	}
; 740  : 
; 741  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 742  : }

	add	esp, 8
	ret	0
??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T255793 = -4						; size = 1
__Cat$255796 = 8					; size = 1
$T255762 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 810  : 		if (size() < capacity())

	mov	ebp, DWORD PTR [edi+4]
	test	ebp, ebp
	jne	SHORT $LN9@push_back
	xor	esi, esi
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@push_back:
	mov	ebx, DWORD PTR [edi+8]
	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$255796[esp+16]
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	BYTE PTR $T255793[esp+20], 0
	mov	ecx, DWORD PTR $T255793[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR [edi+8], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	ebx
	lea	edx, DWORD PTR $T255762[esp+24]
	push	edx
	mov	ecx, edi
	call	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T255822 = -4						; size = 4
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T255822[esp+12]
	push	eax
	call	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@8
	xor	esi, esi
	jmp	SHORT $LN4@insert@8
$LN3@insert@8:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@8:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@9
	xor	esi, esi
	jmp	SHORT $LN4@insert@9
$LN3@insert@9:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@9:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
$T256472 = -4						; size = 1
__Cat$256477 = 8					; size = 1
$T256474 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR __First_arg$[esp+4]
	mov	DWORD PTR [eax], ecx
	cmp	ecx, edx
	je	SHORT $LN1@erase@11

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [ebp+8]
	push	ebx
	push	esi
	push	edi
	mov	BYTE PTR $T256472[esp+20], 0
	mov	esi, DWORD PTR $T256472[esp+20]
	push	esi
	mov	esi, DWORD PTR __Cat$256477[esp+20]
	push	esi
	mov	esi, DWORD PTR $T256474[esp+24]
	push	esi
	push	ecx
	push	eax
	push	edx
	call	??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebx, DWORD PTR [ebp+8]
	mov	edi, eax
	add	esp, 24					; 00000018H
	mov	esi, edi
	cmp	edi, ebx
	je	SHORT $LN32@erase@11
$LL34@erase@11:
	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, ebx
	jne	SHORT $LL34@erase@11
$LN32@erase@11:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ebp+8], edi
	pop	edi
	pop	esi
	pop	ebx
$LN1@erase@11:
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN22@Tidy@6
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@6
$LL12@Tidy@6:
	mov	ecx, esi
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	sub	esi, -128				; ffffff80H
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@6
$LN10@Tidy@6:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN22@Tidy@6:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T256666 = -8						; size = 8
$T256678 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 198  : {

	sub	esp, 8
	push	esi

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	esi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+12]
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T256678[esp+12]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T256678[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T256666[esp+32]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const > >
	add	esp, 20					; 00000014H

; 200  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi

; 201  : }

	add	esp, 8
	ret	0
??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z
_TEXT	SEGMENT
$T256704 = -4						; size = 1
__Cat$256710 = -4					; size = 1
$T256706 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z PROC ; stdext::unchecked_copy<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T256704[esp+4], 0
	mov	eax, DWORD PTR $T256704[esp+4]
	mov	ecx, DWORD PTR __Cat$256710[esp+4]
	mov	edx, DWORD PTR $T256706[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z ENDP ; stdext::unchecked_copy<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
_TEXT	ENDS
PUBLIC	??$fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ; std::fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z PROC ; std::fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
??$fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ENDP ; std::fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUPlayerInfo@CvReplayInfo@@@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU23@00@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Umove<CvReplayInfo::PlayerInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUPlayerInfo@CvReplayInfo@@@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU23@00@Z
_TEXT	SEGMENT
$T256767 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$256770 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUPlayerInfo@CvReplayInfo@@@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU23@00@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Umove<CvReplayInfo::PlayerInfo *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$256770[esp]
	mov	BYTE PTR $T256767[esp+4], 0
	mov	eax, DWORD PTR $T256767[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUPlayerInfo@CvReplayInfo@@@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU23@00@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Umove<CvReplayInfo::PlayerInfo *>
_TEXT	ENDS
PUBLIC	??$fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ; std::fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z PROC ; std::fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
??$fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ENDP ; std::fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
EXTRN	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T256825 = -44						; size = 4
_v$228690 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 83   : {

	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi

; 84   : 	container.clear();

	mov	edi, DWORD PTR _container$[esp+52]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T256825[esp+64]
	push	eax
	mov	ecx, edi
	call	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+52]
	lea	ecx, DWORD PTR _count$[esp+52]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+56], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	cmp	DWORD PTR _count$[esp+52], esi
	jbe	SHORT $LN1@SerializeT@2
$LL3@SerializeT@2:

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$228690[esp+56]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228690[esp+56]
	push	edx
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+72], 0
	call	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$228690[esp+56]
	push	eax
	mov	ecx, edi
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 93   : 	}

	lea	ecx, DWORD PTR _v$228690[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	esi
	cmp	esi, DWORD PTR _count$[esp+52]
	jb	SHORT $LL3@SerializeT@2
$LN1@SerializeT@2:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228690[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$for_each@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >,SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >,SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each@8
	npad	2
$LL6@for_each@8:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esi, 16					; 00000010H
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each@8
$LN1@for_each@8:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@$$CBV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >,SerializeFromSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > const ,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > const > >
_TEXT	ENDS
PUBLIC	??4CvReplayMessage@@QAEAAV0@ABV0@@Z		; CvReplayMessage::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvReplayMessage@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvReplayMessage@@QAEAAV0@ABV0@@Z PROC		; CvReplayMessage::operator=, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [edi+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+8], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	call	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
	mov	eax, DWORD PTR [edi+28]
	add	edi, 32					; 00000020H
	push	edi
	lea	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+28], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??4CvReplayMessage@@QAEAAV0@ABV0@@Z ENDP		; CvReplayMessage::operator=
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z
_TEXT	SEGMENT
$T256898 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$256906 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$256906[esp+12], ecx
	mov	DWORD PTR $T256898[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@10
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
$LN5@construct@10:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$256906[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T256898[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@ABV32@@Z ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::construct
PUBLIC	??$_Copy_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN11@Copy_backw@4
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR [esi-56]
	sub	esi, 60					; 0000003cH
	sub	edi, 60					; 0000003cH
	mov	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+8], ecx
	push	edx
	lea	ecx, DWORD PTR [edi+12]
	call	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	lea	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+28], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@4

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN11@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Swap_adl@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ; std::_Swap_adl<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z PROC ; std::_Swap_adl<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	call	?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap

; 32   : 	}

	ret	0
??$_Swap_adl@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXAAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0@Z ENDP ; std::_Swap_adl<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z ; std::_Construct<CvReplayMessage,CvReplayMessage>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z
_TEXT	SEGMENT
$T256938 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z PROC ; std::_Construct<CvReplayMessage,CvReplayMessage>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T256938[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@11
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0CvReplayMessage@@QAE@ABV0@@Z
$LN3@Construct@11:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T256938[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@ABV1@@Z ENDP ; std::_Construct<CvReplayMessage,CvReplayMessage>
PUBLIC	??$unchecked_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
$T256954 = -4						; size = 1
__Cat$256959 = -4					; size = 1
$T256956 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z PROC ; stdext::unchecked_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T256954[esp+4], 0
	mov	eax, DWORD PTR $T256954[esp+4]
	mov	ecx, DWORD PTR __Cat$256959[esp+4]
	mov	edx, DWORD PTR $T256956[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z ENDP ; stdext::unchecked_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z ; std::_Destroy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z
_TEXT	SEGMENT
$T257150 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z PROC ; std::_Destroy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	esi

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T257150[esp+8]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 60   : 	}

	ret	0
??$_Destroy@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@@Z ENDP ; std::_Destroy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??_G?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEPAXI@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T257316 = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEPAXI@Z PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T257316[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	test	BYTE PTR ___flags$[esp+4], 1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN35@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@scalar@9:
	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??_G?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEPAXI@Z ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$swap@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ; std::swap<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??$swap@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z PROC ; std::swap<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT

; 193  : 	_Left.swap(_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	call	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap

; 194  : 	}

	ret	0
??$swap@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ENDP ; std::swap<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
$T257382 = -4						; size = 1
__Cat$257386 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$257386[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T257382[esp+12], 0
	mov	eax, DWORD PTR $T257382[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z
_TEXT	SEGMENT
$T257530 = -4						; size = 1
__Cat$257534 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$257534[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T257530[esp+12], 0
	mov	eax, DWORD PTR $T257530[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back
_TEXT	ENDS
PUBLIC	??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T257655 = -4						; size = 4
?clear@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T257655[esp+12]
	push	eax
	call	?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$2
__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$6
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$7
__unwindtable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
__Tmp$225124 = -288					; size = 128
__Tmp$225114 = -160					; size = 128
__Ncopied$225101 = -32					; size = 4
_this$ = -28						; size = 4
__Whereoff$225100 = -24					; size = 4
__Newvec$225099 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$257896 = 8					; size = 1
__Cat$257824 = 8					; size = 1
__Where$ = 8						; size = 4
tv516 = 12						; size = 4
__Count$ = 12						; size = 4
$T257893 = 16						; size = 1
$T257821 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	edx, edx
	jne	SHORT $LN31@Insert_n@4
	xor	ebx, ebx
	jmp	SHORT $LN32@Insert_n@4
$LN31@Insert_n@4:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, edx
	sar	ebx, 7
$LN32@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@4

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 7
	mov	edx, 33554431				; 01ffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
$LN95@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ebx, edx
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ebx
	shr	eax, 1
	mov	ecx, 33554431				; 01ffffffH
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN17@Insert_n@4
	xor	ebx, ebx
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ebx, eax
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebx, edx
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	ebx, edx
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ebx
	call	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;

	xor	edx, edx
	sar	ecx, 7
	add	esp, 8
	mov	DWORD PTR __Whereoff$225100[ebp], ecx
	mov	DWORD PTR __Ncopied$225101[ebp], edx

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], edx

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	shl	ecx, 7
	add	ecx, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$225099[ebp], eax
	call	?_Ufill@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU34@IABU34@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$257824[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T257821[ebp], 0
	mov	ecx, DWORD PTR $T257821[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$225099[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	mov	DWORD PTR __Ncopied$225101[ebp], 1
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$225100[ebp]
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	eax, edi
	mov	BYTE PTR $T257893[ebp], 0
	mov	edx, DWORD PTR $T257893[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$257896[ebp]
	push	edx
	shl	eax, 7
	add	eax, DWORD PTR __Newvec$225099[ebp]
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$225101[ebp], 2
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 7
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN83@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	eax
	mov	ecx, esi
	call	?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$225099[ebp]
	shl	ebx, 7
	add	ebx, eax

; 1206 : 			_Mylast = _Newvec + _Count;

	shl	edi, 7
	add	edi, eax
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$225101[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$225100[ebp]
	mov	edi, DWORD PTR __Newvec$225099[ebp]
	jle	SHORT $LN7@Insert_n@4
	mov	ecx, esi
	shl	ecx, 7
	add	ecx, edi
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	shl	eax, 7
	add	eax, edi
	shl	esi, 7
	push	eax
	add	esi, edi
	push	esi
	call	?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN96@Insert_n@4:
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ecx, DWORD PTR __Where$[ebp]
	sar	ecx, 7
	cmp	ecx, edi
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$225114[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, edi
	shl	ebx, 7
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAUPlayerInfo@CvReplayInfo@@@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU23@00@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Umove<CvReplayInfo::PlayerInfo *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$225114[ebp]
	sar	ecx, 7
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU34@IABU34@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$225114[ebp]
	push	edx
	sub	esi, ebx
	push	esi
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ; std::_Fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$225114[ebp]

; 1233 : 		else

	jmp	SHORT $LN94@Insert_n@4
__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	eax, 7
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXPAUPlayerInfo@CvReplayInfo@@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN97@Insert_n@4:
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$225124[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ebx, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	shl	edi, 7
	mov	eax, edi
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv516[ebp], eax
	call	??$_Umove@PAUPlayerInfo@CvReplayInfo@@@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEPAUPlayerInfo@CvReplayInfo@@PAU23@00@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Umove<CvReplayInfo::PlayerInfo *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR __Where$[ebp]
	push	ebx
	push	edi
	push	ecx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUPlayerInfo@CvReplayInfo@@PAU12@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00@Z ; stdext::_Unchecked_move_backward<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR tv516[ebp]
	lea	edx, DWORD PTR __Tmp$225124[ebp]
	push	edx
	add	ecx, eax
	push	ecx
	push	eax
	call	??$_Fill@PAUPlayerInfo@CvReplayInfo@@U12@@std@@YAXPAUPlayerInfo@CvReplayInfo@@0ABU12@@Z ; std::_Fill<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$225124[ebp]
$LN94@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
$LN1@Insert_n@4:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN93@Insert_n@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$225114[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$225124[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
PUBLIC	??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T257956 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T257956[esp+8]
	sar	eax, 4
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T257956[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@16
	npad	2
$LL22@operator@16:
	push	esi
	push	ebx
	call	??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esi, 16					; 00000010H
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@16
$LN34@operator@16:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameOptionTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_v$228663 = -12						; size = 4
_i$ = -8						; size = 4
$T258401 = -4						; size = 1
_loadFrom$ = 8						; size = 4
__Cat$258405 = 12					; size = 1
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >, COMDAT

; 83   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+16]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN20@SerializeT@3
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN45@SerializeT@3
	npad	6
$LL47@SerializeT@3:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL47@SerializeT@3
$LN45@SerializeT@3:
	mov	DWORD PTR [esi+8], edx
$LN20@SerializeT@3:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ecx, DWORD PTR _loadFrom$[esp+20]
	lea	eax, DWORD PTR _count$[esp+20]
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR _count$[esp+24], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[esp+24], ebx
	cmp	DWORD PTR _count$[esp+20], ebx
	jbe	SHORT $LN1@SerializeT@3
	push	ebp
	mov	ebp, DWORD PTR __Cat$258405[esp+24]
$LL104@SerializeT@3:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	mov	edx, DWORD PTR _loadFrom$[esp+24]
	lea	ecx, DWORD PTR _v$228663[esp+28]
	push	ecx
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameOptionTypes@@@Z ; operator>>

; 92   : 		container.push_back(v);

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 8
	cmp	ecx, ebx
	jne	SHORT $LN60@SerializeT@3
	xor	eax, eax
	jmp	SHORT $LN61@SerializeT@3
$LN60@SerializeT@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN61@SerializeT@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN53@SerializeT@3
	mov	BYTE PTR $T258401[esp+28], bl
	mov	eax, DWORD PTR $T258401[esp+28]
	push	eax
	push	ebp
	push	esi
	lea	ecx, DWORD PTR _v$228663[esp+40]
	push	ecx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN2@SerializeT@3
$LN53@SerializeT@3:
	lea	edx, DWORD PTR _v$228663[esp+28]
	push	edx
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n
$LN2@SerializeT@3:
	mov	eax, DWORD PTR _i$[esp+28]
	inc	eax
	mov	DWORD PTR _i$[esp+28], eax
	cmp	eax, DWORD PTR _count$[esp+24]
	jb	SHORT $LL104@SerializeT@3
	pop	ebp
$LN1@SerializeT@3:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 12					; 0000000cH
	ret	0
??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4VictoryTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_v$228673 = -12						; size = 4
_i$ = -8						; size = 4
$T258829 = -4						; size = 1
_loadFrom$ = 8						; size = 4
__Cat$258833 = 12					; size = 1
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >, COMDAT

; 83   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+16]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN20@SerializeT@4
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN45@SerializeT@4
	npad	6
$LL47@SerializeT@4:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL47@SerializeT@4
$LN45@SerializeT@4:
	mov	DWORD PTR [esi+8], edx
$LN20@SerializeT@4:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ecx, DWORD PTR _loadFrom$[esp+20]
	lea	eax, DWORD PTR _count$[esp+20]
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR _count$[esp+24], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[esp+24], ebx
	cmp	DWORD PTR _count$[esp+20], ebx
	jbe	SHORT $LN1@SerializeT@4
	push	ebp
	mov	ebp, DWORD PTR __Cat$258833[esp+24]
$LL104@SerializeT@4:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	mov	edx, DWORD PTR _loadFrom$[esp+24]
	lea	ecx, DWORD PTR _v$228673[esp+28]
	push	ecx
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4VictoryTypes@@@Z ; operator>>

; 92   : 		container.push_back(v);

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 8
	cmp	ecx, ebx
	jne	SHORT $LN60@SerializeT@4
	xor	eax, eax
	jmp	SHORT $LN61@SerializeT@4
$LN60@SerializeT@4:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN61@SerializeT@4:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN53@SerializeT@4
	mov	BYTE PTR $T258829[esp+28], bl
	mov	eax, DWORD PTR $T258829[esp+28]
	push	eax
	push	ebp
	push	esi
	lea	ecx, DWORD PTR _v$228673[esp+40]
	push	ecx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN2@SerializeT@4
$LN53@SerializeT@4:
	lea	edx, DWORD PTR _v$228673[esp+28]
	push	edx
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
$LN2@SerializeT@4:
	mov	eax, DWORD PTR _i$[esp+28]
	inc	eax
	mov	DWORD PTR _i$[esp+28], eax
	cmp	eax, DWORD PTR _count$[esp+24]
	jb	SHORT $LL104@SerializeT@4
	pop	ebp
$LN1@SerializeT@4:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 12					; 0000000cH
	ret	0
??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN12@Copy_opt@8
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@8:

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+8], ecx
	push	edx
	lea	ecx, DWORD PTR [edi+12]
	call	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	lea	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+28], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 60					; 0000003cH
	add	edi, 60					; 0000003cH
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@8

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN12@Copy_opt@8:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ; std::_Fill<CvReplayMessage *,CvReplayMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z PROC ; std::_Fill<CvReplayMessage *,CvReplayMessage>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	cmp	esi, DWORD PTR __Last$[esp]
	je	SHORT $LN1@Fill@7
	push	ebx
	push	ebp
	push	edi
	mov	edi, DWORD PTR __Val$[esp+12]
	lea	ebx, DWORD PTR [edi+12]
	lea	ebp, DWORD PTR [edi+32]
	npad	8
$LL3@Fill@7:

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], ecx
	push	ebx
	lea	ecx, DWORD PTR [esi+12]
	call	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
	mov	edx, DWORD PTR [edi+28]
	push	ebp
	lea	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+28], edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 60					; 0000003cH
	cmp	esi, DWORD PTR __Last$[esp+12]
	jne	SHORT $LL3@Fill@7
	pop	edi
	pop	ebp
	pop	ebx
$LN1@Fill@7:
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ENDP ; std::_Fill<CvReplayMessage *,CvReplayMessage>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T258909 = -4						; size = 1
__Cat$258913 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T258909[esp+4], 0
	mov	eax, DWORD PTR $T258909[esp+4]
	mov	ecx, DWORD PTR __Cat$258913[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>, COMDAT

; 2761 : 	{	// use swap instead of the copy constructor

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	push	eax

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR fs:0, esp
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+12]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last$[esp+20]
	push	edi
	cmp	ebx, esi
	je	SHORT $LN1@Move_backw@4
	lea	edx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [esi+8]
	npad	1
$LL2@Move_backw@4:

; 2764 : 		_STD _Swap_adl(*--_Dest, *--_Last);

	sub	esi, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	sub	ecx, 12					; 0000000cH
	sub	edx, 12					; 0000000cH
	cmp	eax, esi
	je	SHORT $LN104@Move_backw@4
	lea	edi, DWORD PTR [ecx-4]
	lea	ebp, DWORD PTR [edx-4]
	cmp	ebp, edi
	je	SHORT $LN28@Move_backw@4
	mov	ebp, DWORD PTR [ecx-4]
	mov	edi, DWORD PTR [edx-4]
	mov	DWORD PTR [edx-4], ebp
	mov	DWORD PTR [ecx-4], edi
$LN28@Move_backw@4:
	cmp	edx, ecx
	je	SHORT $LN104@Move_backw@4
	mov	ebp, DWORD PTR [ecx]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebp
	mov	DWORD PTR [ecx], edi
$LN104@Move_backw@4:

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	cmp	esi, ebx
	jne	SHORT $LL2@Move_backw@4
$LN1@Move_backw@4:

; 2765 : 	return (_Dest);
; 2766 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>
PUBLIC	?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z ; std::allocator<CvReplayMessage>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z$0
__ehfuncinfo$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z
_TEXT	SEGMENT
$T259609 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$259615 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z PROC ; std::allocator<CvReplayMessage>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$259615[esp+12], ecx
	mov	DWORD PTR $T259609[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@11
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0CvReplayMessage@@QAE@ABV0@@Z
$LN5@construct@11:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z$0:
	mov	eax, DWORD PTR __Vptr$259615[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T259609[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VCvReplayMessage@@@std@@QAEXPAVCvReplayMessage@@ABV3@@Z ENDP ; std::allocator<CvReplayMessage>::construct
PUBLIC	?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
$T259845 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	esi

; 160  : 		_Destroy(_Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T259845[esp+8]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 161  : 		}

	ret	4
?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$8
__ehfuncinfo$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4
	DD	01H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = -36						; size = 12
$T260182 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$260190 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T261001 = 16						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Val$[ebp+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+8], eax
	xor	eax, eax
	mov	DWORD PTR __Val$[ebp+8], eax

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
$LL6@Uninit_mov@2:

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov@2

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	DWORD PTR __Vptr$260190[ebp], esi
	mov	DWORD PTR $T260182[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	test	esi, esi
	je	SHORT $LN68@Uninit_mov@2
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
$LN68@Uninit_mov@2:

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	cmp	esi, edi
	je	SHORT $LN5@Uninit_mov@2
	lea	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN99@Uninit_mov@2
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN99@Uninit_mov@2:
	lea	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN5@Uninit_mov@2
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN5@Uninit_mov@2:
	add	esi, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 12					; 0000000cH
	jmp	SHORT $LL6@Uninit_mov@2
__catch$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 226  : 		}
; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_mov@2
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_mov@2:

; 229  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_mov@2
$LN1@Uninit_mov@2:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN210@Uninit_mov@2:
$LN4@Uninit_mov@2:

; 231  : 	_CATCH_END
; 232  : 	return (_Dest);

	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T261001[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	edx, DWORD PTR __Val$[ebp+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	add	esp, 4
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@Uninit_mov@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4:
	mov	eax, DWORD PTR __Vptr$260190[ebp]
	push	eax
	mov	ecx, DWORD PTR $T260182[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??$_Swap_adl@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ; std::_Swap_adl<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z PROC ; std::_Swap_adl<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	call	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap

; 32   : 	}

	ret	0
??$_Swap_adl@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXAAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0@Z ENDP ; std::_Swap_adl<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T261095 = -28						; size = 4
__Vptr$261101 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	mov	eax, DWORD PTR __First$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

$LL14@Uninit_cop@6:
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$261101[ebp], esi
	mov	DWORD PTR $T261095[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN26@Uninit_cop@6
	push	eax
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	eax, DWORD PTR __First$[ebp]
$LN26@Uninit_cop@6:
	add	esi, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	mov	DWORD PTR __First$[ebp], eax
	jmp	SHORT $LL14@Uninit_cop@6
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@6
	mov	ebx, DWORD PTR __Al$[ebp]
	npad	4
$LL3@Uninit_cop@6:

; 134  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN40@Uninit_cop@6:
$LN4@Uninit_cop@6:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@Uninit_cop@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$261101[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261095[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??$_Destroy@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z ; std::_Destroy<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z
_TEXT	SEGMENT
$T261297 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z PROC ; std::_Destroy<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	esi

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T261297[esp+8]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 60   : 	}

	ret	0
??$_Destroy@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@@Z ENDP ; std::_Destroy<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T261380 = -28						; size = 4
__Vptr$261386 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	mov	eax, DWORD PTR __First$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	bl, 1

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

$LL16@Uninit_cop@7:
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$261386[ebp], esi
	mov	DWORD PTR $T261380[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	test	esi, esi
	je	SHORT $LN30@Uninit_cop@7
	push	eax
	mov	ecx, esi
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	eax, DWORD PTR __First$[ebp]
$LN30@Uninit_cop@7:
	add	esi, 60					; 0000003cH
	add	eax, 60					; 0000003cH
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR __Dest$[ebp], esi
	mov	DWORD PTR __First$[ebp], eax
	jmp	SHORT $LL16@Uninit_cop@7
__catch$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@7
	npad	4
$LL3@Uninit_cop@7:

; 134  : 		_Al.destroy(_Next);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN46@Uninit_cop@7:
$LN4@Uninit_cop@7:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@Uninit_cop@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$261386[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261380[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
PUBLIC	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T261441 = 8						; size = 4
__First$ = 8						; size = 4
__Vptr$261447 = 12					; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	mov	ebx, DWORD PTR __Last$[ebp]
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LL6@Uninit_cop@8:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, ebx
	je	SHORT $LN4@Uninit_cop@8

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$261447[ebp], esi
	mov	DWORD PTR $T261441[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN18@Uninit_cop@8
	push	edi
	mov	ecx, esi
	call	??0CvReplayMessage@@QAE@ABV0@@Z
$LN18@Uninit_cop@8:
	add	esi, 60					; 0000003cH
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 60					; 0000003cH
	jmp	SHORT $LL6@Uninit_cop@8
__catch$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@8
$LL3@Uninit_cop@8:

; 134  : 		_Al.destroy(_Next);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@8
$LN1@Uninit_cop@8:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN34@Uninit_cop@8:
$LN4@Uninit_cop@8:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@Uninit_cop@8:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$261447[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261441[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
PUBLIC	??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T261506 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$261514 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@9:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@9

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$261514[ebp], esi
	mov	DWORD PTR $T261506[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@9
	push	edi
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
$LN18@Uninit_cop@9:
	add	esi, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 12					; 0000000cH
	jmp	SHORT $LL6@Uninit_cop@9
__catch$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@9
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_cop@9:

; 134  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@9
$LN1@Uninit_cop@9:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN32@Uninit_cop@9:
$LN4@Uninit_cop@9:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@Uninit_cop@9:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$261514[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261506[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z	; CvReplayInfo::write
EXTRN	?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z:PROC ; CvReplayMessage::write
EXTRN	?Version@CvReplayMessage@@SAIXZ:PROC		; CvReplayMessage::Version
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
$T261711 = -8						; size = 8
$T261602 = -8						; size = 8
$T261714 = 8						; size = 4
$T261605 = 8						; size = 4
$T261532 = 8						; size = 4
$T261531 = 8						; size = 4
_kStream$ = 8						; size = 4
?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z PROC	; CvReplayInfo::write, COMDAT
; _this$ = ecx

; 580  : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 581  : 	kStream << REPLAY_VERSION;

	mov	edi, DWORD PTR _kStream$[esp+16]
	mov	esi, ecx
	push	OFFSET ?REPLAY_VERSION@CvReplayInfo@@1HA ; CvReplayInfo::REPLAY_VERSION
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 582  : 	kStream << m_iActivePlayer;

	lea	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 583  : 	kStream << m_strMapScriptName;

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 584  : 	kStream << m_eWorldSize;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z ; operator<<

; 585  : 	kStream << m_eClimate;

	lea	eax, DWORD PTR [esi+40]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z ; operator<<

; 586  : 	kStream << m_eSeaLevel;

	lea	ecx, DWORD PTR [esi+44]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z ; operator<<

; 587  : 	kStream << m_eEra;

	lea	edx, DWORD PTR [esi+48]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<

; 588  : 	kStream << m_eGameSpeed;

	lea	eax, DWORD PTR [esi+52]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z ; operator<<

; 589  : 	kStream << m_listGameOptions;

	lea	ecx, DWORD PTR [esi+56]
	push	ecx
	push	edi
	call	??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator<<<enum GameOptionTypes>

; 590  : 	kStream << m_listVictoryTypes;

	lea	edx, DWORD PTR [esi+72]
	push	edx
	push	edi
	call	??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator<<<enum VictoryTypes>

; 591  : 	kStream << m_eVictoryType;

	lea	eax, DWORD PTR [esi+88]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z ; operator<<
	add	esp, 64					; 00000040H

; 592  : 	kStream << m_eGameType;

	lea	ecx, DWORD PTR [esi+92]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameTypes@@@Z ; operator<<
	add	esp, 8

; 593  : 	kStream << m_iInitialTurn;

	lea	edx, DWORD PTR [esi+96]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 594  : 	kStream << m_iStartYear;

	lea	eax, DWORD PTR [esi+104]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 595  : 	kStream << m_iFinalTurn;

	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 596  : 	kStream << m_strFinalDate;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 597  : 	kStream << m_eCalendar;

	lea	eax, DWORD PTR [esi+136]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z ; operator<<
	add	esp, 8

; 598  : 	kStream << m_iNormalizedScore;

	lea	ecx, DWORD PTR [esi+140]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 599  : 
; 600  : 	kStream << m_listPlayerInfo;

	mov	edx, DWORD PTR [esi+152]
	lea	ebx, DWORD PTR [esi+144]
	sub	edx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR $T261605[esp+16]
	sar	edx, 7
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T261605[esp+20], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+4]
	push	ebx
	push	edi
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T261602[esp+36]
	push	ecx
	call	??$for_each@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUPlayerInfo@CvReplayInfo@@$$CBV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >,SerializeFromSequenceContainer<CvReplayInfo::PlayerInfo const ,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > const > >

; 601  : 	kStream << m_dataSetMap;

	lea	edx, DWORD PTR [esi+176]
	push	edx
	push	edi
	call	??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 602  : 	kStream << m_listPlayerDataSets;

	lea	eax, DWORD PTR [esi+192]
	push	eax
	push	edi
	call	??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 36					; 00000024H

; 603  : 
; 604  : 	kStream << CvReplayMessage::Version();

	call	?Version@CvReplayMessage@@SAIXZ		; CvReplayMessage::Version
	lea	ecx, DWORD PTR $T261531[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T261531[esp+20], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 605  : 	kStream << m_listReplayMessages.size();

	mov	ecx, DWORD PTR [esi+168]
	sub	ecx, DWORD PTR [esi+164]
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T261532[esp+16]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T261532[esp+20], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 606  : 	for(ReplayMessageList::const_iterator it = m_listReplayMessages.begin(); it != m_listReplayMessages.end(); ++it)

	mov	ebx, DWORD PTR [esi+164]
	cmp	ebx, DWORD PTR [esi+168]
	je	SHORT $LN1@write
	npad	3
$LL48@write:

; 607  : 	{
; 608  : 		(*it).write(kStream);

	push	edi
	mov	ecx, ebx
	call	?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z ; CvReplayMessage::write
	add	ebx, 60					; 0000003cH
	cmp	ebx, DWORD PTR [esi+168]
	jne	SHORT $LL48@write
$LN1@write:

; 609  : 	}
; 610  : 
; 611  : 	kStream << m_iMapWidth;

	lea	edx, DWORD PTR [esi+212]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 612  : 	kStream << m_iMapHeight;

	lea	eax, DWORD PTR [esi+208]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 613  : 	kStream << m_listPlots;

	mov	ecx, DWORD PTR [esi+224]
	sub	ecx, DWORD PTR [esi+220]
	add	esi, 216				; 000000d8H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	lea	edx, DWORD PTR $T261714[esp+16]
	mov	DWORD PTR $T261714[esp+16], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T261711[esp+36]
	push	eax
	call	??$for_each@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@U?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@$$CBV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,SerializeFromSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const ,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > const > >
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 614  : }

	add	esp, 8
	ret	4
?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z ENDP	; CvReplayInfo::write
_TEXT	ENDS
PUBLIC	?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -128				; ffffff80H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@10
	xor	esi, esi
	jmp	SHORT $LN4@insert@10
$LN3@insert@10:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 7
$LN4@insert@10:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	shl	esi, 7
	add	esi, DWORD PTR [edi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert
_TEXT	ENDS
PUBLIC	??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator>><enum GameOptionTypes>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; operator>><enum GameOptionTypes>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; operator>><enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator>><enum VictoryTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; operator>><enum VictoryTypes>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; operator>><enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ; stdext::unchecked_copy<CvReplayMessage *,CvReplayMessage *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z
_TEXT	SEGMENT
$T261800 = -4						; size = 1
__Cat$261805 = -4					; size = 1
$T261802 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvReplayMessage *,CvReplayMessage *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T261800[esp+4], 0
	mov	eax, DWORD PTR $T261800[esp+4]
	mov	ecx, DWORD PTR __Cat$261805[esp+4]
	mov	edx, DWORD PTR $T261802[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvReplayMessage *,CvReplayMessage *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ; std::fill<CvReplayMessage *,CvReplayMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z PROC ; std::fill<CvReplayMessage *,CvReplayMessage>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ; std::_Fill<CvReplayMessage *,CvReplayMessage>
??$fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ENDP ; std::fill<CvReplayMessage *,CvReplayMessage>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z
_TEXT	SEGMENT
$T261837 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$261840 = 16					; size = 1
$T261820 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$261840[esp]
	mov	edx, DWORD PTR $T261820[esp]
	mov	BYTE PTR $T261837[esp+4], 0
	mov	eax, DWORD PTR $T261837[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
$T261850 = -4						; size = 1
__Cat$261856 = -4					; size = 1
$T261852 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T261850[esp+4], 0
	mov	eax, DWORD PTR $T261850[esp+4]
	mov	ecx, DWORD PTR __Cat$261856[esp+4]
	mov	edx, DWORD PTR $T261852[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Move_backward_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T261891 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$261897 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ebx, 1
$LL6@Uninit_fil@5:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	edi, edi
	jbe	SHORT $LN4@Uninit_fil@5

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$261897[ebp], esi
	mov	DWORD PTR $T261891[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	test	esi, esi
	je	SHORT $LN18@Uninit_fil@5
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0CvReplayMessage@@QAE@ABV0@@Z
$LN18@Uninit_fil@5:
	sub	edi, ebx
	add	esi, 60					; 0000003cH
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@5
__catch$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@5
	npad	6
$LL3@Uninit_fil@5:

; 407  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, esi
	call	eax
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@5
$LN1@Uninit_fil@5:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN34@Uninit_fil@5:
$LN4@Uninit_fil@5:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@Uninit_fil@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$261897[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261891[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
PUBLIC	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T261956 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$261964 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@6:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@6

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$261964[ebp], esi
	mov	DWORD PTR $T261956[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@6
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
$LN18@Uninit_fil@6:
	dec	edi
	add	esi, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@6
__catch$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@6
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_fil@6:

; 407  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@QAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@6
$LN1@Uninit_fil@6:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN32@Uninit_fil@6:
$LN4@Uninit_fil@6:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@Uninit_fil@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$261964[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261956[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T262249 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@7
	push	ebx
	xor	ebx, ebx
$LL3@Destroy_ra@7:

; 234  : 		_Al.destroy(_First);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T262249[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	add	esi, 12					; 0000000cH
	add	esp, 4
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@7
	pop	ebx
$LN1@Destroy_ra@7:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T262276 = -4						; size = 1
__Cat$262281 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T262276[esp+4], 0
	mov	eax, DWORD PTR $T262276[esp+4]
	mov	ecx, DWORD PTR __Cat$262281[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>, COMDAT

; 2761 : 	{	// use swap instead of the copy constructor

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	push	eax

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR fs:0, esp
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+12]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last$[esp+20]
	push	edi
	cmp	ebx, esi
	je	SHORT $LN1@Move_backw@5
	lea	edx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [esi+8]
	npad	1
$LL2@Move_backw@5:

; 2764 : 		_STD _Swap_adl(*--_Dest, *--_Last);

	sub	esi, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	sub	ecx, 12					; 0000000cH
	sub	edx, 12					; 0000000cH
	cmp	eax, esi
	je	SHORT $LN104@Move_backw@5
	lea	edi, DWORD PTR [ecx-4]
	lea	ebp, DWORD PTR [edx-4]
	cmp	ebp, edi
	je	SHORT $LN28@Move_backw@5
	mov	ebp, DWORD PTR [ecx-4]
	mov	edi, DWORD PTR [edx-4]
	mov	DWORD PTR [edx-4], ebp
	mov	DWORD PTR [ecx-4], edi
$LN28@Move_backw@5:
	cmp	edx, ecx
	je	SHORT $LN104@Move_backw@5
	mov	ebp, DWORD PTR [ecx]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebp
	mov	DWORD PTR [ecx], edi
$LN104@Move_backw@5:

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	cmp	esi, ebx
	jne	SHORT $LL2@Move_backw@5
$LN1@Move_backw@5:

; 2765 : 	return (_Dest);
; 2766 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T262965 = -4						; size = 1
__Cat$262970 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T262965[esp+4], 0
	mov	eax, DWORD PTR $T262965[esp+4]
	mov	ecx, DWORD PTR __Cat$262970[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
$T263208 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	esi

; 160  : 		_Destroy(_Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T263208[esp+8]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 161  : 		}

	ret	4
?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$8
__ehfuncinfo$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4
	DD	01H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = -40						; size = 12
$T263547 = -28						; size = 4
__Vptr$263555 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T264372 = 16						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR __Val$[ebp+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+8], eax
	xor	eax, eax
	mov	DWORD PTR __Val$[ebp+8], eax

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], eax

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

$LL66@Uninit_mov@3:
	cmp	edx, DWORD PTR __Last$[ebp]
	je	$LN4@Uninit_mov@3

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	DWORD PTR __Vptr$263555[ebp], esi
	mov	DWORD PTR $T263547[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	test	esi, esi
	je	SHORT $LN76@Uninit_mov@3
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	edx, DWORD PTR __First$[ebp]
$LN76@Uninit_mov@3:

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	mov	edi, edx
	cmp	esi, edx
	je	SHORT $LN5@Uninit_mov@3
	lea	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN111@Uninit_mov@3
	mov	edx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __First$[ebp]
$LN111@Uninit_mov@3:
	lea	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN5@Uninit_mov@3
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __First$[ebp]
$LN5@Uninit_mov@3:
	add	esi, 12					; 0000000cH
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], esi
	mov	DWORD PTR __First$[ebp], edx
	jmp	SHORT $LL66@Uninit_mov@3
__catch$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 226  : 		}
; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_mov@3
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_mov@3:

; 229  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_mov@3
$LN1@Uninit_mov@3:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN223@Uninit_mov@3:
$LN4@Uninit_mov@3:

; 231  : 	_CATCH_END
; 232  : 	return (_Dest);

	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T264372[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	edx, DWORD PTR __Val$[ebp+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	add	esp, 4
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN222@Uninit_mov@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4:
	mov	eax, DWORD PTR __Vptr$263555[ebp]
	push	eax
	mov	ecx, DWORD PTR $T263547[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$8
__ehfuncinfo$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4
	DD	01H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = -36						; size = 12
$T264725 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$264733 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T265541 = 16						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR __Val$[ebp+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+8], eax
	xor	eax, eax
	mov	DWORD PTR __Val$[ebp+8], eax

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
$LL6@Uninit_mov@4:

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov@4

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	DWORD PTR __Vptr$264733[ebp], esi
	mov	DWORD PTR $T264725[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	test	esi, esi
	je	SHORT $LN68@Uninit_mov@4
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
$LN68@Uninit_mov@4:

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	cmp	esi, edi
	je	SHORT $LN5@Uninit_mov@4
	lea	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN99@Uninit_mov@4
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN99@Uninit_mov@4:
	lea	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN5@Uninit_mov@4
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN5@Uninit_mov@4:
	add	esi, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 12					; 0000000cH
	jmp	SHORT $LL6@Uninit_mov@4
__catch$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 226  : 		}
; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_mov@4
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_mov@4:

; 229  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_mov@4
$LN1@Uninit_mov@4:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN210@Uninit_mov@4:
$LN4@Uninit_mov@4:

; 231  : 	_CATCH_END
; 232  : 	return (_Dest);

	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T265541[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	edx, DWORD PTR __Val$[ebp+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	add	esp, 4
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@Uninit_mov@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4:
	mov	eax, DWORD PTR __Vptr$264733[ebp]
	push	eax
	mov	ecx, DWORD PTR $T264725[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z
_TEXT	SEGMENT
$T265584 = -4						; size = 1
__Cat$265589 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T265584[esp+4], 0
	mov	eax, DWORD PTR $T265584[esp+4]
	mov	ecx, DWORD PTR __Cat$265589[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z
_TEXT	SEGMENT
$T265593 = -4						; size = 1
__Cat$265598 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T265593[esp+4], 0
	mov	eax, DWORD PTR $T265593[esp+4]
	mov	ecx, DWORD PTR __Cat$265598[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T265602 = -4						; size = 1
__Cat$265607 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T265602[esp+4], 0
	mov	eax, DWORD PTR $T265602[esp+4]
	mov	ecx, DWORD PTR __Cat$265607[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
$T265643 = -4						; size = 1
__Cat$265647 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@4
	xor	eax, eax
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 7
$LN10@push_back@4:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 7
	cmp	edx, eax
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$265647[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T265643[esp+12], 0
	mov	eax, DWORD PTR $T265643[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 24					; 00000018H
	sub	edi, -128				; ffffff80H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z
_TEXT	SEGMENT
$T265811 = -4						; size = 1
__Cat$265816 = 8					; size = 1
$T265813 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR __First_arg$[esp+4]
	mov	DWORD PTR [eax], ecx
	cmp	ecx, edx
	je	SHORT $LN1@erase@12

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [ebp+8]
	push	ebx
	push	esi
	push	edi
	mov	BYTE PTR $T265811[esp+20], 0
	mov	esi, DWORD PTR $T265811[esp+20]
	push	esi
	mov	esi, DWORD PTR __Cat$265816[esp+20]
	push	esi
	mov	esi, DWORD PTR $T265813[esp+24]
	push	esi
	push	ecx
	push	eax
	push	edx
	call	??$_Copy_opt@PAVCvReplayMessage@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvReplayMessage@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayMessage *,CvReplayMessage *,std::random_access_iterator_tag>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edi, DWORD PTR [ebp+8]
	mov	ebx, eax
	add	esp, 24					; 00000018H
	mov	esi, ebx
	cmp	ebx, edi
	je	SHORT $LN32@erase@12
$LL34@erase@12:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 60					; 0000003cH
	cmp	esi, edi
	jne	SHORT $LL34@erase@12
$LN32@erase@12:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp+8], ebx
	pop	ebx
$LN1@erase@12:
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@std@@@Z
_TEXT	SEGMENT
$T265891 = -4						; size = 1
__Cat$265895 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T265891[esp+4], 0
	mov	eax, DWORD PTR $T265891[esp+4]
	mov	ecx, DWORD PTR __Cat$265895[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IABV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IABV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T265900 = -4						; size = 1
__Cat$265904 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IABV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T265900[esp+4], 0
	mov	eax, DWORD PTR $T265900[esp+4]
	mov	ecx, DWORD PTR __Cat$265904[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@stdext@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IABV12@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$265912 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Cat$265912[esp+4]
	mov	ecx, DWORD PTR __Al$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 226  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Umove<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z
_TEXT	SEGMENT
$T265925 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$265929 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Umove<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$265929[esp]
	mov	BYTE PTR $T265925[esp+4], 0
	mov	eax, DWORD PTR $T265925[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Umove<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z
_TEXT	SEGMENT
$T265935 = -4						; size = 1
__Cat$265940 = -4					; size = 1
$T265937 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T265935[esp+4], 0
	mov	eax, DWORD PTR $T265935[esp+4]
	mov	ecx, DWORD PTR __Cat$265940[esp+4]
	mov	edx, DWORD PTR $T265937[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Move_backward_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@0PAV21@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@0PAV21@@Z
_TEXT	SEGMENT
$T265958 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$265962 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@0PAV21@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$265962[esp]
	mov	BYTE PTR $T265958[esp+4], 0
	mov	eax, DWORD PTR $T265958[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@0PAV21@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
$T266250 = -152						; size = 1
__Cat$266253 = -152					; size = 1
$T266013 = -152						; size = 4
_count$ = -148						; size = 4
_i$ = -144						; size = 4
_v$228680 = -140					; size = 128
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >, COMDAT

; 83   : {

	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 84   : 	container.clear();

	mov	edi, DWORD PTR _container$[esp+160]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T266013[esp+172]
	push	eax
	mov	ecx, edi
	call	?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	esi, DWORD PTR _loadFrom$[esp+160]
	lea	ecx, DWORD PTR _count$[esp+164]
	push	ecx
	xor	ebx, ebx
	mov	ecx, esi
	mov	DWORD PTR _count$[esp+168], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[esp+164], ebx
	cmp	DWORD PTR _count$[esp+164], ebx
	jbe	$LN1@SerializeT@5
	push	ebp
$LL3@SerializeT@5:

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$228680[esp+184]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _v$228680[esp+212]
	mov	DWORD PTR __$EHRec$[esp+176], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _v$228680[esp+240]
	mov	BYTE PTR __$EHRec$[esp+176], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _v$228680[esp+268]
	mov	BYTE PTR __$EHRec$[esp+176], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228680[esp+168]
	push	edx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+184], 3
	call	??5@YAAAVFDataStream@@AAV0@AAW4CivilizationTypes@@@Z ; operator>>
	lea	eax, DWORD PTR _v$228680[esp+180]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4LeaderHeadTypes@@@Z ; operator>>
	lea	ecx, DWORD PTR _v$228680[esp+192]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerColorTypes@@@Z ; operator>>
	lea	edx, DWORD PTR _v$228680[esp+204]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4HandicapTypes@@@Z ; operator>>
	add	esp, 32					; 00000020H
	lea	eax, DWORD PTR _v$228680[esp+184]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read
	lea	ecx, DWORD PTR _v$228680[esp+212]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read
	lea	edx, DWORD PTR _v$228680[esp+240]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read
	lea	eax, DWORD PTR _v$228680[esp+268]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	jne	SHORT $LN59@SerializeT@5
	xor	ecx, ecx
	jmp	SHORT $LN60@SerializeT@5
$LN59@SerializeT@5:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, eax
	sar	ecx, 7
$LN60@SerializeT@5:
	mov	ebp, DWORD PTR [edi+8]
	mov	edx, ebp
	sub	edx, eax
	sar	edx, 7
	cmp	edx, ecx
	jae	SHORT $LN52@SerializeT@5
	mov	BYTE PTR $T266250[esp+168], bl
	mov	eax, DWORD PTR $T266250[esp+168]
	mov	ecx, DWORD PTR __Cat$266253[esp+168]
	push	eax
	push	ecx
	push	edi
	lea	edx, DWORD PTR _v$228680[esp+180]
	push	edx
	push	1
	push	ebp
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 24					; 00000018H
	sub	ebp, -128				; ffffff80H
	mov	DWORD PTR [edi+8], ebp
	jmp	SHORT $LN93@SerializeT@5
$LN52@SerializeT@5:
	lea	eax, DWORD PTR _v$228680[esp+168]
	push	eax
	push	1
	push	ebp
	mov	ecx, edi
	call	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
$LN93@SerializeT@5:

; 93   : 	}

	lea	ecx, DWORD PTR _v$228680[esp+168]
	mov	DWORD PTR __$EHRec$[esp+176], -1
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR _i$[esp+168]
	inc	eax
	mov	DWORD PTR _i$[esp+168], eax
	cmp	eax, DWORD PTR _count$[esp+168]
	jb	$LL3@SerializeT@5
	pop	ebp
$LN1@SerializeT@5:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 152				; 00000098H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$1:
	lea	ecx, DWORD PTR _v$228680[ebp+16]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$2:
	lea	ecx, DWORD PTR _v$228680[ebp+44]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$3:
	lea	ecx, DWORD PTR _v$228680[ebp+72]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228680[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z
_TEXT	SEGMENT
$T266302 = -4						; size = 1
__Cat$266307 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T266302[esp+4], 0
	mov	eax, DWORD PTR $T266302[esp+4]
	mov	ecx, DWORD PTR __Cat$266307[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0PAV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T266571 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@8
	push	ebx
	xor	ebx, ebx
$LL3@Destroy_ra@8:

; 234  : 		_Al.destroy(_First);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T266571[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	add	esi, 12					; 0000000cH
	add	esp, 4
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@8
	pop	ebx
$LN1@Destroy_ra@8:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T266638 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$266646 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@7:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@7

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$266646[ebp], esi
	mov	DWORD PTR $T266638[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@7
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
$LN18@Uninit_fil@7:
	dec	edi
	add	esi, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@7
__catch$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@7
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_fil@7:

; 407  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@QAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >::destroy
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@7
$LN1@Uninit_fil@7:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN32@Uninit_fil@7:
$LN4@Uninit_fil@7:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@Uninit_fil@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$266646[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266638[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z
_TEXT	SEGMENT
$T266664 = -4						; size = 1
__Cat$266668 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T266664[esp+4], 0
	mov	eax, DWORD PTR $T266664[esp+4]
	mov	ecx, DWORD PTR __Cat$266668[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@U_Undefined_move_tag@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@U_Undefined_move_tag@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T266682 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$266686 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@U_Undefined_move_tag@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$266686[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T266682[esp+4], 0
	mov	eax, DWORD PTR $T266682[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@U_Undefined_move_tag@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T266701 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$266705 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$266705[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T266701[esp+4], 0
	mov	eax, DWORD PTR $T266701[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z
_TEXT	SEGMENT
$T266720 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$266724 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$266724[esp]
	mov	BYTE PTR $T266720[esp+4], 0
	mov	eax, DWORD PTR $T266720[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T266734 = -4						; size = 4
?clear@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T266734[esp+12]
	push	eax
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::clear
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV3@IABV3@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T266778 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$266782 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV3@IABV3@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$266782[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T266778[esp+12], 0
	mov	eax, DWORD PTR $T266778[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, esi
	add	esp, 24					; 00000018H
	shl	ecx, 4
	sub	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV3@IABV3@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T266796 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$266800 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$266800[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T266796[esp+12], 0
	mov	eax, DWORD PTR $T266796[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$266816 = 12					; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Cat$266816[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+4]
	push	ecx
	push	edx
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 16					; 00000010H

; 1120 : 		}

	ret	8
?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$8
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$9
__unwindtable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
__Tmp$224909 = -60					; size = 12
__Tmp$224899 = -48					; size = 12
__Whereoff$224885 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$224886 = -28					; size = 4
__Newvec$224884 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$266968 = 8					; size = 1
__Cat$266938 = 8					; size = 1
__Cat$266912 = 8					; size = 1
__Where$ = 8						; size = 4
tv559 = 12						; size = 4
__Count$ = 12						; size = 4
$T266934 = 16						; size = 1
$T266908 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@5
$LN31@Insert_n@5:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 357913941				; 15555555H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
$LN95@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Ncopied$224886[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	mov	DWORD PTR __Newvec$224884[ebp], ecx
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$224885[ebp], ebx
	call	?_Ufill@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$266912[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T266908[ebp], 0
	mov	edx, DWORD PTR $T266908[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$224884[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224886[ebp], 1
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$224884[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T266934[ebp], 0
	mov	edx, DWORD PTR $T266934[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$266938[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$224886[ebp], 2
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN77@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR __Cat$266968[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	edx
	push	esi
	push	eax
	push	ebx
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN77@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$224884[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$224886[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$224885[ebp]
	mov	edi, DWORD PTR __Newvec$224884[ebp]
	jle	SHORT $LN7@Insert_n@5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [edi+edx*4]
	push	eax
	push	edi
	call	?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+ecx]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+edx*4]
	lea	ecx, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	push	eax
	push	edx
	call	?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN96@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224899[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi+edi*2]
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Umove<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR __Tmp$224899[ebp]
	push	edx
	mov	edx, ecx
	sub	edx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224899[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$224899[ebp]

; 1233 : 		else

	jmp	SHORT $LN94@Insert_n@5
__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN97@Insert_n@5:
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224909[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ebx, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv559[ebp], eax
	call	??$_Umove@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Umove<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv559[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224909[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V12@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$224909[ebp]
$LN94@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
$LN1@Insert_n@5:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN93@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224899[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224909[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n
PUBLIC	??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; operator>><CvReplayInfo::PlayerInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; operator>><CvReplayInfo::PlayerInfo>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; operator>><CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$_Umove@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@1@0PAV21@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@1@0PAV21@@Z
_TEXT	SEGMENT
$T267023 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$267026 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@1@0PAV21@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$267026[esp]
	mov	BYTE PTR $T267023[esp+4], 0
	mov	eax, DWORD PTR $T267023[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@1@0PAV21@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$267035 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Cat$267035[esp+4]
	mov	ecx, DWORD PTR __Al$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 226  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IABV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IABV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z
_TEXT	SEGMENT
$T267040 = -4						; size = 1
__Cat$267044 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IABV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T267040[esp+4], 0
	mov	eax, DWORD PTR $T267040[esp+4]
	mov	ecx, DWORD PTR __Cat$267044[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@stdext@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IABV12@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@PAV21@00@Z
_TEXT	SEGMENT
$T267058 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$267061 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@PAV21@00@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$267061[esp]
	mov	BYTE PTR $T267058[esp+4], 0
	mov	eax, DWORD PTR $T267058[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@PAV21@00@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z
_TEXT	SEGMENT
$T267094 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$267097 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$267097[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T267094[esp+4], 0
	mov	eax, DWORD PTR $T267094[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@stdext@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@0PAV1@AAV?$allocator@VCvReplayMessage@@@3@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z
_TEXT	SEGMENT
$T267131 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$267134 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$267134[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T267131[esp+4], 0
	mov	eax, DWORD PTR $T267131[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
$T267192 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$267226 = 12					; size = 1
__Cat$267197 = 12					; size = 1
$T267194 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [ebx], eax
	cmp	eax, edx
	je	SHORT $LN32@erase@13

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	BYTE PTR $T267192[esp+8], 0
	mov	edi, DWORD PTR $T267192[esp+8]
	push	edi
	mov	edi, DWORD PTR __Cat$267197[esp+12]
	push	edi
	mov	edi, DWORD PTR $T267194[esp+16]
	push	edi
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR [esi+8]
	mov	edi, eax
	mov	eax, DWORD PTR __Cat$267226[esp+32]
	push	eax
	push	esi
	push	ecx
	push	edi
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 40					; 00000028H

; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], edi
	pop	edi
$LN32@erase@13:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase
_TEXT	ENDS
PUBLIC	?clearReplayMessageMap@CvReplayInfo@@QAEXXZ	; CvReplayInfo::clearReplayMessageMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?clearReplayMessageMap@CvReplayInfo@@QAEXXZ
_TEXT	SEGMENT
$T267283 = -4						; size = 4
?clearReplayMessageMap@CvReplayInfo@@QAEXXZ PROC	; CvReplayInfo::clearReplayMessageMap, COMDAT
; _this$ = ecx

; 419  : {

	push	ecx

; 420  : 	m_listReplayMessages.clear();

	mov	eax, DWORD PTR [ecx+168]
	mov	edx, DWORD PTR [ecx+164]
	add	ecx, 160				; 000000a0H
	push	eax
	push	edx
	lea	eax, DWORD PTR $T267283[esp+12]
	push	eax
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 421  : }

	pop	ecx
	ret	0
?clearReplayMessageMap@CvReplayInfo@@QAEXXZ ENDP	; CvReplayInfo::clearReplayMessageMap
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@11
	xor	esi, esi
	jmp	SHORT $LN4@insert@11
$LN3@insert@11:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@11:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$267375 = -4					; size = 1
?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR __Cat$267375[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN10@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$267398 = 12					; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Cat$267398[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+4]
	push	ecx
	push	edx
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 16					; 00000010H

; 1120 : 		}

	ret	8
?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$267425 = -4					; size = 1
?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR __Cat$267425[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN10@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@PAV32@IABV32@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T267446 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$267450 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@PAV32@IABV32@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$267450[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T267446[esp+12], 0
	mov	eax, DWORD PTR $T267446[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$8
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$9
__unwindtable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
__Tmp$225264 = -60					; size = 12
__Tmp$225254 = -48					; size = 12
__Whereoff$225240 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$225241 = -28					; size = 4
__Newvec$225239 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$267600 = 8					; size = 1
__Cat$267571 = 8					; size = 1
__Cat$267545 = 8					; size = 1
__Where$ = 8						; size = 4
tv559 = 12						; size = 4
__Count$ = 12						; size = 4
$T267568 = 16						; size = 1
$T267542 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@6
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@6
$LN31@Insert_n@6:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@6:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@6

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 357913941				; 15555555H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
$LN95@Insert_n@6:
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@6:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Ncopied$225241[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	mov	DWORD PTR __Newvec$225239[ebp], ecx
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$225240[ebp], ebx
	call	?_Ufill@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@PAV32@IABV32@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$267545[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T267542[ebp], 0
	mov	edx, DWORD PTR $T267542[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$225239[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$225241[ebp], 1
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$225239[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T267568[ebp], 0
	mov	edx, DWORD PTR $T267568[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$267571[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$225241[ebp], 2
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN77@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR __Cat$267600[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	edx
	push	esi
	push	eax
	push	ebx
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN77@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$225239[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$225241[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$225240[ebp]
	mov	edi, DWORD PTR __Newvec$225239[ebp]
	jle	SHORT $LN7@Insert_n@6
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [edi+edx*4]
	push	eax
	push	edi
	call	?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Destroy
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+ecx]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+edx*4]
	lea	ecx, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	push	eax
	push	edx
	call	?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Destroy
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN96@Insert_n@6:
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$225254[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi+edi*2]
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR __Tmp$225254[ebp]
	push	edx
	mov	edx, ecx
	sub	edx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@PAV32@IABV32@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$225254[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$225254[ebp]

; 1233 : 		else

	jmp	SHORT $LN94@Insert_n@6
__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN97@Insert_n@6:
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$225264[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ebx, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv559[ebp], eax
	call	??$_Umove@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Umove<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv559[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@@stdext@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$225264[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V12@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0ABV10@@Z ; std::_Fill<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$225264[ebp]
$LN94@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
$LN1@Insert_n@6:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN93@Insert_n@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$225254[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$225264[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n
PUBLIC	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T267758 = 8						; size = 1
__Cat$267762 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	edi
	sar	edx, 1
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	je	SHORT $LN7@vector@5
	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN22@vector@5
	call	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
$LN54@vector@5:
$LN22@vector@5:
	push	eax
	push	edi
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+12], edx

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T267758[ebp], 0
	mov	edx, DWORD PTR $T267758[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$267762[ebp]
	push	edx
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@5:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@5:
$LN53@vector@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??$_Umove@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@1@0PAV2@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@1@0PAV2@@Z
_TEXT	SEGMENT
$T267826 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$267830 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@1@0PAV2@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$267830[esp]
	mov	BYTE PTR $T267826[esp+4], 0
	mov	eax, DWORD PTR $T267826[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@1@0PAV2@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvReplayMessage@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV2@00@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<CvReplayMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvReplayMessage@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV2@00@Z
_TEXT	SEGMENT
$T267880 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$267884 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvReplayMessage@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV2@00@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<CvReplayMessage *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$267884[esp]
	mov	BYTE PTR $T267880[esp+4], 0
	mov	eax, DWORD PTR $T267880[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvReplayMessage@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV2@00@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<CvReplayMessage *>
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T267895 = -4						; size = 4
?clear@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T267895[esp+12]
	push	eax
	call	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::clear
_TEXT	ENDS
PUBLIC	??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z ; std::_Construct<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z
_TEXT	SEGMENT
$T267932 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z PROC ; std::_Construct<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T267932[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@12
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
$LN3@Construct@12:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T267932[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@ABV10@@Z ENDP ; std::_Construct<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
PUBLIC	?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T268078 = -24						; size = 1
__Ptr$222004 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$268081 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 603  : 		if (max_size() < _Count)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edi, 71582788				; 04444444H
	jbe	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
$LN57@reserve:
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN21@reserve
$LN20@reserve:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN21@reserve:
	cmp	eax, edi
	jae	$LN3@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edi
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T268078[ebp], 0
	mov	edi, DWORD PTR $T268078[ebp]
	push	edi
	mov	edi, DWORD PTR __Cat$268081[ebp]
	push	edi
	push	esi
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR __Ptr$222004[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 32					; 00000020H
	add	edi, edx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 617  : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN52@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR __Ptr$222004[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 628  : 			_Mylast = _Ptr + _Size;

	mov	ecx, edi
	shl	ecx, 4
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], eax
$LN3@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$222004[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve:
$LN56@reserve:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve
PUBLIC	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$268150 = -4					; size = 1
??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@vector@6
	mov	ecx, DWORD PTR __Cat$268150[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN12@vector@6:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	pop	ecx
	ret	0
??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
$T268190 = -4						; size = 1
__Cat$268193 = 8					; size = 1
$T268159 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@5
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@5:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$268193[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T268190[esp+16], 0
	mov	ecx, DWORD PTR $T268190[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T268159[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back
_TEXT	ENDS
PUBLIC	??1?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$268255 = -4					; size = 1
??1?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@vector@7
	mov	ecx, DWORD PTR __Cat$268255[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN12@vector@7:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	pop	ecx
	ret	0
??1?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T268344 = -24						; size = 1
__Ptr$222978 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$268379 = 8					; size = 1
__Cat$268348 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 603  : 		if (max_size() < _Count)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN5@reserve@2

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
$LN57@reserve@2:
$LN5@reserve@2:

; 605  : 		else if (capacity() < _Count)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN21@reserve@2
$LN20@reserve@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN21@reserve@2:
	cmp	eax, edi
	jae	$LN3@reserve@2

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edi
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T268344[ebp], 0
	mov	edi, DWORD PTR $T268344[ebp]
	push	edi
	mov	edi, DWORD PTR __Cat$268348[ebp]
	push	edi
	push	esi
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR __Ptr$222978[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 32					; 00000020H
	add	edi, edx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 617  : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN52@reserve@2

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR __Cat$268379[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+8]
	push	esi
	push	eax
	push	ebx
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN52@reserve@2:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Ptr$222978[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], eax
$LN3@reserve@2:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	edx, DWORD PTR __Ptr$222978[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve@2:
$LN56@reserve@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve
PUBLIC	?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0
__unwindtable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv202 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T268462 = 8						; size = 1
__Cat$268466 = 8					; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n, COMDAT
; _this$ = ecx

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 546  : 		if (_Buy(_Count))

	mov	ebx, DWORD PTR __Count$[ebp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_
	cmp	ebx, 357913941				; 15555555H
	jbe	SHORT $LN10@Construct_
	call	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
$LN34@Construct_:
$LN10@Construct_:
	push	eax
	push	ebx
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	edi, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv202[ebp], eax
	add	eax, edi
	mov	DWORD PTR [esi+12], eax
	mov	BYTE PTR $T268462[ebp], 0
	mov	eax, DWORD PTR $T268462[ebp]
	mov	ecx, DWORD PTR __Cat$268466[ebp]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	ebx
	push	edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	eax, DWORD PTR tv202[ebp]
	add	esp, 32					; 00000020H
	add	eax, edi
	mov	DWORD PTR [esi+8], eax
$LN7@Construct_:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN35@Construct_:
$LN33@Construct_:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n
PUBLIC	?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@12
	xor	esi, esi
	jmp	SHORT $LN4@insert@12
$LN3@insert@12:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@12:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z
_TEXT	SEGMENT
$T268598 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$268630 = 12					; size = 1
__Cat$268603 = 12					; size = 1
$T268600 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [ebx], eax
	cmp	eax, edx
	je	SHORT $LN32@erase@14

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	BYTE PTR $T268598[esp+8], 0
	mov	edi, DWORD PTR $T268598[esp+8]
	push	edi
	mov	edi, DWORD PTR __Cat$268603[esp+12]
	push	edi
	mov	edi, DWORD PTR $T268600[esp+16]
	push	edi
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR [esi+8]
	mov	edi, eax
	mov	eax, DWORD PTR __Cat$268630[esp+32]
	push	eax
	push	esi
	push	ecx
	push	edi
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 40					; 00000028H

; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], edi
	pop	edi
$LN32@erase@14:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$6
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$7
__unwindtable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
_TEXT	SEGMENT
__Tmp$224839 = -76					; size = 60
__$EHRec$ = -16						; size = 16
__Tmp$224829 = 0					; size = 60
__Whereoff$224815 = 60					; size = 4
__Ncopied$224816 = 64					; size = 4
_this$ = 68						; size = 4
__Newvec$224814 = 72					; size = 4
__Capacity$ = 76					; size = 4
__Cat$268844 = 88					; size = 1
__Cat$268771 = 88					; size = 1
__Where$ = 88						; size = 4
tv493 = 92						; size = 4
__Count$ = 92						; size = 4
$T268840 = 96						; size = 1
$T268767 = 96						; size = 1
__Val$ = 96						; size = 4
?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	lea	ebp, DWORD PTR [esp-80]
	sub	esp, 80					; 00000050H
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@7
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@7
$LN31@Insert_n@7:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@7:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@7

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 71582788				; 04444444H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@7

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
$LN95@Insert_n@7:
$LN12@Insert_n@7:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 71582788				; 04444444H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@7
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@7:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@7:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, -2004318071			; 88888889H
	imul	ebx
	add	edx, ebx
	sar	edx, 5
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Ncopied$224816[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	add	esp, 8
	mov	eax, ebx
	shl	eax, 4
	push	edx
	mov	DWORD PTR __Newvec$224814[ebp], ecx
	sub	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$224815[ebp], ebx
	call	?_Ufill@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV3@IABV3@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$268771[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T268767[ebp], 0
	mov	edx, DWORD PTR $T268767[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$224814[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224816[ebp], 1
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$224814[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	mov	edx, ebx
	shl	edx, 4
	sub	edx, ebx
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T268840[ebp], 0
	mov	edx, DWORD PTR $T268840[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$268844[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$224816[ebp], 2
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN83@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR __Newvec$224814[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, edi
	shl	ecx, 4
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax
	jmp	$LN1@Insert_n@7
__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$224816[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$224815[ebp]
	mov	edi, DWORD PTR __Newvec$224814[ebp]
	jle	SHORT $LN7@Insert_n@7
	mov	eax, esi
	shl	eax, 4
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy
$LN7@Insert_n@7:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@7

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, esi
	lea	edx, DWORD PTR [edi+ecx*4]
	shl	eax, 4
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy
$LN6@Insert_n@7:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN96@Insert_n@7:
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, -2004318071			; 88888889H
	imul	ebx
	add	edx, ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@7

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224829[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, edi
	shl	ebx, 4
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAVCvReplayMessage@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV2@00@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<CvReplayMessage *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224829[ebp]
	push	edx
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV3@IABV3@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224829[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ; std::_Fill<CvReplayMessage *,CvReplayMessage>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$224829[ebp]

; 1233 : 		else

	jmp	$LN94@Insert_n@7
__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXPAVCvReplayMessage@@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN97@Insert_n@7:
$LN3@Insert_n@7:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224839[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ebx, edi
	shl	ebx, 4
	sub	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv493[ebp], eax
	call	??$_Umove@PAVCvReplayMessage@@@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEPAVCvReplayMessage@@PAV2@00@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Umove<CvReplayMessage *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv493[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224839[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$_Fill@PAVCvReplayMessage@@V1@@std@@YAXPAVCvReplayMessage@@0ABV1@@Z ; std::_Fill<CvReplayMessage *,CvReplayMessage>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$224839[ebp]
$LN94@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
$LN1@Insert_n@7:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	ebp, 80					; 00000050H
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN93@Insert_n@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224829[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224839[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__ehhandler$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n
PUBLIC	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Cat$268999 = 8					; size = 1
$T268965 = 8						; size = 1
__Cat$268969 = 8					; size = 1
$T268967 = 8						; size = 1
$T268933 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN59@operator@17

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	ebp
	sar	edx, 1
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	jne	SHORT $LN8@operator@17

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T268933[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase
	pop	ebp
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@17:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebp, ecx
	ja	SHORT $LN6@operator@17

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	BYTE PTR $T268965[esp+12], 0
	mov	ecx, DWORD PTR $T268965[esp+12]
	mov	edx, DWORD PTR __Cat$268969[esp+12]
	mov	eax, DWORD PTR $T268967[esp+12]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR [edi+8]
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??$_Copy_opt@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::random_access_iterator_tag>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR __Cat$268999[esp+36]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [esi+4]
	sar	edx, 1
	add	esp, 40					; 00000028H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	ebx
	lea	eax, DWORD PTR [eax+eax*2]
	pop	ebp
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@17:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ebx, ebx
	jne	SHORT $LN50@operator@17
	xor	eax, eax
	jmp	SHORT $LN51@operator@17
$LN50@operator@17:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN51@operator@17:
	cmp	ebp, eax
	ja	SHORT $LN4@operator@17

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ebp, DWORD PTR [eax+ecx*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ebx
	push	ebp
	push	eax
	call	??$unchecked_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@@stdext@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	edx
	push	eax
	push	ebp
	mov	ecx, esi
	call	??$_Ucopy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
	pop	ebx
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@17:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN54@operator@17

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN54@operator@17:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	ecx, esi
	call	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
	test	al, al
	je	SHORT $LN58@operator@17

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@1@PAV21@00@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Ucopy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *>
	mov	DWORD PTR [esi+8], eax
$LN58@operator@17:
	pop	ebx
	pop	ebp
$LN59@operator@17:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z
_TEXT	SEGMENT
$T269047 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$269053 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$269053[esp+12], ecx
	mov	DWORD PTR $T269047[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@12
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
$LN5@construct@12:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$269053[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T269047[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV32@@Z ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::construct
PUBLIC	??_G?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEPAXI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
__Cat$269118 = 8					; size = 1
___flags$ = 8						; size = 4
??_G?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEPAXI@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN15@scalar@10
	mov	ecx, DWORD PTR __Cat$269118[esp]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN15@scalar@10:
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	je	SHORT $LN17@scalar@10
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@scalar@10:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEPAXI@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T269600 = -28						; size = 4
$T269172 = -28						; size = 4
_v$230591 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 83   : {

	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 84   : 	container.clear();

	mov	ebp, DWORD PTR _container$[esp+32]
	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T269172[esp+52]
	push	eax
	mov	ecx, ebp
	call	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+40]
	lea	ecx, DWORD PTR _count$[esp+40]
	push	ecx
	xor	edi, edi
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+44], edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	cmp	DWORD PTR _count$[esp+40], edi
	jbe	$LN1@SerializeT@6
$LL3@SerializeT@6:

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$230591[esp+44]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR _v$230591[esp+48], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR _v$230591[esp+48]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _v$230591[esp+48]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _v$230591[esp+48]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR _v$230591[esp+52], edi

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$230591[esp+44]
	push	edx
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+60], edi
	call	??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$230591[esp+44]
	push	eax
	mov	ecx, ebp
	call	?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back

; 93   : 	}

	mov	eax, DWORD PTR _v$230591[esp+48]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T269600[esp+52]
	push	ecx
	lea	ecx, DWORD PTR _v$230591[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	edx, DWORD PTR _v$230591[esp+48]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	inc	esi
	add	esp, 4
	mov	DWORD PTR _v$230591[esp+48], edi
	mov	DWORD PTR _v$230591[esp+52], edi
	cmp	esi, DWORD PTR _count$[esp+40]
	jb	$LL3@SerializeT@6
$LN1@SerializeT@6:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$230591[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
PUBLIC	?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap, COMDAT
; _this$ = ecx

; 1064 : 		{	// exchange contents with _Right

	push	esi

; 1065 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp]
	cmp	ecx, esi
	je	SHORT $LN18@swap@8

; 1066 : 			;	// same object, do nothing
; 1067 : 		else if (this->_Alval == _Right._Alval)
; 1068 : 			{	// same allocator, swap control information
; 1069 : 
; 1070 :  #if _HAS_ITERATOR_DEBUGGING
; 1071 : 			this->_Swap_all(_Right);
; 1072 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1073 : 
; 1074 : 			this->_Swap_aux(_Right);
; 1075 : 
; 1076 : 			_STD swap(_Myfirst, _Right._Myfirst);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	push	ebx
	push	edi
	cmp	edx, eax
	je	SHORT $LN12@swap@8
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN12@swap@8:

; 1077 : 			_STD swap(_Mylast, _Right._Mylast);

	lea	eax, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [ecx+8]
	cmp	edx, eax
	je	SHORT $LN15@swap@8
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN15@swap@8:

; 1078 : 			_STD swap(_Myend, _Right._Myend);

	lea	eax, DWORD PTR [esi+12]
	add	ecx, 12					; 0000000cH
	pop	edi
	pop	ebx
	cmp	ecx, eax
	je	SHORT $LN18@swap@8
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN18@swap@8:
	pop	esi

; 1079 : 			}
; 1080 : 		else
; 1081 : 			{	// different allocator, do multiple assigns
; 1082 : 			this->_Swap_aux(_Right);
; 1083 : 
; 1084 : 			_Myt _Ts = *this;
; 1085 : 
; 1086 : 			*this = _Right;
; 1087 : 			_Right = _Ts;
; 1088 : 			}
; 1089 : 		}

	ret	4
?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap
_TEXT	ENDS
PUBLIC	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
_TEXT	SEGMENT
$T269676 = -24						; size = 12
__$EHRec$ = -12						; size = 12
$T270119 = 8						; size = 4
__Count$ = 8						; size = 4
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 483  : 		_Construct_n(_Count, _Ty());

	lea	ecx, DWORD PTR $T269676[esp+28]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR $T269676[esp+32], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR $T269676[esp+32]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR $T269676[esp+32]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR $T269676[esp+32]
	mov	DWORD PTR [eax+8], eax
	xor	eax, eax
	mov	DWORD PTR $T269676[esp+36], eax
	mov	ecx, DWORD PTR __Count$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], eax
	lea	eax, DWORD PTR $T269676[esp+28]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n
	mov	eax, DWORD PTR $T269676[esp+32]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T270119[esp+32]
	push	edx
	lea	ecx, DWORD PTR $T269676[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	eax, DWORD PTR $T269676[esp+32]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 484  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	add	esp, 4
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$0:
	lea	ecx, DWORD PTR $T269676[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
$T270186 = -4						; size = 1
__Cat$270189 = 8					; size = 1
$T270156 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@6
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@6:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$270189[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T270186[esp+16], 0
	mov	ecx, DWORD PTR $T270186[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T270156[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T270216 = -4						; size = 4
?clear@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T270216[esp+12]
	push	eax
	call	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@13
	xor	esi, esi
	jmp	SHORT $LN4@insert@13
$LN3@insert@13:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@13:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, esi
	shl	edx, 4
	sub	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T270791 = -28						; size = 4
$T270364 = -28						; size = 4
_v$228719 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >, COMDAT

; 83   : {

	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 84   : 	container.clear();

	mov	ebp, DWORD PTR _container$[esp+32]
	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T270364[esp+52]
	push	eax
	mov	ecx, ebp
	call	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+40]
	lea	ecx, DWORD PTR _count$[esp+40]
	push	ecx
	xor	edi, edi
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+44], edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	cmp	DWORD PTR _count$[esp+40], edi
	jbe	$LN1@SerializeT@7
$LL3@SerializeT@7:

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$228719[esp+44]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR _v$228719[esp+48], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR _v$228719[esp+48]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _v$228719[esp+48]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _v$228719[esp+48]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR _v$228719[esp+52], edi

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228719[esp+44]
	push	edx
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+60], edi
	call	??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$228719[esp+44]
	push	eax
	mov	ecx, ebp
	call	?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back

; 93   : 	}

	mov	eax, DWORD PTR _v$228719[esp+48]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T270791[esp+52]
	push	ecx
	lea	ecx, DWORD PTR _v$228719[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	edx, DWORD PTR _v$228719[esp+48]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	inc	esi
	add	esp, 4
	mov	DWORD PTR _v$228719[esp+48], edi
	mov	DWORD PTR _v$228719[esp+52], edi
	cmp	esi, DWORD PTR _count$[esp+40]
	jb	$LL3@SerializeT@7
$LN1@SerializeT@7:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228719[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
PUBLIC	??$_Copy_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@Copy_opt@9
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@9:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	add	esi, 16					; 00000010H
	add	edi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@9

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN8@Copy_opt@9:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z ; std::_Fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z PROC ; std::_Fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill@8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill@8:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	add	esi, 16					; 00000010H
	cmp	esi, edi
	jne	SHORT $LL3@Fill@8
	pop	ebx
$LN1@Fill@8:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z ENDP ; std::_Fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z ; std::_Destroy<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Cat$270913 = 8					; size = 1
__Ptr$ = 8						; size = 4
??$_Destroy@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z PROC ; std::_Destroy<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	esi

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN17@Destroy@4
	mov	ecx, DWORD PTR __Cat$270913[esp]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN17@Destroy@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 60   : 	}

	ret	0
??$_Destroy@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@@Z ENDP ; std::_Destroy<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$swap@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ; std::swap<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$swap@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z PROC ; std::swap<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 1357 : 	_Left.swap(_Right);

	mov	edx, DWORD PTR __Left$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Right$[esp]
	cmp	edx, esi
	je	SHORT $LN20@swap@9
	lea	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edx+4]
	push	ebx
	push	edi
	cmp	ecx, eax
	je	SHORT $LN14@swap@9
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edi
$LN14@swap@9:
	lea	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx+8]
	cmp	ecx, eax
	je	SHORT $LN17@swap@9
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edi
$LN17@swap@9:
	lea	eax, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edx+12]
	pop	edi
	pop	ebx
	cmp	ecx, eax
	je	SHORT $LN20@swap@9
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN20@swap@9:
	pop	esi

; 1358 : 	}

	ret	0
??$swap@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ENDP ; std::swap<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z
_TEXT	SEGMENT
$T271019 = -4						; size = 1
__Cat$271022 = 8					; size = 1
$T270988 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 810  : 		if (size() < capacity())

	mov	ebp, DWORD PTR [edi+4]
	test	ebp, ebp
	jne	SHORT $LN9@push_back@7
	xor	esi, esi
	jmp	SHORT $LN10@push_back@7
$LN9@push_back@7:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebp
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@push_back@7:
	mov	ebx, DWORD PTR [edi+8]
	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -2004318071			; 88888889H
	imul	ecx
	add	edx, ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$271022[esp+16]
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	BYTE PTR $T271019[esp+20], 0
	mov	ecx, DWORD PTR $T271019[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR [edi+8], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@7:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	ebx
	lea	edx, DWORD PTR $T270988[esp+24]
	push	edx
	mov	ecx, edi
	call	?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back
_TEXT	ENDS
PUBLIC	??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z PROC ; stdext::unchecked_copy<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	esi, ebx
	je	SHORT $LN14@unchecked_@5
$LL9@unchecked_@5:
	push	esi
	mov	ecx, edi
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	add	esi, 16					; 00000010H
	add	edi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL9@unchecked_@5
$LN14@unchecked_@5:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z ENDP ; stdext::unchecked_copy<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
_TEXT	ENDS
PUBLIC	??$fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z ; std::fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z PROC ; std::fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill@4
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill@4:
	push	ebx
	mov	ecx, esi
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	add	esi, 16					; 00000010H
	cmp	esi, edi
	jne	SHORT $LL5@fill@4
	pop	ebx
$LN3@fill@4:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z ENDP ; std::fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
__Cat$271180 = 8					; size = 1
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	esi

; 160  : 		_Destroy(_Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN19@destroy
	mov	ecx, DWORD PTR __Cat$271180[esp]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN19@destroy:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 161  : 		}

	ret	4
?destroy@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::destroy
_TEXT	ENDS
PUBLIC	??$_Swap_adl@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ; std::_Swap_adl<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z PROC ; std::_Swap_adl<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	edx, DWORD PTR __Left$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Right$[esp]
	cmp	edx, esi
	je	SHORT $LN22@Swap_adl
	lea	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edx+4]
	push	ebx
	push	edi
	cmp	ecx, eax
	je	SHORT $LN16@Swap_adl
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edi
$LN16@Swap_adl:
	lea	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx+8]
	cmp	ecx, eax
	je	SHORT $LN19@Swap_adl
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edi
$LN19@Swap_adl:
	lea	eax, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edx+12]
	pop	edi
	pop	ebx
	cmp	ecx, eax
	je	SHORT $LN22@Swap_adl
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN22@Swap_adl:
	pop	esi

; 32   : 	}

	ret	0
??$_Swap_adl@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAXAAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0@Z ENDP ; std::_Swap_adl<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z ; CvReplayInfo::addReplayMessage
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
;	COMDAT ?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z
_TEXT	SEGMENT
_pMessage$ = 8						; size = 4
?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z PROC ; CvReplayInfo::addReplayMessage, COMDAT
; _this$ = ecx

; 415  : 	m_listReplayMessages.push_back(pMessage);

	add	ecx, 160				; 000000a0H
	jmp	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back
?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z ENDP ; CvReplayInfo::addReplayMessage
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T271310 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$271316 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@8:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@8

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$271316[ebp], esi
	mov	DWORD PTR $T271310[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@8
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
$LN18@Uninit_fil@8:
	dec	edi
	add	esi, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@8
__catch$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@8
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_fil@8:

; 407  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::destroy
	add	esi, 16					; 00000010H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@8
$LN1@Uninit_fil@8:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Uninit_fil@8:
$LN4@Uninit_fil@8:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Uninit_fil@8:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$271316[ebp]
	push	eax
	mov	ecx, DWORD PTR $T271310[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Cat$271446 = 8					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebx

; 233  : 	for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN1@Destroy_ra@9
	push	ebp
	mov	ebp, DWORD PTR __Cat$271446[esp+8]
	push	edi
	xor	edi, edi
$LL3@Destroy_ra@9:

; 234  : 		_Al.destroy(_First);

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN24@Destroy_ra@9
	mov	ecx, DWORD PTR [esi+8]
	push	ebp
	push	esi
	push	ecx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN24@Destroy_ra@9:
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	add	esi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL3@Destroy_ra@9
	pop	edi
	pop	ebp
$LN1@Destroy_ra@9:
	pop	esi
	pop	ebx

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>, COMDAT

; 2761 : 	{	// use swap instead of the copy constructor

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	push	eax

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR fs:0, esp
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp+12]
	push	ebp
	push	esi
	push	edi
	cmp	DWORD PTR __First$[esp+24], ebx
	je	SHORT $LN1@Move_backw@6
	lea	edx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [ebx+8]
	npad	3
$LL2@Move_backw@6:

; 2764 : 		_STD _Swap_adl(*--_Dest, *--_Last);

	sub	eax, 16					; 00000010H
	sub	ebx, 16					; 00000010H
	sub	ecx, 16					; 00000010H
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Dest$[esp+24], eax
	cmp	eax, ebx
	je	SHORT $LN26@Move_backw@6
	lea	esi, DWORD PTR [ecx-4]
	lea	edi, DWORD PTR [edx-4]
	cmp	edi, esi
	je	SHORT $LN20@Move_backw@6
	mov	edi, DWORD PTR [ecx-4]
	mov	esi, DWORD PTR [edx-4]
	mov	DWORD PTR [edx-4], edi
	mov	DWORD PTR [ecx-4], esi
$LN20@Move_backw@6:
	cmp	edx, ecx
	je	SHORT $LN23@Move_backw@6
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [ecx], esi
$LN23@Move_backw@6:
	lea	esi, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [edx+4]
	cmp	edi, esi
	je	SHORT $LN26@Move_backw@6
	mov	eax, DWORD PTR [esi]
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi], ebp
$LN26@Move_backw@6:

; 2762 : 	_DEBUG_RANGE(_First, _Last);
; 2763 : 	while (_First != _Last)

	cmp	ebx, DWORD PTR __First$[esp+24]
	jne	SHORT $LL2@Move_backw@6
$LN1@Move_backw@6:

; 2765 : 	return (_Dest);
; 2766 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>
PUBLIC	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__ehfuncinfo$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3
	DD	01H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = -40						; size = 16
$T271860 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$271866 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$272142 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __Val$[ebp+4], ebx
	mov	DWORD PTR __Val$[ebp+8], ebx
	mov	DWORD PTR __Val$[ebp+12], ebx

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	8
$LL6@Uninit_mov@5:

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	$LN4@Uninit_mov@5

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	DWORD PTR __Vptr$271866[ebp], esi
	mov	DWORD PTR $T271860[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	test	esi, esi
	je	SHORT $LN56@Uninit_mov@5
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
$LN56@Uninit_mov@5:

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	cmp	esi, edi
	je	SHORT $LN5@Uninit_mov@5
	lea	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN76@Uninit_mov@5
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN76@Uninit_mov@5:
	lea	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN79@Uninit_mov@5
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN79@Uninit_mov@5:
	lea	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [esi+12]
	cmp	ecx, eax
	je	SHORT $LN5@Uninit_mov@5
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN5@Uninit_mov@5:
	mov	ebx, DWORD PTR __Val$[ebp+4]
	add	esi, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 16					; 00000010H
	jmp	SHORT $LL6@Uninit_mov@5
__catch$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 226  : 		}
; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_mov@5
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_mov@5:

; 229  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@QAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >::destroy
	add	esi, 16					; 00000010H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_mov@5
$LN1@Uninit_mov@5:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN119@Uninit_mov@5:
$LN4@Uninit_mov@5:

; 231  : 	_CATCH_END
; 232  : 	return (_Dest);

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	test	ebx, ebx
	je	SHORT $LN111@Uninit_mov@5
	mov	ecx, DWORD PTR __Cat$272142[ebp]
	mov	eax, DWORD PTR __Val$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	eax
	push	ebx
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN111@Uninit_mov@5:

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@Uninit_mov@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3:
	mov	eax, DWORD PTR __Vptr$271866[ebp]
	push	eax
	mov	ecx, DWORD PTR $T271860[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T272163 = -4						; size = 1
__Cat$272167 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T272163[esp+4], 0
	mov	eax, DWORD PTR $T272163[esp+4]
	mov	ecx, DWORD PTR __Cat$272167[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$272175 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Cat$272175[esp+4]
	mov	ecx, DWORD PTR __Al$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 226  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
$T272180 = -4						; size = 1
__Cat$272185 = -4					; size = 1
$T272182 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T272180[esp+4], 0
	mov	eax, DWORD PTR $T272180[esp+4]
	mov	ecx, DWORD PTR __Cat$272185[esp+4]
	mov	edx, DWORD PTR $T272182[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Move_backward_opt@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T272194 = -4						; size = 1
__Cat$272198 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T272194[esp+4], 0
	mov	eax, DWORD PTR $T272194[esp+4]
	mov	ecx, DWORD PTR __Cat$272198[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T272212 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$272215 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$272215[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T272212[esp+12], 0
	mov	eax, DWORD PTR $T272212[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	add	esp, 24					; 00000018H
	shl	eax, 4
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$272230 = 12					; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Cat$272230[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+4]
	push	ecx
	push	edx
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 16					; 00000010H

; 1120 : 		}

	ret	8
?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@PAV21@00@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Umove<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@PAV21@00@Z
_TEXT	SEGMENT
$T272247 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$272250 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@PAV21@00@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Umove<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$272250[esp]
	mov	BYTE PTR $T272247[esp+4], 0
	mov	eax, DWORD PTR $T272247[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@PAV21@00@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Umove<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
__Cat$272356 = 8					; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	ebp
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First_arg$[esp+8]
	mov	ebp, ecx
	mov	DWORD PTR [eax], edi
	cmp	edi, esi
	je	SHORT $LN1@erase@15
	push	ebx

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebx, DWORD PTR [ebp+8]
	cmp	esi, ebx
	je	SHORT $LN26@erase@15
	npad	1
$LL28@erase@15:
	push	esi
	mov	ecx, edi
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	add	esi, 16					; 00000010H
	add	edi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL28@erase@15
$LN26@erase@15:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR __Cat$272356[esp+12]
	mov	ecx, DWORD PTR [ebp+8]
	push	eax
	push	ebp
	push	ecx
	push	edi
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebp+8], edi
	pop	ebx
$LN1@erase@15:
	pop	edi
	pop	esi
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$272386 = -4					; size = 1
?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR __Cat$272386[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN10@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$6
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$7
__unwindtable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
__Tmp$225199 = -48					; size = 16
__Tmp$225189 = -48					; size = 16
_this$ = -32						; size = 4
__Whereoff$225175 = -28					; size = 4
__Ncopied$225176 = -24					; size = 4
__Newvec$225174 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$272542 = 8					; size = 1
__Cat$272513 = 8					; size = 1
__Cat$272487 = 8					; size = 1
__Where$ = 8						; size = 4
tv516 = 12						; size = 4
__Count$ = 12						; size = 4
$T272509 = 16						; size = 1
$T272482 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	edx, edx
	jne	SHORT $LN31@Insert_n@8
	xor	ebx, ebx
	jmp	SHORT $LN32@Insert_n@8
$LN31@Insert_n@8:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, edx
	sar	ebx, 4
$LN32@Insert_n@8:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@8

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 4
	mov	edx, 268435455				; 0fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@8

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
$LN85@Insert_n@8:
$LN12@Insert_n@8:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ebx, edx
	jae	$LN10@Insert_n@8

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ebx
	shr	eax, 1
	mov	ecx, 268435455				; 0fffffffH
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN17@Insert_n@8
	xor	ebx, ebx
	jmp	SHORT $LN18@Insert_n@8
$LN17@Insert_n@8:
	add	ebx, eax
$LN18@Insert_n@8:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebx, edx
	jae	SHORT $LN9@Insert_n@8

; 1172 : 				_Capacity = size() + _Count;

	mov	ebx, edx
$LN9@Insert_n@8:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ebx
	call	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;

	xor	edx, edx
	sar	ecx, 4
	add	esp, 8
	mov	DWORD PTR __Whereoff$225175[ebp], ecx
	mov	DWORD PTR __Ncopied$225176[ebp], edx

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], edx

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	shl	ecx, 4
	add	ecx, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$225174[ebp], eax
	call	?_Ufill@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$272487[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T272482[ebp], 0
	mov	ecx, DWORD PTR $T272482[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$225174[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	mov	DWORD PTR __Ncopied$225176[ebp], 1
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$225175[ebp]
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	eax, edi
	mov	BYTE PTR $T272509[ebp], 0
	mov	edx, DWORD PTR $T272509[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$272513[ebp]
	push	edx
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$225174[ebp]
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$225176[ebp], 2
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 4
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN77@Insert_n@8

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR __Cat$272542[ebp]
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	push	esi
	push	ecx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN77@Insert_n@8:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$225174[ebp]
	shl	ebx, 4
	add	ebx, eax

; 1206 : 			_Mylast = _Newvec + _Count;

	shl	edi, 4
	add	edi, eax
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$225176[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$225175[ebp]
	mov	edi, DWORD PTR __Newvec$225174[ebp]
	jle	SHORT $LN7@Insert_n@8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, esi
	shl	eax, 4
	add	eax, edi
	push	eax
	push	edi
	call	?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Destroy
$LN7@Insert_n@8:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@8

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	shl	edx, 4
	add	edx, edi
	shl	esi, 4
	push	edx
	add	esi, edi
	push	esi
	call	?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Destroy
$LN6@Insert_n@8:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN86@Insert_n@8:
$LN10@Insert_n@8:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ecx, DWORD PTR __Where$[ebp]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	sar	ecx, 4
	cmp	ecx, edi
	push	eax
	lea	ecx, DWORD PTR __Tmp$225189[ebp]
	jae	$LN3@Insert_n@8
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR [esi+8]
	mov	ebx, edi
	shl	ebx, 4
	lea	ecx, DWORD PTR [ebx+eax]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@PAV21@00@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Umove<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	edx, eax
	sub	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$225189[ebp]
	push	ecx
	sar	edx, 4
	sub	edi, edx
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR __Tmp$225189[ebp]
	push	eax
	sub	esi, ebx
	push	esi
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z ; std::fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN84@Insert_n@8
__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	eax, 4
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN87@Insert_n@8:
$LN3@Insert_n@8:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ebx, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	shl	edi, 4
	mov	eax, edi
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv516[ebp], eax
	call	??$_Umove@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@1@PAV21@00@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Umove<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR __Where$[ebp]
	push	ebx
	push	edi
	push	ecx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@@stdext@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR tv516[ebp]
	lea	edx, DWORD PTR __Tmp$225199[ebp]
	push	edx
	add	ecx, eax
	push	ecx
	push	eax
	call	??$fill@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0ABV10@@Z ; std::fill<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 24					; 00000018H
$LN84@Insert_n@8:

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$225199[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
$LN1@Insert_n@8:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN83@Insert_n@8:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$225189[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$225199[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__ehhandler$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
PUBLIC	??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$272608 = -4					; size = 1
??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@vector@8
	mov	ecx, DWORD PTR __Cat$272608[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN12@vector@8:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	pop	ecx
	ret	0
??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T272622 = -4						; size = 4
?clear@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T272622[esp+12]
	push	eax
	call	?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -16				; fffffff0H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@14
	xor	esi, esi
	jmp	SHORT $LN4@insert@14
$LN3@insert@14:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 4
$LN4@insert@14:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	shl	esi, 4
	add	esi, DWORD PTR [edi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert
_TEXT	ENDS
PUBLIC	??_7CvReplayInfo@@6B@				; CvReplayInfo::`vftable'
PUBLIC	??0CvReplayInfo@@QAE@XZ				; CvReplayInfo::CvReplayInfo
PUBLIC	??_R4CvReplayInfo@@6B@				; CvReplayInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvReplayInfo@@@8			; CvReplayInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvReplayInfo@@8				; CvReplayInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvReplayInfo@@8				; CvReplayInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvReplayInfo@@8			; CvReplayInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECvReplayInfo@@UAEPAXI@Z:PROC		; CvReplayInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvReplayInfo@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@CvReplayInfo@@8 DD FLAT:??_R0?AVCvReplayInfo@@@8 ; CvReplayInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvReplayInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvReplayInfo@@8
rdata$r	SEGMENT
??_R2CvReplayInfo@@8 DD FLAT:??_R1A@?0A@EA@CvReplayInfo@@8 ; CvReplayInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvReplayInfo@@8
rdata$r	SEGMENT
??_R3CvReplayInfo@@8 DD 00H				; CvReplayInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvReplayInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvReplayInfo@@@8
_DATA	SEGMENT
??_R0?AVCvReplayInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvReplayInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvReplayInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvReplayInfo@@6B@
rdata$r	SEGMENT
??_R4CvReplayInfo@@6B@ DD 00H				; CvReplayInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvReplayInfo@@@8
	DD	FLAT:??_R3CvReplayInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvReplayInfo@@6B@
CONST	SEGMENT
??_7CvReplayInfo@@6B@ DD FLAT:??_R4CvReplayInfo@@6B@	; CvReplayInfo::`vftable'
	DD	FLAT:??_ECvReplayInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvReplayInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0CvReplayInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvReplayInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ??0CvReplayInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvReplayInfo@@QAE@XZ PROC				; CvReplayInfo::CvReplayInfo, COMDAT
; _this$ = ecx

; 56   : {

	push	-1
	push	__ehhandler$??0CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvReplayInfo@@6B@
	mov	DWORD PTR [esi+4], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	or	eax, -1
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+84], edi
	lea	ecx, DWORD PTR [esi+108]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	mov	DWORD PTR [esi+88], eax
	mov	DWORD PTR [esi+96], edi
	mov	DWORD PTR [esi+100], edi
	mov	DWORD PTR [esi+104], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+140], edi
	mov	DWORD PTR [esi+148], edi
	mov	DWORD PTR [esi+152], edi
	mov	DWORD PTR [esi+156], edi
	mov	DWORD PTR [esi+164], edi
	mov	DWORD PTR [esi+168], edi
	mov	DWORD PTR [esi+172], edi
	mov	DWORD PTR [esi+180], edi
	mov	DWORD PTR [esi+184], edi
	mov	DWORD PTR [esi+188], edi
	mov	DWORD PTR [esi+196], edi
	mov	DWORD PTR [esi+200], edi
	mov	DWORD PTR [esi+204], edi

; 57   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+208], edi
	mov	DWORD PTR [esi+212], edi
	mov	DWORD PTR [esi+220], edi
	mov	DWORD PTR [esi+224], edi
	mov	DWORD PTR [esi+228], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	jmp	??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	jmp	??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	jmp	??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
__ehhandler$??0CvReplayInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvReplayInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReplayInfo@@QAE@XZ ENDP				; CvReplayInfo::CvReplayInfo
PUBLIC	??1CvReplayInfo@@UAE@XZ				; CvReplayInfo::~CvReplayInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvReplayInfo@@UAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvReplayInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvReplayInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ??1CvReplayInfo@@UAE@XZ
_TEXT	SEGMENT
__Cat$273836 = -16					; size = 1
__Cat$273775 = -16					; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvReplayInfo@@UAE@XZ PROC				; CvReplayInfo::~CvReplayInfo, COMDAT
; _this$ = ecx

; 60   : {

	push	-1
	push	__ehhandler$??1CvReplayInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvReplayInfo@@6B@

; 61   : };

	mov	eax, DWORD PTR [esi+220]
	lea	edi, DWORD PTR [esi+216]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+36], 7
	cmp	eax, ebx
	je	SHORT $LN23@CvReplayIn
	mov	edx, DWORD PTR __Cat$273775[esp+28]
	mov	ecx, DWORD PTR [edi+8]
	push	edx
	push	edi
	push	ecx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN23@CvReplayIn:
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], ebx
	mov	eax, DWORD PTR [esi+196]
	lea	edi, DWORD PTR [esi+192]
	mov	BYTE PTR __$EHRec$[esp+36], 6
	cmp	eax, ebx
	je	SHORT $LN36@CvReplayIn
	mov	edx, DWORD PTR __Cat$273836[esp+28]
	mov	ecx, DWORD PTR [edi+8]
	push	edx
	push	edi
	push	ecx
	push	eax
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN36@CvReplayIn:
	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], ebx
	mov	BYTE PTR __$EHRec$[esp+36], 5
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	ecx, DWORD PTR [esi+160]
	mov	BYTE PTR __$EHRec$[esp+36], 4
	call	?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
	lea	ecx, DWORD PTR [esi+144]
	mov	BYTE PTR __$EHRec$[esp+36], 3
	call	?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
	lea	ecx, DWORD PTR [esi+108]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, ebx
	je	SHORT $LN52@CvReplayIn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@CvReplayIn:
	mov	DWORD PTR [esi+76], ebx
	mov	DWORD PTR [esi+80], ebx
	mov	DWORD PTR [esi+84], ebx
	mov	eax, DWORD PTR [esi+60]
	cmp	eax, ebx
	je	SHORT $LN59@CvReplayIn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN59@CvReplayIn:
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+60], ebx
	mov	DWORD PTR [esi+64], ebx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	jmp	??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	jmp	??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	jmp	??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
__ehhandler$??1CvReplayInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvReplayInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvReplayInfo@@UAE@XZ ENDP				; CvReplayInfo::~CvReplayInfo
PUBLIC	?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
$T273948 = -4						; size = 1
__Cat$273952 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@8
	xor	eax, eax
	jmp	SHORT $LN10@push_back@8
$LN9@push_back@8:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 4
$LN10@push_back@8:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 4
	cmp	edx, eax
	jae	SHORT $LN2@push_back@8

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$273952[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T273948[esp+12], 0
	mov	eax, DWORD PTR $T273948[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H
	add	edi, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@8:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T274429 = -32						; size = 1
$T274108 = -32						; size = 4
_v$228700 = -28						; size = 16
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
__Cat$274522 = 12					; size = 1
__Cat$274432 = 12					; size = 1
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >, COMDAT

; 83   : {

	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+40]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T274108[esp+52]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	lea	ecx, DWORD PTR _count$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[esp+44]
	xor	ebx, ebx
	mov	DWORD PTR _count$[esp+44], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	ebp, ebp
	cmp	DWORD PTR _count$[esp+40], ebx
	jbe	$LN1@SerializeT@8
	push	edi
$LL125@SerializeT@8:

; 89   : 	{
; 90   : 		ElementType v;

	mov	DWORD PTR _v$228700[esp+52], ebx
	mov	DWORD PTR _v$228700[esp+56], ebx
	mov	DWORD PTR _v$228700[esp+60], ebx

; 91   : 		loadFrom >> v;

	mov	eax, DWORD PTR _loadFrom$[esp+44]
	lea	edx, DWORD PTR _v$228700[esp+48]
	push	edx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	call	??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >

; 92   : 		container.push_back(v);

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 8
	cmp	ecx, ebx
	jne	SHORT $LN70@SerializeT@8
	xor	eax, eax
	jmp	SHORT $LN71@SerializeT@8
$LN70@SerializeT@8:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 4
$LN71@SerializeT@8:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 4
	cmp	edx, eax
	jae	SHORT $LN63@SerializeT@8
	mov	ecx, DWORD PTR __Cat$274432[esp+44]
	mov	BYTE PTR $T274429[esp+48], bl
	mov	eax, DWORD PTR $T274429[esp+48]
	push	eax
	push	ecx
	push	esi
	lea	edx, DWORD PTR _v$228700[esp+60]
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H
	add	edi, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN104@SerializeT@8
$LN63@SerializeT@8:
	lea	eax, DWORD PTR _v$228700[esp+48]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
$LN104@SerializeT@8:

; 93   : 	}

	mov	edi, DWORD PTR _v$228700[esp+52]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	cmp	edi, ebx
	je	SHORT $LN121@SerializeT@8
	mov	ecx, DWORD PTR __Cat$274522[esp+44]
	mov	eax, DWORD PTR _v$228700[esp+56]
	push	ecx
	lea	edx, DWORD PTR _v$228700[esp+52]
	push	edx
	push	eax
	push	edi
	call	??$_Destroy_range@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@0AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN121@SerializeT@8:
	inc	ebp
	mov	DWORD PTR _v$228700[esp+52], ebx
	mov	DWORD PTR _v$228700[esp+56], ebx
	mov	DWORD PTR _v$228700[esp+60], ebx
	cmp	ebp, DWORD PTR _count$[esp+44]
	jb	$LL125@SerializeT@8
	pop	edi
$LN1@SerializeT@8:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228700[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__ehhandler$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvReplayInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvReplayInfo@@UAEPAXI@Z PROC			; CvReplayInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvReplayInfo@@UAE@XZ			; CvReplayInfo::~CvReplayInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@11
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@11:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvReplayInfo@@UAEPAXI@Z ENDP			; CvReplayInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?createInfo@CvReplayInfo@@QAEXXZ		; CvReplayInfo::createInfo
EXTRN	?isNWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNWOfRiver
EXTRN	?isWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isWOfRiver
EXTRN	?isNEOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNEOfRiver
EXTRN	?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z:PROC ; CvReplayMessage::setPlayer
EXTRN	?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ:PROC ; CvReplayMessage::getPlayer
EXTRN	?getReplayMessage@CvGame@@QBEPBVCvReplayMessage@@I@Z:PROC ; CvGame::getReplayMessage
EXTRN	?getNumReplayMessages@CvGame@@QBEIXZ:PROC	; CvGame::getNumReplayMessages
EXTRN	?getReplayDataHistory@CvPlayer@@QBE?AV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@I@Z:PROC ; CvPlayer::getReplayDataHistory
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:PROC
EXTRN	?getReplayDataSetName@CvPlayer@@QBEPBDI@Z:PROC	; CvPlayer::getReplayDataSetName
EXTRN	?getNumReplayDataSets@CvPlayer@@QBEIXZ:PROC	; CvPlayer::getNumReplayDataSets
EXTRN	?getPlayerColor@CvPlayer@@QBE?AW4PlayerColorTypes@@XZ:PROC ; CvPlayer::getPlayerColor
EXTRN	?getCivilizationAdjective@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationAdjective
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getCivilizationDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationDescription
EXTRN	?getName@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getName
EXTRN	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ:PROC ; CvPlayer::getHandicapType
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?getLeaderType@CvPlayer@@QBE?AW4LeaderHeadTypes@@XZ:PROC ; CvPlayer::getLeaderType
EXTRN	?GatherPerTurnReplayStats@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::GatherPerTurnReplayStats
EXTRN	?setYearStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z:PROC ; CvGameTextMgr::setYearStr
EXTRN	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ:PROC ; CvGame::getCalendar
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getStartYear@CvGame@@QBEHXZ:PROC		; CvGame::getStartYear
EXTRN	?getStartTurn@CvGame@@QBEHXZ:PROC		; CvGame::getStartTurn
EXTRN	?GetScore@CvPlayer@@QBEH_N0@Z:PROC		; CvPlayer::GetScore
EXTRN	?getVictory@CvGame@@QBE?AW4VictoryTypes@@XZ:PROC ; CvGame::getVictory
EXTRN	?getWinner@CvGame@@QBE?AW4TeamTypes@@XZ:PROC	; CvGame::getWinner
EXTRN	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z:PROC ; CvGame::isVictoryValid
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ:PROC ; CvGame::getGameSpeedType
EXTRN	?era@CvPreGame@@YA?AW4EraTypes@@XZ:PROC		; CvPreGame::era
EXTRN	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ:PROC ; CvPreGame::seaLevel
EXTRN	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ:PROC	; CvPreGame::climate
EXTRN	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ:PROC ; CvPreGame::worldSize
EXTRN	?mapScriptName@CvPreGame@@YAABVCvString@@XZ:PROC ; CvPreGame::mapScriptName
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?createInfo@CvReplayInfo@@QAEXXZ DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$?createInfo@CvReplayInfo@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?createInfo@CvReplayInfo@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$9
	DD	00H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$10
	DD	01H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$0
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$18
	DD	04H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$19
	DD	05H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$20
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$1
	DD	07H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$2
	DD	08H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$3
	DD	09H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$4
	DD	09H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$5
	DD	0bH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$32
	DD	0dH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$33
	DD	0eH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$34
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$40
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$7
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ?createInfo@CvReplayInfo@@QAEXXZ
_TEXT	SEGMENT
tv3561 = -352						; size = 4
tv3544 = -352						; size = 4
$T276059 = -352						; size = 4
$T275683 = -352						; size = 4
$T275348 = -352						; size = 4
_i$220356 = -352					; size = 4
_uiPlayerDataSet$220213 = -352				; size = 4
_i$219692 = -352					; size = 4
$T276473 = -348						; size = 1
$T276222 = -348						; size = 1
$T275158 = -348						; size = 1
tv1436 = -348						; size = 4
__Ptr$276486 = -348					; size = 4
$T276058 = -348						; size = 4
$T275410 = -348						; size = 4
_player$220206 = -348					; size = 4
$T274546 = -348						; size = 4
_eOption$219689 = -348					; size = 4
$T275684 = -344						; size = 4
$T275349 = -344						; size = 4
_iPlayer$220202 = -344					; size = 4
_eActivePlayer$ = -344					; size = 4
$T279571 = -340						; size = 1
$T278641 = -340						; size = 1
__Cat$276492 = -340					; size = 1
__Cat$276477 = -340					; size = 1
$T276475 = -340						; size = 1
__Cat$276227 = -340					; size = 1
$T276224 = -340						; size = 1
__Cat$275832 = -340					; size = 1
__Cat$275162 = -340					; size = 1
$T274551 = -340						; size = 4
$T274550 = -340						; size = 4
__Ptr$276265 = -336					; size = 4
_iPlayerIndex$ = -336					; size = 4
_eVictory$219696 = -336					; size = 4
_plotStatePerTurn$220956 = -332				; size = 12
_turnData$220229 = -332					; size = 12
_game$ = -320						; size = 4
__Cat$279586 = -316					; size = 1
__Cat$279575 = -316					; size = 1
$T279573 = -316						; size = 1
$T280188 = -316						; size = 4
$T280021 = -316						; size = 4
$T279201 = -316						; size = 4
$T279319 = -316						; size = 4
$T278405 = -312						; size = 1
_kMap$ = -312						; size = 4
_nMessages$ = -312					; size = 4
_plotState$220371 = -308				; size = 16
_dataSet$220211 = -308					; size = 16
_this$ = -292						; size = 4
_mapPlayers$ = -288					; size = 12
$T274547 = -276						; size = 12
__Cat$278644 = -264					; size = 1
__Cat$278408 = -264					; size = 1
$T278217 = -264						; size = 4
_playerData$220227 = -260				; size = 12
_uiNumDataSets$220212 = -248				; size = 4
$T274549 = -244						; size = 4
$T277888 = -240						; size = 4
$T277266 = -236						; size = 4
$T278048 = -232						; size = 4
_playerInfo$220210 = -228				; size = 128
_modifiedMessage$220362 = -100				; size = 60
_playerDataSetName$220217 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?createInfo@CvReplayInfo@@QAEXXZ PROC			; CvReplayInfo::createInfo, COMDAT
; _this$ = ecx

; 64   : {

	push	-1
	push	__ehhandler$?createInfo@CvReplayInfo@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 65   : 	CvGame& game = GC.getGame();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, ecx

; 66   : 
; 67   : 	const PlayerTypes eActivePlayer = game.getActivePlayer();

	mov	ecx, edi
	mov	DWORD PTR _this$[esp+368], ebp
	mov	DWORD PTR _game$[esp+368], edi
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[esp+368], eax

; 68   : 
; 69   : 	m_strMapScriptName = CvPreGame::mapScriptName();

	call	?mapScriptName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::mapScriptName
	lea	ecx, DWORD PTR [ebp+8]
	push	eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 70   : 	m_eWorldSize = CvPreGame::worldSize();

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	mov	DWORD PTR [ebp+36], eax

; 71   : 	m_eClimate = CvPreGame::climate();

	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
	mov	DWORD PTR [ebp+40], eax

; 72   : 	m_eSeaLevel = CvPreGame::seaLevel();

	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
	mov	DWORD PTR [ebp+44], eax

; 73   : 	m_eEra = CvPreGame::era();

	call	?era@CvPreGame@@YA?AW4EraTypes@@XZ	; CvPreGame::era

; 74   : 	m_eGameSpeed = game.getGameSpeedType();

	mov	ecx, edi
	mov	DWORD PTR [ebp+48], eax
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	mov	DWORD PTR [ebp+52], eax

; 75   : 
; 76   : 	m_listGameOptions.clear();

	mov	eax, DWORD PTR [ebp+64]
	mov	edx, DWORD PTR [ebp+60]
	cmp	edx, eax
	je	SHORT $LN63@createInfo
	mov	ecx, eax
	cmp	eax, eax
	je	SHORT $LN88@createInfo
$LL90@createInfo:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	add	ecx, 4
	add	edx, 4
	cmp	ecx, eax
	jne	SHORT $LL90@createInfo
$LN88@createInfo:
	mov	DWORD PTR [ebp+64], edx
$LN63@createInfo:

; 77   : 	for(int i = 0; i < NUM_GAMEOPTION_TYPES; i++)

	xor	ebx, ebx
	xor	esi, esi
$LL33@createInfo:

; 78   : 	{
; 79   : 		GameOptionTypes eOption = (GameOptionTypes)i;
; 80   : 		if(game.isOption(eOption))

	push	esi
	mov	ecx, edi
	mov	DWORD PTR _eOption$219689[esp+372], esi
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN32@createInfo

; 81   : 		{
; 82   : 			m_listGameOptions.push_back(eOption);

	lea	eax, DWORD PTR _eOption$219689[esp+368]
	push	eax
	lea	ecx, DWORD PTR [ebp+56]
	call	?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back
$LN32@createInfo:
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL33@createInfo

; 83   : 		}
; 84   : 	}
; 85   : 
; 86   : 	m_listVictoryTypes.clear();

	mov	ecx, DWORD PTR [ebp+80]
	mov	edx, DWORD PTR [ebp+76]
	lea	esi, DWORD PTR [ebp+72]
	cmp	edx, ecx
	je	SHORT $LN107@createInfo
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN132@createInfo
	npad	2
$LL134@createInfo:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL134@createInfo
$LN132@createInfo:
	mov	DWORD PTR [esi+8], edx
$LN107@createInfo:

; 87   : #ifdef AUI_WARNING_FIXES
; 88   : 	for (uint i = 0; i < GC.getNumVictoryInfos(); i++)
; 89   : #else
; 90   : 	for(int i = 0; i < GC.getNumVictoryInfos(); i++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _i$219692[esp+368], edi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	test	eax, eax
	jle	$LN27@createInfo
	npad	7
$LL29@createInfo:

; 91   : #endif
; 92   : 	{
; 93   : 		VictoryTypes eVictory = (VictoryTypes)i;
; 94   : 		if(game.isVictoryValid(eVictory))

	mov	ecx, DWORD PTR _game$[esp+368]
	push	edi
	mov	DWORD PTR _eVictory$219696[esp+372], edi
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	test	al, al
	je	SHORT $LN28@createInfo

; 95   : 		{
; 96   : 			m_listVictoryTypes.push_back(eVictory);

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	jne	SHORT $LN145@createInfo
	xor	eax, eax
	jmp	SHORT $LN146@createInfo
$LN145@createInfo:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN146@createInfo:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN138@createInfo
	mov	ecx, DWORD PTR __Cat$275162[esp+368]
	mov	BYTE PTR $T275158[esp+368], bl
	mov	eax, DWORD PTR $T275158[esp+368]
	push	eax
	push	ecx
	push	esi
	lea	edx, DWORD PTR _eVictory$219696[esp+380]
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN1219@createInfo
$LN138@createInfo:
	lea	eax, DWORD PTR _eVictory$219696[esp+368]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
$LN1219@createInfo:
	mov	edi, DWORD PTR _i$219692[esp+368]
$LN28@createInfo:

; 87   : #ifdef AUI_WARNING_FIXES
; 88   : 	for (uint i = 0; i < GC.getNumVictoryInfos(); i++)
; 89   : #else
; 90   : 	for(int i = 0; i < GC.getNumVictoryInfos(); i++)

	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _i$219692[esp+368], edi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	edi, eax
	jl	SHORT $LL29@createInfo
$LN27@createInfo:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	m_eVictoryType = NO_VICTORY;
; 101  : 	m_iNormalizedScore = 0;
; 102  : 	if(NO_PLAYER != eActivePlayer)

	mov	eax, DWORD PTR _eActivePlayer$[esp+368]
	or	edi, -1
	mov	DWORD PTR [ebp+88], edi
	mov	DWORD PTR [ebp+140], ebx
	cmp	eax, edi
	je	SHORT $LN25@createInfo

; 103  : 	{
; 104  : 		CvPlayer& player = GET_PLAYER(eActivePlayer);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax

; 105  : 		if(game.getWinner() == player.getTeam())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN191@createInfo
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
$LN191@createInfo:
	mov	ecx, DWORD PTR _game$[esp+368]
	call	?getWinner@CvGame@@QBE?AW4TeamTypes@@XZ	; CvGame::getWinner
	cmp	eax, edi
	jne	SHORT $LN24@createInfo

; 106  : 		{
; 107  : 			m_eVictoryType = game.getVictory();

	mov	ecx, DWORD PTR _game$[esp+368]
	call	?getVictory@CvGame@@QBE?AW4VictoryTypes@@XZ ; CvGame::getVictory
	mov	DWORD PTR [ebp+88], eax
$LN24@createInfo:

; 108  : 		}
; 109  : 
; 110  : 		m_iNormalizedScore = player.GetScore(true, player.getTeam() == game.getWinner());

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN200@createInfo
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN201@createInfo
$LN200@createInfo:
	or	edi, -1
$LN201@createInfo:
	mov	ecx, DWORD PTR _game$[esp+368]
	call	?getWinner@CvGame@@QBE?AW4TeamTypes@@XZ	; CvGame::getWinner
	cmp	edi, eax
	sete	al
	movzx	ecx, al
	push	ecx
	push	1
	mov	ecx, esi
	call	?GetScore@CvPlayer@@QBEH_N0@Z		; CvPlayer::GetScore
	mov	DWORD PTR [ebp+140], eax
$LN25@createInfo:

; 111  : 	}
; 112  : 
; 113  : 	//m_eGameType = CvPreGame::getGameType();
; 114  : 
; 115  : 	m_iInitialTurn = game.getStartTurn();

	mov	edi, DWORD PTR _game$[esp+368]
	mov	ecx, edi
	call	?getStartTurn@CvGame@@QBEHXZ		; CvGame::getStartTurn

; 116  : 	m_iStartYear = game.getStartYear();

	mov	ecx, edi
	mov	DWORD PTR [ebp+96], eax
	call	?getStartYear@CvGame@@QBEHXZ		; CvGame::getStartYear

; 117  : 	m_iFinalTurn = game.getGameTurn();

	mov	ecx, edi
	mov	DWORD PTR [ebp+104], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 118  : 	CvGameTextMgr::setYearStr(m_strFinalDate, m_iFinalTurn, false, game.getCalendar(), game.getStartYear(), game.getGameSpeedType());

	mov	ecx, edi
	mov	DWORD PTR [ebp+100], eax
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	push	eax
	mov	ecx, edi
	call	?getStartYear@CvGame@@QBEHXZ		; CvGame::getStartYear
	push	eax
	mov	ecx, edi
	call	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ ; CvGame::getCalendar
	mov	edx, DWORD PTR [ebp+100]
	push	eax
	push	ebx
	push	edx
	lea	eax, DWORD PTR [ebp+108]
	push	eax
	call	?setYearStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z ; CvGameTextMgr::setYearStr
	add	esp, 24					; 00000018H

; 119  : 
; 120  : 	m_eCalendar = game.getCalendar();

	mov	ecx, edi
	call	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ ; CvGame::getCalendar

; 121  : 
; 122  : 	m_dataSetMap.clear();

	lea	edi, DWORD PTR [ebp+176]
	mov	DWORD PTR [ebp+136], eax
	mov	esi, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, esi
	je	SHORT $LN219@createInfo
	mov	DWORD PTR $T275349[esp+368], eax
	mov	DWORD PTR $T275348[esp+368], esi
	cmp	esi, esi
	je	SHORT $LN244@createInfo
	npad	3
$LL246@createInfo:
	mov	ecx, DWORD PTR $T275348[esp+368]
	push	ecx
	mov	ecx, DWORD PTR $T275349[esp+372]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR $T275348[esp+368]
	add	DWORD PTR $T275349[esp+368], 28		; 0000001cH
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T275348[esp+368], eax
	cmp	eax, esi
	jne	SHORT $LL246@createInfo
$LN244@createInfo:
	mov	eax, DWORD PTR [edi+8]
	mov	esi, DWORD PTR $T275349[esp+368]
	mov	DWORD PTR $T275410[esp+368], eax
	cmp	esi, eax
	je	SHORT $LN255@createInfo
$LL257@createInfo:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, DWORD PTR $T275410[esp+368]
	jne	SHORT $LL257@createInfo
	mov	esi, DWORD PTR $T275349[esp+368]
$LN255@createInfo:
	mov	DWORD PTR [edi+8], esi
$LN219@createInfo:

; 123  : 	m_listPlayerDataSets.clear();

	mov	esi, DWORD PTR [ebp+200]
	mov	eax, DWORD PTR [ebp+196]
	cmp	eax, esi
	je	SHORT $LN281@createInfo
	mov	DWORD PTR $T275684[esp+368], eax
	mov	DWORD PTR $T275683[esp+368], esi
	cmp	esi, esi
	je	SHORT $LN306@createInfo
$LL308@createInfo:
	mov	edx, DWORD PTR $T275683[esp+368]
	mov	ecx, DWORD PTR $T275684[esp+368]
	push	edx
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	mov	eax, DWORD PTR $T275683[esp+368]
	add	DWORD PTR $T275684[esp+368], 16		; 00000010H
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T275683[esp+368], eax
	cmp	eax, esi
	jne	SHORT $LL308@createInfo
$LN306@createInfo:
	mov	ecx, DWORD PTR __Cat$275832[esp+368]
	mov	eax, DWORD PTR [ebp+200]
	mov	edx, DWORD PTR $T275684[esp+368]
	push	ecx
	lea	esi, DWORD PTR [ebp+192]
	push	esi
	push	eax
	push	edx
	call	??$_Destroy_range@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	mov	eax, DWORD PTR $T275684[esp+384]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], eax
$LN281@createInfo:

; 124  : 	m_listPlayerInfo.clear();

	mov	eax, DWORD PTR [ebp+152]
	mov	ecx, DWORD PTR [ebp+148]
	cmp	ecx, eax
	je	$LN331@createInfo
	mov	BYTE PTR $T276222[esp+368], bl
	mov	edx, DWORD PTR $T276222[esp+368]
	push	edx
	mov	edx, DWORD PTR __Cat$276227[esp+372]
	push	edx
	mov	edx, DWORD PTR $T276224[esp+376]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR [ebp+152]
	add	esp, 24					; 00000018H
	mov	esi, eax
	mov	DWORD PTR __Ptr$276265[esp+368], eax
	mov	DWORD PTR $T276059[esp+368], ecx
	mov	DWORD PTR $T276058[esp+368], esi
	cmp	eax, ecx
	je	SHORT $LN362@createInfo
	npad	7
$LL364@createInfo:
	lea	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR __$EHRec$[esp+376], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+72]
	mov	BYTE PTR __$EHRec$[esp+376], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+44]
	mov	BYTE PTR __$EHRec$[esp+376], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __$EHRec$[esp+376], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	sub	esi, -128				; ffffff80H
	mov	DWORD PTR $T276058[esp+368], esi
	cmp	esi, DWORD PTR $T276059[esp+368]
	jne	SHORT $LL364@createInfo
$LN362@createInfo:
	mov	eax, DWORD PTR __Ptr$276265[esp+368]
	mov	DWORD PTR [ebp+152], eax
$LN331@createInfo:

; 125  : #ifndef AUI_WARNING_FIXES
; 126  : 	m_listPlots.clear();

	mov	eax, DWORD PTR [ebp+224]
	mov	ecx, DWORD PTR [ebp+220]
	lea	esi, DWORD PTR [ebp+216]
	cmp	ecx, eax
	je	SHORT $LN406@createInfo
	mov	BYTE PTR $T276473[esp+368], bl
	mov	edx, DWORD PTR $T276473[esp+368]
	push	edx
	mov	edx, DWORD PTR __Cat$276477[esp+372]
	push	edx
	mov	edx, DWORD PTR $T276475[esp+376]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Cat$276492[esp+392]
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	DWORD PTR __Ptr$276486[esp+408], eax
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	mov	eax, DWORD PTR __Ptr$276486[esp+408]
	add	esp, 40					; 00000028H
	mov	DWORD PTR [esi+8], eax
$LN406@createInfo:

; 127  : #endif
; 128  : 
; 129  : 	std::map<int, int> mapPlayers;

	lea	ecx, DWORD PTR _mapPlayers$[esp+368]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR _mapPlayers$[esp+372], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR _mapPlayers$[esp+372]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _mapPlayers$[esp+372]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _mapPlayers$[esp+372]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR _mapPlayers$[esp+376], ebx

; 130  : 	mapPlayers[-1] = -1;	//account for NO_PLAYER.

	lea	ecx, DWORD PTR $T274546[esp+368]
	or	esi, -1
	push	ecx
	lea	ecx, DWORD PTR _mapPlayers$[esp+372]
	mov	DWORD PTR __$EHRec$[esp+380], 3
	mov	DWORD PTR $T274546[esp+372], esi
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	DWORD PTR [eax], esi

; 131  : 
; 132  : 	m_iActivePlayer = -1;

	mov	DWORD PTR [ebp+4], esi

; 133  : 	int iPlayerIndex = 0;

	mov	DWORD PTR _iPlayerIndex$[esp+368], ebx

; 134  : 	for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)

	mov	DWORD PTR _iPlayer$220202[esp+368], ebx
	mov	eax, ebx
	npad	9
$LL23@createInfo:

; 135  : 	{
; 136  : 		CvPlayer& player = GET_PLAYER((PlayerTypes)iPlayer);

	mov	esi, eax
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _player$220206[esp+368], esi

; 137  : 		if(player.isEverAlive())

	cmp	BYTE PTR [esi+2268], bl
	je	$LN22@createInfo

; 138  : 		{
; 139  : 			//Ensure that final turn is stored.
; 140  : 			player.GatherPerTurnReplayStats(m_iFinalTurn);

	mov	edx, DWORD PTR [ebp+100]
	push	edx
	mov	ecx, esi
	call	?GatherPerTurnReplayStats@CvPlayer@@QAEXH@Z ; CvPlayer::GatherPerTurnReplayStats

; 141  : 
; 142  : 			mapPlayers[iPlayer] = iPlayerIndex;

	lea	eax, DWORD PTR _iPlayer$220202[esp+368]
	push	eax
	lea	ecx, DWORD PTR _mapPlayers$[esp+372]
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	ecx, DWORD PTR _iPlayerIndex$[esp+368]
	mov	DWORD PTR [eax], ecx

; 143  : 			if(iPlayer == game.getActivePlayer())

	mov	ecx, DWORD PTR _game$[esp+368]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _iPlayer$220202[esp+368], eax
	jne	SHORT $LN19@createInfo

; 144  : 			{
; 145  : 				m_iActivePlayer = iPlayerIndex;

	mov	edx, DWORD PTR _iPlayerIndex$[esp+368]
	mov	DWORD PTR [ebp+4], edx
$LN19@createInfo:

; 146  : 			}
; 147  : 			++iPlayerIndex;

	inc	DWORD PTR _iPlayerIndex$[esp+368]

; 148  : 
; 149  : 			PlayerInfo playerInfo;

	lea	ecx, DWORD PTR _playerInfo$220210[esp+384]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerInfo$220210[esp+412]
	mov	BYTE PTR __$EHRec$[esp+376], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerInfo$220210[esp+440]
	mov	BYTE PTR __$EHRec$[esp+376], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerInfo$220210[esp+468]
	mov	BYTE PTR __$EHRec$[esp+376], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 150  : 			playerInfo.m_eLeader = player.getLeaderType();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+376], 7
	call	?getLeaderType@CvPlayer@@QBE?AW4LeaderHeadTypes@@XZ ; CvPlayer::getLeaderType

; 151  : 			playerInfo.m_eCivilization = player.getCivilizationType();

	mov	ecx, esi
	mov	DWORD PTR _playerInfo$220210[esp+372], eax
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType

; 152  : 
; 153  : 			playerInfo.m_eDifficulty = player.getHandicapType();

	mov	ecx, esi
	mov	DWORD PTR _playerInfo$220210[esp+368], eax
	call	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ ; CvPlayer::getHandicapType

; 154  : 			playerInfo.m_strCustomLeaderName = player.getName();

	mov	ecx, esi
	mov	DWORD PTR _playerInfo$220210[esp+380], eax
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	lea	ecx, DWORD PTR _playerInfo$220210[esp+384]
	cmp	eax, ebx
	je	SHORT $LN511@createInfo
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN510@createInfo
$LN511@createInfo:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN510@createInfo:

; 155  : 			playerInfo.m_strCustomCivilizationName = player.getCivilizationDescription();

	mov	ecx, esi
	call	?getCivilizationDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationDescription
	lea	ecx, DWORD PTR _playerInfo$220210[esp+412]
	cmp	eax, ebx
	je	SHORT $LN515@createInfo
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN514@createInfo
$LN515@createInfo:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN514@createInfo:

; 156  : 			playerInfo.m_strCustomCivilizationShortName = player.getCivilizationShortDescription();

	mov	ecx, esi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerInfo$220210[esp+440]
	cmp	eax, ebx
	je	SHORT $LN519@createInfo
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN518@createInfo
$LN519@createInfo:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN518@createInfo:

; 157  : 			playerInfo.m_strCustomCivilizationAdjective = player.getCivilizationAdjective();

	mov	ecx, esi
	call	?getCivilizationAdjective@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjective
	lea	ecx, DWORD PTR _playerInfo$220210[esp+468]
	cmp	eax, ebx
	je	SHORT $LN523@createInfo
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN522@createInfo
$LN523@createInfo:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN522@createInfo:

; 158  : 			playerInfo.m_ePlayerColor = player.getPlayerColor();

	mov	ecx, esi
	call	?getPlayerColor@CvPlayer@@QBE?AW4PlayerColorTypes@@XZ ; CvPlayer::getPlayerColor

; 159  : 
; 160  : 
; 161  : 			TurnDataSets dataSet(m_dataSetMap.size());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _playerInfo$220210[esp+376], eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR _dataSet$220211[esp+372]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >

; 162  : 
; 163  : 			unsigned int uiNumDataSets = player.getNumReplayDataSets();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+376], 8
	call	?getNumReplayDataSets@CvPlayer@@QBEIXZ	; CvPlayer::getNumReplayDataSets
	mov	DWORD PTR _uiNumDataSets$220212[esp+368], eax

; 164  : 			for(unsigned int uiPlayerDataSet = 0; uiPlayerDataSet < uiNumDataSets; ++uiPlayerDataSet)

	mov	DWORD PTR _uiPlayerDataSet$220213[esp+368], ebx
	cmp	eax, ebx
	jbe	$LN1217@createInfo
	npad	7
$LL18@createInfo:

; 165  : 			{
; 166  : 				// First, Locate the index of the dataset
; 167  : 				std::string playerDataSetName = player.getReplayDataSetName(uiPlayerDataSet);

	mov	eax, DWORD PTR _uiPlayerDataSet$220213[esp+368]
	mov	ecx, DWORD PTR _player$220206[esp+368]
	push	eax
	call	?getReplayDataSetName@CvPlayer@@QBEPBDI@Z ; CvPlayer::getReplayDataSetName
	push	eax
	lea	ecx, DWORD PTR _playerDataSetName$220217[esp+372]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 168  : 				unsigned int uiDataSet = 0;
; 169  : 				bool bFound = false;
; 170  : 				for(uiDataSet = 0; uiDataSet < m_dataSetMap.size(); ++uiDataSet)

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	xor	ebp, ebp
	add	ecx, edx
	mov	BYTE PTR __$EHRec$[esp+376], 9
	je	SHORT $LN1216@createInfo

; 159  : 
; 160  : 
; 161  : 			TurnDataSets dataSet(m_dataSetMap.size());

	xor	esi, esi
$LL15@createInfo:

; 171  : 				{
; 172  : 					const std::string& dataSetName = m_dataSetMap[uiDataSet];

	mov	edx, DWORD PTR _this$[esp+368]
	mov	eax, DWORD PTR [edx+180]

; 173  : 					if(dataSetName == playerDataSetName)

	lea	ecx, DWORD PTR _playerDataSetName$220217[esp+368]
	add	eax, esi
	push	ecx
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	jne	$LN11@createInfo
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebp
	add	eax, edx
	add	esi, 28					; 0000001cH
	cmp	ebp, eax
	jb	SHORT $LL15@createInfo
$LN1216@createInfo:

; 174  : 					{
; 175  : 						bFound = true;
; 176  : 						break;
; 177  : 					}
; 178  : 				}
; 179  : 
; 180  : 				// Add a new index if one doesn't exist.
; 181  : 				if(!bFound)
; 182  : 				{
; 183  : 					m_dataSetMap.push_back(playerDataSetName);

	lea	ecx, DWORD PTR _playerDataSetName$220217[esp+368]
	push	ecx
	mov	ecx, edi
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 184  : 					dataSet.push_back(TurnData());

	lea	ecx, DWORD PTR $T274547[esp+368]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR $T274547[esp+372], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR $T274547[esp+372]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR $T274547[esp+372]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR $T274547[esp+372]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR $T274547[esp+376], ebx
	lea	edx, DWORD PTR $T274547[esp+368]
	push	edx
	lea	ecx, DWORD PTR _dataSet$220211[esp+372]
	mov	BYTE PTR __$EHRec$[esp+380], 10		; 0000000aH
	call	?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back
	mov	eax, DWORD PTR $T274547[esp+372]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T277266[esp+376]
	push	eax
	lea	ecx, DWORD PTR $T274547[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 9
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR $T274547[esp+372]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete

; 185  : 					uiDataSet = m_dataSetMap.size() - 1;

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	add	esp, 4
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR $T274547[esp+372], ebx
	mov	DWORD PTR $T274547[esp+376], ebx
	lea	ebp, DWORD PTR [edx+eax-1]
$LN11@createInfo:

; 186  : 				}
; 187  : 
; 188  : 				CvPlayer::TurnData playerData = player.getReplayDataHistory(uiPlayerDataSet);

	mov	ecx, DWORD PTR _uiPlayerDataSet$220213[esp+368]
	push	ecx
	mov	ecx, DWORD PTR _player$220206[esp+372]
	lea	edx, DWORD PTR _playerData$220227[esp+372]
	push	edx
	call	?getReplayDataHistory@CvPlayer@@QBE?AV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@I@Z ; CvPlayer::getReplayDataHistory

; 189  : 				TurnData turnData;

	lea	ecx, DWORD PTR _turnData$220229[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 11		; 0000000bH
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR _turnData$220229[esp+372], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR _turnData$220229[esp+372]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _turnData$220229[esp+372]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _turnData$220229[esp+372]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR _turnData$220229[esp+376], ebx

; 190  : 
; 191  : 				for(CvPlayer::TurnData::iterator it = playerData.begin(); it != playerData.end(); ++it)

	mov	eax, DWORD PTR _playerData$220227[esp+372]
	mov	esi, DWORD PTR [eax]
	mov	BYTE PTR __$EHRec$[esp+376], 12		; 0000000cH
	cmp	esi, eax
	je	SHORT $LN8@createInfo
	npad	1
$LL679@createInfo:

; 192  : 				{
; 193  : 					turnData[(*it).first - m_iInitialTurn] = (*it).second;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _this$[esp+368]
	sub	eax, DWORD PTR [ecx+96]
	lea	edx, DWORD PTR $T274549[esp+368]
	push	edx
	lea	ecx, DWORD PTR _turnData$220229[esp+372]
	mov	DWORD PTR $T274549[esp+372], eax
	call	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], ecx
	cmp	BYTE PTR [esi+21], bl
	jne	SHORT $LN1210@createInfo
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+21], bl
	jne	SHORT $LN1194@createInfo
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], bl
	jne	SHORT $LN1210@createInfo
	npad	6

; 190  : 
; 191  : 				for(CvPlayer::TurnData::iterator it = playerData.begin(); it != playerData.end(); ++it)

$LL694@createInfo:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], bl
	je	SHORT $LL694@createInfo
	jmp	SHORT $LN1210@createInfo
$LN1194@createInfo:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], bl
	jne	SHORT $LN677@createInfo
$LL678@createInfo:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN677@createInfo
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], bl
	je	SHORT $LL678@createInfo
$LN677@createInfo:
	mov	esi, eax
$LN1210@createInfo:
	cmp	esi, DWORD PTR _playerData$220227[esp+372]
	jne	SHORT $LL679@createInfo
$LN8@createInfo:

; 194  : 				}
; 195  : 
; 196  : 				dataSet[uiDataSet] = turnData;

	mov	eax, DWORD PTR _dataSet$220211[esp+372]
	lea	edx, DWORD PTR [ebp+ebp*2]
	lea	esi, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR _turnData$220229[esp+368]
	cmp	esi, ecx
	je	SHORT $LN735@createInfo
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T277888[esp+376]
	push	edx
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	lea	eax, DWORD PTR _turnData$220229[esp+368]
	push	eax
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN735@createInfo:

; 197  : 			}

	mov	eax, DWORD PTR _turnData$220229[esp+372]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T278048[esp+376]
	push	ecx
	lea	ecx, DWORD PTR _turnData$220229[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 11		; 0000000bH
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	edx, DWORD PTR _turnData$220229[esp+372]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _playerData$220227[esp+376]
	add	esp, 4
	push	eax
	mov	DWORD PTR _turnData$220229[esp+376], ebx
	mov	DWORD PTR _turnData$220229[esp+380], ebx
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	eax, DWORD PTR $T278217[esp+376]
	push	eax
	lea	ecx, DWORD PTR _playerData$220227[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 9
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR _playerData$220227[esp+372]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR _playerDataSetName$220217[esp+368]
	mov	DWORD PTR _playerData$220227[esp+372], ebx
	mov	DWORD PTR _playerData$220227[esp+376], ebx
	mov	BYTE PTR __$EHRec$[esp+376], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _uiPlayerDataSet$220213[esp+368]
	inc	eax
	mov	DWORD PTR _uiPlayerDataSet$220213[esp+368], eax
	cmp	eax, DWORD PTR _uiNumDataSets$220212[esp+368]
	jb	$LL18@createInfo

; 164  : 			for(unsigned int uiPlayerDataSet = 0; uiPlayerDataSet < uiNumDataSets; ++uiPlayerDataSet)

	mov	ebp, DWORD PTR _this$[esp+368]
$LN1217@createInfo:

; 198  : 
; 199  : 			m_listPlayerDataSets.push_back(dataSet);

	mov	ecx, DWORD PTR [ebp+196]
	lea	esi, DWORD PTR [ebp+192]
	cmp	ecx, ebx
	jne	SHORT $LN824@createInfo
	xor	eax, eax
	jmp	SHORT $LN825@createInfo
$LN824@createInfo:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 4
$LN825@createInfo:
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR tv3544[esp+368], edx
	sub	edx, ecx
	sar	edx, 4
	lea	ecx, DWORD PTR _dataSet$220211[esp+368]
	cmp	edx, eax
	jae	SHORT $LN817@createInfo
	mov	eax, DWORD PTR __Cat$278408[esp+368]
	mov	BYTE PTR $T278405[esp+368], bl
	mov	edx, DWORD PTR $T278405[esp+368]
	push	edx
	mov	edx, DWORD PTR tv3544[esp+372]
	push	eax
	push	esi
	push	ecx
	push	1
	push	edx
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	mov	eax, DWORD PTR tv3544[esp+392]
	add	esp, 24					; 00000018H
	add	eax, 16					; 00000010H
	mov	DWORD PTR [esi+8], eax
	jmp	SHORT $LN858@createInfo
$LN817@createInfo:
	mov	edx, DWORD PTR tv3544[esp+368]
	push	ecx
	push	1
	push	edx
	mov	ecx, esi
	call	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
$LN858@createInfo:

; 200  : 			m_listPlayerInfo.push_back(playerInfo);

	mov	ecx, DWORD PTR [ebp+148]
	lea	esi, DWORD PTR [ebp+144]
	cmp	ecx, ebx
	jne	SHORT $LN872@createInfo
	xor	eax, eax
	jmp	SHORT $LN873@createInfo
$LN872@createInfo:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 7
$LN873@createInfo:
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR tv3561[esp+368], edx
	sub	edx, ecx
	sar	edx, 7
	cmp	edx, eax
	lea	edx, DWORD PTR _playerInfo$220210[esp+368]
	jae	SHORT $LN865@createInfo
	mov	ecx, DWORD PTR __Cat$278644[esp+368]
	mov	BYTE PTR $T278641[esp+368], bl
	mov	eax, DWORD PTR $T278641[esp+368]
	push	eax
	mov	eax, DWORD PTR tv3561[esp+372]
	push	ecx
	push	esi
	push	edx
	push	1
	push	eax
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
	mov	ecx, DWORD PTR tv3561[esp+392]
	add	esp, 24					; 00000018H
	sub	ecx, -128				; ffffff80H
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN906@createInfo
$LN865@createInfo:
	mov	eax, DWORD PTR tv3561[esp+368]
	push	edx
	push	1
	push	eax
	mov	ecx, esi
	call	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
$LN906@createInfo:

; 201  : 		}

	mov	BYTE PTR __$EHRec$[esp+376], 7
	cmp	DWORD PTR _dataSet$220211[esp+372], ebx
	je	SHORT $LN966@createInfo
	mov	ecx, DWORD PTR _dataSet$220211[esp+372]
	cmp	ecx, DWORD PTR _dataSet$220211[esp+376]
	je	SHORT $LN923@createInfo
	mov	esi, ecx
	add	esi, 4
$LL925@createInfo:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T279201[esp+376]
	push	edx
	lea	ecx, DWORD PTR [esi-4]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	add	esi, 12					; 0000000cH
	lea	eax, DWORD PTR [esi-4]
	add	esp, 4
	cmp	eax, DWORD PTR _dataSet$220211[esp+376]
	jne	SHORT $LL925@createInfo
$LN923@createInfo:
	mov	ecx, DWORD PTR _dataSet$220211[esp+372]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN966@createInfo:
	mov	DWORD PTR _dataSet$220211[esp+372], ebx
	mov	DWORD PTR _dataSet$220211[esp+376], ebx
	mov	DWORD PTR _dataSet$220211[esp+380], ebx
	lea	ecx, DWORD PTR _playerInfo$220210[esp+468]
	mov	BYTE PTR __$EHRec$[esp+376], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerInfo$220210[esp+440]
	mov	BYTE PTR __$EHRec$[esp+376], 14		; 0000000eH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerInfo$220210[esp+412]
	mov	BYTE PTR __$EHRec$[esp+376], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerInfo$220210[esp+384]
	mov	BYTE PTR __$EHRec$[esp+376], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _iPlayer$220202[esp+368]
$LN22@createInfo:
	inc	eax
	cmp	eax, 63					; 0000003fH
	mov	DWORD PTR _iPlayer$220202[esp+368], eax
	jl	$LL23@createInfo

; 202  : 	}
; 203  : 
; 204  : 	m_listReplayMessages.clear();

	mov	eax, DWORD PTR [ebp+168]
	mov	ecx, DWORD PTR [ebp+164]
	lea	edi, DWORD PTR [ebp+160]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T279319[esp+376]
	push	edx
	mov	ecx, edi
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 205  : 	const uint nMessages = game.getNumReplayMessages();

	mov	ecx, DWORD PTR _game$[esp+368]
	call	?getNumReplayMessages@CvGame@@QBEIXZ	; CvGame::getNumReplayMessages
	mov	esi, eax

; 206  : 	m_listReplayMessages.reserve(nMessages);

	push	esi
	mov	ecx, edi
	mov	DWORD PTR _nMessages$[esp+372], esi
	call	?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve

; 207  : 
; 208  : 	for(uint i = 0; i < nMessages; ++i)

	mov	DWORD PTR _i$220356[esp+368], ebx
	cmp	esi, ebx
	jbe	$LN5@createInfo
	npad	7
$LL7@createInfo:

; 209  : 	{
; 210  : 		const CvReplayMessage* pMessage = game.getReplayMessage(i);

	mov	eax, DWORD PTR _i$220356[esp+368]
	mov	ecx, DWORD PTR _game$[esp+368]
	push	eax
	call	?getReplayMessage@CvGame@@QBEPBVCvReplayMessage@@I@Z ; CvGame::getReplayMessage
	mov	esi, eax

; 211  : 		if(pMessage)

	cmp	esi, ebx
	je	$LN6@createInfo

; 212  : 		{
; 213  : 			CvReplayMessage modifiedMessage = (*pMessage);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _modifiedMessage$220362[esp+372], ecx
	push	eax
	lea	ecx, DWORD PTR _modifiedMessage$220362[esp+384]
	mov	DWORD PTR _modifiedMessage$220362[esp+372], OFFSET ??_7CvReplayMessage@@6B@
	mov	DWORD PTR _modifiedMessage$220362[esp+380], edx
	call	??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR _modifiedMessage$220362[esp+396], ecx
	add	esi, 32					; 00000020H
	push	esi
	lea	ecx, DWORD PTR _modifiedMessage$220362[esp+404]
	mov	BYTE PTR __$EHRec$[esp+380], 16		; 00000010H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 214  : 			modifiedMessage.setPlayer((PlayerTypes)mapPlayers[modifiedMessage.getPlayer()]);

	lea	ecx, DWORD PTR _modifiedMessage$220362[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 17		; 00000011H
	call	?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ ; CvReplayMessage::getPlayer
	lea	edx, DWORD PTR $T274550[esp+368]
	push	edx
	lea	ecx, DWORD PTR _mapPlayers$[esp+372]
	mov	DWORD PTR $T274550[esp+372], eax
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR _modifiedMessage$220362[esp+372]
	call	?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z ; CvReplayMessage::setPlayer

; 215  : 
; 216  : 			m_listReplayMessages.push_back(modifiedMessage);

	lea	ecx, DWORD PTR _modifiedMessage$220362[esp+368]
	push	ecx
	mov	ecx, edi
	call	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back

; 217  : 		}

	lea	ecx, DWORD PTR _modifiedMessage$220362[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 3
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
$LN6@createInfo:
	mov	eax, DWORD PTR _i$220356[esp+368]
	inc	eax
	mov	DWORD PTR _i$220356[esp+368], eax
	cmp	eax, DWORD PTR _nMessages$[esp+368]
	jb	$LL7@createInfo
$LN5@createInfo:

; 218  : 	}
; 219  : 
; 220  : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 221  : 
; 222  : 	m_iMapWidth = kMap.getGridWidth();

	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR [ebp+212], ecx

; 223  : 	m_iMapHeight = kMap.getGridHeight();

	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR [ebp+208], ecx

; 224  : 
; 225  : 	int numPlots = kMap.numPlots();

	mov	esi, DWORD PTR [eax+4028]

; 226  : 	m_listPlots.clear();

	mov	ecx, DWORD PTR [ebp+220]
	lea	edi, DWORD PTR [ebp+216]
	mov	DWORD PTR _kMap$[esp+368], eax
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	je	SHORT $LN1029@createInfo
	mov	BYTE PTR $T279571[esp+368], bl
	mov	edx, DWORD PTR $T279571[esp+368]
	push	edx
	mov	edx, DWORD PTR __Cat$279575[esp+372]
	push	edx
	mov	edx, DWORD PTR $T279573[esp+376]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@Urandom_access_iterator_tag@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR __Cat$279586[esp+392]
	push	ecx
	mov	ebp, eax
	mov	eax, DWORD PTR [edi+8]
	push	edi
	push	eax
	push	ebp
	call	??$_Destroy_range@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@0AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR [edi+8], ebp
$LN1029@createInfo:

; 227  : 	m_listPlots.reserve(numPlots);

	push	esi
	mov	ecx, edi
	call	?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve

; 228  : 
; 229  : 	for(int i = 0; i < numPlots; i++)

	cmp	esi, ebx
	jle	$LN1@createInfo
	xor	edi, edi
	mov	DWORD PTR tv1436[esp+368], esi
	npad	8
$LL3@createInfo:

; 230  : 	{
; 231  : 		PlotState plotState;
; 232  : 
; 233  : 		CvPlot* pkPlot = kMap.plotByIndexUnchecked(i);

	mov	edx, DWORD PTR _kMap$[esp+368]
	mov	esi, DWORD PTR [edx+4068]

; 234  : 		plotState.m_ePlotType = pkPlot->getPlotType();
; 235  : 		plotState.m_eTerrain = pkPlot->getTerrainType();
; 236  : 		plotState.m_eFeature = pkPlot->getFeatureType();

	movsx	ecx, BYTE PTR [esi+edi+432]
	movsx	eax, BYTE PTR [esi+edi+6]
	movsx	ebp, BYTE PTR [esi+edi+5]
	add	esi, edi
	mov	DWORD PTR _plotState$220371[esp+376], ecx

; 237  : 		plotState.m_bNEOfRiver = pkPlot->isNEOfRiver();

	mov	ecx, esi
	mov	DWORD PTR _plotState$220371[esp+372], eax
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver

; 238  : 		plotState.m_bWOfRiver = pkPlot->isWOfRiver();

	mov	ecx, esi
	mov	BYTE PTR _plotState$220371[esp+380], al
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver

; 239  : 		plotState.m_bNWOfRiver = pkPlot->isNWOfRiver();

	mov	ecx, esi
	mov	BYTE PTR _plotState$220371[esp+381], al
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver

; 240  : 
; 241  : 		PlotStatePerTurn plotStatePerTurn;

	lea	ecx, DWORD PTR _plotStatePerTurn$220956[esp+368]
	mov	BYTE PTR _plotState$220371[esp+382], al
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR _plotStatePerTurn$220956[esp+372], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR _plotStatePerTurn$220956[esp+372]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _plotStatePerTurn$220956[esp+372]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _plotStatePerTurn$220956[esp+372]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR _plotStatePerTurn$220956[esp+376], ebx

; 242  : 		plotStatePerTurn[m_iFinalTurn] = plotState;

	mov	esi, DWORD PTR _this$[esp+368]
	mov	edx, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T274551[esp+368]
	push	eax
	lea	ecx, DWORD PTR _plotStatePerTurn$220956[esp+372]
	mov	BYTE PTR __$EHRec$[esp+380], 18		; 00000012H
	mov	DWORD PTR $T274551[esp+372], edx
	call	??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[]
	mov	ecx, DWORD PTR _plotState$220371[esp+372]
	mov	edx, DWORD PTR _plotState$220371[esp+376]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _plotState$220371[esp+380]
	mov	DWORD PTR [eax+8], edx

; 243  : 
; 244  : 		m_listPlots.push_back(plotStatePerTurn);

	lea	edx, DWORD PTR _plotStatePerTurn$220956[esp+368]
	mov	DWORD PTR [eax+12], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+216]
	call	?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back

; 245  : 	}

	mov	eax, DWORD PTR _plotStatePerTurn$220956[esp+372]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T280021[esp+376]
	push	eax
	lea	ecx, DWORD PTR _plotStatePerTurn$220956[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 3
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	mov	ecx, DWORD PTR _plotStatePerTurn$220956[esp+372]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	add	edi, 484				; 000001e4H
	sub	DWORD PTR tv1436[esp+368], 1
	mov	DWORD PTR _plotStatePerTurn$220956[esp+372], ebx
	mov	DWORD PTR _plotStatePerTurn$220956[esp+376], ebx
	jne	$LL3@createInfo
$LN1@createInfo:

; 246  : }

	mov	eax, DWORD PTR _mapPlayers$[esp+372]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T280188[esp+376]
	push	edx
	lea	ecx, DWORD PTR _mapPlayers$[esp+380]
	mov	DWORD PTR __$EHRec$[esp+388], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	eax, DWORD PTR _mapPlayers$[esp+372]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+372]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 352				; 00000160H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$9:
	mov	ecx, DWORD PTR $T276058[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$10:
	mov	ecx, DWORD PTR $T276058[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$11:
	mov	ecx, DWORD PTR $T276058[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$0:
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	jmp	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$18:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp+16]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$19:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp+44]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$20:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp+72]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$1:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$2:
	lea	ecx, DWORD PTR _dataSet$220211[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$3:
	lea	ecx, DWORD PTR _playerDataSetName$220217[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T274547[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$5:
	lea	ecx, DWORD PTR _playerData$220227[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$6:
	lea	ecx, DWORD PTR _turnData$220229[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$32:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp+16]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$33:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp+44]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$34:
	lea	ecx, DWORD PTR _playerInfo$220210[ebp+72]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$40:
	lea	ecx, DWORD PTR _modifiedMessage$220362[ebp+12]
	jmp	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$7:
	lea	ecx, DWORD PTR _modifiedMessage$220362[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$8:
	lea	ecx, DWORD PTR _plotStatePerTurn$220956[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__ehhandler$?createInfo@CvReplayInfo@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?createInfo@CvReplayInfo@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?createInfo@CvReplayInfo@@QAEXXZ ENDP			; CvReplayInfo::createInfo
PUBLIC	??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z	; CvReplayInfo::read
EXTRN	?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z:PROC ; CvReplayMessage::read
EXTRN	??0CvReplayMessage@@QAE@XZ:PROC			; CvReplayMessage::CvReplayMessage
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z:PROC ; operator>>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z$0
__ehfuncinfo$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiReplayMessageVersion$ = -84				; size = 4
_iVersion$ = -80					; size = 4
$T280353 = -76						; size = 4
_message$221353 = -72					; size = 60
__$EHRec$ = -12						; size = 12
_uiReplayMessageCount$ = 8				; size = 4
_kStream$ = 8						; size = 4
?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z PROC	; CvReplayInfo::read, COMDAT
; _this$ = ecx

; 528  : {

	push	-1
	push	__ehhandler$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi

; 529  : 	bool bSuccess = true;
; 530  : 
; 531  : 	int iVersion;
; 532  : 	kStream >> iVersion;

	mov	esi, DWORD PTR _kStream$[esp+92]
	push	edi
	lea	eax, DWORD PTR _iVersion$[esp+100]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 533  : 
; 534  : 	kStream >> m_iActivePlayer;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 535  : 	kStream >> m_strMapScriptName;

	lea	edx, DWORD PTR [edi+8]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 536  : 	kStream >> m_eWorldSize;

	lea	eax, DWORD PTR [edi+36]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z ; operator>>

; 537  : 	kStream >> m_eClimate;

	lea	ecx, DWORD PTR [edi+40]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z ; operator>>

; 538  : 	kStream >> m_eSeaLevel;

	lea	edx, DWORD PTR [edi+44]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z ; operator>>

; 539  : 	kStream >> m_eEra;

	lea	eax, DWORD PTR [edi+48]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>

; 540  : 	kStream >> m_eGameSpeed;

	lea	ecx, DWORD PTR [edi+52]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z ; operator>>

; 541  : 	kStream >> m_listGameOptions;

	lea	edx, DWORD PTR [edi+56]
	push	edx
	push	esi
	call	??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >

; 542  : 	kStream >> m_listVictoryTypes;

	lea	eax, DWORD PTR [edi+72]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >

; 543  : 	kStream >> m_eVictoryType;

	lea	ecx, DWORD PTR [edi+88]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4VictoryTypes@@@Z ; operator>>
	add	esp, 64					; 00000040H

; 544  : 	kStream >> m_eGameType;

	lea	edx, DWORD PTR [edi+92]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameTypes@@@Z ; operator>>
	add	esp, 8

; 545  : 	kStream >> m_iInitialTurn;

	lea	eax, DWORD PTR [edi+96]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 546  : 	kStream >> m_iStartYear;

	lea	ecx, DWORD PTR [edi+104]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 547  : 	kStream >> m_iFinalTurn;

	lea	edx, DWORD PTR [edi+100]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 548  : 	kStream >> m_strFinalDate;

	lea	eax, DWORD PTR [edi+108]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 549  : 	kStream >> m_eCalendar;

	lea	ecx, DWORD PTR [edi+136]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z ; operator>>
	add	esp, 8

; 550  : 	kStream >> m_iNormalizedScore;

	lea	edx, DWORD PTR [edi+140]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 551  : 
; 552  : 	kStream >> m_listPlayerInfo;

	lea	eax, DWORD PTR [edi+144]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >

; 553  : 
; 554  : 	kStream >> m_dataSetMap;

	lea	ecx, DWORD PTR [edi+176]
	push	ecx
	push	esi
	call	??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 555  : 	kStream >> m_listPlayerDataSets;

	lea	edx, DWORD PTR [edi+192]
	push	edx
	push	esi
	call	??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
	add	esp, 24					; 00000018H

; 556  : 
; 557  : 	unsigned int uiReplayMessageVersion = 2;
; 558  : 	kStream >> uiReplayMessageVersion;

	lea	eax, DWORD PTR _uiReplayMessageVersion$[esp+100]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiReplayMessageVersion$[esp+104], 2
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 559  : 
; 560  : 	unsigned int uiReplayMessageCount = 0;
; 561  : 	kStream >> uiReplayMessageCount;

	lea	ecx, DWORD PTR _uiReplayMessageCount$[esp+96]
	push	ecx
	xor	ebp, ebp
	mov	ecx, esi
	mov	DWORD PTR _uiReplayMessageCount$[esp+100], ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 562  : 
; 563  : 	m_listReplayMessages.clear();

	mov	eax, DWORD PTR [edi+168]
	mov	ecx, DWORD PTR [edi+164]
	lea	ebx, DWORD PTR [edi+160]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T280353[esp+108]
	push	edx
	mov	ecx, ebx
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 564  : 	m_listReplayMessages.reserve(uiReplayMessageCount);

	mov	eax, DWORD PTR _uiReplayMessageCount$[esp+96]
	push	eax
	mov	ecx, ebx
	call	?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve

; 565  : 	for(unsigned int ui = 0; ui < uiReplayMessageCount; ++ui)

	cmp	DWORD PTR _uiReplayMessageCount$[esp+96], ebp
	jbe	SHORT $LN1@read
$LL3@read:

; 566  : 	{
; 567  : 		CvReplayMessage message;

	lea	ecx, DWORD PTR _message$221353[esp+100]
	call	??0CvReplayMessage@@QAE@XZ		; CvReplayMessage::CvReplayMessage

; 568  : 		message.read(kStream, uiReplayMessageVersion);

	mov	ecx, DWORD PTR _uiReplayMessageVersion$[esp+100]
	push	ecx
	push	esi
	lea	ecx, DWORD PTR _message$221353[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z ; CvReplayMessage::read

; 569  : 		m_listReplayMessages.push_back(message);

	lea	edx, DWORD PTR _message$221353[esp+100]
	push	edx
	mov	ecx, ebx
	call	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back

; 570  : 	}

	lea	ecx, DWORD PTR _message$221353[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
	inc	ebp
	cmp	ebp, DWORD PTR _uiReplayMessageCount$[esp+96]
	jb	SHORT $LL3@read
$LN1@read:

; 571  : 
; 572  : 	kStream >> m_iMapWidth;

	lea	eax, DWORD PTR [edi+212]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 573  : 	kStream >> m_iMapHeight;

	lea	ecx, DWORD PTR [edi+208]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 574  : 	kStream >> m_listPlots;

	add	edi, 216				; 000000d8H
	push	edi
	push	esi
	call	??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >

; 575  : 
; 576  : 	return bSuccess;
; 577  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _message$221353[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__ehhandler$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z ENDP	; CvReplayInfo::read
END
