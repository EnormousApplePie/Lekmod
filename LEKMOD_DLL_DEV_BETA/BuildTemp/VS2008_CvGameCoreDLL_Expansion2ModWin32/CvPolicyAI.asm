; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPolicyAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG221997 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG222029 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG222032 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG222037 DB	'AIGRANDSTRATEGY_SPACESHIP', 00H
	ORG $+2
$SG222040 DB	'FLAVOR_SPACESHIP', 00H
	ORG $+3
$SG222045 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
	ORG $+1
$SG222048 DB	'FLAVOR_DIPLOMACY', 00H
	ORG $+3
$SG222053 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG222056 DB	'FLAVOR_CULTURE', 00H
	ORG $+1
$SG222061 DB	'Choosing policy from Top Choices', 00H
	ORG $+3
$SG222064 DB	'Choosing policy at random (no good choices)', 00H
$SG222120 DB	'After Grand Strategies', 00H
	ORG $+1
$SG222121 DB	'After Free Policies', 00H
$SG222160 DB	'After Relations', 00H
$SG222167 DB	'After Tenet Happiness Boosts', 00H
	ORG $+3
$SG222174 DB	'After Public Opinion Happiness', 00H
	ORG $+1
$SG222175 DB	'Freedom random priority bump', 00H
	ORG $+3
$SG222176 DB	'Autocracy random priority bump', 00H
	ORG $+1
$SG222177 DB	'Order random priority bump', 00H
	ORG $+1
$SG222178 DB	'After Random (1 to 10)', 00H
	ORG $+1
$SG222179 DB	'Final (after Clear Victory Preference)', 00H
	ORG $+1
$SG222350 DB	'%03d, ', 00H
	ORG $+1
$SG222352 DB	', ', 00H
	ORG $+1
$SG222360 DB	'Branch %d, %d', 00H
	ORG $+2
$SG222366 DB	'Unknown', 00H
$SG222367 DB	'%s, %d', 00H
	ORG $+1
$SG222381 DB	'%03d, ', 00H
	ORG $+1
$SG222383 DB	', ', 00H
	ORG $+1
$SG222386 DB	'Unknown', 00H
$SG222387 DB	'CHOSEN, %s', 00H
	ORG $+1
$SG222401 DB	'%03d, ', 00H
	ORG $+1
$SG222403 DB	', ', 00H
	ORG $+1
$SG222404 DB	'CHOSEN, Branch %d', 00H
	ORG $+2
$SG222420 DB	'%03d, ', 00H
	ORG $+1
$SG222422 DB	', ', 00H
	ORG $+1
$SG222423 DB	'%s, Freedom: %d, Order: %d, Autocracy: %d', 00H
	ORG $+2
$SG222434 DB	'.csv', 00H
	ORG $+3
$SG222435 DB	'PolicyAILog_', 00H
	ORG $+3
$SG222437 DB	'PolicyAILog.csv', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z:PROC ; CvPolicyEntry::GetBuildingClassHappiness
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ:PROC	; CvPolicyEntry::GetPolicyBranchType
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
;	COMDAT ?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_iSpecialPolicyBuildingHappiness$ = -8			; size = 4
_iPolicyLoop$222225 = -4				; size = 4
_iLoop$222245 = 8					; size = 4
_pPlayer$ = 8						; size = 4
_eBranch$ = 12						; size = 4
?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::GetBranchBuildingHappiness, COMDAT
; _this$ = ecx

; 679  : {

	sub	esp, 8
	push	esi
	push	edi

; 680  : 	// Policy Building Mods
; 681  : 	int iSpecialPolicyBuildingHappiness = 0;

	xor	esi, esi

; 682  : #ifdef AUI_WARNING_FIXES
; 683  : 	uint iBuildingClassLoop;
; 684  : #else
; 685  : 	int iBuildingClassLoop;
; 686  : #endif
; 687  : 	BuildingClassTypes eBuildingClass;
; 688  : #ifdef AUI_WARNING_FIXES
; 689  : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 690  : #else
; 691  : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSpecialPolicyBuildingHappiness$[esp+16], esi
	mov	DWORD PTR _iPolicyLoop$222225[esp+16], edi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	test	eax, eax
	jle	$LN24@GetBranchB
	push	ebx
	mov	ebx, DWORD PTR _pPlayer$[esp+16]
	push	ebp
	npad	7
$LL27@GetBranchB:

; 692  : #endif
; 693  : 	{
; 694  : 		PolicyTypes ePolicy = (PolicyTypes)iPolicyLoop;
; 695  : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	ebp, eax

; 696  : 		if(pkPolicyInfo)

	test	ebp, ebp
	je	$LN14@GetBranchB

; 697  : 		{
; 698  : 			if (pkPolicyInfo->GetPolicyBranchType() == eBranch)

	mov	ecx, ebp
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[esp+20]
	jne	$LN14@GetBranchB

; 699  : 			{
; 700  : 				for(iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN14@GetBranchB
	npad	6
$LL10@GetBranchB:

; 701  : 				{
; 702  : 					eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;
; 703  : 
; 704  : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 705  : 					if (!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN9@GetBranchB

; 706  : 					{
; 707  : 						continue;
; 708  : 					}
; 709  : 
; 710  : 					if (pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass) != 0)

	push	esi
	mov	ecx, ebp
	call	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
	test	eax, eax
	je	SHORT $LN9@GetBranchB

; 711  : 					{
; 712  : 						BuildingTypes eBuilding = (BuildingTypes)pPlayer->getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	push	esi
	mov	ecx, ebx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	edi, eax

; 713  : 						if (eBuilding != NO_BUILDING)

	cmp	edi, -1
	je	SHORT $LN9@GetBranchB

; 714  : 						{
; 715  : 							CvCity *pCity;
; 716  : 							int iLoop;
; 717  : 							for (pCity = pPlayer->firstCity(&iLoop); pCity != NULL; pCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$222245[esp+24]
	push	eax
	mov	ecx, ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN9@GetBranchB
$LL4@GetBranchB:

; 718  : 							{
; 719  : 								if (pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	edi
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN3@GetBranchB

; 720  : 								{
; 721  : 									iSpecialPolicyBuildingHappiness += pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass);

	push	esi
	mov	ecx, ebp
	call	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
	add	DWORD PTR _iSpecialPolicyBuildingHappiness$[esp+24], eax
$LN3@GetBranchB:
	push	0
	lea	ecx, DWORD PTR _iLoop$222245[esp+24]
	push	ecx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL4@GetBranchB
$LN9@GetBranchB:

; 699  : 			{
; 700  : 				for(iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	esi, eax
	jl	$LL10@GetBranchB
	mov	edi, DWORD PTR _iPolicyLoop$222225[esp+24]
$LN14@GetBranchB:

; 682  : #ifdef AUI_WARNING_FIXES
; 683  : 	uint iBuildingClassLoop;
; 684  : #else
; 685  : 	int iBuildingClassLoop;
; 686  : #endif
; 687  : 	BuildingClassTypes eBuildingClass;
; 688  : #ifdef AUI_WARNING_FIXES
; 689  : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 690  : #else
; 691  : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iPolicyLoop$222225[esp+24], edi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	edi, eax
	jl	$LL27@GetBranchB

; 722  : 								}
; 723  : 							}
; 724  : 						}
; 725  : 					}
; 726  : 				}
; 727  : 			}
; 728  : 		}
; 729  : 	}
; 730  : 	return iSpecialPolicyBuildingHappiness;

	mov	eax, DWORD PTR _iSpecialPolicyBuildingHappiness$[esp+24]
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 731  : }

	add	esp, 8
	ret	8
$LN24@GetBranchB:
	pop	edi

; 722  : 								}
; 723  : 							}
; 724  : 						}
; 725  : 					}
; 726  : 				}
; 727  : 			}
; 728  : 		}
; 729  : 	}
; 730  : 	return iSpecialPolicyBuildingHappiness;

	mov	eax, esi
	pop	esi

; 731  : }

	add	esp, 8
	ret	8
?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::GetBranchBuildingHappiness
_TEXT	ENDS
PUBLIC	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
EXTRN	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsNoOccupiedUnhappiness
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_iRtnValue$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_eBranch$ = 12						; size = 4
?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::GetNumHappinessPolicies, COMDAT
; _this$ = ecx

; 735  : {

	push	ecx
	push	ebx
	push	esi

; 736  : 	int iRtnValue = 0;

	xor	esi, esi

; 737  : #ifdef AUI_WARNING_FIXES
; 738  : 	uint iBuildingClassLoop;
; 739  : 	BuildingClassTypes eBuildingClass;
; 740  : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 741  : #else
; 742  : 	int iBuildingClassLoop;
; 743  : 	BuildingClassTypes eBuildingClass;
; 744  : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iRtnValue$[esp+12], esi
	xor	ebx, ebx
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	test	eax, eax
	jle	$LN21@GetNumHapp
	push	ebp
	mov	ebp, DWORD PTR _pPlayer$[esp+12]
	push	edi
$LL24@GetNumHapp:

; 745  : #endif
; 746  : 	{
; 747  : 		PolicyTypes ePolicy = (PolicyTypes)iPolicyLoop;
; 748  : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	edi, eax

; 749  : 		if(pkPolicyInfo)

	test	edi, edi
	je	SHORT $LN12@GetNumHapp

; 750  : 		{
; 751  : 			if (pkPolicyInfo->GetPolicyBranchType() == eBranch)

	mov	ecx, edi
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[esp+16]
	jne	SHORT $LN12@GetNumHapp

; 752  : 			{
; 753  : 				for(iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN12@GetNumHapp
$LL8@GetNumHapp:

; 754  : 				{
; 755  : 					eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;
; 756  : 
; 757  : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 758  : 					if (!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN7@GetNumHapp

; 759  : 					{
; 760  : 						continue;
; 761  : 					}
; 762  : 
; 763  : 					BuildingTypes eBuilding = (BuildingTypes)pPlayer->getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	push	esi
	mov	ecx, ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 764  : 					if (eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN7@GetNumHapp

; 765  : 					{
; 766  : 						// Don't count a building that can only be built in conquered cities
; 767  : 						CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 768  : 						if (!pkEntry || pkEntry->IsNoOccupiedUnhappiness())

	test	eax, eax
	je	SHORT $LN7@GetNumHapp
	mov	ecx, eax
	call	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNoOccupiedUnhappiness
	test	al, al
	jne	SHORT $LN7@GetNumHapp

; 769  : 						{
; 770  : 							continue;
; 771  : 						}
; 772  : 
; 773  : 						if (pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass) != 0)

	push	esi
	mov	ecx, edi
	call	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
	test	eax, eax
	jne	SHORT $LN18@GetNumHapp
$LN7@GetNumHapp:

; 752  : 			{
; 753  : 				for(iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	esi, eax
	jl	SHORT $LL8@GetNumHapp

; 769  : 						{
; 770  : 							continue;
; 771  : 						}
; 772  : 
; 773  : 						if (pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass) != 0)

	jmp	SHORT $LN12@GetNumHapp
$LN18@GetNumHapp:

; 774  : 						{
; 775  : 							iRtnValue++;

	inc	DWORD PTR _iRtnValue$[esp+20]
$LN12@GetNumHapp:

; 737  : #ifdef AUI_WARNING_FIXES
; 738  : 	uint iBuildingClassLoop;
; 739  : 	BuildingClassTypes eBuildingClass;
; 740  : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 741  : #else
; 742  : 	int iBuildingClassLoop;
; 743  : 	BuildingClassTypes eBuildingClass;
; 744  : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	ebx, eax
	jl	$LL24@GetNumHapp

; 776  : 							break;
; 777  : 						}
; 778  : 					}
; 779  : 				}
; 780  : 			}
; 781  : 		}
; 782  : 	}
; 783  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+20]
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 784  : }

	pop	ecx
	ret	8
$LN21@GetNumHapp:

; 776  : 							break;
; 777  : 						}
; 778  : 					}
; 779  : 				}
; 780  : 			}
; 781  : 		}
; 782  : 	}
; 783  : 	return iRtnValue;

	mov	eax, esi
	pop	esi
	pop	ebx

; 784  : }

	pop	ecx
	ret	8
?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::GetNumHappinessPolicies
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fire'
	DB	'place\include\fireworks\FFastVector.h', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis, COMDAT
; _this$ = ecx

; 701  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
_TEXT	ENDS
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr, COMDAT
; _this$ = ecx

; 702  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z PROC ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>, COMDAT

; 153  : 	return input;

	mov	eax, DWORD PTR _input$[esp-4]

; 154  : }

	ret	0
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ENDP ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z ; CvWeightedVector<int,64,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,64,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,64,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
_bound_func$ = 16					; size = 4
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z PROC ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>, COMDAT

; 306  : 			GenericMemFuncType &bound_func) {
; 307  : #if defined __DMC__  
; 308  : 		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
; 309  : 		// even though the standard says you can. The 32-bit compiler lets you
; 310  : 		// static_cast through an int, but the DOS compiler doesn't.
; 311  : 		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
; 312  : #else 
; 313  :         bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

	mov	eax, DWORD PTR _bound_func$[esp-4]
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax], ecx

; 314  : #endif
; 315  :         return reinterpret_cast<GenericClass *>(pthis);

	mov	eax, DWORD PTR _pthis$[esp-4]

; 316  : 	}

	ret	0
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ENDP ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; std::_Dist_type<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::swap<CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::swap<CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::swap<CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Iter_random<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPOLICY_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ ; CvGlobals::getPOLICY_WEIGHT_PROPAGATION_LEVELS
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPOLICY_WEIGHT_PROPAGATION_LEVELS, COMDAT
; _this$ = ecx

; 893  : 		return m_iPOLICY_WEIGHT_PROPAGATION_LEVELS;

	mov	eax, DWORD PTR [ecx+1828]

; 894  : 	}

	ret	0
?getPOLICY_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPOLICY_WEIGHT_PROPAGATION_LEVELS
_TEXT	ENDS
PUBLIC	?getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH@CvGlobals@@QAEHXZ ; CvGlobals::getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH, COMDAT
; _this$ = ecx

; 897  : 		return m_iPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH;

	mov	eax, DWORD PTR [ecx+1832]

; 898  : 	}

	ret	0
?getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH
_TEXT	ENDS
PUBLIC	?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_OR_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUM_OR_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5344 : 		return m_iNUM_OR_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6268]

; 5345 : 	}

	ret	0
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUM_OR_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getSUPER_UNHAPPY_THRESHOLD@CvGlobals@@QAEHXZ	; CvGlobals::getSUPER_UNHAPPY_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getSUPER_UNHAPPY_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSUPER_UNHAPPY_THRESHOLD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSUPER_UNHAPPY_THRESHOLD, COMDAT
; _this$ = ecx

; 5452 : 		return m_iSUPER_UNHAPPY_THRESHOLD;

	mov	eax, DWORD PTR [ecx+6376]

; 5453 : 	}

	ret	0
?getSUPER_UNHAPPY_THRESHOLD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSUPER_UNHAPPY_THRESHOLD
_TEXT	ENDS
PUBLIC	?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS, COMDAT
; _this$ = ecx

; 6052 : 		return m_iSWITCH_POLICY_BRANCHES_ANARCHY_TURNS;

	mov	eax, DWORD PTR [ecx+6976]

; 6053 : 	}

	ret	0
?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF@CvGlobals@@QAEHXZ ; CvGlobals::getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF@CvGlobals@@QAEHXZ PROC ; CvGlobals::getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF, COMDAT
; _this$ = ecx

; 7567 : 		return m_iIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF;

	mov	eax, DWORD PTR [ecx+8344]

; 7568 : 	}

	ret	0
?getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_GRAND_STRATS@CvGlobals@@QAEHXZ ; CvGlobals::getIDEOLOGY_SCORE_GRAND_STRATS
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_GRAND_STRATS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_GRAND_STRATS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getIDEOLOGY_SCORE_GRAND_STRATS, COMDAT
; _this$ = ecx

; 7571 : 		return m_iIDEOLOGY_SCORE_GRAND_STRATS;

	mov	eax, DWORD PTR [ecx+8348]

; 7572 : 	}

	ret	0
?getIDEOLOGY_SCORE_GRAND_STRATS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getIDEOLOGY_SCORE_GRAND_STRATS
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_HAPPINESS@CvGlobals@@QAEHXZ	; CvGlobals::getIDEOLOGY_SCORE_HAPPINESS
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_HAPPINESS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_HAPPINESS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getIDEOLOGY_SCORE_HAPPINESS, COMDAT
; _this$ = ecx

; 7575 : 		return m_iIDEOLOGY_SCORE_HAPPINESS;

	mov	eax, DWORD PTR [ecx+8352]

; 7576 : 	}

	ret	0
?getIDEOLOGY_SCORE_HAPPINESS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getIDEOLOGY_SCORE_HAPPINESS
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_PER_FREE_TENET@CvGlobals@@QAEHXZ ; CvGlobals::getIDEOLOGY_SCORE_PER_FREE_TENET
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_PER_FREE_TENET@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_PER_FREE_TENET@CvGlobals@@QAEHXZ PROC ; CvGlobals::getIDEOLOGY_SCORE_PER_FREE_TENET, COMDAT
; _this$ = ecx

; 7579 : 		return m_iIDEOLOGY_SCORE_PER_FREE_TENET;

	mov	eax, DWORD PTR [ecx+8356]

; 7580 : 	}

	ret	0
?getIDEOLOGY_SCORE_PER_FREE_TENET@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getIDEOLOGY_SCORE_PER_FREE_TENET
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_HOSTILE@CvGlobals@@QAEHXZ	; CvGlobals::getIDEOLOGY_SCORE_HOSTILE
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_HOSTILE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_HOSTILE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getIDEOLOGY_SCORE_HOSTILE, COMDAT
; _this$ = ecx

; 7583 : 		return m_iIDEOLOGY_SCORE_HOSTILE;

	mov	eax, DWORD PTR [ecx+8360]

; 7584 : 	}

	ret	0
?getIDEOLOGY_SCORE_HOSTILE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getIDEOLOGY_SCORE_HOSTILE
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_GUARDED@CvGlobals@@QAEHXZ	; CvGlobals::getIDEOLOGY_SCORE_GUARDED
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_GUARDED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_GUARDED@CvGlobals@@QAEHXZ PROC	; CvGlobals::getIDEOLOGY_SCORE_GUARDED, COMDAT
; _this$ = ecx

; 7587 : 		return m_iIDEOLOGY_SCORE_GUARDED;

	mov	eax, DWORD PTR [ecx+8364]

; 7588 : 	}

	ret	0
?getIDEOLOGY_SCORE_GUARDED@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getIDEOLOGY_SCORE_GUARDED
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_AFRAID@CvGlobals@@QAEHXZ	; CvGlobals::getIDEOLOGY_SCORE_AFRAID
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_AFRAID@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_AFRAID@CvGlobals@@QAEHXZ PROC	; CvGlobals::getIDEOLOGY_SCORE_AFRAID, COMDAT
; _this$ = ecx

; 7591 : 		return m_iIDEOLOGY_SCORE_AFRAID;

	mov	eax, DWORD PTR [ecx+8368]

; 7592 : 	}

	ret	0
?getIDEOLOGY_SCORE_AFRAID@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getIDEOLOGY_SCORE_AFRAID
_TEXT	ENDS
PUBLIC	?getIDEOLOGY_SCORE_FRIENDLY@CvGlobals@@QAEHXZ	; CvGlobals::getIDEOLOGY_SCORE_FRIENDLY
; Function compile flags: /Ogtpy
;	COMDAT ?getIDEOLOGY_SCORE_FRIENDLY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getIDEOLOGY_SCORE_FRIENDLY@CvGlobals@@QAEHXZ PROC	; CvGlobals::getIDEOLOGY_SCORE_FRIENDLY, COMDAT
; _this$ = ecx

; 7595 : 		return m_iIDEOLOGY_SCORE_FRIENDLY;

	mov	eax, DWORD PTR [ecx+8372]

; 7596 : 	}

	ret	0
?getIDEOLOGY_SCORE_FRIENDLY@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getIDEOLOGY_SCORE_FRIENDLY
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_FREEDOM
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_FREEDOM, COMDAT
; _this$ = ecx

; 7599 : 		return m_iPOLICY_BRANCH_FREEDOM;

	mov	eax, DWORD PTR [ecx+8376]

; 7600 : 	}

	ret	0
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_FREEDOM
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY, COMDAT
; _this$ = ecx

; 7603 : 		return m_iPOLICY_BRANCH_AUTOCRACY;

	mov	eax, DWORD PTR [ecx+8380]

; 7604 : 	}

	ret	0
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_ORDER
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPOLICY_BRANCH_ORDER, COMDAT
; _this$ = ecx

; 7607 : 		return m_iPOLICY_BRANCH_ORDER;

	mov	eax, DWORD PTR [ecx+8384]

; 7608 : 	}

	ret	0
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPOLICY_BRANCH_ORDER
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = ecx

; 579  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
_TEXT	ENDS
PUBLIC	?clear@DelegateMemento@fastdelegate@@QAEXXZ	; fastdelegate::DelegateMemento::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@DelegateMemento@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@DelegateMemento@fastdelegate@@QAEXXZ PROC	; fastdelegate::DelegateMemento::clear, COMDAT
; _this$ = ecx

; 580  : 	void clear() {	m_pthis=0; m_pFunction=0;	}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@DelegateMemento@fastdelegate@@QAEXXZ ENDP	; fastdelegate::DelegateMemento::clear
_TEXT	ENDS
PUBLIC	?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ; fastdelegate::DelegateMemento::SetMementoFrom
; Function compile flags: /Ogtpy
;	COMDAT ?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z
_TEXT	SEGMENT
_right$ = 8						; size = 4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z PROC ; fastdelegate::DelegateMemento::SetMementoFrom, COMDAT
; _this$ = ecx

; 637  : 		m_pFunction = right.m_pFunction;

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 638  : 		m_pthis = right.m_pthis;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 639  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 640  : 		m_pStaticFunction = right.m_pStaticFunction;
; 641  : #endif
; 642  : 	}

	ret	4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ENDP ; fastdelegate::DelegateMemento::SetMementoFrom
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T223732 = -80						; size = 28
$T223731 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T223732[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T223731[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T223732[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T223731[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T223731[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T223731[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T223731[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T223732[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T223731[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T223795 = -12						; size = 12
$T223799 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T223799[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T223795[esp+16]
	mov	DWORD PTR $T223799[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T223795[esp+16]
	push	ecx
	mov	DWORD PTR $T223795[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z ; CvPolicyAI::IsBranchEffectiveInGame
EXTRN	?GetNumMinorCivsEver@CvGame@@QAEHXZ:PROC	; CvGame::GetNumMinorCivsEver
EXTRN	?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
EXTRN	?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoScience
EXTRN	?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoCulture
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoReligion
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
;	COMDAT ?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::IsBranchEffectiveInGame, COMDAT
; _this$ = ecx

; 888  : 	CvPolicyBranchEntry* pBranchInfo = GC.getPolicyBranchInfo(eBranch);

	mov	eax, DWORD PTR _eBranch$[esp-4]
	push	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	esi, eax

; 889  : 	CvAssertMsg(pBranchInfo, "Branch info not found! Please send Anton your save file and version.");
; 890  : 	if (!pBranchInfo) return false;

	test	esi, esi
	jne	SHORT $LN9@IsBranchEf
$LN20@IsBranchEf:
	xor	al, al
	pop	esi

; 909  : }

	ret	4
$LN9@IsBranchEf:

; 891  : 	
; 892  : 	if (pBranchInfo->IsDelayWhenNoReligion())

	mov	ecx, esi
	call	?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoReligion
	test	al, al
	je	SHORT $LN7@IsBranchEf

; 893  : 		if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	21					; 00000015H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 894  : 			return false;

	jne	SHORT $LN20@IsBranchEf
$LN7@IsBranchEf:

; 895  : 
; 896  : 	if (pBranchInfo->IsDelayWhenNoCulture())

	mov	ecx, esi
	call	?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCulture
	test	al, al
	je	SHORT $LN5@IsBranchEf

; 897  : 		if (GC.getGame().isOption(GAMEOPTION_NO_POLICIES))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	18					; 00000012H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 898  : 			return false;

	jne	SHORT $LN20@IsBranchEf
$LN5@IsBranchEf:

; 899  : 
; 900  : 	if (pBranchInfo->IsDelayWhenNoScience())

	mov	ecx, esi
	call	?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoScience
	test	al, al
	je	SHORT $LN3@IsBranchEf

; 901  : 		if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	17					; 00000011H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 902  : 			return false;

	jne	SHORT $LN20@IsBranchEf
$LN3@IsBranchEf:

; 903  : 
; 904  : 	if (pBranchInfo->IsDelayWhenNoCityStates())

	mov	ecx, esi
	call	?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
	test	al, al
	je	SHORT $LN1@IsBranchEf

; 905  : 		if (GC.getGame().GetNumMinorCivsEver() <= 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetNumMinorCivsEver@CvGame@@QAEHXZ	; CvGame::GetNumMinorCivsEver
	test	eax, eax

; 906  : 			return false;

	jle	SHORT $LN20@IsBranchEf
$LN1@IsBranchEf:

; 907  : 
; 908  : 	return true;

	mov	al, 1
	pop	esi

; 909  : }

	ret	4
?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::IsBranchEffectiveInGame
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
$T223897 = -72						; size = 4
$T223895 = -68						; size = 28
$T223894 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z PROC ; CvPolicyAI::GetLogFileName, COMDAT
; _this$ = ecx

; 1048 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T223897[esp+80], ebx

; 1049 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1059 : 	}
; 1060 : 
; 1061 : 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T223897[esp+80], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T223894[esp+84]
	push	OFFSET $SG222435
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG222434
	push	eax
	lea	edx, DWORD PTR $T223895[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T223895[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T223894[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	pop	ebx

; 1062 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN2@GetLogFile:

; 1050 : 
; 1051 : 	// Open the log file
; 1052 : 	if(GC.getPlayerAndCityAILogSplit())
; 1053 : 	{
; 1054 : 		strLogName = "PolicyAILog_" + playerName + ".csv";
; 1055 : 	}
; 1056 : 	else
; 1057 : 	{
; 1058 : 		strLogName = "PolicyAILog.csv";

	push	OFFSET $SG222437
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 1062 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$0:
	mov	eax, DWORD PTR $T223897[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T223897[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T223894[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T223895[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ENDP ; CvPolicyAI::GetLogFileName
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z ; CvWeightedVector<int,64,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z PROC ; CvWeightedVector<int,64,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z ENDP ; CvWeightedVector<int,64,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@H$0EA@$00@@QBEHI@Z ; CvWeightedVector<int,64,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@H$0EA@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@H$0EA@$00@@QBEHI@Z PROC	; CvWeightedVector<int,64,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@H$0EA@$00@@QBEHI@Z ENDP	; CvWeightedVector<int,64,1>::GetWeight
_TEXT	ENDS
PUBLIC	?IncreaseWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z ; CvWeightedVector<int,64,1>::IncreaseWeight
; Function compile flags: /Ogtpy
;	COMDAT ?IncreaseWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?IncreaseWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z PROC ; CvWeightedVector<int,64,1>::IncreaseWeight, COMDAT
; _this$ = ecx

; 78   : 		m_pItems[iIndex].m_iWeight += iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	mov	edx, DWORD PTR _iWeight$[esp-4]
	add	DWORD PTR [eax+ecx*8+4], edx
	lea	eax, DWORD PTR [eax+ecx*8+4]

; 79   : 		CvAssertMsg(m_pItems[iIndex].m_iWeight >= 0, "Weight should not be negative.");
; 80   : 	}

	ret	8
?IncreaseWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z ENDP ; CvWeightedVector<int,64,1>::IncreaseWeight
_TEXT	ENDS
PUBLIC	?SetWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z ; CvWeightedVector<int,64,1>::SetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?SetWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?SetWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z PROC	; CvWeightedVector<int,64,1>::SetWeight, COMDAT
; _this$ = ecx

; 83   : 		m_pItems[iIndex].m_iWeight = iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iWeight$[esp-4]
	mov	edx, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 84   : 		CvAssertMsg(m_pItems[iIndex].m_iWeight >= 0, "Weight should not be negative.");
; 85   : 	}

	ret	8
?SetWeight@?$CvWeightedVector@H$0EA@$00@@QAEXIH@Z ENDP	; CvWeightedVector<int,64,1>::SetWeight
_TEXT	ENDS
PUBLIC	?GetTotalWeight@?$CvWeightedVector@H$0EA@$00@@QAEHXZ ; CvWeightedVector<int,64,1>::GetTotalWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@H$0EA@$00@@QAEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@H$0EA@$00@@QAEHXZ PROC ; CvWeightedVector<int,64,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR [ecx+4]
	push	ebp
	push	esi
	push	edi

; 90   : 		int rtnValue = 0;

	xor	edx, edx
	xor	esi, esi
	xor	edi, edi

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	xor	ebp, ebp
	cmp	ebx, 2
	mov	DWORD PTR _rtnValue$[esp+20], edx
	jl	SHORT $LC15@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ebx-2]
	shr	edx, 1
	add	eax, 12					; 0000000cH
	inc	edx
	lea	ebp, DWORD PTR [edx+edx]
$LL16@GetTotalWe:
	add	esi, DWORD PTR [eax-8]
	add	edi, DWORD PTR [eax]
	add	eax, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL16@GetTotalWe
	mov	edx, DWORD PTR _rtnValue$[esp+20]
$LC15@GetTotalWe:

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	ebp, ebx
	jae	SHORT $LN14@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+ebp*8+4]
$LN14@GetTotalWe:
	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebp

; 96   : 		}
; 97   : 
; 98   : 		return rtnValue;

	add	eax, edx
	pop	ebx

; 99   : 	};

	pop	ecx
	ret	0
?GetTotalWeight@?$CvWeightedVector@H$0EA@$00@@QAEHXZ ENDP ; CvWeightedVector<int,64,1>::GetTotalWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ	; CvWeightedVector<int,64,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ PROC		; CvWeightedVector<int,64,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ ENDP		; CvWeightedVector<int,64,1>::size
_TEXT	ENDS
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z PROC	; fastdelegate::FastDelegate2<int,char const *,int>::operator(), COMDAT
; _this$ = ecx

; 1080 : 	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	eax
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::operator()
_TEXT	ENDS
PUBLIC	?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ; fastdelegate::FastDelegate2<int,char const *,int>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::clear, COMDAT
; _this$ = ecx

; 1101 : 	void clear() { m_Closure.clear();}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::clear
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
_right$ = 12						; size = 4
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >, COMDAT
; _this$ = ecx

; 763  : #endif
; 764  : 		SetMementoFrom(right);

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 765  : 	}

	ret	8
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
_TEXT	ENDS
PUBLIC	??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>, COMDAT
; _this$ = ecx

; 673  : 		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
; 674  : 			::Convert(pthis, function_to_bind, m_pFunction);

	mov	eax, DWORD PTR _function_to_bind$[esp-4]
	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx

; 675  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 676  : 		m_pStaticFunction = 0;
; 677  : #endif
; 678  : 	}

	ret	8
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::iter_swap<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_
	push	esi
$LL8@unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_
	pop	esi
$LN7@unchecked_:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z	; CvPolicyAI::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ:PROC	; CvPolicyXMLEntries::GetNumPolicies
EXTRN	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ:PROC ; CvPlayerPolicies::GetPolicies
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
;	COMDAT ?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -16					; size = 4
$T224323 = -12						; size = 4
_elem$224343 = -8					; size = 8
_uiPolicyCount$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z PROC		; CvPolicyAI::Write, COMDAT
; _this$ = ecx

; 92   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 93   : 	// Current version number
; 94   : 	uint uiVersion = 1;
; 95   : 	kStream << uiVersion;

	mov	ebx, DWORD PTR _kStream$[esp+16]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	edi, ecx
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _uiVersion$[esp+32], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 96   : 
; 97   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies() != NULL, "Policy AI serialization failure: no policy data");
; 98   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies()->GetNumPolicies() > 0, "Policy AI serialization failure: number of policies not greater than 0");
; 99   : 
; 100  : 	// Loop through writing each entry
; 101  : 	uint uiPolicyCount = m_pCurrentPolicies->GetPolicies()->GetNumPolicies();

	mov	ecx, DWORD PTR [edi]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies

; 102  : 	kStream << uiPolicyCount;

	lea	ecx, DWORD PTR _uiPolicyCount$[esp+24]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR _uiPolicyCount$[esp+28], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 103  : 
; 104  : #ifdef AUI_WARNING_FIXES
; 105  : 	for (uint i = 0; i < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); i++)
; 106  : #else
; 107  : 	for(int i = 0; i < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); i++)

	mov	ecx, DWORD PTR [edi]
	xor	esi, esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	test	eax, eax
	jle	SHORT $LN1@Write
$LL3@Write:

; 108  : #endif
; 109  : 	{
; 110  : 		CvInfosSerializationHelper::WriteHashed(kStream, static_cast<const PolicyTypes>(i));

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 111  : 		kStream << m_PolicyAIWeights.GetWeight(i);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [eax+esi*8+4]
	mov	DWORD PTR $T224323[esp+36], eax
	add	esp, 8
	lea	eax, DWORD PTR $T224323[esp+28]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _elem$224343[esp+32], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	esi, eax
	jl	SHORT $LL3@Write
$LN1@Write:
	pop	edi
	pop	esi
	pop	ebx

; 112  : 	}
; 113  : }

	add	esp, 16					; 00000010H
	ret	4
?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z ENDP		; CvPolicyAI::Write
_TEXT	ENDS
PUBLIC	?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoConsiderIdeologySwitch
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::DoSwitchIdeologies
EXTRN	?SetAnarchyNumTurns@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::SetAnarchyNumTurns
EXTRN	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetCulturePriority
EXTRN	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetSpaceshipPriority
EXTRN	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetUnitedNationsPriority
EXTRN	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetConquestPriority
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlayerCulture::GetPublicOpinionBiggestInfluence
EXTRN	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ:PROC ; CvPlayerPolicies::GetLateGamePolicyTree
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ:PROC ; CvPlayerCulture::GetPublicOpinionPreferredIdeology
EXTRN	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetPublicOpinionUnhappiness
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetExcessHappiness@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetExcessHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_bDontSwitchAutocracy$222199 = -34			; size = 1
_bDontSwitchOrder$222198 = -33				; size = 1
_iTechPriority$222202 = -32				; size = 4
_iCulturePriority$222203 = -28				; size = 4
_iPublicOpinionUnhappiness$ = -24			; size = 4
_ePreferredIdeology$ = -20				; size = 4
_iHappinessPreferredIdeology$222196 = -16		; size = 4
_iHappinessCurrentIdeology$222195 = -12			; size = 4
_eCurrentIdeology$ = -8					; size = 4
_eMostPressure$ = -4					; size = 4
_bDontSwitchFreedom$222197 = 8				; size = 1
_iCurrentHappiness$ = 8					; size = 4
_pPlayer$ = 8						; size = 4
?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z PROC ; CvPolicyAI::DoConsiderIdeologySwitch, COMDAT
; _this$ = ecx

; 603  : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi

; 604  : 	// Gather basic Ideology info
; 605  : 	int iCurrentHappiness = pPlayer->GetExcessHappiness();

	mov	esi, DWORD PTR _pPlayer$[esp+44]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness

; 606  : 	int iPublicOpinionUnhappiness = pPlayer->GetCulture()->GetPublicOpinionUnhappiness();

	mov	ecx, esi
	mov	DWORD PTR _iCurrentHappiness$[esp+48], eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness

; 607  : 	PolicyBranchTypes ePreferredIdeology = pPlayer->GetCulture()->GetPublicOpinionPreferredIdeology();

	mov	ecx, esi
	mov	DWORD PTR _iPublicOpinionUnhappiness$[esp+52], eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerCulture::GetPublicOpinionPreferredIdeology
	mov	ebx, eax

; 608  : 	PolicyBranchTypes eCurrentIdeology = pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, esi
	mov	DWORD PTR _ePreferredIdeology$[esp+52], ebx
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	ebp, eax

; 609  : 	PlayerTypes eMostPressure = pPlayer->GetCulture()->GetPublicOpinionBiggestInfluence();

	mov	ecx, esi
	mov	DWORD PTR _eCurrentIdeology$[esp+52], ebp
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ ; CvPlayerCulture::GetPublicOpinionBiggestInfluence
	mov	DWORD PTR _eMostPressure$[esp+52], eax

; 610  : 	
; 611  : 	// Possible enough that we need to look at this in detail?
; 612  : 	if (iCurrentHappiness <= GC.getSUPER_UNHAPPY_THRESHOLD() && iPublicOpinionUnhappiness >= 10)

	mov	eax, DWORD PTR _iCurrentHappiness$[esp+48]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6376
	jg	$LN1@DoConsider
	cmp	DWORD PTR _iPublicOpinionUnhappiness$[esp+52], 10 ; 0000000aH
	jl	$LN1@DoConsider

; 613  : 	{
; 614  : 		// How much Happiness could we gain from a switch?
; 615  : 		int iHappinessCurrentIdeology = GetBranchBuildingHappiness(pPlayer, eCurrentIdeology);

	push	ebp
	push	esi
	mov	ecx, edi
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness

; 616  : 		int iHappinessPreferredIdeology = GetBranchBuildingHappiness(pPlayer, ePreferredIdeology);

	push	ebx
	push	esi
	mov	ecx, edi
	mov	DWORD PTR _iHappinessCurrentIdeology$222195[esp+60], eax
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness

; 617  : 
; 618  : 		// Does the switch fight against our clearly preferred victory path?
; 619  : 		bool bDontSwitchFreedom = false;
; 620  : 		bool bDontSwitchOrder = false;
; 621  : 		bool bDontSwitchAutocracy = false;
; 622  : 		int iConquestPriority = pPlayer->GetGrandStrategyAI()->GetConquestPriority();

	mov	ecx, esi
	mov	DWORD PTR _iHappinessPreferredIdeology$222196[esp+52], eax
	mov	BYTE PTR _bDontSwitchFreedom$222197[esp+48], 0
	mov	BYTE PTR _bDontSwitchOrder$222198[esp+52], 0
	mov	BYTE PTR _bDontSwitchAutocracy$222199[esp+52], 0
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetConquestPriority

; 623  : 		int iDiploPriority = pPlayer->GetGrandStrategyAI()->GetUnitedNationsPriority();

	mov	ecx, esi
	mov	ebp, eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetUnitedNationsPriority

; 624  : 		int iTechPriority = pPlayer->GetGrandStrategyAI()->GetSpaceshipPriority();

	mov	ecx, esi
	mov	ebx, eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetSpaceshipPriority

; 625  : 		int iCulturePriority = pPlayer->GetGrandStrategyAI()->GetCulturePriority();

	mov	ecx, esi
	mov	DWORD PTR _iTechPriority$222202[esp+52], eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetCulturePriority

; 626  : 		int iClearPrefPercent = GC.getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8344

; 627  : 		if (iConquestPriority > (iDiploPriority   * (100 + iClearPrefPercent) / 100) &&
; 628  : 			iConquestPriority > (iTechPriority    * (100 + iClearPrefPercent) / 100) &&
; 629  : 			iConquestPriority > (iCulturePriority * (100 + iClearPrefPercent) / 100))

	add	ecx, 100				; 00000064H
	mov	edx, ecx
	imul	edx, ebx
	mov	DWORD PTR _iCulturePriority$222203[esp+52], eax
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	cmp	ebp, edi
	jle	SHORT $LN11@DoConsider
	mov	edx, ecx
	imul	edx, DWORD PTR _iTechPriority$222202[esp+52]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jle	SHORT $LN11@DoConsider
	mov	edx, ecx
	imul	edx, DWORD PTR _iCulturePriority$222203[esp+52]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jle	SHORT $LN11@DoConsider

; 630  : 		{
; 631  : 			bDontSwitchFreedom = true;

	mov	BYTE PTR _bDontSwitchFreedom$222197[esp+48], 1

; 632  : 		}
; 633  : 		else if (iDiploPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	$LN43@DoConsider
$LN11@DoConsider:

; 634  : 			iDiploPriority > (iTechPriority     * (100 + iClearPrefPercent) / 100) &&
; 635  : 			iDiploPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, ecx
	imul	edx, ebp
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	cmp	ebx, ebp
	jle	SHORT $LN41@DoConsider
	mov	edx, ecx
	imul	edx, DWORD PTR _iTechPriority$222202[esp+52]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jle	SHORT $LN41@DoConsider
	mov	edx, ecx
	imul	edx, DWORD PTR _iCulturePriority$222203[esp+52]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jle	SHORT $LN41@DoConsider

; 636  : 		{
; 637  : 			bDontSwitchOrder = true;

	mov	BYTE PTR _bDontSwitchOrder$222198[esp+52], 1

; 638  : 		}
; 639  : 		else if (iTechPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	SHORT $LN43@DoConsider
$LN41@DoConsider:

; 640  : 			iTechPriority > (iDiploPriority    * (100 + iClearPrefPercent) / 100) &&
; 641  : 			iTechPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	ebx, DWORD PTR _iTechPriority$222202[esp+52]
	cmp	ebx, ebp
	jle	SHORT $LN43@DoConsider
	cmp	ebx, edi
	jle	SHORT $LN43@DoConsider
	imul	ecx, DWORD PTR _iCulturePriority$222203[esp+52]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebx, ecx
	jle	SHORT $LN43@DoConsider

; 642  : 		{
; 643  : 			bDontSwitchAutocracy = true;

	mov	BYTE PTR _bDontSwitchAutocracy$222199[esp+52], 1
$LN43@DoConsider:

; 644  : 		}
; 645  : 
; 646  : 		int iTotalHappinessImprovement = iPublicOpinionUnhappiness + iHappinessPreferredIdeology - iHappinessCurrentIdeology;
; 647  : 		if (iTotalHappinessImprovement >= 10)

	mov	eax, DWORD PTR _iHappinessPreferredIdeology$222196[esp+52]
	sub	eax, DWORD PTR _iHappinessCurrentIdeology$222195[esp+52]
	add	eax, DWORD PTR _iPublicOpinionUnhappiness$[esp+52]
	cmp	eax, 10					; 0000000aH
	jl	$LN1@DoConsider

; 648  : 		{
; 649  : 			if (bDontSwitchFreedom && ePreferredIdeology == GC.getPOLICY_BRANCH_FREEDOM())

	cmp	BYTE PTR _bDontSwitchFreedom$222197[esp+48], 0
	mov	edi, DWORD PTR _ePreferredIdeology$[esp+52]
	je	SHORT $LN5@DoConsider
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	je	$LN1@DoConsider
$LN5@DoConsider:

; 650  : 			{
; 651  : 				return;
; 652  : 			}
; 653  : 			if (bDontSwitchAutocracy && ePreferredIdeology == GC.getPOLICY_BRANCH_AUTOCRACY())

	cmp	BYTE PTR _bDontSwitchAutocracy$222199[esp+52], 0
	je	SHORT $LN4@DoConsider
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	je	$LN1@DoConsider
$LN4@DoConsider:

; 654  : 			{
; 655  : 				return;
; 656  : 			}
; 657  : 			if (bDontSwitchOrder && ePreferredIdeology == GC.getPOLICY_BRANCH_ORDER())

	cmp	BYTE PTR _bDontSwitchOrder$222198[esp+52], 0
	je	SHORT $LN3@DoConsider
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	je	SHORT $LN1@DoConsider
$LN3@DoConsider:

; 658  : 			{
; 659  : 				return;
; 660  : 			}
; 661  : 
; 662  : 			// Cleared all obstacles -- REVOLUTION!
; 663  : 			pPlayer->SetAnarchyNumTurns(GC.getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6976
	push	edx
	mov	ecx, esi
	call	?SetAnarchyNumTurns@CvPlayer@@QAEXH@Z	; CvPlayer::SetAnarchyNumTurns

; 664  : 			pPlayer->GetPlayerPolicies()->DoSwitchIdeologies(ePreferredIdeology);	

	push	edi
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchIdeologies

; 665  : 
; 666  : 			if (ePreferredIdeology == GC.getPOLICY_BRANCH_FREEDOM() && eCurrentIdeology == GC.getPOLICY_BRANCH_ORDER())

	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	jne	SHORT $LN1@DoConsider
	mov	eax, DWORD PTR _eCurrentIdeology$[esp+52]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	jne	SHORT $LN1@DoConsider

; 667  : 			{
; 668  : 				if (GET_PLAYER(eMostPressure).GetID() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _eMostPressure$[esp+52]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	esi, DWORD PTR [eax+ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN1@DoConsider

; 669  : 				{
; 670  : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_39);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 671  : 				}
; 672  : 			}
; 673  : 		}
; 674  : 	}
; 675  : }

	add	esp, 36					; 00000024H

; 669  : 				{
; 670  : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_39);

	mov	DWORD PTR _pPlayer$[esp-4], 281		; 00000119H
	mov	eax, DWORD PTR [edx+828]
	jmp	eax
$LN1@DoConsider:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 671  : 				}
; 672  : 			}
; 673  : 		}
; 674  : 	}
; 675  : }

	add	esp, 36					; 00000024H
	ret	4
?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ENDP ; CvPolicyAI::DoConsiderIdeologySwitch
_TEXT	ENDS
PUBLIC	?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z	; CvPolicyAI::PropagateWeights
EXTRN	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z:PROC ; CvPolicyEntry::GetPrereqAndPolicies
EXTRN	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z:PROC ; CvPolicyXMLEntries::GetPolicyEntry
; Function compile flags: /Ogtpy
;	COMDAT ?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z
_TEXT	SEGMENT
_iPolicy$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
_iPropagationLevel$ = 20				; size = 4
?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z PROC		; CvPolicyAI::PropagateWeights, COMDAT
; _this$ = ecx

; 813  : {

	push	ebp

; 814  : 	if(iPropagationLevel < m_iPolicyWeightPropagationLevels)

	mov	ebp, DWORD PTR _iPropagationLevel$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebp, DWORD PTR [edi+1060]
	jge	SHORT $LN3@PropagateW

; 815  : 	{
; 816  : 		int iPropagatedWeight = iWeight * iPropagationPercent / 100;

	mov	ecx, DWORD PTR _iWeight$[esp+4]
	imul	ecx, DWORD PTR _iPropagationPercent$[esp+4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	push	ebx
	sar	edx, 5
	push	esi
	mov	esi, edx
	shr	esi, 31					; 0000001fH

; 817  : 
; 818  : 		// Loop through all prerequisites
; 819  : 		for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	xor	ebx, ebx
	add	esi, edx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268, ebx
	jle	SHORT $LN19@PropagateW
$LL6@PropagateW:

; 820  : 		{
; 821  : 			// Did we find a prereq?
; 822  : 			int iPrereq = m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicy)->GetPrereqAndPolicies(iI);

	mov	eax, DWORD PTR _iPolicy$[esp+12]
	mov	ecx, DWORD PTR [edi]
	push	ebx
	push	eax
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPrereqAndPolicies

; 823  : 			if(iPrereq != NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN19@PropagateW

; 824  : 			{
; 825  : 				// Apply reduced weight here.  Note that we apply these to the master weight array, not
; 826  : 				// the temporary one.  The temporary one is just used to hold the newly weighted policies
; 827  : 				// (from which this weight propagation must originate).
; 828  : 				m_PolicyAIWeights.IncreaseWeight(iPrereq, iPropagatedWeight);

	mov	ecx, DWORD PTR [edi+4]
	add	DWORD PTR [ecx+eax*8+4], esi
	lea	ecx, DWORD PTR [ecx+eax*8+4]

; 829  : 
; 830  : 				// Recurse to its prereqs (assuming we have any weight left)
; 831  : 				if(iPropagatedWeight > 0)

	test	esi, esi
	jle	SHORT $LN5@PropagateW

; 832  : 				{
; 833  : 					PropagateWeights(iPrereq, iPropagatedWeight, iPropagationPercent, iPropagationLevel++);

	mov	edx, DWORD PTR _iPropagationPercent$[esp+12]
	push	ebp
	push	edx
	push	esi
	push	eax
	mov	ecx, edi
	call	?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z ; CvPolicyAI::PropagateWeights
	inc	ebp
$LN5@PropagateW:
	inc	ebx
	cmp	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	jl	SHORT $LL6@PropagateW
$LN19@PropagateW:
	pop	esi
	pop	ebx
$LN3@PropagateW:
	pop	edi
	pop	ebp

; 834  : 				}
; 835  : 			}
; 836  : 			else
; 837  : 			{
; 838  : 				break;
; 839  : 			}
; 840  : 		}
; 841  : 	}
; 842  : }

	ret	16					; 00000010H
?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z ENDP		; CvPolicyAI::PropagateWeights
_TEXT	ENDS
PUBLIC	?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z ; CvPolicyAI::WeighBranch
EXTRN	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ:PROC	; CvPolicyBranchEntry::GetFreePolicy
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
; Function compile flags: /Ogtpy
;	COMDAT ?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_pkPolicyBranchInfo$ = -12				; size = 4
_elem$224459 = -8					; size = 8
_elem$224445 = -8					; size = 8
_eBranch$ = 8						; size = 4
?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::WeighBranch, COMDAT
; _this$ = ecx

; 846  : {

	sub	esp, 12					; 0000000cH

; 847  : 	int iWeight = 0;
; 848  : 
; 849  : 	CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranch);

	mov	eax, DWORD PTR _eBranch$[esp+8]
	push	ebx
	push	ebp
	push	edi
	mov	edi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	ebx, eax
	mov	DWORD PTR _pkPolicyBranchInfo$[esp+24], ebx

; 850  : 	if(pkPolicyBranchInfo)

	test	ebx, ebx
	je	$LN25@WeighBranc

; 851  : 	{
; 852  : #ifdef AUI_WARNING_FIXES
; 853  : 		for (uint iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 854  : #else
; 855  : 		for(int iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	ecx, DWORD PTR [edi]
	push	esi
	xor	esi, esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	test	eax, eax
	jle	SHORT $LN5@WeighBranc
	npad	4
$LL26@WeighBranc:

; 856  : #endif
; 857  : 		{
; 858  : 			const PolicyTypes ePolicyLoop = static_cast<PolicyTypes>(iPolicyLoop);
; 859  : 			CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(ePolicyLoop);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	ebx, eax

; 860  : 			if(pkLoopPolicyInfo)

	test	ebx, ebx
	je	SHORT $LN6@WeighBranc

; 861  : 			{
; 862  : 				// Policy we don't have?
; 863  : 				if(!m_pCurrentPolicies->HasPolicy(ePolicyLoop))

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	jne	SHORT $LN6@WeighBranc

; 864  : 				{
; 865  : 					// From this branch we are considering opening?
; 866  : 					if(pkLoopPolicyInfo->GetPolicyBranchType() == eBranch)

	mov	ecx, ebx
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[esp+24]
	jne	SHORT $LN6@WeighBranc

; 867  : 					{
; 868  : 						// With no prereqs?
; 869  : 						if(pkLoopPolicyInfo->GetPrereqAndPolicies(0) == NO_POLICY)

	push	0
	mov	ecx, ebx
	call	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPrereqAndPolicies
	cmp	eax, -1
	jne	SHORT $LN6@WeighBranc

; 870  : 						{
; 871  : 							iWeight += m_PolicyAIWeights.GetWeight(iPolicyLoop);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+esi*8]
	add	ebp, DWORD PTR [eax+esi*8+4]
	mov	DWORD PTR _elem$224445[esp+28], ecx
$LN6@WeighBranc:
	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	esi, eax
	jl	SHORT $LL26@WeighBranc

; 851  : 	{
; 852  : #ifdef AUI_WARNING_FIXES
; 853  : 		for (uint iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 854  : #else
; 855  : 		for(int iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	ebx, DWORD PTR _pkPolicyBranchInfo$[esp+28]
$LN5@WeighBranc:

; 872  : 						}
; 873  : 					}
; 874  : 				}
; 875  : 			}
; 876  : 		}
; 877  : 
; 878  : 		// Add weight of free policy from branch
; 879  : 		iWeight += m_PolicyAIWeights.GetWeight(pkPolicyBranchInfo->GetFreePolicy());

	mov	ecx, ebx
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	mov	edi, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+eax*8]
	add	ebp, DWORD PTR [edi+eax*8+4]
	mov	DWORD PTR _elem$224459[esp+28], edx
	pop	esi
$LN25@WeighBranc:
	pop	edi

; 880  : 	}
; 881  : 
; 882  : 	return iWeight;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 883  : }

	add	esp, 12					; 0000000cH
	ret	4
?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::WeighBranch
_TEXT	ENDS
PUBLIC	?LogPossiblePolicies@CvPolicyAI@@AAEXXZ		; CvPolicyAI::LogPossiblePolicies
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyBranchInfos
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ:PROC ; CvPlayerPolicies::GetPlayer
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
_TEXT	SEGMENT
_elem$224537 = -216					; size = 8
_playerName$222346 = -208				; size = 28
_strBaseString$222344 = -180				; size = 28
_strTemp$222345 = -152					; size = 28
_strOutBuf$222343 = -124				; size = 28
$T224472 = -96						; size = 28
$T224469 = -96						; size = 28
$T224468 = -68						; size = 28
_strDesc$222347 = -40					; size = 28
__$EHRec$ = -12						; size = 12
?LogPossiblePolicies@CvPolicyAI@@AAEXXZ PROC		; CvPolicyAI::LogPossiblePolicies, COMDAT
; _this$ = ecx

; 913  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 204				; 000000ccH
	push	esi
	mov	esi, ecx

; 914  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@LogPossibl

; 915  : 	{
; 916  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$222343[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 917  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$222344[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 918  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222345[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 919  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$222346[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 920  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$222347[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 921  : 
; 922  : 		// Find the name of this civ and city
; 923  : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+228], 4
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$222346[esp+220]
	test	eax, eax
	je	SHORT $LN35@LogPossibl
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN34@LogPossibl
$LN35@LogPossibl:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN34@LogPossibl:
	push	ebx
	push	ebp
	push	edi

; 924  : 
; 925  : 		FILogFile* pLog;
; 926  : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	lea	eax, DWORD PTR _playerName$222346[esp+232]
	push	eax
	lea	ecx, DWORD PTR $T224468[esp+236]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+240], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T224468[esp+232]
	mov	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+240], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 927  : 
; 928  : 		// Get the leading info for this line
; 929  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222344[esp+236]
	push	OFFSET $SG222350
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 930  : 		strBaseString += playerName + ", ";

	push	OFFSET $SG222352
	lea	edx, DWORD PTR _playerName$222346[esp+248]
	push	edx
	lea	eax, DWORD PTR $T224469[esp+252]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222344[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T224469[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 931  : 
; 932  : #ifdef AUI_WARNING_FIXES
; 933  : 		uint iNumBranches = GC.getNumPolicyBranchInfos();
; 934  : #else
; 935  : 		int iNumBranches = GC.getNumPolicyBranchInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos

; 936  : #endif
; 937  : 
; 938  : 		// Dump out the weight of each possible policy
; 939  : 		for(int iI = 0; iI < m_AdoptablePolicies.size(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+536], edi
	mov	ebx, eax
	jle	$LN3@LogPossibl
$LL5@LogPossibl:
	mov	ecx, DWORD PTR [esi+532]

; 940  : 		{
; 941  : 			int iWeight = m_AdoptablePolicies.GetWeight(iI);

	mov	edx, DWORD PTR [ecx+edi*8]
	lea	eax, DWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR [eax+4]

; 942  : 
; 943  : 			if(m_AdoptablePolicies.GetElement(iI) < iNumBranches)

	mov	eax, edx
	cmp	eax, ebx
	mov	DWORD PTR _elem$224537[esp+232], edx
	mov	DWORD PTR _elem$224537[esp+236], ecx
	jge	SHORT $LN2@LogPossibl

; 944  : 			{
; 945  : 				strTemp.Format("Branch %d, %d", m_AdoptablePolicies.GetElement(iI), iWeight);

	push	ecx
	push	eax
	push	OFFSET $SG222360
	lea	eax, DWORD PTR _strTemp$222345[esp+244]
	push	eax

; 946  : 			}
; 947  : 			else

	jmp	SHORT $LN91@LogPossibl
$LN2@LogPossibl:

; 948  : 			{
; 949  : 
; 950  : 				PolicyTypes ePolicy = (PolicyTypes)(m_AdoptablePolicies.GetElement(iI) - iNumBranches);

	sub	eax, ebx

; 951  : 				CvPolicyEntry* pPolicyEntry = GC.getPolicyInfo(ePolicy);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 952  : 				const char* szPolicyType = (pPolicyEntry != NULL)? pPolicyEntry->GetType() : "Unknown";

	test	eax, eax
	je	SHORT $LN9@LogPossibl
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN10@LogPossibl
$LN9@LogPossibl:
	mov	eax, OFFSET $SG222366
$LN10@LogPossibl:

; 953  : 				strTemp.Format("%s, %d", szPolicyType, iWeight);

	mov	ecx, DWORD PTR _elem$224537[esp+236]
	push	ecx
	push	eax
	push	OFFSET $SG222367
	lea	edx, DWORD PTR _strTemp$222345[esp+244]
	push	edx
$LN91@LogPossibl:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 954  : 			}
; 955  : 			strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$222345[esp+232]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222344[esp+236]
	push	ecx
	lea	edx, DWORD PTR $T224472[esp+240]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+240], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$222343[esp+236]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T224472[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 956  : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$222343[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [esi+536]
	jl	$LL5@LogPossibl
$LN3@LogPossibl:

; 957  : 		}
; 958  : 	}

	lea	ecx, DWORD PTR _strDesc$222347[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$222346[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222345[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$222344[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$222343[esp+232]
	mov	DWORD PTR __$EHRec$[esp+240], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN6@LogPossibl:

; 959  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+220]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 216				; 000000d8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$222343[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$222344[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$222345[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$222346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strDesc$222347[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T224468[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T224469[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T224472[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossiblePolicies@CvPolicyAI@@AAEXXZ ENDP		; CvPolicyAI::LogPossiblePolicies
PUBLIC	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
_TEXT	SEGMENT
_playerName$222377 = -208				; size = 28
_strBaseString$222375 = -180				; size = 28
_strOutBuf$222374 = -152				; size = 28
$T224614 = -124						; size = 28
$T224611 = -124						; size = 28
_strTemp$222376 = -96					; size = 28
$T224610 = -68						; size = 28
_strDesc$222378 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_ePolicy$ = 8						; size = 4
?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z PROC	; CvPolicyAI::LogPolicyChoice, COMDAT
; _this$ = ecx

; 963  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 964  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogPolicyC
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogPolicyC
	push	ebx
	push	esi

; 965  : 	{
; 966  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$222374[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 967  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$222375[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 968  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222376[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 969  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$222377[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 970  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$222378[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 971  : 
; 972  : 		// Find the name of this civ and city
; 973  : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$222377[esp+220]
	test	eax, eax
	je	SHORT $LN30@LogPolicyC
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogPolicyC
$LN30@LogPolicyC:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogPolicyC:

; 974  : 
; 975  : 		FILogFile* pLog;
; 976  : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _playerName$222377[esp+220]
	push	eax
	lea	ecx, DWORD PTR $T224610[esp+224]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T224610[esp+220]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 977  : 
; 978  : 		// Get the leading info for this line
; 979  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222375[esp+224]
	push	OFFSET $SG222381
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 980  : 		strBaseString += playerName + ", ";

	push	OFFSET $SG222383
	lea	edx, DWORD PTR _playerName$222377[esp+236]
	push	edx
	lea	eax, DWORD PTR $T224611[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222375[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T224611[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 981  : 
; 982  : 		CvPolicyEntry* pPolicyEntry = GC.getPolicyInfo(ePolicy);

	mov	ecx, DWORD PTR _ePolicy$[esp+216]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 983  : 		const char* szPolicyType = (pPolicyEntry != NULL)? pPolicyEntry->GetType() : "Unknown";

	test	eax, eax
	je	SHORT $LN4@LogPolicyC
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN5@LogPolicyC
$LN4@LogPolicyC:
	mov	eax, OFFSET $SG222386
$LN5@LogPolicyC:

; 984  : 		strTemp.Format("CHOSEN, %s", szPolicyType);

	push	eax
	lea	edx, DWORD PTR _strTemp$222376[esp+224]
	push	OFFSET $SG222387
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 985  : 
; 986  : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$222376[esp+232]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222375[esp+236]
	push	ecx
	lea	edx, DWORD PTR $T224614[esp+240]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$222374[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T224614[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 987  : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$222374[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 988  : 	}

	lea	ecx, DWORD PTR _strDesc$222378[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$222377[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222376[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$222375[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$222374[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogPolicyC:

; 989  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$222374[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$222375[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$222376[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$222377[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$222378[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$5:
	lea	ecx, DWORD PTR $T224610[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$6:
	lea	ecx, DWORD PTR $T224611[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$7:
	lea	ecx, DWORD PTR $T224614[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ENDP	; CvPolicyAI::LogPolicyChoice
PUBLIC	?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ; CvPolicyAI::LogBranchChoice
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_playerName$222397 = -208				; size = 28
_strBaseString$222395 = -180				; size = 28
_strOutBuf$222394 = -152				; size = 28
$T224704 = -124						; size = 28
$T224703 = -124						; size = 28
_strTemp$222396 = -96					; size = 28
$T224702 = -68						; size = 28
_strDesc$222398 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eBranch$ = 8						; size = 4
?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::LogBranchChoice, COMDAT
; _this$ = ecx

; 993  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 994  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogBranchC
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogBranchC
	push	ebx
	push	esi

; 995  : 	{
; 996  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$222394[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 997  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$222395[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 998  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222396[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 999  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$222397[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1000 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$222398[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1001 : 
; 1002 : 		// Find the name of this civ and city
; 1003 : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$222397[esp+220]
	test	eax, eax
	je	SHORT $LN28@LogBranchC
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN27@LogBranchC
$LN28@LogBranchC:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN27@LogBranchC:

; 1004 : 
; 1005 : 		FILogFile* pLog;
; 1006 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _playerName$222397[esp+220]
	push	eax
	lea	ecx, DWORD PTR $T224702[esp+224]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T224702[esp+220]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1007 : 
; 1008 : 		// Get the leading info for this line
; 1009 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222395[esp+224]
	push	OFFSET $SG222401
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1010 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG222403
	lea	edx, DWORD PTR _playerName$222397[esp+236]
	push	edx
	lea	eax, DWORD PTR $T224703[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222395[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T224703[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1011 : 
; 1012 : 		strTemp.Format("CHOSEN, Branch %d", eBranch);

	mov	ecx, DWORD PTR _eBranch$[esp+216]
	push	ecx
	lea	edx, DWORD PTR _strTemp$222396[esp+224]
	push	OFFSET $SG222404
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1013 : 
; 1014 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$222396[esp+232]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222395[esp+236]
	push	ecx
	lea	edx, DWORD PTR $T224704[esp+240]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$222394[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T224704[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1015 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$222394[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 1016 : 	}

	lea	ecx, DWORD PTR _strDesc$222398[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+228], 2
	lea	ecx, DWORD PTR _playerName$222397[esp+220]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222396[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$222395[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$222394[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogBranchC:

; 1017 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$222394[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$222395[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$222396[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$222397[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$222398[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$5:
	lea	ecx, DWORD PTR $T224702[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$6:
	lea	ecx, DWORD PTR $T224703[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$7:
	lea	ecx, DWORD PTR $T224704[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::LogBranchChoice
PUBLIC	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
_TEXT	SEGMENT
_playerName$222417 = -180				; size = 28
_strBaseString$222415 = -152				; size = 28
_strTemp$222416 = -124					; size = 28
$T224791 = -96						; size = 28
$T224790 = -96						; size = 28
_strOutBuf$222414 = -68					; size = 28
$T224789 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_decisionState$ = 8					; size = 4
_iWeightFreedom$ = 12					; size = 4
_iWeightAutocracy$ = 16					; size = 4
_iWeightOrder$ = 20					; size = 4
?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z PROC ; CvPolicyAI::LogIdeologyChoice, COMDAT
; _this$ = ecx

; 1021 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	edi
	mov	edi, ecx

; 1022 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogIdeolog
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogIdeolog
	push	ebx
	push	esi

; 1023 : 	{
; 1024 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$222414[esp+192]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1025 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$222415[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1026 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222416[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1027 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$222417[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1028 : 
; 1029 : 		// Find the name of this civ
; 1030 : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 3
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$222417[esp+192]
	test	eax, eax
	je	SHORT $LN24@LogIdeolog
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@LogIdeolog
$LN24@LogIdeolog:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@LogIdeolog:

; 1031 : 
; 1032 : 		FILogFile* pLog;
; 1033 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _playerName$222417[esp+192]
	push	eax
	lea	ecx, DWORD PTR $T224789[esp+196]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+200], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T224789[esp+192]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1034 : 
; 1035 : 		// Get the leading info for this line
; 1036 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222415[esp+196]
	push	OFFSET $SG222420
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1037 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG222422
	lea	edx, DWORD PTR _playerName$222417[esp+208]
	push	edx
	lea	eax, DWORD PTR $T224790[esp+212]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$222415[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T224790[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1038 : 
; 1039 : 		strTemp.Format("%s, Freedom: %d, Order: %d, Autocracy: %d", decisionState.c_str(), iWeightFreedom, iWeightOrder, iWeightAutocracy);

	mov	ecx, DWORD PTR _iWeightAutocracy$[esp+188]
	mov	edx, DWORD PTR _iWeightOrder$[esp+188]
	mov	eax, DWORD PTR _iWeightFreedom$[esp+188]
	push	ecx
	mov	ecx, DWORD PTR _decisionState$[esp+192]
	push	edx
	push	eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222416[esp+208]
	push	OFFSET $SG222423
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1040 : 
; 1041 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$222416[esp+216]
	push	edx
	lea	eax, DWORD PTR _strBaseString$222415[esp+220]
	push	eax
	lea	ecx, DWORD PTR $T224791[esp+224]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 36					; 00000024H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+200], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$222414[esp+196]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T224791[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1042 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$222414[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	push	esi
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 8

; 1043 : 	}

	lea	ecx, DWORD PTR _playerName$222417[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222416[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$222415[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$222414[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogIdeolog:

; 1044 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+184]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 180				; 000000b4H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$222414[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$1:
	lea	ecx, DWORD PTR _strBaseString$222415[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$2:
	lea	ecx, DWORD PTR _strTemp$222416[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$3:
	lea	ecx, DWORD PTR _playerName$222417[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$4:
	lea	ecx, DWORD PTR $T224789[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$5:
	lea	ecx, DWORD PTR $T224790[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$6:
	lea	ecx, DWORD PTR $T224791[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ENDP ; CvPolicyAI::LogIdeologyChoice
PUBLIC	?clear@?$CvWeightedVector@H$0EA@$00@@QAEXXZ	; CvWeightedVector<int,64,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@H$0EA@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@H$0EA@$00@@QAEXXZ PROC	; CvWeightedVector<int,64,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@H$0EA@$00@@QAEXXZ ENDP	; CvWeightedVector<int,64,1>::clear
_TEXT	ENDS
PUBLIC	?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,64,1>::ChooseAtRandom
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_rndFcn$ = 8						; size = 4
_szRollName$ = 12					; size = 4
?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,64,1>::ChooseAtRandom, COMDAT
; _this$ = ecx

; 185  : 	{

	push	esi
	push	edi

; 186  : 		int iChoice;
; 187  : 
; 188  : 		// Based on the number of elements we have, pick one at random
; 189  : 		iChoice = (*rndFcn)(m_pItems.size(), szRollName);

	mov	edi, DWORD PTR _szRollName$[esp+4]
	mov	esi, ecx
	mov	ecx, DWORD PTR _rndFcn$[esp+4]
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	push	eax
	call	edx

; 190  : 		WeightedElement elem = m_pItems[iChoice];
; 191  : 
; 192  : 		return elem.m_Element;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+eax*8]
	pop	edi
	pop	esi

; 193  : 	};

	ret	8
?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,64,1>::ChooseAtRandom
_TEXT	ENDS
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,64,1>::ChooseFromTopChoices
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,64,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebx
	push	esi
	mov	ebx, ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR [ebx+4]
	push	edi
	mov	edi, DWORD PTR _iNumChoices$[esp+8]
	cmp	edi, eax
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	edi, eax
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	xor	esi, esi

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	xor	ecx, ecx

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	test	edi, edi
	jle	SHORT $LN5@ChooseFrom
	mov	eax, DWORD PTR [ebx]
	mov	edx, edi
	npad	2
$LL7@ChooseFrom:

; 237  : 		{
; 238  : 			elem = m_pItems[i];
; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	add	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL7@ChooseFrom
$LN5@ChooseFrom:

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	eax, DWORD PTR _szRollName$[esp+8]
	push	eax
	mov	eax, DWORD PTR _rndFcn$[esp+12]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	edx

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN2@ChooseFrom

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	ecx, DWORD PTR [ebx]
$LL4@ChooseFrom:

; 247  : 		{
; 248  : 			elem = m_pItems[i];
; 249  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]

; 250  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseFrom
	inc	edx
	add	ecx, 8
	cmp	edx, edi
	jl	SHORT $LL4@ChooseFrom
$LN2@ChooseFrom:
	pop	edi

; 251  : 			{
; 252  : 				return elem.m_Element;
; 253  : 			}
; 254  : 		}
; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, esi
	pop	esi
	pop	ebx

; 260  : 	};

	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,64,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>, COMDAT
; _this$ = ecx

; 1041 : 	FastDelegate2() { clear(); }

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
_TEXT	ENDS
PUBLIC	??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::operator=, COMDAT
; _this$ = ecx

; 1045 : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	eax, DWORD PTR _x$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	ret	4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN34@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+524], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>, COMDAT
; _this$ = ecx

; 1057 : 		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoChooseIdeology
EXTRN	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z:PROC ; CvPlayerPolicies::SetPolicyBranchUnlocked
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z:PROC ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::IsPlayerValid
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z:PROC ; PolicyHelpers::GetNumFreePolicies
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z$0
__ehfuncinfo$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
_eFreedomBranch$ = -84					; size = 4
_eAutocracyBranch$ = -80				; size = 4
_eOrderBranch$ = -76					; size = 4
$T225361 = -72						; size = 4
_iTechPriority$ = -72					; size = 4
$T225359 = -68						; size = 4
_iDiploPriority$ = -68					; size = 4
tv950 = -64						; size = 4
_iHappinessDelta$ = -64					; size = 4
$T225357 = -64						; size = 4
_iConquestPriority$ = -64				; size = 4
$T225369 = -60						; size = 4
$T225367 = -60						; size = 4
$T225365 = -60						; size = 4
_iPlayerLoop$222123 = -60				; size = 4
$T225362 = -60						; size = 4
_iCulturePriority$ = -60				; size = 4
$T225360 = -60						; size = 4
$T225358 = -60						; size = 4
$T225356 = -60						; size = 4
_iFreedomMultiplier$ = -56				; size = 4
_iAutocracyMultiplier$ = -52				; size = 4
_iOrderMultiplier$ = -48				; size = 4
tv666 = -44						; size = 4
$T225368 = -44						; size = 4
$T225366 = -44						; size = 4
$T225364 = -44						; size = 4
_iOrderTotal$ = -44					; size = 4
$T225363 = -44						; size = 4
_stage$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z PROC	; CvPolicyAI::DoChooseIdeology, COMDAT
; _this$ = ecx

; 377  : {

	push	-1
	push	__ehhandler$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH

; 378  : 	int iFreedomPriority = 0;
; 379  : 	int iAutocracyPriority = 0;
; 380  : 	int iOrderPriority = 0;
; 381  : 	int iFreedomMultiplier = 1;
; 382  : 	int iAutocracyMultiplier = 1;
; 383  : 	int iOrderMultiplier = 1;
; 384  : 	PolicyBranchTypes eFreedomBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();
; 385  : 	PolicyBranchTypes eAutocracyBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();
; 386  : 	PolicyBranchTypes eOrderBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	push	ebx
	mov	eax, 1
	push	ebp
	mov	DWORD PTR _iFreedomMultiplier$[esp+96], eax
	mov	DWORD PTR _iAutocracyMultiplier$[esp+96], eax
	mov	DWORD PTR _iOrderMultiplier$[esp+96], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	push	edi
	mov	DWORD PTR _this$[esp+100], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	xor	ebx, ebx
	xor	ebp, ebp
	xor	edi, edi
	mov	DWORD PTR _eFreedomBranch$[esp+100], eax
	mov	DWORD PTR _eAutocracyBranch$[esp+100], ecx
	mov	DWORD PTR _eOrderBranch$[esp+100], edx

; 387  : 	if (eFreedomBranch == NO_POLICY_BRANCH_TYPE || eAutocracyBranch == NO_POLICY_BRANCH_TYPE || eOrderBranch == NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	je	$LN45@DoChooseId
	cmp	ecx, -1
	je	$LN45@DoChooseId
	cmp	edx, -1
	je	$LN45@DoChooseId
	push	esi

; 388  : 	{
; 389  : 		return;
; 390  : 	}
; 391  : 
; 392  : 	// First consideration is our victory type
; 393  : 	int iConquestPriority = max(0, pPlayer->GetGrandStrategyAI()->GetConquestPriority());

	mov	esi, DWORD PTR _pPlayer$[esp+100]
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetConquestPriority
	mov	DWORD PTR $T225356[esp+104], eax
	test	eax, eax
	mov	DWORD PTR $T225357[esp+104], ebx
	lea	eax, DWORD PTR $T225356[esp+104]
	jg	SHORT $LN59@DoChooseId
	lea	eax, DWORD PTR $T225357[esp+104]
$LN59@DoChooseId:
	mov	eax, DWORD PTR [eax]

; 394  : 	int iDiploPriority = max(0, pPlayer->GetGrandStrategyAI()->GetUnitedNationsPriority());

	mov	ecx, esi
	mov	DWORD PTR _iConquestPriority$[esp+104], eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetUnitedNationsPriority
	mov	DWORD PTR $T225358[esp+104], eax
	test	eax, eax
	mov	DWORD PTR $T225359[esp+104], ebx
	lea	eax, DWORD PTR $T225358[esp+104]
	jg	SHORT $LN63@DoChooseId
	lea	eax, DWORD PTR $T225359[esp+104]
$LN63@DoChooseId:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iDiploPriority$[esp+104], ecx

; 395  : 	int iTechPriority = max(0, pPlayer->GetGrandStrategyAI()->GetSpaceshipPriority());

	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetSpaceshipPriority
	mov	DWORD PTR $T225360[esp+104], eax
	test	eax, eax
	mov	DWORD PTR $T225361[esp+104], ebx
	lea	eax, DWORD PTR $T225360[esp+104]
	jg	SHORT $LN67@DoChooseId
	lea	eax, DWORD PTR $T225361[esp+104]
$LN67@DoChooseId:
	mov	edx, DWORD PTR [eax]

; 396  : 	int iCulturePriority = max(0, pPlayer->GetGrandStrategyAI()->GetCulturePriority());

	mov	ecx, esi
	mov	DWORD PTR _iTechPriority$[esp+104], edx
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetCulturePriority
	mov	DWORD PTR $T225362[esp+104], eax
	test	eax, eax
	mov	DWORD PTR $T225363[esp+104], ebx
	lea	eax, DWORD PTR $T225362[esp+104]
	jg	SHORT $LN71@DoChooseId
	lea	eax, DWORD PTR $T225363[esp+104]
$LN71@DoChooseId:

; 397  : 
; 398  : 	// Rule out one ideology if we are clearly (at least 25% more priority) going for the victory this ideology doesn't support
; 399  : 	int iClearPrefPercent = GC.getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8344
	mov	eax, DWORD PTR [eax]

; 400  : 	if (iConquestPriority > (iDiploPriority   * (100 + iClearPrefPercent) / 100) &&
; 401  : 		iConquestPriority > (iTechPriority    * (100 + iClearPrefPercent) / 100) &&
; 402  : 		iConquestPriority > (iCulturePriority * (100 + iClearPrefPercent) / 100))

	add	ecx, 100				; 00000064H
	mov	edx, ecx
	imul	edx, DWORD PTR _iDiploPriority$[esp+104]
	mov	DWORD PTR _iCulturePriority$[esp+104], eax
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	cmp	DWORD PTR _iConquestPriority$[esp+104], esi
	jle	SHORT $LN179@DoChooseId
	mov	edx, ecx
	imul	edx, DWORD PTR _iTechPriority$[esp+104]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _iConquestPriority$[esp+104], eax
	jle	SHORT $LN179@DoChooseId
	mov	edx, ecx
	imul	edx, DWORD PTR _iCulturePriority$[esp+104]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _iConquestPriority$[esp+104], eax
	jle	SHORT $LN179@DoChooseId

; 403  : 	{
; 404  : 		iFreedomMultiplier = 0;

	mov	DWORD PTR _iFreedomMultiplier$[esp+104], ebx

; 405  : 	}
; 406  : 	else if (iDiploPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	$LN181@DoChooseId
$LN179@DoChooseId:

; 407  : 		iDiploPriority > (iTechPriority     * (100 + iClearPrefPercent) / 100) &&
; 408  : 		iDiploPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, ecx
	imul	edx, DWORD PTR _iConquestPriority$[esp+104]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _iDiploPriority$[esp+104], eax
	mov	DWORD PTR tv666[esp+104], eax
	jle	SHORT $LN42@DoChooseId
	mov	edx, ecx
	imul	edx, DWORD PTR _iTechPriority$[esp+104]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _iDiploPriority$[esp+104], eax
	jle	SHORT $LN180@DoChooseId
	mov	edx, ecx
	imul	edx, DWORD PTR _iCulturePriority$[esp+104]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _iDiploPriority$[esp+104], eax
	jle	SHORT $LN180@DoChooseId

; 409  : 	{
; 410  : 		iOrderMultiplier = 0;

	mov	DWORD PTR _iOrderMultiplier$[esp+104], ebx

; 411  : 	}
; 412  : 	else if (iTechPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	SHORT $LN181@DoChooseId
$LN180@DoChooseId:
	mov	eax, DWORD PTR tv666[esp+104]
$LN42@DoChooseId:

; 413  : 		iTechPriority > (iDiploPriority    * (100 + iClearPrefPercent) / 100) &&
; 414  : 		iTechPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, DWORD PTR _iTechPriority$[esp+104]
	cmp	edx, eax
	jle	SHORT $LN181@DoChooseId
	cmp	edx, esi
	jle	SHORT $LN181@DoChooseId
	imul	ecx, DWORD PTR _iCulturePriority$[esp+104]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	DWORD PTR _iTechPriority$[esp+104], ecx
	jle	SHORT $LN181@DoChooseId

; 415  : 	{
; 416  : 		iAutocracyMultiplier = 0;

	mov	DWORD PTR _iAutocracyMultiplier$[esp+104], ebx
$LN181@DoChooseId:

; 417  : 	}
; 418  : 
; 419  : 	int iFreedomTotal = iDiploPriority + iTechPriority + iCulturePriority;

	mov	esi, DWORD PTR _iCulturePriority$[esp+104]
	mov	edx, DWORD PTR _iTechPriority$[esp+104]
	mov	ecx, DWORD PTR _iDiploPriority$[esp+104]
	lea	eax, DWORD PTR [esi+edx]

; 420  : 	int iAutocracyTotal = iDiploPriority + iConquestPriority + iCulturePriority;

	add	esi, ecx
	lea	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _iConquestPriority$[esp+104]
	add	esi, ecx

; 421  : 	int iOrderTotal = iTechPriority + iConquestPriority + iCulturePriority;

	add	ecx, eax
	mov	DWORD PTR _iOrderTotal$[esp+104], ecx

; 422  : 	int iGrandTotal = iFreedomTotal + iAutocracyTotal + iOrderTotal;

	add	ecx, esi
	add	ecx, edx

; 423  : 
; 424  : 	if (iGrandTotal > 0)

	test	ecx, ecx
	jle	SHORT $LN39@DoChooseId

; 425  : 	{
; 426  : 		int iPriorityToDivide = GC.getIDEOLOGY_SCORE_GRAND_STRATS();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8348

; 427  : 		iFreedomPriority = (iFreedomTotal * iPriorityToDivide) / iGrandTotal;

	mov	eax, edi
	imul	eax, edx
	cdq
	idiv	ecx
	mov	ebx, eax

; 428  : 		iAutocracyPriority = (iAutocracyTotal * iPriorityToDivide) / iGrandTotal;

	mov	eax, edi
	imul	eax, esi
	cdq
	idiv	ecx
	mov	ebp, eax

; 429  : 		iOrderPriority = (iOrderTotal * iPriorityToDivide) / iGrandTotal;

	mov	eax, edi
	imul	eax, DWORD PTR _iOrderTotal$[esp+104]
	cdq
	idiv	ecx
	mov	edi, eax
$LN39@DoChooseId:

; 430  : 	}
; 431  : 
; 432  : 	CvString stage = "After Grand Strategies";

	push	OFFSET $SG222120
	lea	ecx, DWORD PTR _stage$[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 433  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	ecx, DWORD PTR _this$[esp+104]
	push	edi
	push	ebp
	push	ebx
	lea	eax, DWORD PTR _stage$[esp+116]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 434  : 
; 435  : 	// Next look at free policies we can get
; 436  : 	iFreedomPriority += PolicyHelpers::GetNumFreePolicies(eFreedomBranch) * GC.getIDEOLOGY_SCORE_PER_FREE_TENET();

	mov	ecx, DWORD PTR _eFreedomBranch$[esp+104]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8356
	push	ecx
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	imul	eax, esi

; 437  : 	iAutocracyPriority += PolicyHelpers::GetNumFreePolicies(eAutocracyBranch) * GC.getIDEOLOGY_SCORE_PER_FREE_TENET();

	mov	edx, DWORD PTR _eAutocracyBranch$[esp+108]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8356
	push	edx
	add	ebx, eax
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	imul	eax, esi

; 438  : 	iOrderPriority += PolicyHelpers::GetNumFreePolicies(eOrderBranch) * GC.getIDEOLOGY_SCORE_PER_FREE_TENET();;

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8356
	add	ebp, eax
	mov	eax, DWORD PTR _eOrderBranch$[esp+112]
	push	eax
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	imul	eax, esi
	add	esp, 12					; 0000000cH

; 439  : 
; 440  : 	stage = "After Free Policies";

	push	OFFSET $SG222121
	lea	ecx, DWORD PTR _stage$[esp+108]
	add	edi, eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 441  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	push	edi
	push	ebp
	push	ebx
	lea	ecx, DWORD PTR _stage$[esp+116]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+120]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 442  : 
; 443  : 	// Finally see what our friends (and enemies) have already chosen
; 444  : 	PlayerTypes eLoopPlayer;
; 445  : 	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	eax, eax
	xor	esi, esi
	mov	DWORD PTR _iPlayerLoop$222123[esp+104], eax
	mov	DWORD PTR tv950[esp+104], esi
	npad	9
$LL184@DoChooseId:

; 446  : 	{
; 447  : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 448  : 		if (eLoopPlayer != pPlayer->GetID() && pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	cmp	eax, DWORD PTR [ecx+44]
	je	$LN37@DoChooseId
	push	0
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	$LN37@DoChooseId

; 449  : 		{
; 450  : 			CvPlayer &kOtherPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]

; 451  : 			PolicyBranchTypes eOtherPlayerIdeology;
; 452  : 			eOtherPlayerIdeology = kOtherPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 453  : 
; 454  : 			switch(pPlayer->GetDiplomacyAI()->GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ true))

	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	mov	esi, eax
	mov	eax, DWORD PTR _iPlayerLoop$222123[esp+104]
	push	1
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 4
	ja	$LN37@DoChooseId
	jmp	DWORD PTR $LN188@DoChooseId[eax*4]
$LN32@DoChooseId:

; 455  : 			{
; 456  : 			case MAJOR_CIV_APPROACH_HOSTILE:
; 457  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	cmp	esi, DWORD PTR _eFreedomBranch$[esp+104]
	jne	SHORT $LN31@DoChooseId

; 458  : 				{
; 459  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	add	ebp, eax

; 460  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	add	edi, eax
	jmp	$LN37@DoChooseId
$LN31@DoChooseId:

; 461  : 				}
; 462  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	cmp	esi, DWORD PTR _eAutocracyBranch$[esp+104]
	jne	SHORT $LN29@DoChooseId

; 463  : 				{
; 464  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	add	ebx, eax

; 465  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	add	edi, eax
	jmp	$LN37@DoChooseId
$LN29@DoChooseId:

; 466  : 				}
; 467  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	cmp	esi, DWORD PTR _eOrderBranch$[esp+104]
	jne	$LN37@DoChooseId

; 468  : 				{
; 469  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_HOSTILE();;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	add	ebp, eax

; 470  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	add	ebx, eax

; 471  : 				}
; 472  : 				break;

	jmp	$LN37@DoChooseId
$LN26@DoChooseId:

; 473  : 			case MAJOR_CIV_APPROACH_GUARDED:
; 474  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	cmp	esi, DWORD PTR _eFreedomBranch$[esp+104]
	jne	SHORT $LN25@DoChooseId

; 475  : 				{
; 476  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	add	ebp, eax

; 477  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	add	edi, eax
	jmp	SHORT $LN37@DoChooseId
$LN25@DoChooseId:

; 478  : 				}
; 479  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	cmp	esi, DWORD PTR _eAutocracyBranch$[esp+104]
	jne	SHORT $LN23@DoChooseId

; 480  : 				{
; 481  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	add	ebx, eax

; 482  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	add	edi, eax
	jmp	SHORT $LN37@DoChooseId
$LN23@DoChooseId:

; 483  : 				}
; 484  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	cmp	esi, DWORD PTR _eOrderBranch$[esp+104]
	jne	SHORT $LN37@DoChooseId

; 485  : 				{
; 486  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	add	ebp, eax

; 487  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	add	ebx, eax

; 488  : 				}
; 489  : 				break;

	jmp	SHORT $LN37@DoChooseId
$LN20@DoChooseId:

; 490  : 			case MAJOR_CIV_APPROACH_AFRAID:
; 491  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	cmp	esi, DWORD PTR _eFreedomBranch$[esp+104]
	jne	SHORT $LN19@DoChooseId

; 492  : 				{
; 493  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_AFRAID();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8368
	jmp	SHORT $LN37@DoChooseId
$LN19@DoChooseId:

; 494  : 				}
; 495  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	cmp	esi, DWORD PTR _eAutocracyBranch$[esp+104]
	jne	SHORT $LN17@DoChooseId

; 496  : 				{
; 497  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_AFRAID();

	add	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8368
	jmp	SHORT $LN37@DoChooseId
$LN17@DoChooseId:

; 498  : 				}
; 499  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	cmp	esi, DWORD PTR _eOrderBranch$[esp+104]
	jne	SHORT $LN37@DoChooseId

; 500  : 				{
; 501  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_AFRAID();

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8368

; 502  : 				}
; 503  : 				break;

	jmp	SHORT $LN37@DoChooseId
$LN14@DoChooseId:

; 504  : 			case MAJOR_CIV_APPROACH_FRIENDLY:
; 505  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	cmp	esi, DWORD PTR _eFreedomBranch$[esp+104]
	jne	SHORT $LN13@DoChooseId

; 506  : 				{
; 507  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_FRIENDLY();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8372
	jmp	SHORT $LN37@DoChooseId
$LN13@DoChooseId:

; 508  : 				}
; 509  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	cmp	esi, DWORD PTR _eAutocracyBranch$[esp+104]
	jne	SHORT $LN11@DoChooseId

; 510  : 				{
; 511  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_FRIENDLY();

	add	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8372
	jmp	SHORT $LN37@DoChooseId
$LN11@DoChooseId:

; 512  : 				}
; 513  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	cmp	esi, DWORD PTR _eOrderBranch$[esp+104]
	jne	SHORT $LN37@DoChooseId

; 514  : 				{
; 515  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_FRIENDLY();

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8372
$LN37@DoChooseId:

; 442  : 
; 443  : 	// Finally see what our friends (and enemies) have already chosen
; 444  : 	PlayerTypes eLoopPlayer;
; 445  : 	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	esi, DWORD PTR tv950[esp+104]
	mov	eax, DWORD PTR _iPlayerLoop$222123[esp+104]
	add	esi, 63236				; 0000f704H
	inc	eax
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR _iPlayerLoop$222123[esp+104], eax
	mov	DWORD PTR tv950[esp+104], esi
	jl	$LL184@DoChooseId

; 516  : 				}
; 517  : 				break;
; 518  : 			case MAJOR_CIV_APPROACH_NEUTRAL:
; 519  : 				// No changes
; 520  : 				break;
; 521  : 			}
; 522  : 		}
; 523  : 	}
; 524  : 
; 525  : 	stage = "After Relations";

	push	OFFSET $SG222160
	lea	ecx, DWORD PTR _stage$[esp+108]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 526  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	push	edi
	push	ebp
	push	ebx
	lea	ecx, DWORD PTR _stage$[esp+116]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+120]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 527  : 
; 528  : 	// Look at Happiness impacts
; 529  : 	int iHappinessModifier = GC.getIDEOLOGY_SCORE_HAPPINESS();
; 530  : 
; 531  : 	// -- Happiness we could add through tenets
; 532  : 	int iHappinessDelta;
; 533  : 	int iHappinessPoliciesInBranch;
; 534  : 	iHappinessDelta = GetBranchBuildingHappiness(pPlayer, eFreedomBranch);

	mov	edx, DWORD PTR _eFreedomBranch$[esp+104]
	mov	eax, DWORD PTR _pPlayer$[esp+100]
	mov	ecx, DWORD PTR _this$[esp+104]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8352
	push	edx
	push	eax
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness

; 535  : 	iHappinessPoliciesInBranch = GetNumHappinessPolicies(pPlayer, eFreedomBranch);

	mov	ecx, DWORD PTR _eFreedomBranch$[esp+104]
	mov	edx, DWORD PTR _pPlayer$[esp+100]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+108]
	push	edx
	mov	DWORD PTR _iHappinessDelta$[esp+112], eax
	call	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
	mov	ecx, eax

; 536  : 	if (iHappinessPoliciesInBranch > 0)

	test	ecx, ecx
	jle	SHORT $LN7@DoChooseId

; 537  : 	{
; 538  : 		iFreedomPriority += iHappinessDelta * iHappinessModifier / iHappinessPoliciesInBranch;		

	mov	eax, DWORD PTR _iHappinessDelta$[esp+104]
	imul	eax, esi
	cdq
	idiv	ecx
	add	ebx, eax
$LN7@DoChooseId:

; 539  : 	}
; 540  : 	iHappinessDelta = GetBranchBuildingHappiness(pPlayer, eAutocracyBranch);

	mov	eax, DWORD PTR _eAutocracyBranch$[esp+104]
	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+112]
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness

; 541  : 	iHappinessPoliciesInBranch = GetNumHappinessPolicies(pPlayer, eAutocracyBranch);

	mov	edx, DWORD PTR _eAutocracyBranch$[esp+104]
	mov	ecx, DWORD PTR _this$[esp+104]
	mov	DWORD PTR _iHappinessDelta$[esp+104], eax
	mov	eax, DWORD PTR _pPlayer$[esp+100]
	push	edx
	push	eax
	call	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
	mov	ecx, eax

; 542  : 	if (iHappinessPoliciesInBranch > 0)

	test	ecx, ecx
	jle	SHORT $LN6@DoChooseId

; 543  : 	{
; 544  : 		iAutocracyPriority += iHappinessDelta * iHappinessModifier / iHappinessPoliciesInBranch;		

	mov	eax, DWORD PTR _iHappinessDelta$[esp+104]
	imul	eax, esi
	cdq
	idiv	ecx
	add	ebp, eax
$LN6@DoChooseId:

; 545  : 	}
; 546  : 	iHappinessDelta = GetBranchBuildingHappiness(pPlayer, eOrderBranch);

	mov	ecx, DWORD PTR _eOrderBranch$[esp+104]
	mov	edx, DWORD PTR _pPlayer$[esp+100]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+108]
	push	edx
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness

; 547  : 	iHappinessPoliciesInBranch = GetNumHappinessPolicies(pPlayer, eOrderBranch);

	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	mov	DWORD PTR _iHappinessDelta$[esp+104], eax
	mov	eax, DWORD PTR _eOrderBranch$[esp+104]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+112]
	call	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
	mov	ecx, eax

; 548  : 	if (iHappinessPoliciesInBranch > 0)

	test	ecx, ecx
	jle	SHORT $LN5@DoChooseId

; 549  : 	{
; 550  : 		iOrderPriority += iHappinessDelta * iHappinessModifier / iHappinessPoliciesInBranch;		

	mov	eax, DWORD PTR _iHappinessDelta$[esp+104]
	imul	eax, esi
	cdq
	idiv	ecx
	add	edi, eax
$LN5@DoChooseId:

; 551  : 	}
; 552  : 
; 553  : 	stage = "After Tenet Happiness Boosts";

	push	OFFSET $SG222167
	lea	ecx, DWORD PTR _stage$[esp+108]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 554  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	ecx, DWORD PTR _this$[esp+104]
	push	edi
	push	ebp
	push	ebx
	lea	edx, DWORD PTR _stage$[esp+116]
	push	edx
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 555  : 
; 556  : 	// -- Happiness we'd lose through Public Opinion
; 557  : 	iHappinessDelta = max (0, 100 - pPlayer->GetCulture()->ComputeHypotheticalPublicOpinionUnhappiness(eFreedomBranch));

	mov	eax, DWORD PTR _eFreedomBranch$[esp+104]
	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	mov	DWORD PTR $T225364[esp+104], ecx
	mov	DWORD PTR $T225365[esp+104], 0
	lea	eax, DWORD PTR $T225364[esp+104]
	test	ecx, ecx
	jg	SHORT $LN146@DoChooseId
	lea	eax, DWORD PTR $T225365[esp+104]
$LN146@DoChooseId:

; 558  : 	iFreedomPriority += iHappinessDelta * iHappinessModifier;

	mov	ecx, DWORD PTR [eax]

; 559  : 	iHappinessDelta = max (0, 100 - pPlayer->GetCulture()->ComputeHypotheticalPublicOpinionUnhappiness(eAutocracyBranch));

	mov	edx, DWORD PTR _eAutocracyBranch$[esp+104]
	imul	ecx, esi
	add	ebx, ecx
	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	push	edx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	mov	DWORD PTR $T225366[esp+104], ecx
	mov	DWORD PTR $T225367[esp+104], 0
	lea	eax, DWORD PTR $T225366[esp+104]
	test	ecx, ecx
	jg	SHORT $LN150@DoChooseId
	lea	eax, DWORD PTR $T225367[esp+104]
$LN150@DoChooseId:

; 560  : 	iAutocracyPriority += iHappinessDelta * iHappinessModifier;

	mov	eax, DWORD PTR [eax]

; 561  : 	iHappinessDelta = max (0, 100 - pPlayer->GetCulture()->ComputeHypotheticalPublicOpinionUnhappiness(eOrderBranch));

	mov	ecx, DWORD PTR _eOrderBranch$[esp+104]
	imul	eax, esi
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[esp+104]
	add	ebp, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	mov	DWORD PTR $T225368[esp+104], ecx
	mov	DWORD PTR $T225369[esp+104], 0
	lea	eax, DWORD PTR $T225368[esp+104]
	test	ecx, ecx
	jg	SHORT $LN154@DoChooseId
	lea	eax, DWORD PTR $T225369[esp+104]
$LN154@DoChooseId:
	mov	eax, DWORD PTR [eax]

; 562  : 	iOrderPriority += iHappinessDelta * iHappinessModifier;

	imul	eax, esi

; 563  : 
; 564  : 	stage = "After Public Opinion Happiness";

	push	OFFSET $SG222174
	lea	ecx, DWORD PTR _stage$[esp+108]
	add	edi, eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 565  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	esi, DWORD PTR _this$[esp+104]
	push	edi
	push	ebp
	push	ebx
	lea	edx, DWORD PTR _stage$[esp+116]
	push	edx
	mov	ecx, esi
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 566  : 
; 567  : 	// Small random add-on
; 568  : 	iFreedomPriority += GC.getGame().getJonRandNum(10, "Freedom random priority bump");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222175
	push	10					; 0000000aH
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 569  : 	iAutocracyPriority += GC.getGame().getJonRandNum(10, "Autocracy random priority bump");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222176
	push	10					; 0000000aH
	add	ebx, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 570  : 	iOrderPriority += GC.getGame().getJonRandNum(10, "Order random priority bump");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222177
	push	10					; 0000000aH
	add	ebp, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 571  : 
; 572  : 	stage = "After Random (1 to 10)";

	push	OFFSET $SG222178
	lea	ecx, DWORD PTR _stage$[esp+108]
	add	edi, eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 573  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	push	edi
	push	ebp
	push	ebx
	lea	eax, DWORD PTR _stage$[esp+116]
	push	eax
	mov	ecx, esi
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 574  : 
; 575  : 	// Rule out any branches that are totally out of consideration
; 576  : 	iFreedomPriority = iFreedomPriority * iFreedomMultiplier;
; 577  : 	iAutocracyPriority = iAutocracyPriority * iAutocracyMultiplier;
; 578  : 	iOrderPriority = iOrderPriority * iOrderMultiplier;

	mov	eax, DWORD PTR _iOrderMultiplier$[esp+104]
	mov	esi, DWORD PTR _iFreedomMultiplier$[esp+104]
	imul	eax, edi
	imul	esi, ebx
	mov	ebx, DWORD PTR _iAutocracyMultiplier$[esp+104]

; 579  : 
; 580  : 	stage = "Final (after Clear Victory Preference)";

	push	OFFSET $SG222179
	imul	ebx, ebp
	lea	ecx, DWORD PTR _stage$[esp+108]
	mov	edi, eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 581  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	ebp, DWORD PTR _this$[esp+104]
	push	edi
	push	ebx
	push	esi
	lea	ecx, DWORD PTR _stage$[esp+116]
	push	ecx
	mov	ecx, ebp
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 582  : 
; 583  : 	// Pick the ideology
; 584  : 	PolicyBranchTypes eChosenBranch;
; 585  : 	if (iFreedomPriority >= iAutocracyPriority && iFreedomPriority >= iOrderPriority)

	cmp	ebx, esi
	jg	SHORT $LN187@DoChooseId
	cmp	esi, edi
	jl	SHORT $LN4@DoChooseId

; 586  : 	{
; 587  : 		eChosenBranch = eFreedomBranch;

	mov	esi, DWORD PTR _eFreedomBranch$[esp+104]
	jmp	SHORT $LN1@DoChooseId
$LN4@DoChooseId:

; 588  : 	}
; 589  : 	else if (iAutocracyPriority >= iFreedomPriority && iAutocracyPriority >= iOrderPriority)

	cmp	ebx, esi
	jl	SHORT $LN2@DoChooseId
$LN187@DoChooseId:
	cmp	ebx, edi

; 590  : 	{
; 591  : 		eChosenBranch = eAutocracyBranch;

	mov	esi, DWORD PTR _eAutocracyBranch$[esp+104]
	jge	SHORT $LN1@DoChooseId
$LN2@DoChooseId:

; 592  : 	}
; 593  : 	else
; 594  : 	{
; 595  : 		eChosenBranch = eOrderBranch;

	mov	esi, DWORD PTR _eOrderBranch$[esp+104]
$LN1@DoChooseId:

; 596  : 	}
; 597  : 	pPlayer->GetPlayerPolicies()->SetPolicyBranchUnlocked(eChosenBranch, true, false);

	mov	ecx, DWORD PTR _pPlayer$[esp+100]
	push	0
	push	1
	push	esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 598  : 	LogBranchChoice(eChosenBranch);

	push	esi
	mov	ecx, ebp
	call	?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ; CvPolicyAI::LogBranchChoice

; 599  : }

	lea	ecx, DWORD PTR _stage$[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
$LN45@DoChooseId:
	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	4
	npad	3
$LN188@DoChooseId:
	DD	$LN32@DoChooseId
	DD	$LN37@DoChooseId
	DD	$LN26@DoChooseId
	DD	$LN20@DoChooseId
	DD	$LN14@DoChooseId
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _stage$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ENDP	; CvPolicyAI::DoChooseIdeology
PUBLIC	?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z		; CvPolicyAI::WeightPrereqs
; Function compile flags: /Ogtpy
;	COMDAT ?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z
_TEXT	SEGMENT
_paiTempWeights$ = 8					; size = 4
_iPropagationPercent$ = 12				; size = 4
?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z PROC		; CvPolicyAI::WeightPrereqs, COMDAT
; _this$ = ecx

; 796  : {

	push	esi
	push	edi
	mov	edi, ecx

; 797  : 	int iPolicyLoop;
; 798  : #endif
; 799  : 
; 800  : 	// Loop through policies looking for ones that are just getting some new weight
; 801  : 	for(iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	ecx, DWORD PTR [edi]
	xor	esi, esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	test	eax, eax
	jle	SHORT $LN2@WeightPrer
	push	ebx
	mov	ebx, DWORD PTR _iPropagationPercent$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _paiTempWeights$[esp+12]
$LL4@WeightPrer:

; 802  : 	{
; 803  : 		// If found one, call our recursive routine to weight everything to the left in the tree
; 804  : 		if(paiTempWeights[iPolicyLoop] > 0)

	mov	eax, DWORD PTR [ebp+esi*4]
	test	eax, eax
	jle	SHORT $LN3@WeightPrer

; 805  : 		{
; 806  : 			PropagateWeights(iPolicyLoop, paiTempWeights[iPolicyLoop], iPropagationPercent, 0);

	push	0
	push	ebx
	push	eax
	push	esi
	mov	ecx, edi
	call	?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z ; CvPolicyAI::PropagateWeights
$LN3@WeightPrer:
	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	esi, eax
	jl	SHORT $LL4@WeightPrer
	pop	ebp
	pop	ebx
$LN2@WeightPrer:
	pop	edi
	pop	esi

; 807  : 		}
; 808  : 	}
; 809  : }

	ret	8
?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z ENDP		; CvPolicyAI::WeightPrereqs
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ		; CvWeightedVector<int,64,1>::CvWeightedVector<int,64,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC		; CvWeightedVector<int,64,1>::CvWeightedVector<int,64,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,64,1>::CvWeightedVector<int,64,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::resize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _func$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx

; 2032 : }

	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Tmp$225856 = -24					; size = 8
__Tmp$225785 = -16					; size = 8
__Tmp$225811 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225785[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$225785[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225811[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$225811[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$225856[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$225856[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$225856[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$225856[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::make_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::pop_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z	; CvPolicyAI::CvPolicyAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z$0
__ehfuncinfo$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_currentPolicies$ = 8					; size = 4
??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z PROC		; CvPolicyAI::CvPolicyAI, COMDAT
; _this$ = ecx

; 20   : {

	push	-1
	push	__ehhandler$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR _currentPolicies$[esp+12]
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [eax+16]
	mov	edx, 64					; 00000040H
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+4], ecx
	lea	ecx, DWORD PTR [eax+544]
	mov	DWORD PTR [eax+532], ecx

; 21   : #ifdef AUI_WARNING_FIXES
; 22   : 	m_iPolicyWeightPropagationLevels = 0;
; 23   : 	m_iPolicyWeightPercentDropNewBranch = 0;
; 24   : #endif	
; 25   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+536], 0
	mov	DWORD PTR [eax+540], edx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ	; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
__ehhandler$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z ENDP		; CvPolicyAI::CvPolicyAI
PUBLIC	??1CvPolicyAI@@QAE@XZ				; CvPolicyAI::~CvPolicyAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPolicyAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyAI@@QAE@XZ$0
__ehfuncinfo$??1CvPolicyAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvPolicyAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvPolicyAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPolicyAI@@QAE@XZ PROC				; CvPolicyAI::~CvPolicyAI, COMDAT
; _this$ = ecx

; 29   : {

	push	-1
	push	__ehhandler$??1CvPolicyAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi

; 30   : }

	mov	eax, DWORD PTR [esi+532]
	lea	ecx, DWORD PTR [esi+544]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	cmp	eax, ecx
	je	SHORT $LN10@CvPolicyAI
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN10@CvPolicyAI:
	mov	eax, DWORD PTR [esi+4]
	add	esi, 16					; 00000010H
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN27@CvPolicyAI
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@CvPolicyAI:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPolicyAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ	; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
__ehhandler$??1CvPolicyAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPolicyAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPolicyAI@@QAE@XZ ENDP				; CvPolicyAI::~CvPolicyAI
PUBLIC	?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z ; CvPolicyAI::AddFlavorWeights
EXTRN	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z:PROC	; CvPolicyEntry::GetFlavorValue
EXTRN	__alloca_probe_16:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z PROC ; CvPolicyAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 118  : #ifdef AUI_WARNING_FIXES
; 119  : 	uint iPolicy;
; 120  : #else
; 121  : 	int iPolicy;
; 122  : #endif
; 123  : 	CvPolicyEntry* entry;
; 124  : #ifndef AUI_WARNING_FIXES
; 125  : 	int* paiTempWeights;
; 126  : #endif
; 127  : 
; 128  : 	CvPolicyXMLEntries* pkPolicyEntries = m_pCurrentPolicies->GetPolicies();

	mov	ecx, DWORD PTR [ecx]
	push	edi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ebx, eax

; 129  : 	// Create a temporary array of weights
; 130  : #ifdef AUI_WARNING_FIXES
; 131  : 	FFastVector<int, true> paiTempWeights;
; 132  : 	paiTempWeights.reserve(pkPolicyEntries->GetNumPolicies());
; 133  : #else
; 134  : 	paiTempWeights = (int*)_alloca(sizeof(int*) * pkPolicyEntries->GetNumPolicies());

	mov	ecx, ebx
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	add	eax, eax
	add	eax, eax
	call	__alloca_probe_16

; 135  : #endif
; 136  : 
; 137  : 	// Loop through all our policies
; 138  : 	for(iPolicy = 0; iPolicy < pkPolicyEntries->GetNumPolicies(); iPolicy++)

	mov	ecx, ebx
	mov	edi, esp
	xor	esi, esi
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	test	eax, eax
	jle	SHORT $LN7@AddFlavorW
$LL9@AddFlavorW:

; 139  : 	{
; 140  : 		entry = pkPolicyEntries->GetPolicyEntry(iPolicy);

	push	esi
	mov	ecx, ebx
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry

; 141  : 
; 142  : 		// Set its weight by looking at policy's weight for this flavor and using iWeight multiplier passed in
; 143  : 		if(entry)

	test	eax, eax
	je	SHORT $LN6@AddFlavorW

; 144  : #ifdef AUI_WARNING_FIXES
; 145  : 			paiTempWeights.push_back(entry->GetFlavorValue(eFlavor) * iWeight);
; 146  : 		else
; 147  : 			paiTempWeights.push_back(0);
; 148  : #else
; 149  : 			paiTempWeights[iPolicy] = entry->GetFlavorValue(eFlavor) * iWeight;

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	push	ecx
	mov	ecx, eax
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR [edi+esi*4], eax

; 150  : 		else

	jmp	SHORT $LN8@AddFlavorW
$LN6@AddFlavorW:

; 151  : 			paiTempWeights[iPolicy] = 0;

	mov	DWORD PTR [edi+esi*4], 0
$LN8@AddFlavorW:

; 135  : #endif
; 136  : 
; 137  : 	// Loop through all our policies
; 138  : 	for(iPolicy = 0; iPolicy < pkPolicyEntries->GetNumPolicies(); iPolicy++)

	mov	ecx, ebx
	inc	esi
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	esi, eax
	jl	SHORT $LL9@AddFlavorW
$LN7@AddFlavorW:

; 152  : #endif
; 153  : 	}
; 154  : 
; 155  : 	// Propagate these values left in the tree so prereqs get bought
; 156  : 	if(iPropagationPercent > 0)

	mov	eax, DWORD PTR _iPropagationPercent$[ebp]

; 157  : 	{
; 158  : 		WeightPrereqs(paiTempWeights, iPropagationPercent);

	mov	ebx, DWORD PTR _this$[ebp]
	test	eax, eax
	jle	SHORT $LN4@AddFlavorW
	push	eax
	push	edi
	mov	ecx, ebx
	call	?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z	; CvPolicyAI::WeightPrereqs
$LN4@AddFlavorW:

; 159  : 	}
; 160  : 
; 161  : 	// Add these weights over previous ones
; 162  : 	for(iPolicy = 0; iPolicy < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicy++)

	mov	ecx, DWORD PTR [ebx]
	xor	esi, esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	test	eax, eax
	jle	SHORT $LN1@AddFlavorW
	npad	4
$LL3@AddFlavorW:

; 163  : 	{
; 164  : 		m_PolicyAIWeights.IncreaseWeight(iPolicy, paiTempWeights[iPolicy]);

	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [edi+esi*4]
	add	DWORD PTR [edx+esi*8+4], ecx
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [edx+esi*8+4]
	inc	esi
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	esi, eax
	jl	SHORT $LL3@AddFlavorW
$LN1@AddFlavorW:

; 165  : 	}
; 166  : }

	lea	esp, DWORD PTR [ebp-16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z ENDP ; CvPolicyAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z ; CvWeightedVector<int,64,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z PROC ; CvWeightedVector<int,64,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@2
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN5@push_back@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@2
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@2:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z ENDP ; CvWeightedVector<int,64,1>::push_back
_TEXT	ENDS
PUBLIC	?resize@?$CvWeightedVector@H$0EA@$00@@QAEXI@Z	; CvWeightedVector<int,64,1>::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$CvWeightedVector@H$0EA@$00@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$CvWeightedVector@H$0EA@$00@@QAEXI@Z PROC	; CvWeightedVector<int,64,1>::resize, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	push	edi

; 122  : 		m_pItems.resize(uiNewSize);

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize@2
	push	edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN6@resize@2:
	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 123  : 	};

	ret	4
?resize@?$CvWeightedVector@H$0EA@$00@@QAEXI@Z ENDP	; CvWeightedVector<int,64,1>::resize
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@4
	pop	esi
$LN13@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	?Reset@CvPolicyAI@@QAEXXZ			; CvPolicyAI::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
;	COMDAT ?Reset@CvPolicyAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvPolicyAI@@QAEXXZ PROC				; CvPolicyAI::Reset, COMDAT
; _this$ = ecx

; 34   : {

	push	ebx
	push	esi
	mov	esi, ecx

; 35   : 	m_PolicyAIWeights.clear();

	xor	ebx, ebx
	mov	DWORD PTR [esi+8], ebx

; 36   : 	m_iPolicyWeightPropagationLevels = GC.getPOLICY_WEIGHT_PROPAGATION_LEVELS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1828
	mov	DWORD PTR [esi+1060], eax

; 37   : 	m_iPolicyWeightPercentDropNewBranch = GC.getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1832
	mov	DWORD PTR [esi+1064], ecx

; 38   : 
; 39   : 	CvAssertMsg(m_pCurrentPolicies != NULL, "Policy AI init failure: player policy data is NULL");
; 40   : 	if(m_pCurrentPolicies != NULL)

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, ebx
	je	SHORT $LN1@Reset

; 41   : 	{
; 42   : 		CvPolicyXMLEntries* pPolicyEntries = m_pCurrentPolicies->GetPolicies();

	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies

; 43   : 		CvAssertMsg(pPolicyEntries != NULL, "Policy AI init failure: no policy data");
; 44   : 		if(pPolicyEntries != NULL)

	cmp	eax, ebx
	je	SHORT $LN1@Reset
	push	ebp
	push	edi

; 45   : 		{
; 46   : 			// Loop through reading each one and add an entry with 0 weight to our vector
; 47   : 			const int nPolicyEntries = pPolicyEntries->GetNumPolicies();

	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	ebp, eax

; 48   : 			for(int i = 0; i < nPolicyEntries; i++)

	xor	edi, edi
	cmp	ebp, ebx
	jle	SHORT $LN38@Reset
	add	esi, 4
$LL3@Reset:

; 49   : 			{
; 50   : 				m_PolicyAIWeights.push_back(i, 0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN26@Reset
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN26@Reset:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*8]
	cmp	eax, ebx
	je	SHORT $LN29@Reset
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN29@Reset:
	inc	DWORD PTR [esi+4]
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL3@Reset
$LN38@Reset:
	pop	edi
	pop	ebp
$LN1@Reset:
	pop	esi
	pop	ebx

; 51   : 			}
; 52   : 		}
; 53   : 	}
; 54   : }

	ret	0
?Reset@CvPolicyAI@@QAEXXZ ENDP				; CvPolicyAI::Reset
_TEXT	ENDS
PUBLIC	?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z	; CvPolicyAI::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiPolicyCount$ = -12					; size = 4
_iWeight$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_uiIndex$221761 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z PROC		; CvPolicyAI::Read, COMDAT
; _this$ = ecx

; 58   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 59   : 	// Version number to maintain backwards compatibility
; 60   : 	uint uiVersion;
; 61   : 	kStream >> uiVersion;

	mov	ebp, DWORD PTR _kStream$[esp+16]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	edi, ecx
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 62   : 
; 63   : 	int iWeight;
; 64   : 
; 65   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies() != NULL, "Policy AI serialization failure: no policy data");
; 66   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies()->GetNumPolicies() > 0, "Policy AI serialization failure: number of policies not greater than 0");
; 67   : 
; 68   : 	// Reset vector
; 69   : 	m_PolicyAIWeights.clear();

	mov	DWORD PTR [edi+8], 0

; 70   : 
; 71   : 	uint uiPolicyArraySize = m_pCurrentPolicies->GetPolicies()->GetNumPolicies();

	mov	ecx, DWORD PTR [edi]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	esi, eax

; 72   : 	// Must set to the final size because we might not be adding in sequentially
; 73   : 	m_PolicyAIWeights.resize(uiPolicyArraySize);

	cmp	DWORD PTR [edi+12], esi
	lea	ebx, DWORD PTR [edi+4]
	jae	SHORT $LN24@Read
	push	esi
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN24@Read:

; 74   : 	// Clear the contents in case we are loading a smaller set
; 75   : 	for(uint uiIndex = 0; uiIndex < uiPolicyArraySize; ++uiIndex)

	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR [ebx+4], esi
	cmp	esi, edi
	jbe	SHORT $LN5@Read
	npad	5
$LL7@Read:

; 76   : 		m_PolicyAIWeights.SetWeight(uiIndex, 0);

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+eax*8+4], edi
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL7@Read
$LN5@Read:

; 77   : 
; 78   : 	uint uiPolicyCount;
; 79   : 	kStream >> uiPolicyCount;

	lea	edx, DWORD PTR _uiPolicyCount$[esp+28]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 80   : 
; 81   : 	for(uint uiIndex = 0; uiIndex < uiPolicyCount; ++uiIndex)

	mov	DWORD PTR _uiIndex$221761[esp+24], edi
	cmp	DWORD PTR _uiPolicyCount$[esp+28], edi
	jbe	SHORT $LN2@Read
$LL43@Read:

; 82   : 	{
; 83   : 		PolicyTypes ePolicy = (PolicyTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	ebp
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	edi, eax
	add	esp, 8

; 84   : 		kStream >> iWeight;

	lea	eax, DWORD PTR _iWeight$[esp+28]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 85   : 		if(ePolicy != NO_POLICY && (uint)ePolicy < uiPolicyArraySize)

	cmp	edi, -1
	je	SHORT $LN3@Read
	cmp	edi, esi
	jae	SHORT $LN3@Read

; 86   : 			m_PolicyAIWeights.SetWeight((uint)ePolicy, iWeight);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _iWeight$[esp+28]
	mov	DWORD PTR [ecx+edi*8+4], edx
$LN3@Read:
	mov	eax, DWORD PTR _uiIndex$221761[esp+24]
	inc	eax
	mov	DWORD PTR _uiIndex$221761[esp+24], eax
	cmp	eax, DWORD PTR _uiPolicyCount$[esp+28]
	jb	SHORT $LL43@Read
$LN2@Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 87   : 	}
; 88   : }

	add	esp, 12					; 0000000cH
	ret	4
?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z ENDP		; CvPolicyAI::Read
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214850 = 16					; size = 4
__Tmp$214840 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214840[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214840[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214840[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214850[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z
_TEXT	SEGMENT
__Mid$222682 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$222682[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$222682[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$222682[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$222682[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::sort<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::sort<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::sort<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@3:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@3
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ	; CvWeightedVector<int,64,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ PROC	; CvWeightedVector<int,64,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ ENDP	; CvWeightedVector<int,64,1>::SortItems
_TEXT	ENDS
PUBLIC	?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z ; CvPolicyAI::ChooseNextPolicy
EXTRN	?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::GetPolicyNumOptions
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::CanUnlockPolicyBranch
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsMutuallyExclusive
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ:PROC ; CvPolicyBranchEntry::GetFreeFinishingPolicy
EXTRN	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z:PROC ; CvPolicyXMLEntries::GetPolicyBranchEntry
EXTRN	?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::WillFinishBranchIfAdopted
EXTRN	?GetLevel@CvPolicyEntry@@QBEHXZ:PROC		; CvPolicyEntry::GetLevel
EXTRN	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z:PROC ; CvPlayerPolicies::CanAdoptPolicy
EXTRN	?GetNumFreeTenets@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetNumFreeTenets
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$0
__ehfuncinfo$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
_TEXT	SEGMENT
_bMustChooseTenet$ = -54				; size = 1
_bStartedAMutuallyExclusiveBranch$ = -53		; size = 1
_elem$227727 = -52					; size = 8
_elem$227712 = -52					; size = 8
_eCurrentGrandStrategy$ = -52				; size = 4
_iWeight$221975 = -52					; size = 4
_eCultureGrandStrategy$ = -44				; size = 4
_iPolicyLoop$ = -44					; size = 4
_iRtnValue$ = -40					; size = 4
_fcn$ = -36						; size = 8
_aLevel3Tenets$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z PROC	; CvPolicyAI::ChooseNextPolicy, COMDAT
; _this$ = ecx

; 174  : {

	push	-1
	push	__ehhandler$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH

; 175  : 	RandomNumberDelegate fcn;
; 176  : 	fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	ebp

; 177  : #ifdef AUI_WARNING_FIXES
; 178  : 	uint iRtnValue = (uint)NO_POLICY;
; 179  : 	uint iPolicyLoop;
; 180  : #else
; 181  : 	int iRtnValue = (int)NO_POLICY;
; 182  : 	int iPolicyLoop;
; 183  : #endif
; 184  : 	vector<int> aLevel3Tenets;

	xor	ebp, ebp
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _fcn$[esp+72], eax
	mov	DWORD PTR _iRtnValue$[esp+72], -1
	mov	DWORD PTR _aLevel3Tenets$[esp+76], ebp
	mov	DWORD PTR _aLevel3Tenets$[esp+80], ebp
	mov	DWORD PTR _aLevel3Tenets$[esp+84], ebp

; 185  : 
; 186  : 	bool bMustChooseTenet = (pPlayer->GetNumFreeTenets() > 0);

	mov	ecx, DWORD PTR _pPlayer$[esp+68]
	mov	DWORD PTR __$EHRec$[esp+80], ebp
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	test	eax, eax

; 187  : 
; 188  : 	// Create a new vector holding only policies we can currently adopt
; 189  : 	m_AdoptablePolicies.clear();

	mov	DWORD PTR [esi+536], ebp

; 190  : 
; 191  : 	// Loop through adding the adoptable policies
; 192  : 	for(iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	ecx, DWORD PTR [esi]
	setg	BYTE PTR _bMustChooseTenet$[esp+72]
	mov	DWORD PTR _iPolicyLoop$[esp+72], ebp
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	test	eax, eax
	jle	$LN44@ChooseNext
$LL415@ChooseNext:

; 193  : 	{
; 194  : 		if(m_pCurrentPolicies->CanAdoptPolicy((PolicyTypes) iPolicyLoop) && (!bMustChooseTenet || m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicyLoop)->GetLevel() > 0))

	mov	ecx, DWORD PTR [esi]
	push	0
	push	ebp
	call	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ; CvPlayerPolicies::CanAdoptPolicy
	test	al, al
	je	$LN45@ChooseNext
	cmp	BYTE PTR _bMustChooseTenet$[esp+72], 0
	je	SHORT $LN42@ChooseNext
	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	test	eax, eax
	jle	$LN45@ChooseNext
$LN42@ChooseNext:

; 195  : 		{
; 196  : 			int iWeight = 0;
; 197  : 
; 198  : 			iWeight += m_PolicyAIWeights.GetWeight(iPolicyLoop);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+ebp*8]
	mov	edi, DWORD PTR [eax+ebp*8+4]
	mov	DWORD PTR _elem$227712[esp+72], ecx

; 199  : 
; 200  : 			// Does this policy finish a branch for us?
; 201  : 			if(m_pCurrentPolicies->WillFinishBranchIfAdopted((PolicyTypes) iPolicyLoop))

	mov	ecx, DWORD PTR [esi]
	push	ebp
	mov	DWORD PTR _iWeight$221975[esp+76], edi
	call	?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::WillFinishBranchIfAdopted
	test	al, al
	je	SHORT $LN39@ChooseNext

; 202  : 			{
; 203  : 				int iPolicyBranch = m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicyLoop)->GetPolicyBranchType();

	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType

; 204  : 				if(iPolicyBranch != NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	je	SHORT $LN39@ChooseNext

; 205  : 				{
; 206  : 					int iFinisherPolicy = m_pCurrentPolicies->GetPolicies()->GetPolicyBranchEntry(iPolicyBranch)->GetFreeFinishingPolicy();

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyBranchEntry
	mov	ecx, eax
	call	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreeFinishingPolicy

; 207  : 					if(iFinisherPolicy != NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN39@ChooseNext

; 208  : 					{
; 209  : 						iWeight += m_PolicyAIWeights.GetWeight(iFinisherPolicy);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	add	eax, edi
	mov	DWORD PTR _elem$227727[esp+72], edx
	mov	DWORD PTR _iWeight$221975[esp+72], eax
$LN39@ChooseNext:

; 210  : 					}
; 211  : 				}
; 212  : 			}
; 213  : 			m_AdoptablePolicies.push_back(iPolicyLoop + GC.getNumPolicyBranchInfos(), iWeight);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	lea	edi, DWORD PTR [esi+532]
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+8]
	add	ebx, ebp
	mov	BYTE PTR [edi+524], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN145@ChooseNext
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN145@ChooseNext:
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN148@ChooseNext
	mov	edx, DWORD PTR _iWeight$221975[esp+72]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edx
$LN148@ChooseNext:
	inc	DWORD PTR [edi+4]

; 214  : 
; 215  : 			if (m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicyLoop)->GetLevel() == 3)

	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	cmp	eax, 3
	jne	SHORT $LN45@ChooseNext

; 216  : 			{
; 217  : 				aLevel3Tenets.push_back(iPolicyLoop);

	mov	edx, DWORD PTR _aLevel3Tenets$[esp+76]
	test	edx, edx
	jne	SHORT $LN163@ChooseNext
	xor	eax, eax
	jmp	SHORT $LN164@ChooseNext
$LN163@ChooseNext:
	mov	eax, DWORD PTR _aLevel3Tenets$[esp+84]
	sub	eax, edx
	sar	eax, 2
$LN164@ChooseNext:
	mov	ecx, DWORD PTR _aLevel3Tenets$[esp+80]
	mov	edi, ecx
	sub	edi, edx
	sar	edi, 2
	cmp	edi, eax
	jae	SHORT $LN156@ChooseNext
	mov	DWORD PTR [ecx], ebp
	add	ecx, 4
	mov	DWORD PTR _aLevel3Tenets$[esp+80], ecx
	jmp	SHORT $LN45@ChooseNext
$LN156@ChooseNext:
	lea	eax, DWORD PTR _iPolicyLoop$[esp+72]
	push	eax
	push	1
	push	ecx
	lea	ecx, DWORD PTR _aLevel3Tenets$[esp+84]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN45@ChooseNext:
	mov	ecx, DWORD PTR [esi]
	inc	ebp
	mov	DWORD PTR _iPolicyLoop$[esp+72], ebp
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	ebp, eax
	jl	$LL415@ChooseNext
$LN44@ChooseNext:

; 218  : 			}
; 219  : 		}
; 220  : 	}
; 221  : 
; 222  : 	// Did we already start a branch in the set that is mutually exclusive?
; 223  : 	bool bStartedAMutuallyExclusiveBranch = false;
; 224  : #ifdef AUI_WARNING_FIXES
; 225  : 	for (uint iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)
; 226  : #else
; 227  : 	for(int iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bStartedAMutuallyExclusiveBranch$[esp+72], 0
	xor	edi, edi
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	ebp, DWORD PTR _pPlayer$[esp+68]
	test	eax, eax
	jle	SHORT $LN35@ChooseNext
$LL414@ChooseNext:

; 228  : #endif
; 229  : 	{
; 230  : 		const PolicyBranchTypes ePolicyBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 231  : 		CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(ePolicyBranch);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	ebx, eax

; 232  : 		if(pkPolicyBranchInfo)

	test	ebx, ebx
	je	SHORT $LN36@ChooseNext

; 233  : 		{
; 234  : 			if(pPlayer->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))

	push	edi
	mov	ecx, ebp
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	je	SHORT $LN36@ChooseNext

; 235  : 			{
; 236  : 				if(pkPolicyBranchInfo->IsMutuallyExclusive())

	mov	ecx, ebx
	call	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsMutuallyExclusive
	test	al, al
	je	SHORT $LN36@ChooseNext

; 237  : 				{
; 238  : 					bStartedAMutuallyExclusiveBranch = true;

	mov	BYTE PTR _bStartedAMutuallyExclusiveBranch$[esp+72], 1
$LN36@ChooseNext:

; 218  : 			}
; 219  : 		}
; 220  : 	}
; 221  : 
; 222  : 	// Did we already start a branch in the set that is mutually exclusive?
; 223  : 	bool bStartedAMutuallyExclusiveBranch = false;
; 224  : #ifdef AUI_WARNING_FIXES
; 225  : 	for (uint iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)
; 226  : #else
; 227  : 	for(int iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	cmp	edi, eax
	jl	SHORT $LL414@ChooseNext
$LN35@ChooseNext:

; 239  : 				}
; 240  : 			}
; 241  : 		}
; 242  : 	}
; 243  : 
; 244  : 	AIGrandStrategyTypes eCultureGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET $SG221997
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 245  : 	AIGrandStrategyTypes eCurrentGrandStrategy = pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, ebp
	mov	DWORD PTR _eCultureGrandStrategy$[esp+72], eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy

; 246  : 
; 247  : 	// Loop though the branches adding each as another possibility
; 248  : 	if (!bMustChooseTenet)

	cmp	BYTE PTR _bMustChooseTenet$[esp+72], 0
	mov	DWORD PTR _eCurrentGrandStrategy$[esp+72], eax
	jne	$LN407@ChooseNext

; 249  : 	{
; 250  : #ifdef AUI_WARNING_FIXES
; 251  : 		for (uint iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)
; 252  : #else
; 253  : 		for(int iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	test	eax, eax
	jle	$LN407@ChooseNext
	mov	edi, DWORD PTR _pPlayer$[esp+68]
	npad	1
$LL416@ChooseNext:

; 254  : #endif
; 255  : 		{
; 256  : 			const PolicyBranchTypes ePolicyBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 257  : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(ePolicyBranch);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 258  : 			if(pkPolicyBranchInfo)

	test	eax, eax
	je	$LN29@ChooseNext

; 259  : 			{
; 260  : 				if(bStartedAMutuallyExclusiveBranch && pkPolicyBranchInfo->IsMutuallyExclusive())

	cmp	BYTE PTR _bStartedAMutuallyExclusiveBranch$[esp+72], 0
	je	SHORT $LN26@ChooseNext
	mov	ecx, eax
	call	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsMutuallyExclusive
	test	al, al
	jne	$LN29@ChooseNext
$LN26@ChooseNext:

; 261  : 				{
; 262  : 					continue;
; 263  : 				}
; 264  : 
; 265  : 				if(pPlayer->GetPlayerPolicies()->CanUnlockPolicyBranch(ePolicyBranch) && !pPlayer->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))

	push	ebx
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	test	al, al
	je	$LN29@ChooseNext
	push	ebx
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	jne	$LN29@ChooseNext

; 266  : 				{
; 267  : 					int iBranchWeight = 0;
; 268  : 
; 269  : 					// Does this branch actually help us, based on game options?
; 270  : 					if(IsBranchEffectiveInGame(ePolicyBranch))

	push	ebx
	mov	ecx, esi
	xor	edi, edi
	call	?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z ; CvPolicyAI::IsBranchEffectiveInGame
	test	al, al
	je	SHORT $LN23@ChooseNext

; 271  : 					{
; 272  : 						iBranchWeight += WeighBranch(ePolicyBranch);

	push	ebx
	mov	ecx, esi
	call	?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z ; CvPolicyAI::WeighBranch

; 273  : 
; 274  : 						iBranchWeight *= (100 - m_iPolicyWeightPercentDropNewBranch);

	mov	ecx, 100				; 00000064H
	sub	ecx, DWORD PTR [esi+1064]
	imul	ecx, eax

; 275  : 						iBranchWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 276  : 						if(eCurrentGrandStrategy == eCultureGrandStrategy)

	mov	ecx, DWORD PTR _eCultureGrandStrategy$[esp+72]
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	cmp	DWORD PTR _eCurrentGrandStrategy$[esp+72], ecx
	jne	SHORT $LN23@ChooseNext

; 277  : 						{
; 278  : 							iBranchWeight /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
$LN23@ChooseNext:

; 279  : 						}
; 280  : 					}
; 281  : 
; 282  : 					m_AdoptablePolicies.push_back(iBranchLoop, iBranchWeight);

	mov	eax, DWORD PTR [esi+540]
	lea	ebp, DWORD PTR [esi+532]
	mov	BYTE PTR [ebp+524], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN220@ChooseNext
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN220@ChooseNext:
	mov	ecx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN223@ChooseNext
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
$LN223@ChooseNext:
	inc	DWORD PTR [ebp+4]
	mov	edi, DWORD PTR _pPlayer$[esp+68]
$LN29@ChooseNext:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	cmp	ebx, eax
	jl	$LL416@ChooseNext
$LN407@ChooseNext:

; 283  : 				}
; 284  : 			}
; 285  : 		}
; 286  : 	}
; 287  : 
; 288  : 	m_AdoptablePolicies.SortItems();

	mov	eax, DWORD PTR [esi+532]
	mov	ecx, DWORD PTR [esi+536]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 289  : 	LogPossiblePolicies();

	mov	ecx, esi
	call	?LogPossiblePolicies@CvPolicyAI@@AAEXXZ	; CvPolicyAI::LogPossiblePolicies

; 290  : 
; 291  : 	// If there were any Level 3 tenets found, consider going for the one that matches our victory strategy
; 292  : 	if (aLevel3Tenets.size() > 0)

	mov	eax, DWORD PTR _aLevel3Tenets$[esp+80]
	mov	ebx, DWORD PTR _aLevel3Tenets$[esp+76]
	mov	ecx, eax
	sub	ecx, ebx
	sar	ecx, 2
	test	ecx, ecx
	jbe	$LN409@ChooseNext

; 293  : 	{
; 294  : 		vector<int>::const_iterator it;
; 295  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 296  : 		for (it = aLevel3Tenets.begin(); it != aLevel3Tenets.end(); ++it)
; 297  : #else
; 298  : 		for (it = aLevel3Tenets.begin(); it != aLevel3Tenets.end(); it++)

	cmp	ebx, eax
	je	$LN409@ChooseNext
	npad	7
$LL250@ChooseNext:

; 299  : #endif
; 300  : 		{
; 301  : 			CvPolicyEntry *pEntry;
; 302  : 			pEntry = m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(*it);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ebp, eax

; 303  : 			if (pEntry)

	test	ebp, ebp
	je	$LN20@ChooseNext

; 304  : 			{
; 305  : 				AIGrandStrategyTypes eGrandStrategy = pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, DWORD PTR _pPlayer$[esp+68]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy

; 306  : 				if (eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))

	push	0
	push	OFFSET $SG222029
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 307  : 				{
; 308  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE")) > 0)

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	edi, eax
	jne	SHORT $LN17@ChooseNext
	push	OFFSET $SG222032

; 312  : 					}
; 313  : 				}

	jmp	$LN421@ChooseNext
$LN17@ChooseNext:

; 314  : 				else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))

	push	OFFSET $SG222037
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 315  : 				{
; 316  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_SPACESHIP")) > 0)

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	edi, eax
	jne	SHORT $LN14@ChooseNext
	push	OFFSET $SG222040
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, ebp
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jle	SHORT $LN20@ChooseNext

; 317  : 					{
; 318  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	ecx, DWORD PTR [ebx]
	push	ecx

; 319  : 						return (*it) + GC.getNumPolicyBranchInfos();

	jmp	$LN419@ChooseNext
$LN14@ChooseNext:

; 320  : 					}
; 321  : 				}
; 322  : 				else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	push	OFFSET $SG222045
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 323  : 				{
; 324  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DIPLOMACY")) > 0)

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	edi, eax
	jne	SHORT $LN11@ChooseNext
	push	OFFSET $SG222048
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, ebp
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jle	SHORT $LN20@ChooseNext

; 325  : 					{
; 326  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	edx, DWORD PTR [ebx]
	push	edx

; 327  : 						return (*it) + GC.getNumPolicyBranchInfos();

	jmp	$LN419@ChooseNext
$LN11@ChooseNext:

; 328  : 					}
; 329  : 				}
; 330  : 				else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	push	OFFSET $SG222053
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	edi, eax
	jne	SHORT $LN20@ChooseNext

; 331  : 				{
; 332  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE")) > 0)

	push	0
	push	OFFSET $SG222056
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
$LN421@ChooseNext:
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, ebp
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jg	$LN392@ChooseNext
$LN20@ChooseNext:

; 293  : 	{
; 294  : 		vector<int>::const_iterator it;
; 295  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 296  : 		for (it = aLevel3Tenets.begin(); it != aLevel3Tenets.end(); ++it)
; 297  : #else
; 298  : 		for (it = aLevel3Tenets.begin(); it != aLevel3Tenets.end(); it++)

	add	ebx, 4
	cmp	ebx, DWORD PTR _aLevel3Tenets$[esp+80]
	jne	$LL250@ChooseNext

; 348  : 		iRtnValue = m_AdoptablePolicies.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing policy from Top Choices");

	mov	ebx, DWORD PTR _aLevel3Tenets$[esp+76]
$LN409@ChooseNext:

; 333  : 					{
; 334  : 						LogPolicyChoice((PolicyTypes)*it);
; 335  : 						return (*it) + GC.getNumPolicyBranchInfos();
; 336  : 					}
; 337  : 				}
; 338  : 			}
; 339  : 		}
; 340  : 	}
; 341  : 
; 342  : 	CvAssertMsg(m_AdoptablePolicies.GetTotalWeight() >= 0, "Total weights of considered policies should not be negative! Please send Anton your save file and version.");
; 343  : 
; 344  : 	// If total weight is above 0, choose one above a threshold
; 345  : 	if(m_AdoptablePolicies.GetTotalWeight() > 0)

	mov	edx, DWORD PTR [esi+536]
	xor	ecx, ecx
	test	edx, edx
	jbe	$LN417@ChooseNext
	mov	eax, DWORD PTR [esi+532]
	add	eax, 4
$LL310@ChooseNext:
	add	ecx, DWORD PTR [eax]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL310@ChooseNext
	test	ecx, ecx
	jle	$LN417@ChooseNext

; 346  : 	{
; 347  : 		int iNumChoices = GC.getGame().getHandicapInfo().GetPolicyNumOptions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetPolicyNumOptions

; 348  : 		iRtnValue = m_AdoptablePolicies.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing policy from Top Choices");

	mov	ebp, eax
	mov	eax, DWORD PTR [esi+536]
	cmp	ebp, eax
	jle	SHORT $LN328@ChooseNext
	mov	ebp, eax
$LN328@ChooseNext:
	xor	edi, edi
	xor	ecx, ecx
	test	ebp, ebp
	jle	SHORT $LN413@ChooseNext
	mov	eax, DWORD PTR [esi+532]
	mov	edx, ebp
$LL327@ChooseNext:
	add	ecx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL327@ChooseNext
$LN413@ChooseNext:
	push	OFFSET $SG222061
	push	ecx
	mov	ecx, DWORD PTR _fcn$[esp+80]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	xor	edx, edx
	test	ebp, ebp
	jle	$LN4@ChooseNext
	mov	ecx, DWORD PTR [esi+532]
$LL324@ChooseNext:
	sub	eax, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	js	$LN4@ChooseNext
	inc	edx
	add	ecx, 8
	cmp	edx, ebp
	jl	SHORT $LL324@ChooseNext
	jmp	$LN4@ChooseNext
$LN392@ChooseNext:

; 309  : 					{
; 310  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	eax, DWORD PTR [ebx]
	push	eax
$LN419@ChooseNext:
	mov	ecx, esi
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 311  : 						return (*it) + GC.getNumPolicyBranchInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	esi, eax
	mov	eax, DWORD PTR _aLevel3Tenets$[esp+76]
	add	esi, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN273@ChooseNext
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN273@ChooseNext:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 374  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
$LN417@ChooseNext:

; 349  : 	}
; 350  : 	// Total weight may be 0 if the only branches and policies left are ones that are ineffective in our game, but we gotta pick something
; 351  : 	else if(m_AdoptablePolicies.GetTotalWeight() == 0 && m_AdoptablePolicies.size() > 0)

	mov	edx, DWORD PTR [esi+536]
	xor	ecx, ecx
	test	edx, edx
	jbe	SHORT $LN406@ChooseNext
	mov	eax, DWORD PTR [esi+532]
	add	eax, 4
	npad	3
$LL349@ChooseNext:
	add	ecx, DWORD PTR [eax]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL349@ChooseNext
	test	ecx, ecx
	jne	SHORT $LN410@ChooseNext
$LN406@ChooseNext:
	cmp	DWORD PTR [esi+536], 0
	jle	SHORT $LN410@ChooseNext

; 352  : 	{
; 353  : 		iRtnValue = m_AdoptablePolicies.ChooseAtRandom(&fcn, "Choosing policy at random (no good choices)");

	mov	eax, DWORD PTR [esi+536]
	mov	ecx, DWORD PTR _fcn$[esp+72]
	push	OFFSET $SG222064
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ecx, DWORD PTR [esi+532]
	mov	edi, DWORD PTR [ecx+eax*8]
$LN4@ChooseNext:

; 354  : 	}
; 355  : 
; 356  : 	// Log our choice
; 357  : #ifdef AUI_WARNING_FIXES
; 358  : 	if (iRtnValue != (uint)NO_POLICY)
; 359  : #else
; 360  : 	if(iRtnValue != (int)NO_POLICY)

	cmp	edi, -1
	je	SHORT $LN1@ChooseNext

; 361  : #endif
; 362  : 	{
; 363  : 		if(iRtnValue >= GC.getNumPolicyBranchInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	cmp	edi, eax
	jl	SHORT $LN2@ChooseNext

; 364  : 		{
; 365  : 			LogPolicyChoice((PolicyTypes)(iRtnValue - GC.getNumPolicyBranchInfos()));

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	edx, edi
	sub	edx, eax
	push	edx
	mov	ecx, esi
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 366  : 		}
; 367  : 		else

	jmp	SHORT $LN1@ChooseNext
$LN2@ChooseNext:

; 368  : 		{
; 369  : 			LogBranchChoice((PolicyBranchTypes)iRtnValue);

	push	edi
	mov	ecx, esi
	call	?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ; CvPolicyAI::LogBranchChoice
	jmp	SHORT $LN1@ChooseNext
$LN410@ChooseNext:
	mov	edi, DWORD PTR _iRtnValue$[esp+72]
$LN1@ChooseNext:

; 370  : 		}
; 371  : 	}
; 372  : 
; 373  : 	return iRtnValue;

	test	ebx, ebx
	je	SHORT $LN381@ChooseNext
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN381@ChooseNext:

; 374  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z ENDP	; CvPolicyAI::ChooseNextPolicy
END
