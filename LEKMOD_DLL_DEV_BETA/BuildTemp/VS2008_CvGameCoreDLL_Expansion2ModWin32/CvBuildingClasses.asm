; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBuildingClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218166 DB	'GoldMaintenance', 00H
$SG218167 DB	'MutuallyExclusiveGroup', 00H
	ORG $+1
$SG218168 DB	'TeamShare', 00H
	ORG $+2
$SG218169 DB	'Water', 00H
	ORG $+2
$SG218170 DB	'River', 00H
	ORG $+2
$SG218171 DB	'FreshWater', 00H
	ORG $+1
$SG218172 DB	'Mountain', 00H
	ORG $+3
$SG218173 DB	'Hill', 00H
	ORG $+3
$SG218174 DB	'Flat', 00H
	ORG $+3
$SG218175 DB	'FoundsReligion', 00H
	ORG $+1
$SG218176 DB	'IsReligious', 00H
$SG218177 DB	'BorderObstacle', 00H
	ORG $+1
$SG218178 DB	'PlayerBorderObstacle', 00H
	ORG $+3
$SG218179 DB	'Capital', 00H
$SG218180 DB	'GoldenAge', 00H
	ORG $+2
$SG218181 DB	'GrantsFreeCulturalGreatPersonWithTrait', 00H
	ORG $+1
$SG218182 DB	'MapCentering', 00H
	ORG $+3
$SG218183 DB	'NeverCapture', 00H
	ORG $+3
$SG218184 DB	'NukeImmune', 00H
	ORG $+1
$SG218185 DB	'CityWall', 00H
	ORG $+3
$SG218186 DB	'ExtraLuxuries', 00H
	ORG $+2
$SG218187 DB	'DiplomaticVoting', 00H
	ORG $+3
$SG218188 DB	'AllowsWaterRoutes', 00H
	ORG $+2
$SG218189 DB	'Cost', 00H
	ORG $+3
$SG218190 DB	'FaithCost', 00H
	ORG $+2
$SG218191 DB	'LeagueCost', 00H
	ORG $+1
$SG218192 DB	'UnlockedByBelief', 00H
	ORG $+3
$SG218193 DB	'UnlockedByLeague', 00H
	ORG $+3
$SG218194 DB	'HolyCity', 00H
	ORG $+3
$SG218195 DB	'AffectSpiesNow', 00H
	ORG $+1
$SG218196 DB	'Espionage', 00H
	ORG $+2
$SG218197 DB	'MaliTreasury', 00H
	ORG $+3
$SG218198 DB	'AllowsFoodTradeRoutes', 00H
	ORG $+2
$SG218199 DB	'AllowsProductionTradeRoutes', 00H
$SG218200 DB	'NullifyInfluenceModifier', 00H
	ORG $+3
$SG218201 DB	'NumCityCostMod', 00H
	ORG $+1
$SG218202 DB	'HurryCostModifier', 00H
	ORG $+2
$SG218203 DB	'MinAreaSize', 00H
$SG218204 DB	'ConquestProb', 00H
	ORG $+3
$SG218205 DB	'CitiesPrereq', 00H
	ORG $+3
$SG218206 DB	'LevelPrereq', 00H
$SG218207 DB	'CultureRateModifier', 00H
$SG218208 DB	'GlobalCultureRateModifier', 00H
	ORG $+2
$SG218209 DB	'GreatPeopleRateModifier', 00H
$SG218210 DB	'GlobalGreatPeopleRateModifier', 00H
	ORG $+2
$SG218211 DB	'GreatGeneralRateModifier', 00H
	ORG $+3
$SG218212 DB	'GreatPersonExpendGold', 00H
	ORG $+2
$SG218213 DB	'UnitUpgradeCostMod', 00H
	ORG $+1
$SG218214 DB	'GoldenAgeModifier', 00H
	ORG $+2
$SG218215 DB	'Experience', 00H
	ORG $+1
$SG218216 DB	'GlobalExperience', 00H
	ORG $+3
$SG218217 DB	'FoodKept', 00H
	ORG $+3
$SG218218 DB	'Airlift', 00H
$SG218219 DB	'AirModifier', 00H
$SG218220 DB	'NukeModifier', 00H
	ORG $+3
$SG218221 DB	'NukeExplosionRand', 00H
	ORG $+2
$SG218222 DB	'HealRateChange', 00H
	ORG $+1
$SG218223 DB	'Happiness', 00H
	ORG $+2
$SG218224 DB	'UnmoddedHappiness', 00H
	ORG $+2
$SG218225 DB	'UnhappinessModifier', 00H
$SG218226 DB	'HappinessPerCity', 00H
	ORG $+3
$SG218227 DB	'HappinessPerXPolicies', 00H
	ORG $+2
$SG218228 DB	'CityCountUnhappinessMod', 00H
$SG218229 DB	'NoOccupiedUnhappiness', 00H
	ORG $+2
$SG218230 DB	'WorkerSpeedModifier', 00H
$SG218231 DB	'MilitaryProductionModifier', 00H
	ORG $+1
$SG218232 DB	'SpaceProductionModifier', 00H
$SG218233 DB	'GlobalSpaceProductionModifier', 00H
	ORG $+2
$SG218234 DB	'BuildingProductionModifier', 00H
	ORG $+1
$SG218235 DB	'WonderProductionModifier', 00H
	ORG $+3
$SG218236 DB	'CityConnectionTradeRouteModifier', 00H
	ORG $+3
$SG218237 DB	'CapturePlunderModifier', 00H
	ORG $+1
$SG218238 DB	'PolicyCostModifier', 00H
	ORG $+1
$SG218239 DB	'PlotCultureCostModifier', 00H
$SG218240 DB	'GlobalPlotCultureCostModifier', 00H
	ORG $+2
$SG218241 DB	'PlotBuyCostModifier', 00H
$SG218242 DB	'GlobalPlotBuyCostModifier', 00H
	ORG $+2
$SG218243 DB	'GlobalPopulationChange', 00H
	ORG $+1
$SG218244 DB	'LocalPopulationChange', 00H
	ORG $+2
$SG218245 DB	'TechShare', 00H
	ORG $+2
$SG218246 DB	'FreeTechs', 00H
	ORG $+2
$SG218247 DB	'FreePolicies', 00H
	ORG $+3
$SG218248 DB	'FreeFlatFaith', 00H
	ORG $+2
$SG218249 DB	'MountainScienceYield', 00H
	ORG $+3
$SG218250 DB	'FreeGreatPeople', 00H
$SG218251 DB	'MedianTechPercentChange', 00H
$SG218252 DB	'Gold', 00H
	ORG $+3
$SG218253 DB	'NearbyMountainRequired', 00H
	ORG $+1
$SG218254 DB	'AllowsRangeStrike', 00H
	ORG $+2
$SG218255 DB	'Defense', 00H
$SG218256 DB	'DefensePerCitizen', 00H
	ORG $+2
$SG218257 DB	'GlobalDefenseMod', 00H
	ORG $+3
$SG218258 DB	'ExtraCityHitPoints', 00H
	ORG $+1
$SG218259 DB	'MinorFriendshipChange', 00H
	ORG $+2
$SG218260 DB	'VictoryPoints', 00H
	ORG $+2
$SG218261 DB	'ExtraMissionarySpreads', 00H
	ORG $+1
$SG218262 DB	'ReligiousPressureModifier', 00H
	ORG $+2
$SG218263 DB	'EspionageModifier', 00H
	ORG $+2
$SG218264 DB	'GlobalEspionageModifier', 00H
$SG218265 DB	'ExtraSpies', 00H
	ORG $+1
$SG218266 DB	'SpyRankChange', 00H
	ORG $+2
$SG218267 DB	'TradeRouteRecipientBonus', 00H
	ORG $+3
$SG218268 DB	'TradeRouteTargetBonus', 00H
	ORG $+2
$SG218269 DB	'NumTradeRouteBonus', 00H
	ORG $+1
$SG218270 DB	'TradeRouteSeaDistanceModifier', 00H
	ORG $+2
$SG218271 DB	'TradeRouteSeaGoldBonus', 00H
	ORG $+1
$SG218272 DB	'TradeRouteLandDistanceModifier', 00H
	ORG $+1
$SG218273 DB	'TradeRouteLandGoldBonus', 00H
$SG218274 DB	'CityStateTradeRouteProductionModifier', 00H
	ORG $+2
$SG218275 DB	'CityStateTradeRouteGoldModifier', 00H
$SG218276 DB	'InstantSpyRankChange', 00H
	ORG $+3
$SG218277 DB	'LandmarksTourismPercent', 00H
$SG218278 DB	'InstantMilitaryIncrease', 00H
$SG218279 DB	'GreatWorksTourismModifier', 00H
	ORG $+2
$SG218280 DB	'XBuiltTriggersIdeologyChoice', 00H
	ORG $+3
$SG218281 DB	'GreatScientistBeakerModifier', 00H
	ORG $+3
$SG218282 DB	'ExtraLeagueVotes', 00H
	ORG $+3
$SG218283 DB	'DisplayPosition', 00H
$SG218284 DB	'PortraitIndex', 00H
	ORG $+2
$SG218285 DB	'ArtInfoCulturalVariation', 00H
	ORG $+3
$SG218286 DB	'ArtInfoEraVariation', 00H
$SG218287 DB	'ArtInfoRandomVariation', 00H
	ORG $+1
$SG218289 DB	'BuildingClass', 00H
	ORG $+2
$SG218291 DB	'ArtDefineTag', 00H
	ORG $+3
$SG218292 DB	'WonderSplashAudio', 00H
	ORG $+2
$SG218293 DB	'ThemingBonusHelp', 00H
	ORG $+3
$SG218294 DB	'NearbyTerrainRequired', 00H
	ORG $+2
$SG218295 DB	'ProhibitedCityTerrain', 00H
	ORG $+2
$SG218296 DB	'VictoryPrereq', 00H
	ORG $+2
$SG218297 DB	'FreeStartEra', 00H
	ORG $+3
$SG218298 DB	'MaxStartEra', 00H
$SG218299 DB	'ObsoleteTech', 00H
	ORG $+3
$SG218300 DB	'EnhancedYieldTech', 00H
	ORG $+2
$SG218301 DB	'TechEnhancedTourism', 00H
$SG218302 DB	'FreeBuilding', 00H
	ORG $+3
$SG218303 DB	'FreeBuildingThisCity', 00H
	ORG $+3
$SG218304 DB	'FreePromotion', 00H
	ORG $+2
$SG218305 DB	'TrainedFreePromotion', 00H
	ORG $+3
$SG218306 DB	'FreePromotionRemoved', 00H
	ORG $+3
$SG218307 DB	'ReplacementBuildingClass', 00H
	ORG $+3
$SG218308 DB	'PrereqTech', 00H
	ORG $+1
$SG218309 DB	'PolicyBranchType', 00H
	ORG $+3
$SG218310 DB	'SpecialistType', 00H
	ORG $+1
$SG218311 DB	'SpecialistCount', 00H
$SG218312 DB	'SpecialistExtraCulture', 00H
	ORG $+1
$SG218313 DB	'GreatPeopleRateChange', 00H
	ORG $+2
$SG218314 DB	'GreatWorkSlotType', 00H
	ORG $+2
$SG218316 DB	'GreatWorkCount', 00H
	ORG $+1
$SG218317 DB	'FreeGreatWork', 00H
	ORG $+2
$SG218320 DB	'BuildingType', 00H
	ORG $+3
$SG218321 DB	'Building_Flavors', 00H
	ORG $+3
$SG218322 DB	'BuildingType', 00H
	ORG $+3
$SG218323 DB	'Building_SeaPlotYieldChanges', 00H
	ORG $+3
$SG218324 DB	'BuildingType', 00H
	ORG $+3
$SG218325 DB	'Building_RiverPlotYieldChanges', 00H
	ORG $+1
$SG218326 DB	'BuildingType', 00H
	ORG $+3
$SG218327 DB	'Building_LakePlotYieldChanges', 00H
	ORG $+2
$SG218328 DB	'BuildingType', 00H
	ORG $+3
$SG218329 DB	'Building_SeaResourceYieldChanges', 00H
	ORG $+3
$SG218330 DB	'BuildingType', 00H
	ORG $+3
$SG218331 DB	'Building_YieldChanges', 00H
	ORG $+2
$SG218332 DB	'BuildingType', 00H
	ORG $+3
$SG218333 DB	'Building_YieldChangesPerPop', 00H
$SG218334 DB	'BuildingType', 00H
	ORG $+3
$SG218335 DB	'Building_YieldChangesPerReligion', 00H
	ORG $+3
$SG218336 DB	'BuildingType', 00H
	ORG $+3
$SG218337 DB	'Building_YieldModifiers', 00H
$SG218338 DB	'BuildingType', 00H
	ORG $+3
$SG218339 DB	'Building_AreaYieldModifiers', 00H
$SG218340 DB	'BuildingType', 00H
	ORG $+3
$SG218341 DB	'Building_GlobalYieldModifiers', 00H
	ORG $+2
$SG218342 DB	'BuildingType', 00H
	ORG $+3
$SG218343 DB	'Building_TechEnhancedYieldChanges', 00H
	ORG $+2
$SG218344 DB	'Cost', 00H
	ORG $+3
$SG218345 DB	'BuildingType', 00H
	ORG $+3
$SG218346 DB	'ResourceType', 00H
	ORG $+3
$SG218347 DB	'Building_ResourceQuantityRequirements', 00H
	ORG $+2
$SG218348 DB	'Resources', 00H
	ORG $+2
$SG218349 DB	'Quantity', 00H
	ORG $+3
$SG218350 DB	'BuildingType', 00H
	ORG $+3
$SG218351 DB	'ResourceType', 00H
	ORG $+3
$SG218352 DB	'Building_ResourceQuantity', 00H
	ORG $+2
$SG218353 DB	'Resources', 00H
	ORG $+2
$SG218354 DB	'CultureChange', 00H
	ORG $+2
$SG218355 DB	'BuildingType', 00H
	ORG $+3
$SG218356 DB	'ResourceType', 00H
	ORG $+3
$SG218357 DB	'Building_ResourceCultureChanges', 00H
$SG218358 DB	'Resources', 00H
	ORG $+2
$SG218359 DB	'FaithChange', 00H
$SG218360 DB	'BuildingType', 00H
	ORG $+3
$SG218361 DB	'ResourceType', 00H
	ORG $+3
$SG218362 DB	'Building_ResourceFaithChanges', 00H
	ORG $+2
$SG218363 DB	'Resources', 00H
	ORG $+2
$SG218364 DB	'HurryCostModifier', 00H
	ORG $+2
$SG218365 DB	'BuildingType', 00H
	ORG $+3
$SG218366 DB	'HurryType', 00H
	ORG $+2
$SG218367 DB	'Building_HurryModifiers', 00H
$SG218368 DB	'HurryInfos', 00H
	ORG $+1
$SG218369 DB	'Experience', 00H
	ORG $+1
$SG218370 DB	'BuildingType', 00H
	ORG $+3
$SG218371 DB	'UnitCombatType', 00H
	ORG $+1
$SG218372 DB	'Building_UnitCombatFreeExperiences', 00H
	ORG $+1
$SG218373 DB	'UnitCombatInfos', 00H
$SG218374 DB	'Modifier', 00H
	ORG $+3
$SG218375 DB	'BuildingType', 00H
	ORG $+3
$SG218376 DB	'UnitCombatType', 00H
	ORG $+1
$SG218377 DB	'Building_UnitCombatProductionModifiers', 00H
	ORG $+1
$SG218378 DB	'UnitCombatInfos', 00H
$SG218379 DB	'Experience', 00H
	ORG $+1
$SG218380 DB	'BuildingType', 00H
	ORG $+3
$SG218381 DB	'DomainType', 00H
	ORG $+1
$SG218382 DB	'Building_DomainFreeExperiences', 00H
	ORG $+1
$SG218383 DB	'Domains', 00H
$SG218384 DB	'Experience', 00H
	ORG $+1
$SG218385 DB	'BuildingType', 00H
	ORG $+3
$SG218386 DB	'DomainType', 00H
	ORG $+1
$SG218387 DB	'Building_DomainFreeExperiencePerGreatWork', 00H
	ORG $+2
$SG218388 DB	'Domains', 00H
$SG218389 DB	'Modifier', 00H
	ORG $+3
$SG218390 DB	'BuildingType', 00H
	ORG $+3
$SG218391 DB	'DomainType', 00H
	ORG $+1
$SG218392 DB	'Building_DomainProductionModifiers', 00H
	ORG $+1
$SG218393 DB	'Domains', 00H
$SG218394 DB	'NumBuildingNeeded', 00H
	ORG $+2
$SG218395 DB	'BuildingType', 00H
	ORG $+3
$SG218396 DB	'BuildingClassType', 00H
	ORG $+2
$SG218397 DB	'Building_PrereqBuildingClasses', 00H
	ORG $+1
$SG218398 DB	'BuildingClasses', 00H
$SG218399 DB	'BuildingType', 00H
	ORG $+3
$SG218400 DB	'BuildingClassType', 00H
	ORG $+2
$SG218401 DB	'Building_ClassesNeededInCity', 00H
	ORG $+3
$SG218402 DB	'BuildingClasses', 00H
$SG218403 DB	'NumUnits', 00H
	ORG $+3
$SG218404 DB	'BuildingType', 00H
	ORG $+3
$SG218405 DB	'UnitType', 00H
	ORG $+3
$SG218406 DB	'Building_FreeUnits', 00H
	ORG $+1
$SG218407 DB	'Units', 00H
	ORG $+2
$SG218408 DB	'Happiness', 00H
	ORG $+2
$SG218409 DB	'BuildingType', 00H
	ORG $+3
$SG218410 DB	'BuildingClassType', 00H
	ORG $+2
$SG218411 DB	'Building_BuildingClassHappiness', 00H
$SG218412 DB	'BuildingClasses', 00H
$SG218413 DB	'BuildingType', 00H
	ORG $+3
$SG218414 DB	'BuildingClassType', 00H
	ORG $+2
$SG218415 DB	'Building_LockedBuildingClasses', 00H
	ORG $+1
$SG218416 DB	'BuildingClasses', 00H
$SG218417 DB	'BuildingType', 00H
	ORG $+3
$SG218418 DB	'TechType', 00H
	ORG $+3
$SG218419 DB	'Building_TechAndPrereqs', 00H
$SG218420 DB	'Technologies', 00H
	ORG $+3
$SG218421 DB	'BuildingType', 00H
	ORG $+3
$SG218422 DB	'ResourceType', 00H
	ORG $+3
$SG218423 DB	'Building_LocalResourceAnds', 00H
	ORG $+1
$SG218424 DB	'Resources', 00H
	ORG $+2
$SG218425 DB	'BuildingType', 00H
	ORG $+3
$SG218426 DB	'ResourceType', 00H
	ORG $+3
$SG218427 DB	'Building_LocalResourceOrs', 00H
	ORG $+2
$SG218428 DB	'Resources', 00H
	ORG $+2
$SG218429 DB	'Yields', 00H
	ORG $+1
$SG218430 DB	'Resources', 00H
	ORG $+2
$SG218432 DB	'Building_ResourceYieldChanges', 00H
	ORG $+2
$SG218435 DB	'select Resources.ID as ResourceID, Yields.ID as YieldID,'
	DB	' Yield from Building_ResourceYieldChanges inner join Resource'
	DB	's on Resources.Type = ResourceType inner join Yields on Yield'
	DB	's.Type = YieldType where BuildingType = ?', 00H
$SG218443 DB	'Building_ResourceYieldChangesGlobal', 00H
$SG218446 DB	'select Resources.ID as ResourceID, Yields.ID as YieldID,'
	DB	' Yield from Building_ResourceYieldChangesGlobal inner join Re'
	DB	'sources on Resources.Type = ResourceType inner join Yields on'
	DB	' Yields.Type = YieldType where BuildingType = ?', 00H
	ORG $+2
$SG218964 DB	'Yields', 00H
	ORG $+1
$SG218965 DB	'Features', 00H
	ORG $+3
$SG218967 DB	'Building_FeatureYieldChanges', 00H
	ORG $+3
$SG218970 DB	'select Features.ID as FeatureID, Yields.ID as YieldID, Y'
	DB	'ield from Building_FeatureYieldChanges inner join Features on'
	DB	' Features.Type = FeatureType inner join Yields on Yields.Type'
	DB	' = YieldType where BuildingType = ?', 00H
	ORG $+2
$SG218977 DB	'Yields', 00H
	ORG $+1
$SG218978 DB	'Improvements', 00H
	ORG $+3
$SG218980 DB	'Building_ImprovementYieldChanges', 00H
	ORG $+7
$SG218983 DB	'select Improvements.ID as ImprovementID, Yields.ID as Yi'
	DB	'eldID, Yield from Building_ImprovementYieldChanges inner join'
	DB	' Improvements on Improvements.Type = ImprovementType inner jo'
	DB	'in Yields on Yields.Type = YieldType where BuildingType = ?', 00H
	ORG $+2
$SG218990 DB	'Yields', 00H
	ORG $+1
$SG218991 DB	'Improvements', 00H
	ORG $+3
$SG218993 DB	'Building_ImprovementYieldChangesGlobal', 00H
	ORG $+1
$SG218996 DB	'select Improvements.ID as ImprovementID, Yields.ID as Yi'
	DB	'eldID, Yield from Building_ImprovementYieldChangesGlobal inne'
	DB	'r join Improvements on Improvements.Type = ImprovementType in'
	DB	'ner join Yields on Yields.Type = YieldType where BuildingType'
	DB	' = ?', 00H
$SG219003 DB	'Yields', 00H
	ORG $+1
$SG219004 DB	'Terrains', 00H
	ORG $+3
$SG219006 DB	'Building_TerrainYieldChanges', 00H
	ORG $+3
$SG219009 DB	'select Terrains.ID as TerrainID, Yields.ID as YieldID, Y'
	DB	'ield from Building_TerrainYieldChanges inner join Terrains on'
	DB	' Terrains.Type = TerrainType inner join Yields on Yields.Type'
	DB	' = YieldType where BuildingType = ?', 00H
	ORG $+2
$SG219016 DB	'Yields', 00H
	ORG $+1
$SG219017 DB	'Specialists', 00H
$SG219019 DB	'Building_SpecialistYieldChanges', 00H
$SG219030 DB	'Resources', 00H
	ORG $+2
$SG219022 DB	'select Specialists.ID as SpecialistID, Yields.ID as Yiel'
	DB	'dID, Yield from Building_SpecialistYieldChanges inner join Sp'
	DB	'ecialists on Specialists.Type = SpecialistType inner join Yie'
	DB	'lds on Yields.Type = YieldType where BuildingType = ?', 00H
$SG219029 DB	'Yields', 00H
	ORG $+1
$SG219032 DB	'Building_ResourceYieldModifiers', 00H
$SG219035 DB	'select Resources.ID as ResourceID, Yields.ID as YieldID,'
	DB	' Yield from Building_ResourceYieldModifiers inner join Resour'
	DB	'ces on Resources.Type = ResourceType inner join Yields on Yie'
	DB	'lds.Type = YieldType where BuildingType = ?', 00H
	ORG $+2
$SG219042 DB	'Yields', 00H
	ORG $+1
$SG219043 DB	'BuildingClasses', 00H
$SG219045 DB	'Building_BuildingClassYieldChanges', 00H
	ORG $+5
$SG219048 DB	'select BuildingClasses.ID as BuildingClassID, Yields.ID '
	DB	'as YieldID, YieldChange from Building_BuildingClassYieldChang'
	DB	'es inner join BuildingClasses on BuildingClasses.Type = Build'
	DB	'ingClassType inner join Yields on Yields.Type = YieldType whe'
	DB	're BuildingType = ?', 00H
	ORG $+1
$SG219064 DB	'Building_ThemingBonuses', 00H
$SG219074 DB	'Description', 00H
$SG219067 DB	'select Bonus, Description, SameEra, UniqueEras, MustBeAr'
	DB	't, MustBeArtifact, MustBeEqualArtArtifact, RequiresOwner, Req'
	DB	'uiresAnyButOwner, RequiresSamePlayer, RequiresUniquePlayers, '
	DB	'AIPriority from Building_ThemingBonuses where BuildingType = '
	DB	'?', 00H
	ORG $+3
$SG219073 DB	'Bonus', 00H
	ORG $+2
$SG219075 DB	'SameEra', 00H
$SG219076 DB	'UniqueEras', 00H
	ORG $+1
$SG219077 DB	'MustBeArt', 00H
	ORG $+2
$SG219078 DB	'MustBeArtifact', 00H
	ORG $+1
$SG219079 DB	'MustBeEqualArtArtifact', 00H
	ORG $+1
$SG219080 DB	'RequiresOwner', 00H
	ORG $+2
$SG219081 DB	'RequiresAnyButOwner', 00H
$SG219082 DB	'RequiresSamePlayer', 00H
	ORG $+1
$SG219083 DB	'RequiresUniquePlayers', 00H
	ORG $+2
$SG219084 DB	'AIPriority', 00H
	ORG $+1
$SG219105 DB	'ERROR: Building does not contain valid BuildingClass typ'
	DB	'e!!', 00H
$SG220502 DB	'BUILDINGCLASS_SHRINE', 00H
	ORG $+3
$SG220514 DB	'CityBuildingsIsBuildingSellable', 00H
$SG220713 DB	'BUILDING_TEMPLE', 00H
$SG220811 DB	'TXT_KEY_MISC_COMPLETES_WONDER', 00H
	ORG $+2
$SG220826 DB	'TXT_KEY_MISC_WONDER_COMPLETED', 00H
	ORG $+2
$SG220847 DB	'TXT_KEY_MISC_WONDER_COMPLETED', 00H
	ORG $+2
$SG220854 DB	'TXT_KEY_MISC_WONDER_COMPLETED_UNKNOWN', 00H
	ORG $+2
$SG220857 DB	'BUILDING_GREAT_FIREWALL', 00H
$SG221578 DB	'BUILDINGCLASS_HEROIC_EPIC', 00H
	ORG $+2
$SG221581 DB	'BUILDINGCLASS_NATIONAL_COLLEGE', 00H
	ORG $+1
$SG221584 DB	'BUILDINGCLASS_NATIONAL_EPIC', 00H
$SG221587 DB	'BUILDINGCLASS_IRONWORKS', 00H
$SG221590 DB	'BUILDINGCLASS_OXFORD_UNIVERSITY', 00H
$SG221593 DB	'BUILDINGCLASS_HERMITAGE', 00H
$SG221596 DB	'BUILDINGCLASS_GREAT_LIGHTHOUSE', 00H
	ORG $+1
$SG221599 DB	'BUILDINGCLASS_STONEHENGE', 00H
	ORG $+3
$SG221602 DB	'BUILDINGCLASS_GREAT_LIBRARY', 00H
$SG221605 DB	'BUILDINGCLASS_PYRAMID', 00H
	ORG $+2
$SG221608 DB	'BUILDINGCLASS_COLOSSUS', 00H
	ORG $+1
$SG221611 DB	'BUILDINGCLASS_ORACLE', 00H
	ORG $+3
$SG221614 DB	'BUILDINGCLASS_HANGING_GARDEN', 00H
	ORG $+3
$SG221617 DB	'BUILDINGCLASS_GREAT_WALL', 00H
	ORG $+3
$SG221620 DB	'BUILDINGCLASS_ANGKOR_WAT', 00H
	ORG $+3
$SG221623 DB	'BUILDINGCLASS_HAGIA_SOPHIA', 00H
	ORG $+1
$SG221626 DB	'BUILDINGCLASS_CHICHEN_ITZA', 00H
	ORG $+1
$SG221629 DB	'BUILDINGCLASS_MACHU_PICHU', 00H
	ORG $+2
$SG221632 DB	'BUILDINGCLASS_NOTRE_DAME', 00H
	ORG $+3
$SG221635 DB	'BUILDINGCLASS_PORCELAIN_TOWER', 00H
	ORG $+2
$SG221638 DB	'BUILDINGCLASS_HIMEJI_CASTLE', 00H
$SG221641 DB	'BUILDINGCLASS_SISTINE_CHAPEL', 00H
	ORG $+3
$SG221644 DB	'BUILDINGCLASS_KREMLIN', 00H
	ORG $+2
$SG221647 DB	'BUILDINGCLASS_FORBIDDEN_PALACE', 00H
	ORG $+1
$SG221650 DB	'BUILDINGCLASS_TAJ_MAHAL', 00H
$SG221653 DB	'BUILDINGCLASS_BIG_BEN', 00H
	ORG $+2
$SG221656 DB	'BUILDINGCLASS_LOUVRE', 00H
	ORG $+3
$SG221659 DB	'BUILDINGCLASS_BRANDENBURG_GATE', 00H
	ORG $+1
$SG221662 DB	'BUILDINGCLASS_STATUE_OF_LIBERTY', 00H
$SG221665 DB	'BUILDINGCLASS_CRISTO_REDENTOR', 00H
	ORG $+2
$SG221668 DB	'BUILDINGCLASS_EIFFEL_TOWER', 00H
	ORG $+1
$SG221671 DB	'BUILDINGCLASS_PENTAGON', 00H
	ORG $+1
$SG221674 DB	'BUILDINGCLASS_UNITED_NATIONS', 00H
	ORG $+3
$SG221677 DB	'BUILDINGCLASS_SYDNEY_OPERA_HOUSE', 00H
	ORG $+3
$SG221680 DB	'BUILDINGCLASS_STATUE_ZEUS', 00H
	ORG $+2
$SG221683 DB	'BUILDINGCLASS_TEMPLE_ARTEMIS', 00H
	ORG $+3
$SG221686 DB	'BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS', 00H
	ORG $+2
$SG221739 DB	'LOAD ERROR: Building Type not found', 00H
$SG92486 DB	'2968ab37-29a3-4de7-8b84-ece688231e40', 00H
	ORG $+3
_CIV5_DLC_06_SCENARIO_MODID DD FLAT:$SG92486
$SG92494 DB	'BBB0D085-A0B1-4475-B007-3E549CF3ADC3', 00H
	ORG $+3
_CIV5_DLC_06_PACKAGEID DD FLAT:$SG92494
CONST	ENDS
PUBLIC	?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z	; std::_Container_base::_Swap_aux
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z PROC	; std::_Container_base::_Swap_aux, COMDAT
; _this$ = ecx

; 602  : 		// Do nothing: we don't have an aux object.
; 603  : 		}

	ret	4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z ENDP	; std::_Container_base::_Swap_aux
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetBuildingClassType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?GetBuildingClassType@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingClassType@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetBuildingClassType, COMDAT
; _this$ = ecx

; 855  : 	return m_iBuildingClassType;

	mov	eax, DWORD PTR [ecx+260]

; 856  : }

	ret	0
?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetBuildingClassType
_TEXT	ENDS
PUBLIC	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ
_TEXT	SEGMENT
?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ PROC ; CvBuildingEntry::GetBuildingClassInfo, COMDAT
; _this$ = ecx

; 859  : {

	push	esi
	mov	esi, ecx

; 860  : 	if(m_pkBuildingClassInfo == NULL)

	cmp	DWORD PTR [esi+264], 0
	jne	SHORT $LN4@GetBuildin

; 861  : 	{
; 862  : 		const char* szError = "ERROR: Building does not contain valid BuildingClass type!!";
; 863  : 		GC.LogMessage(szError);

	push	OFFSET $SG219105
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage
$LN4@GetBuildin:

; 864  : 		CvAssertMsg(false, szError);
; 865  : 	}
; 866  : 
; 867  : #pragma warning ( push )
; 868  : #pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
; 869  : 	return *m_pkBuildingClassInfo;

	mov	eax, DWORD PTR [esi+264]
	pop	esi

; 870  : #pragma warning ( pop )
; 871  : }

	ret	0
?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ENDP ; CvBuildingEntry::GetBuildingClassInfo
_TEXT	ENDS
PUBLIC	?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetNearbyTerrainRequired
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNearbyTerrainRequired, COMDAT
; _this$ = ecx

; 876  : 	return m_iNearbyTerrainRequired;

	mov	eax, DWORD PTR [ecx+268]

; 877  : }

	ret	0
?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNearbyTerrainRequired
_TEXT	ENDS
PUBLIC	?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetProhibitedCityTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetProhibitedCityTerrain, COMDAT
; _this$ = ecx

; 882  : 	return m_iProhibitedCityTerrain;

	mov	eax, DWORD PTR [ecx+272]

; 883  : }

	ret	0
?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetProhibitedCityTerrain
_TEXT	ENDS
PUBLIC	?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetVictoryPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetVictoryPrereq, COMDAT
; _this$ = ecx

; 888  : 	return m_iVictoryPrereq;

	mov	eax, DWORD PTR [ecx+276]

; 889  : }

	ret	0
?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetVictoryPrereq
_TEXT	ENDS
PUBLIC	?GetFreeStartEra@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeStartEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeStartEra@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeStartEra@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeStartEra, COMDAT
; _this$ = ecx

; 894  : 	return m_iFreeStartEra;

	mov	eax, DWORD PTR [ecx+280]

; 895  : }

	ret	0
?GetFreeStartEra@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeStartEra
_TEXT	ENDS
PUBLIC	?GetMaxStartEra@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetMaxStartEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxStartEra@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxStartEra@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetMaxStartEra, COMDAT
; _this$ = ecx

; 900  : 	return m_iMaxStartEra;

	mov	eax, DWORD PTR [ecx+284]

; 901  : }

	ret	0
?GetMaxStartEra@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetMaxStartEra
_TEXT	ENDS
PUBLIC	?GetObsoleteTech@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetObsoleteTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetObsoleteTech@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetObsoleteTech@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetObsoleteTech, COMDAT
; _this$ = ecx

; 906  : 	return m_iObsoleteTech;

	mov	eax, DWORD PTR [ecx+288]

; 907  : }

	ret	0
?GetObsoleteTech@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetObsoleteTech
_TEXT	ENDS
PUBLIC	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetEnhancedYieldTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetEnhancedYieldTech, COMDAT
; _this$ = ecx

; 912  : 	return m_iEnhancedYieldTech;

	mov	eax, DWORD PTR [ecx+292]

; 913  : }

	ret	0
?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetEnhancedYieldTech
_TEXT	ENDS
PUBLIC	?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechEnhancedTourism
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTechEnhancedTourism, COMDAT
; _this$ = ecx

; 918  : 	return m_iTechEnhancedTourism;

	mov	eax, DWORD PTR [ecx+296]

; 919  : }

	ret	0
?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTechEnhancedTourism
_TEXT	ENDS
PUBLIC	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGoldMaintenance, COMDAT
; _this$ = ecx

; 924  : 	return m_iGoldMaintenance;

	mov	eax, DWORD PTR [ecx+300]

; 925  : }

	ret	0
?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMutuallyExclusiveGroup
; Function compile flags: /Ogtpy
;	COMDAT ?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetMutuallyExclusiveGroup, COMDAT
; _this$ = ecx

; 930  : 	return m_iMutuallyExclusiveGroup;

	mov	eax, DWORD PTR [ecx+304]

; 931  : }

	ret	0
?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetMutuallyExclusiveGroup
_TEXT	ENDS
PUBLIC	?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetReplacementBuildingClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetReplacementBuildingClass, COMDAT
; _this$ = ecx

; 936  : 	return m_iReplacementBuildingClass;

	mov	eax, DWORD PTR [ecx+308]

; 937  : }

	ret	0
?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetReplacementBuildingClass
_TEXT	ENDS
PUBLIC	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPrereqAndTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetPrereqAndTech, COMDAT
; _this$ = ecx

; 956  : 	return m_iPrereqAndTech;

	mov	eax, DWORD PTR [ecx+312]

; 957  : }

	ret	0
?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetPrereqAndTech
_TEXT	ENDS
PUBLIC	?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPolicyBranchType
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetPolicyBranchType, COMDAT
; _this$ = ecx

; 962  : 	return m_iPolicyBranchType;

	mov	eax, DWORD PTR [ecx+316]

; 963  : }

	ret	0
?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetPolicyBranchType
_TEXT	ENDS
PUBLIC	?GetSpecialistType@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetSpecialistType
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistType@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialistType@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetSpecialistType, COMDAT
; _this$ = ecx

; 968  : 	return m_iSpecialistType;

	mov	eax, DWORD PTR [ecx+320]

; 969  : }

	ret	0
?GetSpecialistType@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetSpecialistType
_TEXT	ENDS
PUBLIC	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetSpecialistCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistCount@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialistCount@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetSpecialistCount, COMDAT
; _this$ = ecx

; 974  : 	return m_iSpecialistCount;

	mov	eax, DWORD PTR [ecx+324]

; 975  : }

	ret	0
?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetSpecialistCount
_TEXT	ENDS
PUBLIC	?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistExtraCulture
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetSpecialistExtraCulture, COMDAT
; _this$ = ecx

; 980  : 	return m_iSpecialistExtraCulture;

	mov	eax, DWORD PTR [ecx+328]

; 981  : }

	ret	0
?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetSpecialistExtraCulture
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatPeopleRateChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGreatPeopleRateChange, COMDAT
; _this$ = ecx

; 986  : 	return m_iGreatPeopleRateChange;

	mov	eax, DWORD PTR [ecx+332]

; 987  : }

	ret	0
?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGreatPeopleRateChange
_TEXT	ENDS
PUBLIC	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ
_TEXT	SEGMENT
?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ PROC ; CvBuildingEntry::GetGreatWorkSlotType, COMDAT
; _this$ = ecx

; 992  : 	return m_eGreatWorkSlotType;

	mov	eax, DWORD PTR [ecx+336]

; 993  : }

	ret	0
?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ENDP ; CvBuildingEntry::GetGreatWorkSlotType
_TEXT	ENDS
PUBLIC	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetGreatWorkCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetGreatWorkCount, COMDAT
; _this$ = ecx

; 1002 : 	return m_iGreatWorkCount;

	mov	eax, DWORD PTR [ecx+340]

; 1003 : }

	ret	0
?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetGreatWorkCount
_TEXT	ENDS
PUBLIC	?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ ; CvBuildingEntry::GetFreeGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ
_TEXT	SEGMENT
?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ PROC ; CvBuildingEntry::GetFreeGreatWork, COMDAT
; _this$ = ecx

; 1008 : 	return m_eFreeGreatWork;

	mov	eax, DWORD PTR [ecx+344]

; 1009 : }

	ret	0
?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ ENDP ; CvBuildingEntry::GetFreeGreatWork
_TEXT	ENDS
PUBLIC	?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeBuildingClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreeBuildingClass, COMDAT
; _this$ = ecx

; 1014 : 	return m_iFreeBuildingClass;

	mov	eax, DWORD PTR [ecx+348]

; 1015 : }

	ret	0
?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreeBuildingClass
_TEXT	ENDS
PUBLIC	?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetFreeBuildingThisCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreeBuildingThisCity, COMDAT
; _this$ = ecx

; 1020 : 	return m_iFreeBuildingThisCity;

	mov	eax, DWORD PTR [ecx+352]

; 1021 : }

	ret	0
?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreeBuildingThisCity
_TEXT	ENDS
PUBLIC	?GetFreePromotion@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreePromotion
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreePromotion@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreePromotion@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreePromotion, COMDAT
; _this$ = ecx

; 1026 : 	return m_iFreePromotion;

	mov	eax, DWORD PTR [ecx+356]

; 1027 : }

	ret	0
?GetFreePromotion@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreePromotion
_TEXT	ENDS
PUBLIC	?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTrainedFreePromotion
; Function compile flags: /Ogtpy
;	COMDAT ?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTrainedFreePromotion, COMDAT
; _this$ = ecx

; 1032 : 	return m_iTrainedFreePromotion;

	mov	eax, DWORD PTR [ecx+360]

; 1033 : }

	ret	0
?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTrainedFreePromotion
_TEXT	ENDS
PUBLIC	?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetFreePromotionRemoved
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreePromotionRemoved, COMDAT
; _this$ = ecx

; 1038 : 	return m_iFreePromotionRemoved;

	mov	eax, DWORD PTR [ecx+364]

; 1039 : }

	ret	0
?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreePromotionRemoved
_TEXT	ENDS
PUBLIC	?GetProductionCost@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetProductionCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetProductionCost@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProductionCost@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetProductionCost, COMDAT
; _this$ = ecx

; 1044 : 	return m_iProductionCost;

	mov	eax, DWORD PTR [ecx+368]

; 1045 : }

	ret	0
?GetProductionCost@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetProductionCost
_TEXT	ENDS
PUBLIC	?GetFaithCost@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetFaithCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithCost@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithCost@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFaithCost, COMDAT
; _this$ = ecx

; 1050 : 	return m_iFaithCost;

	mov	eax, DWORD PTR [ecx+372]

; 1051 : }

	ret	0
?GetFaithCost@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFaithCost
_TEXT	ENDS
PUBLIC	?GetLeagueCost@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetLeagueCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetLeagueCost@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLeagueCost@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetLeagueCost, COMDAT
; _this$ = ecx

; 1056 : 	return m_iLeagueCost;

	mov	eax, DWORD PTR [ecx+376]

; 1057 : }

	ret	0
?GetLeagueCost@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetLeagueCost
_TEXT	ENDS
PUBLIC	?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumCityCostMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetNumCityCostMod, COMDAT
; _this$ = ecx

; 1062 : 	return m_iNumCityCostMod;

	mov	eax, DWORD PTR [ecx+380]

; 1063 : }

	ret	0
?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetNumCityCostMod
_TEXT	ENDS
PUBLIC	?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetHurryCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetHurryCostModifier, COMDAT
; _this$ = ecx

; 1068 : 	return m_iHurryCostModifier;

	mov	eax, DWORD PTR [ecx+384]

; 1069 : }

	ret	0
?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetHurryCostModifier
_TEXT	ENDS
PUBLIC	?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumCitiesPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNumCitiesPrereq, COMDAT
; _this$ = ecx

; 1074 : 	return m_iNumCitiesPrereq;

	mov	eax, DWORD PTR [ecx+388]

; 1075 : }

	ret	0
?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNumCitiesPrereq
_TEXT	ENDS
PUBLIC	?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnitLevelPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnitLevelPrereq, COMDAT
; _this$ = ecx

; 1080 : 	return m_iUnitLevelPrereq;

	mov	eax, DWORD PTR [ecx+392]

; 1081 : }

	ret	0
?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnitLevelPrereq
_TEXT	ENDS
PUBLIC	?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetCultureRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetCultureRateModifier, COMDAT
; _this$ = ecx

; 1086 : 	return m_iCultureRateModifier;

	mov	eax, DWORD PTR [ecx+396]

; 1087 : }

	ret	0
?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetCultureRateModifier
_TEXT	ENDS
PUBLIC	?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalCultureRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalCultureRateModifier, COMDAT
; _this$ = ecx

; 1092 : 	return m_iGlobalCultureRateModifier;

	mov	eax, DWORD PTR [ecx+400]

; 1093 : }

	ret	0
?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalCultureRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatPeopleRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 1098 : 	return m_iGreatPeopleRateModifier;

	mov	eax, DWORD PTR [ecx+404]

; 1099 : }

	ret	0
?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalGreatPeopleRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 1104 : 	return m_iGlobalGreatPeopleRateModifier;

	mov	eax, DWORD PTR [ecx+408]

; 1105 : }

	ret	0
?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatGeneralRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 1110 : 	return m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR [ecx+412]

; 1111 : }

	ret	0
?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatPersonExpendGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGreatPersonExpendGold, COMDAT
; _this$ = ecx

; 1116 : 	return m_iGreatPersonExpendGold;

	mov	eax, DWORD PTR [ecx+416]

; 1117 : }

	ret	0
?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGreatPersonExpendGold
_TEXT	ENDS
PUBLIC	?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnitUpgradeCostMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnitUpgradeCostMod, COMDAT
; _this$ = ecx

; 1122 : 	return m_iUnitUpgradeCostMod;

	mov	eax, DWORD PTR [ecx+420]

; 1123 : }

	ret	0
?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnitUpgradeCostMod
_TEXT	ENDS
PUBLIC	?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetGoldenAgeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGoldenAgeModifier, COMDAT
; _this$ = ecx

; 1128 : 	return m_iGoldenAgeModifier;

	mov	eax, DWORD PTR [ecx+424]

; 1129 : }

	ret	0
?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGoldenAgeModifier
_TEXT	ENDS
PUBLIC	?GetFreeExperience@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeExperience
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeExperience@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeExperience@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeExperience, COMDAT
; _this$ = ecx

; 1134 : 	return m_iFreeExperience;

	mov	eax, DWORD PTR [ecx+428]

; 1135 : }

	ret	0
?GetFreeExperience@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeExperience
_TEXT	ENDS
PUBLIC	?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalFreeExperience
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGlobalFreeExperience, COMDAT
; _this$ = ecx

; 1140 : 	return m_iGlobalFreeExperience;

	mov	eax, DWORD PTR [ecx+432]

; 1141 : }

	ret	0
?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGlobalFreeExperience
_TEXT	ENDS
PUBLIC	?GetFoodKept@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetFoodKept
; Function compile flags: /Ogtpy
;	COMDAT ?GetFoodKept@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFoodKept@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFoodKept, COMDAT
; _this$ = ecx

; 1146 : 	return m_iFoodKept;

	mov	eax, DWORD PTR [ecx+436]

; 1147 : }

	ret	0
?GetFoodKept@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFoodKept
_TEXT	ENDS
PUBLIC	?IsAirlift@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsAirlift
; Function compile flags: /Ogtpy
;	COMDAT ?IsAirlift@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAirlift@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsAirlift, COMDAT
; _this$ = ecx

; 1152 : 	return m_bAirlift;

	mov	al, BYTE PTR [ecx+440]

; 1153 : }

	ret	0
?IsAirlift@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsAirlift
_TEXT	ENDS
PUBLIC	?GetAirModifier@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetAirModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetAirModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAirModifier@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetAirModifier, COMDAT
; _this$ = ecx

; 1158 : 	return m_iAirModifier;

	mov	eax, DWORD PTR [ecx+444]

; 1159 : }

	ret	0
?GetAirModifier@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetAirModifier
_TEXT	ENDS
PUBLIC	?GetNukeModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNukeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNukeModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNukeModifier@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetNukeModifier, COMDAT
; _this$ = ecx

; 1164 : 	return m_iNukeModifier;

	mov	eax, DWORD PTR [ecx+448]

; 1165 : }

	ret	0
?GetNukeModifier@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetNukeModifier
_TEXT	ENDS
PUBLIC	?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNukeExplosionRand
; Function compile flags: /Ogtpy
;	COMDAT ?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNukeExplosionRand, COMDAT
; _this$ = ecx

; 1170 : 	return m_iNukeExplosionRand;

	mov	eax, DWORD PTR [ecx+452]

; 1171 : }

	ret	0
?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNukeExplosionRand
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetWorkerSpeedModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 1176 : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR [ecx+456]

; 1177 : }

	ret	0
?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMilitaryProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetMilitaryProductionModifier, COMDAT
; _this$ = ecx

; 1182 : 	return m_iMilitaryProductionModifier;

	mov	eax, DWORD PTR [ecx+460]

; 1183 : }

	ret	0
?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetMilitaryProductionModifier
_TEXT	ENDS
PUBLIC	?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpaceProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetSpaceProductionModifier, COMDAT
; _this$ = ecx

; 1188 : 	return m_iSpaceProductionModifier;

	mov	eax, DWORD PTR [ecx+464]

; 1189 : }

	ret	0
?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetSpaceProductionModifier
_TEXT	ENDS
PUBLIC	?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalSpaceProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalSpaceProductionModifier, COMDAT
; _this$ = ecx

; 1194 : 	return m_iGlobalSpaceProductionModifier;

	mov	eax, DWORD PTR [ecx+468]

; 1195 : }

	ret	0
?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalSpaceProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 1200 : 	return m_iBuildingProductionModifier;

	mov	eax, DWORD PTR [ecx+472]

; 1201 : }

	ret	0
?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetWonderProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 1206 : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR [ecx+476]

; 1207 : }

	ret	0
?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityConnectionTradeRouteModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityConnectionTradeRouteModifier, COMDAT
; _this$ = ecx

; 1212 : 	return m_iCityConnectionTradeRouteModifier;

	mov	eax, DWORD PTR [ecx+480]

; 1213 : }

	ret	0
?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityConnectionTradeRouteModifier
_TEXT	ENDS
PUBLIC	?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCapturePlunderModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetCapturePlunderModifier, COMDAT
; _this$ = ecx

; 1218 : 	return m_iCapturePlunderModifier;

	mov	eax, DWORD PTR [ecx+484]

; 1219 : }

	ret	0
?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetCapturePlunderModifier
_TEXT	ENDS
PUBLIC	?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPolicyCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetPolicyCostModifier, COMDAT
; _this$ = ecx

; 1224 : 	return m_iPolicyCostModifier;

	mov	eax, DWORD PTR [ecx+488]

; 1225 : }

	ret	0
?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetPolicyCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPlotCultureCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 1230 : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR [ecx+496]

; 1231 : }

	ret	0
?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalPlotCultureCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 1236 : 	return m_iGlobalPlotCultureCostModifier;

	mov	eax, DWORD PTR [ecx+492]

; 1237 : }

	ret	0
?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPlotBuyCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetPlotBuyCostModifier, COMDAT
; _this$ = ecx

; 1242 : 	return m_iPlotBuyCostModifier;

	mov	eax, DWORD PTR [ecx+504]

; 1243 : }

	ret	0
?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetPlotBuyCostModifier
_TEXT	ENDS
PUBLIC	?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalPlotBuyCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalPlotBuyCostModifier, COMDAT
; _this$ = ecx

; 1248 : 	return m_iGlobalPlotBuyCostModifier;

	mov	eax, DWORD PTR [ecx+500]

; 1249 : }

	ret	0
?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalPlotBuyCostModifier
_TEXT	ENDS
PUBLIC	?GetMinAreaSize@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetMinAreaSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinAreaSize@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinAreaSize@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetMinAreaSize, COMDAT
; _this$ = ecx

; 1254 : 	return m_iMinAreaSize;

	mov	eax, DWORD PTR [ecx+508]

; 1255 : }

	ret	0
?GetMinAreaSize@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetMinAreaSize
_TEXT	ENDS
PUBLIC	?GetConquestProbability@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetConquestProbability
; Function compile flags: /Ogtpy
;	COMDAT ?GetConquestProbability@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetConquestProbability@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetConquestProbability, COMDAT
; _this$ = ecx

; 1260 : 	return m_iConquestProbability;

	mov	eax, DWORD PTR [ecx+512]

; 1261 : }

	ret	0
?GetConquestProbability@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetConquestProbability
_TEXT	ENDS
PUBLIC	?GetHealRateChange@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetHealRateChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetHealRateChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHealRateChange@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetHealRateChange, COMDAT
; _this$ = ecx

; 1266 : 	return m_iHealRateChange;

	mov	eax, DWORD PTR [ecx+516]

; 1267 : }

	ret	0
?GetHealRateChange@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetHealRateChange
_TEXT	ENDS
PUBLIC	?GetHappiness@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappiness@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappiness@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetHappiness, COMDAT
; _this$ = ecx

; 1272 : 	return m_iHappiness;

	mov	eax, DWORD PTR [ecx+520]

; 1273 : }

	ret	0
?GetHappiness@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetHappiness
_TEXT	ENDS
PUBLIC	?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnmoddedHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnmoddedHappiness, COMDAT
; _this$ = ecx

; 1278 : 	return m_iUnmoddedHappiness;

	mov	eax, DWORD PTR [ecx+524]

; 1279 : }

	ret	0
?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnmoddedHappiness
_TEXT	ENDS
PUBLIC	?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnhappinessModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnhappinessModifier, COMDAT
; _this$ = ecx

; 1284 : 	return m_iUnhappinessModifier;

	mov	eax, DWORD PTR [ecx+528]

; 1285 : }

	ret	0
?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetHappinessPerCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetHappinessPerCity, COMDAT
; _this$ = ecx

; 1290 : 	return m_iHappinessPerCity;

	mov	eax, DWORD PTR [ecx+532]

; 1291 : }

	ret	0
?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetHappinessPerCity
_TEXT	ENDS
PUBLIC	?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetHappinessPerXPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetHappinessPerXPolicies, COMDAT
; _this$ = ecx

; 1296 : 	return m_iHappinessPerXPolicies;

	mov	eax, DWORD PTR [ecx+536]

; 1297 : }

	ret	0
?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetHappinessPerXPolicies
_TEXT	ENDS
PUBLIC	?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityCountUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityCountUnhappinessMod, COMDAT
; _this$ = ecx

; 1302 : 	return m_iCityCountUnhappinessMod;

	mov	eax, DWORD PTR [ecx+540]

; 1303 : }

	ret	0
?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityCountUnhappinessMod
_TEXT	ENDS
PUBLIC	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNoOccupiedUnhappiness
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsNoOccupiedUnhappiness, COMDAT
; _this$ = ecx

; 1308 : 	return m_bNoOccupiedUnhappiness;

	mov	al, BYTE PTR [ecx+544]

; 1309 : }

	ret	0
?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsNoOccupiedUnhappiness
_TEXT	ENDS
PUBLIC	?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalPopulationChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGlobalPopulationChange, COMDAT
; _this$ = ecx

; 1314 : 	return m_iGlobalPopulationChange;

	mov	eax, DWORD PTR [ecx+548]

; 1315 : }

	ret	0
?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGlobalPopulationChange
_TEXT	ENDS
PUBLIC	?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetLocalPopulationChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetLocalPopulationChange, COMDAT
; _this$ = ecx

; 1321 : 	return m_iLocalPopulationChange;

	mov	eax, DWORD PTR [ecx+552]

; 1322 : }

	ret	0
?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetLocalPopulationChange
_TEXT	ENDS
PUBLIC	?GetTechShare@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetTechShare
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechShare@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechShare@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetTechShare, COMDAT
; _this$ = ecx

; 1328 : 	return m_iTechShare;

	mov	eax, DWORD PTR [ecx+556]

; 1329 : }

	ret	0
?GetTechShare@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetTechShare
_TEXT	ENDS
PUBLIC	?GetFreeTechs@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeTechs@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeTechs@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeTechs, COMDAT
; _this$ = ecx

; 1334 : 	return m_iFreeTechs;

	mov	eax, DWORD PTR [ecx+560]

; 1335 : }

	ret	0
?GetFreeTechs@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeTechs
_TEXT	ENDS
PUBLIC	?GetFreePolicies@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreePolicies@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreePolicies@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreePolicies, COMDAT
; _this$ = ecx

; 1340 : 	return m_iFreePolicies;

	mov	eax, DWORD PTR [ecx+564]

; 1341 : }

	ret	0
?GetFreePolicies@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreePolicies
_TEXT	ENDS
PUBLIC	?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeFlatFaith
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeFlatFaith, COMDAT
; _this$ = ecx

; 1347 : 	return m_iFreeFlatFaith;

	mov	eax, DWORD PTR [ecx+568]

; 1348 : }

	ret	0
?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeFlatFaith
_TEXT	ENDS
PUBLIC	?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMountainScienceYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetMountainScienceYield, COMDAT
; _this$ = ecx

; 1355 : 	return m_iMountainScienceYield;

	mov	eax, DWORD PTR [ecx+572]

; 1356 : }

	ret	0
?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetMountainScienceYield
_TEXT	ENDS
PUBLIC	?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeGreatPeople
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreeGreatPeople, COMDAT
; _this$ = ecx

; 1362 : 	return m_iFreeGreatPeople;

	mov	eax, DWORD PTR [ecx+576]

; 1363 : }

	ret	0
?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreeGreatPeople
_TEXT	ENDS
PUBLIC	?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMedianTechPercentChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetMedianTechPercentChange, COMDAT
; _this$ = ecx

; 1368 : 	return m_iMedianTechPercentChange;

	mov	eax, DWORD PTR [ecx+580]

; 1369 : }

	ret	0
?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetMedianTechPercentChange
_TEXT	ENDS
PUBLIC	?GetGold@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetGold@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGold@CvBuildingEntry@@QBEHXZ PROC			; CvBuildingEntry::GetGold, COMDAT
; _this$ = ecx

; 1374 : 	return m_iGold;

	mov	eax, DWORD PTR [ecx+584]

; 1375 : }

	ret	0
?GetGold@CvBuildingEntry@@QBEHXZ ENDP			; CvBuildingEntry::GetGold
_TEXT	ENDS
PUBLIC	?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNearbyMountainRequired
; Function compile flags: /Ogtpy
;	COMDAT ?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsNearbyMountainRequired, COMDAT
; _this$ = ecx

; 1380 : 	return m_bNearbyMountainRequired;

	mov	al, BYTE PTR [ecx+588]

; 1381 : }

	ret	0
?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsNearbyMountainRequired
_TEXT	ENDS
PUBLIC	?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsAllowsRangeStrike
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsAllowsRangeStrike, COMDAT
; _this$ = ecx

; 1386 : 	return m_bAllowsRangeStrike;

	mov	al, BYTE PTR [ecx+589]

; 1387 : }

	ret	0
?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsAllowsRangeStrike
_TEXT	ENDS
PUBLIC	?GetDefenseModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefenseModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDefenseModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetDefenseModifier, COMDAT
; _this$ = ecx

; 1392 : 	return m_iDefenseModifier;

	mov	eax, DWORD PTR [ecx+592]

; 1393 : }

	ret	0
?GetDefenseModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetDefenseModifier
_TEXT	ENDS
PUBLIC	?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetDefensePerCitizen
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetDefensePerCitizen, COMDAT
; _this$ = ecx

; 1399 : 	return m_iDefensePerCitizen;

	mov	eax, DWORD PTR [ecx+596]

; 1400 : }

	ret	0
?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetDefensePerCitizen
_TEXT	ENDS
PUBLIC	?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGlobalDefenseModifier, COMDAT
; _this$ = ecx

; 1407 : 	return m_iGlobalDefenseModifier;

	mov	eax, DWORD PTR [ecx+600]

; 1408 : }

	ret	0
?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGlobalDefenseModifier
_TEXT	ENDS
PUBLIC	?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetExtraCityHitPoints
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetExtraCityHitPoints, COMDAT
; _this$ = ecx

; 1413 : 	return m_iExtraCityHitPoints;

	mov	eax, DWORD PTR [ecx+604]

; 1414 : }

	ret	0
?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetExtraCityHitPoints
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMinorFriendshipChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetMinorFriendshipChange, COMDAT
; _this$ = ecx

; 1419 : 	return m_iMinorFriendshipChange;

	mov	eax, DWORD PTR [ecx+612]

; 1420 : }

	ret	0
?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetMinorFriendshipChange
_TEXT	ENDS
PUBLIC	?GetVictoryPoints@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetVictoryPoints
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryPoints@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetVictoryPoints@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetVictoryPoints, COMDAT
; _this$ = ecx

; 1425 : 	return m_iVictoryPoints;

	mov	eax, DWORD PTR [ecx+616]

; 1426 : }

	ret	0
?GetVictoryPoints@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetVictoryPoints
_TEXT	ENDS
PUBLIC	?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetExtraMissionarySpreads
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetExtraMissionarySpreads, COMDAT
; _this$ = ecx

; 1431 : 	return m_iExtraMissionarySpreads;

	mov	eax, DWORD PTR [ecx+620]

; 1432 : }

	ret	0
?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetExtraMissionarySpreads
_TEXT	ENDS
PUBLIC	?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetReligiousPressureModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetReligiousPressureModifier, COMDAT
; _this$ = ecx

; 1437 : 	return m_iReligiousPressureModifier;

	mov	eax, DWORD PTR [ecx+624]

; 1438 : }

	ret	0
?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetReligiousPressureModifier
_TEXT	ENDS
PUBLIC	?GetEspionageModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetEspionageModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetEspionageModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEspionageModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetEspionageModifier, COMDAT
; _this$ = ecx

; 1443 : 	return m_iEspionageModifier;

	mov	eax, DWORD PTR [ecx+628]

; 1444 : }

	ret	0
?GetEspionageModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetEspionageModifier
_TEXT	ENDS
PUBLIC	?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalEspionageModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalEspionageModifier, COMDAT
; _this$ = ecx

; 1449 : 	return m_iGlobalEspionageModifier;

	mov	eax, DWORD PTR [ecx+632]

; 1450 : }

	ret	0
?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalEspionageModifier
_TEXT	ENDS
PUBLIC	?GetExtraSpies@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetExtraSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraSpies@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraSpies@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetExtraSpies, COMDAT
; _this$ = ecx

; 1455 : 	return m_iExtraSpies;

	mov	eax, DWORD PTR [ecx+636]

; 1456 : }

	ret	0
?GetExtraSpies@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetExtraSpies
_TEXT	ENDS
PUBLIC	?GetSpyRankChange@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetSpyRankChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpyRankChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpyRankChange@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetSpyRankChange, COMDAT
; _this$ = ecx

; 1461 : 	return m_iSpyRankChange;

	mov	eax, DWORD PTR [ecx+640]

; 1462 : }

	ret	0
?GetSpyRankChange@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetSpyRankChange
_TEXT	ENDS
PUBLIC	?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteRecipientBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteRecipientBonus, COMDAT
; _this$ = ecx

; 1467 : 	return m_iTradeRouteRecipientBonus;

	mov	eax, DWORD PTR [ecx+664]

; 1468 : }

	ret	0
?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteRecipientBonus
_TEXT	ENDS
PUBLIC	?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteTargetBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTradeRouteTargetBonus, COMDAT
; _this$ = ecx

; 1473 : 	return m_iTradeRouteTargetBonus;

	mov	eax, DWORD PTR [ecx+668]

; 1474 : }

	ret	0
?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTradeRouteTargetBonus
_TEXT	ENDS
PUBLIC	?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumTradeRouteBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNumTradeRouteBonus, COMDAT
; _this$ = ecx

; 1478 : 	return m_iNumTradeRouteBonus;

	mov	eax, DWORD PTR [ecx+672]

; 1479 : }

	ret	0
?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNumTradeRouteBonus
_TEXT	ENDS
PUBLIC	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier, COMDAT
; _this$ = ecx

; 1483 : 	return m_iTradeRouteSeaDistanceModifier;

	mov	eax, DWORD PTR [ecx+676]

; 1484 : }

	ret	0
?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTradeRouteSeaGoldBonus, COMDAT
; _this$ = ecx

; 1488 : 	return m_iTradeRouteSeaGoldBonus;

	mov	eax, DWORD PTR [ecx+680]

; 1489 : }

	ret	0
?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTradeRouteSeaGoldBonus
_TEXT	ENDS
PUBLIC	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteLandDistanceModifier, COMDAT
; _this$ = ecx

; 1493 : 	return m_iTradeRouteLandDistanceModifier;

	mov	eax, DWORD PTR [ecx+684]

; 1494 : }

	ret	0
?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandGoldBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteLandGoldBonus, COMDAT
; _this$ = ecx

; 1498 : 	return m_iTradeRouteLandGoldBonus;

	mov	eax, DWORD PTR [ecx+688]

; 1499 : }

	ret	0
?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteLandGoldBonus
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier, COMDAT
; _this$ = ecx

; 1503 : 	return m_iCityStateTradeRouteProductionModifier;

	mov	eax, DWORD PTR [ecx+692]

; 1504 : }

	ret	0
?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 1509 : 	return m_iCityStateTradeRouteGoldModifier;

	mov	eax, DWORD PTR [ecx+696]

; 1510 : }

	ret	0
?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatScientistBeakerModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatScientistBeakerModifier, COMDAT
; _this$ = ecx

; 1515 : 	return m_iGreatScientistBeakerModifier;

	mov	eax, DWORD PTR [ecx+700]

; 1516 : }

	ret	0
?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatScientistBeakerModifier
_TEXT	ENDS
PUBLIC	?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetInstantSpyRankChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetInstantSpyRankChange, COMDAT
; _this$ = ecx

; 1521 : 	return m_iInstantSpyRankChange;

	mov	eax, DWORD PTR [ecx+644]

; 1522 : }

	ret	0
?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetInstantSpyRankChange
_TEXT	ENDS
PUBLIC	?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetLandmarksTourismPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetLandmarksTourismPercent, COMDAT
; _this$ = ecx

; 1527 : 	return m_iLandmarksTourismPercent;

	mov	eax, DWORD PTR [ecx+648]

; 1528 : }

	ret	0
?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetLandmarksTourismPercent
_TEXT	ENDS
PUBLIC	?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetInstantMilitaryIncrease
; Function compile flags: /Ogtpy
;	COMDAT ?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetInstantMilitaryIncrease, COMDAT
; _this$ = ecx

; 1533 : 	return m_iInstantMilitaryIncrease;

	mov	eax, DWORD PTR [ecx+652]

; 1534 : }

	ret	0
?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetInstantMilitaryIncrease
_TEXT	ENDS
PUBLIC	?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorksTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatWorksTourismModifier, COMDAT
; _this$ = ecx

; 1539 : 	return m_iGreatWorksTourismModifier;

	mov	eax, DWORD PTR [ecx+656]

; 1540 : }

	ret	0
?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatWorksTourismModifier
_TEXT	ENDS
PUBLIC	?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
; Function compile flags: /Ogtpy
;	COMDAT ?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice, COMDAT
; _this$ = ecx

; 1545 : 	return m_iXBuiltTriggersIdeologyChoice;

	mov	eax, DWORD PTR [ecx+660]

; 1546 : }

	ret	0
?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
_TEXT	ENDS
PUBLIC	?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetExtraLeagueVotes
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetExtraLeagueVotes, COMDAT
; _this$ = ecx

; 1551 : 	return m_iExtraLeagueVotes;

	mov	eax, DWORD PTR [ecx+704]

; 1552 : }

	ret	0
?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetExtraLeagueVotes
_TEXT	ENDS
PUBLIC	?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPreferredDisplayPosition
; Function compile flags: /Ogtpy
;	COMDAT ?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetPreferredDisplayPosition, COMDAT
; _this$ = ecx

; 1557 : 	return m_iPreferredDisplayPosition;

	mov	eax, DWORD PTR [ecx+708]

; 1558 : }

	ret	0
?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetPreferredDisplayPosition
_TEXT	ENDS
PUBLIC	?GetPortraitIndex@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPortraitIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetPortraitIndex@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPortraitIndex@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetPortraitIndex, COMDAT
; _this$ = ecx

; 1563 : 	return m_iPortraitIndex;

	mov	eax, DWORD PTR [ecx+712]

; 1564 : }

	ret	0
?GetPortraitIndex@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetPortraitIndex
_TEXT	ENDS
PUBLIC	?IsTeamShare@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsTeamShare
; Function compile flags: /Ogtpy
;	COMDAT ?IsTeamShare@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTeamShare@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsTeamShare, COMDAT
; _this$ = ecx

; 1569 : 	return m_bTeamShare;

	mov	al, BYTE PTR [ecx+716]

; 1570 : }

	ret	0
?IsTeamShare@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsTeamShare
_TEXT	ENDS
PUBLIC	?IsWater@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsWater@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsWater, COMDAT
; _this$ = ecx

; 1575 : 	return m_bWater;

	mov	al, BYTE PTR [ecx+717]

; 1576 : }

	ret	0
?IsWater@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsWater
_TEXT	ENDS
PUBLIC	?IsRiver@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsRiver
; Function compile flags: /Ogtpy
;	COMDAT ?IsRiver@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRiver@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsRiver, COMDAT
; _this$ = ecx

; 1581 : 	return m_bRiver;

	mov	al, BYTE PTR [ecx+718]

; 1582 : }

	ret	0
?IsRiver@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsRiver
_TEXT	ENDS
PUBLIC	?IsFreshWater@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsFreshWater@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFreshWater@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsFreshWater, COMDAT
; _this$ = ecx

; 1587 : 	return m_bFreshWater;

	mov	al, BYTE PTR [ecx+719]

; 1588 : }

	ret	0
?IsFreshWater@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsFreshWater
_TEXT	ENDS
PUBLIC	?IsMountain@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsMountain
; Function compile flags: /Ogtpy
;	COMDAT ?IsMountain@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMountain@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsMountain, COMDAT
; _this$ = ecx

; 1593 : 	return m_bMountain;

	mov	al, BYTE PTR [ecx+720]

; 1594 : }

	ret	0
?IsMountain@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsMountain
_TEXT	ENDS
PUBLIC	?IsHill@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsHill
; Function compile flags: /Ogtpy
;	COMDAT ?IsHill@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHill@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsHill, COMDAT
; _this$ = ecx

; 1599 : 	return m_bHill;

	mov	al, BYTE PTR [ecx+721]

; 1600 : }

	ret	0
?IsHill@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsHill
_TEXT	ENDS
PUBLIC	?IsFlat@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsFlat
; Function compile flags: /Ogtpy
;	COMDAT ?IsFlat@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFlat@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsFlat, COMDAT
; _this$ = ecx

; 1605 : 	return m_bFlat;

	mov	al, BYTE PTR [ecx+722]

; 1606 : }

	ret	0
?IsFlat@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsFlat
_TEXT	ENDS
PUBLIC	?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsFoundsReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsFoundsReligion, COMDAT
; _this$ = ecx

; 1611 : 	return m_bFoundsReligion;

	mov	al, BYTE PTR [ecx+723]

; 1612 : }

	ret	0
?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsFoundsReligion
_TEXT	ENDS
PUBLIC	?IsReligious@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsReligious
; Function compile flags: /Ogtpy
;	COMDAT ?IsReligious@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsReligious@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsReligious, COMDAT
; _this$ = ecx

; 1617 : 	return m_bIsReligious;

	mov	al, BYTE PTR [ecx+724]

; 1618 : }

	ret	0
?IsReligious@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsReligious
_TEXT	ENDS
PUBLIC	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsBorderObstacle
; Function compile flags: /Ogtpy
;	COMDAT ?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsBorderObstacle, COMDAT
; _this$ = ecx

; 1623 : 	return m_bBorderObstacle;

	mov	al, BYTE PTR [ecx+725]

; 1624 : }

	ret	0
?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsBorderObstacle
_TEXT	ENDS
PUBLIC	?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsPlayerBorderObstacle
; Function compile flags: /Ogtpy
;	COMDAT ?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsPlayerBorderObstacle, COMDAT
; _this$ = ecx

; 1629 : 	return m_bPlayerBorderObstacle;

	mov	al, BYTE PTR [ecx+726]

; 1630 : }

	ret	0
?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsPlayerBorderObstacle
_TEXT	ENDS
PUBLIC	?IsCityWall@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsCityWall
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityWall@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCityWall@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsCityWall, COMDAT
; _this$ = ecx

; 1635 : 	return m_bCityWall;

	mov	al, BYTE PTR [ecx+736]

; 1636 : }

	ret	0
?IsCityWall@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsCityWall
_TEXT	ENDS
PUBLIC	?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsUnlockedByBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsUnlockedByBelief, COMDAT
; _this$ = ecx

; 1641 : 	return m_bUnlockedByBelief;

	mov	al, BYTE PTR [ecx+737]

; 1642 : }

	ret	0
?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsUnlockedByBelief
_TEXT	ENDS
PUBLIC	?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsUnlockedByLeague
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsUnlockedByLeague, COMDAT
; _this$ = ecx

; 1647 : 	return m_bUnlockedByLeague;

	mov	al, BYTE PTR [ecx+738]

; 1648 : }

	ret	0
?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsUnlockedByLeague
_TEXT	ENDS
PUBLIC	?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsRequiresHolyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsRequiresHolyCity, COMDAT
; _this$ = ecx

; 1653 : 	return m_bRequiresHolyCity;

	mov	al, BYTE PTR [ecx+739]

; 1654 : }

	ret	0
?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsRequiresHolyCity
_TEXT	ENDS
PUBLIC	?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::AffectSpiesNow
; Function compile flags: /Ogtpy
;	COMDAT ?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::AffectSpiesNow, COMDAT
; _this$ = ecx

; 1659 : 	return m_bAffectSpiesNow;

	mov	al, BYTE PTR [ecx+740]

; 1660 : }

	ret	0
?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::AffectSpiesNow
_TEXT	ENDS
PUBLIC	?IsEspionage@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsEspionage
; Function compile flags: /Ogtpy
;	COMDAT ?IsEspionage@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEspionage@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsEspionage, COMDAT
; _this$ = ecx

; 1665 : 	return m_bEspionage;

	mov	al, BYTE PTR [ecx+741]

; 1666 : }

	ret	0
?IsEspionage@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsEspionage
_TEXT	ENDS
PUBLIC	?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsMalianTreasury
; Function compile flags: /Ogtpy
;	COMDAT ?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsMalianTreasury, COMDAT
; _this$ = ecx

; 1672 : 	return m_bMalianTreasury;

	mov	al, BYTE PTR [ecx+742]

; 1673 : }

	ret	0
?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsMalianTreasury
_TEXT	ENDS
PUBLIC	?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::AllowsFoodTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::AllowsFoodTradeRoutes, COMDAT
; _this$ = ecx

; 1678 : 	return m_bAllowsFoodTradeRoutes;

	mov	al, BYTE PTR [ecx+743]

; 1679 : }

	ret	0
?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::AllowsFoodTradeRoutes
_TEXT	ENDS
PUBLIC	?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsProductionTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ PROC ; CvBuildingEntry::AllowsProductionTradeRoutes, COMDAT
; _this$ = ecx

; 1683 : 	return m_bAllowsProductionTradeRoutes;

	mov	al, BYTE PTR [ecx+744]

; 1684 : }

	ret	0
?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ ENDP ; CvBuildingEntry::AllowsProductionTradeRoutes
_TEXT	ENDS
PUBLIC	?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::NullifyInfluenceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::NullifyInfluenceModifier, COMDAT
; _this$ = ecx

; 1688 : 	return m_bNullifyInfluenceModifier;

	mov	al, BYTE PTR [ecx+745]

; 1689 : }

	ret	0
?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::NullifyInfluenceModifier
_TEXT	ENDS
PUBLIC	?IsCapital@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsCapital
; Function compile flags: /Ogtpy
;	COMDAT ?IsCapital@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCapital@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsCapital, COMDAT
; _this$ = ecx

; 1694 : 	return m_bCapital;

	mov	al, BYTE PTR [ecx+727]

; 1695 : }

	ret	0
?IsCapital@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsCapital
_TEXT	ENDS
PUBLIC	?IsGoldenAge@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsGoldenAge
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoldenAge@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGoldenAge@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsGoldenAge, COMDAT
; _this$ = ecx

; 1700 : 	return m_bGoldenAge;

	mov	al, BYTE PTR [ecx+728]

; 1701 : }

	ret	0
?IsGoldenAge@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsGoldenAge
_TEXT	ENDS
PUBLIC	?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsGrantsFreeCulturalGreatPersonWithTrait
; Function compile flags: /Ogtpy
;	COMDAT ?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ PROC ; CvBuildingEntry::IsGrantsFreeCulturalGreatPersonWithTrait, COMDAT
; _this$ = ecx

; 1707 : 	return m_bGrantsFreeCulturalGreatPersonWithTrait;

	mov	al, BYTE PTR [ecx+729]

; 1708 : }

	ret	0
?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ ENDP ; CvBuildingEntry::IsGrantsFreeCulturalGreatPersonWithTrait
_TEXT	ENDS
PUBLIC	?IsMapCentering@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsMapCentering
; Function compile flags: /Ogtpy
;	COMDAT ?IsMapCentering@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMapCentering@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsMapCentering, COMDAT
; _this$ = ecx

; 1714 : 	return m_bMapCentering;

	mov	al, BYTE PTR [ecx+730]

; 1715 : }

	ret	0
?IsMapCentering@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsMapCentering
_TEXT	ENDS
PUBLIC	?IsNeverCapture@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsNeverCapture
; Function compile flags: /Ogtpy
;	COMDAT ?IsNeverCapture@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNeverCapture@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsNeverCapture, COMDAT
; _this$ = ecx

; 1720 : 	return m_bNeverCapture;

	mov	al, BYTE PTR [ecx+731]

; 1721 : }

	ret	0
?IsNeverCapture@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsNeverCapture
_TEXT	ENDS
PUBLIC	?IsNukeImmune@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsNukeImmune
; Function compile flags: /Ogtpy
;	COMDAT ?IsNukeImmune@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNukeImmune@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsNukeImmune, COMDAT
; _this$ = ecx

; 1726 : 	return m_bNukeImmune;

	mov	al, BYTE PTR [ecx+732]

; 1727 : }

	ret	0
?IsNukeImmune@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsNukeImmune
_TEXT	ENDS
PUBLIC	?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsExtraLuxuries
; Function compile flags: /Ogtpy
;	COMDAT ?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsExtraLuxuries, COMDAT
; _this$ = ecx

; 1732 : 	return m_bExtraLuxuries;

	mov	al, BYTE PTR [ecx+733]

; 1733 : }

	ret	0
?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsExtraLuxuries
_TEXT	ENDS
PUBLIC	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsDiplomaticVoting
; Function compile flags: /Ogtpy
;	COMDAT ?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsDiplomaticVoting, COMDAT
; _this$ = ecx

; 1738 : 	return m_bDiplomaticVoting;

	mov	al, BYTE PTR [ecx+734]

; 1739 : }

	ret	0
?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsDiplomaticVoting
_TEXT	ENDS
PUBLIC	?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::AllowsWaterRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::AllowsWaterRoutes, COMDAT
; _this$ = ecx

; 1744 : 	return m_bAllowsWaterRoutes;

	mov	al, BYTE PTR [ecx+735]

; 1745 : }

	ret	0
?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::AllowsWaterRoutes
_TEXT	ENDS
PUBLIC	?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ	; CvBuildingEntry::GetArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ PROC		; CvBuildingEntry::GetArtDefineTag, COMDAT
; _this$ = ecx

; 1783 : 	return m_strArtDefineTag.c_str();

	add	ecx, 752				; 000002f0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ ENDP		; CvBuildingEntry::GetArtDefineTag
_TEXT	ENDS
PUBLIC	?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ ; CvBuildingEntry::GetArtInfoCulturalVariation
; Function compile flags: /Ogtpy
;	COMDAT ?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ
_TEXT	SEGMENT
?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ PROC ; CvBuildingEntry::GetArtInfoCulturalVariation, COMDAT
; _this$ = ecx

; 1795 : 	return m_bArtInfoCulturalVariation;

	mov	al, BYTE PTR [ecx+746]

; 1796 : }

	ret	0
?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ ENDP ; CvBuildingEntry::GetArtInfoCulturalVariation
_TEXT	ENDS
PUBLIC	?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ ; CvBuildingEntry::GetArtInfoEraVariation
; Function compile flags: /Ogtpy
;	COMDAT ?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ
_TEXT	SEGMENT
?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ PROC	; CvBuildingEntry::GetArtInfoEraVariation, COMDAT
; _this$ = ecx

; 1801 : 	return m_bArtInfoEraVariation;

	mov	al, BYTE PTR [ecx+747]

; 1802 : }

	ret	0
?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ ENDP	; CvBuildingEntry::GetArtInfoEraVariation
_TEXT	ENDS
PUBLIC	?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ ; CvBuildingEntry::GetArtInfoRandomVariation
; Function compile flags: /Ogtpy
;	COMDAT ?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ
_TEXT	SEGMENT
?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ PROC ; CvBuildingEntry::GetArtInfoRandomVariation, COMDAT
; _this$ = ecx

; 1807 : 	return m_bArtInfoRandomVariation;

	mov	al, BYTE PTR [ecx+748]

; 1808 : }

	ret	0
?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ ENDP ; CvBuildingEntry::GetArtInfoRandomVariation
_TEXT	ENDS
PUBLIC	?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ	; CvBuildingEntry::GetWonderSplashAudio
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ PROC	; CvBuildingEntry::GetWonderSplashAudio, COMDAT
; _this$ = ecx

; 1812 : 	return m_strWonderSplashAudio.c_str();

	add	ecx, 780				; 0000030cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ ENDP	; CvBuildingEntry::GetWonderSplashAudio
_TEXT	ENDS
PUBLIC	?GetYieldChange@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChange@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 1825 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1826 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1827 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+880]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1828 : }

	ret	4
$LN3@GetYieldCh:

; 1825 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1826 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1827 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	or	eax, -1

; 1828 : }

	ret	4
?GetYieldChange@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ	; CvBuildingEntry::GetYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC	; CvBuildingEntry::GetYieldChangeArray, COMDAT
; _this$ = ecx

; 1833 : 	return m_piYieldChange;

	mov	eax, DWORD PTR [ecx+880]

; 1834 : }

	ret	0
?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP	; CvBuildingEntry::GetYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetYieldChangePerPop
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetYieldChangePerPop, COMDAT
; _this$ = ecx

; 1839 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1840 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1841 : 	return m_piYieldChangePerPop ? m_piYieldChangePerPop[i] : -1;

	mov	eax, DWORD PTR [ecx+884]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1842 : }

	ret	4
$LN3@GetYieldCh@2:

; 1839 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1840 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1841 : 	return m_piYieldChangePerPop ? m_piYieldChangePerPop[i] : -1;

	or	eax, -1

; 1842 : }

	ret	4
?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetYieldChangePerPop
_TEXT	ENDS
PUBLIC	?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetYieldChangePerPopArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetYieldChangePerPopArray, COMDAT
; _this$ = ecx

; 1847 : 	return m_piYieldChangePerPop;

	mov	eax, DWORD PTR [ecx+884]

; 1848 : }

	ret	0
?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetYieldChangePerPopArray
_TEXT	ENDS
PUBLIC	?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChangePerReligion
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetYieldChangePerReligion, COMDAT
; _this$ = ecx

; 1853 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1854 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1855 : 	return m_piYieldChangePerReligion ? m_piYieldChangePerReligion[i] : -1;

	mov	eax, DWORD PTR [ecx+888]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1856 : }

	ret	4
$LN3@GetYieldCh@3:

; 1853 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1854 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1855 : 	return m_piYieldChangePerReligion ? m_piYieldChangePerReligion[i] : -1;

	or	eax, -1

; 1856 : }

	ret	4
?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetYieldChangePerReligion
_TEXT	ENDS
PUBLIC	?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetYieldChangePerReligionArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetYieldChangePerReligionArray, COMDAT
; _this$ = ecx

; 1861 : 	return m_piYieldChangePerReligion;

	mov	eax, DWORD PTR [ecx+888]

; 1862 : }

	ret	0
?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetYieldChangePerReligionArray
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldModifier@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetYieldModifier, COMDAT
; _this$ = ecx

; 1867 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1868 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1869 : 	return m_piYieldModifier ? m_piYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+892]
	test	eax, eax
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1870 : }

	ret	4
$LN3@GetYieldMo:

; 1867 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1868 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1869 : 	return m_piYieldModifier ? m_piYieldModifier[i] : -1;

	or	eax, -1

; 1870 : }

	ret	4
?GetYieldModifier@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetYieldModifierArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ PROC	; CvBuildingEntry::GetYieldModifierArray, COMDAT
; _this$ = ecx

; 1875 : 	return m_piYieldModifier;

	mov	eax, DWORD PTR [ecx+892]

; 1876 : }

	ret	0
?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ENDP	; CvBuildingEntry::GetYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetAreaYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetAreaYieldModifier, COMDAT
; _this$ = ecx

; 1881 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1882 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1883 : 	return m_piAreaYieldModifier ? m_piAreaYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+896]
	test	eax, eax
	je	SHORT $LN3@GetAreaYie
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1884 : }

	ret	4
$LN3@GetAreaYie:

; 1881 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1882 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1883 : 	return m_piAreaYieldModifier ? m_piAreaYieldModifier[i] : -1;

	or	eax, -1

; 1884 : }

	ret	4
?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetAreaYieldModifier
_TEXT	ENDS
PUBLIC	?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetAreaYieldModifierArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetAreaYieldModifierArray, COMDAT
; _this$ = ecx

; 1889 : 	return m_piAreaYieldModifier;

	mov	eax, DWORD PTR [ecx+896]

; 1890 : }

	ret	0
?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetAreaYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetGlobalYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetGlobalYieldModifier, COMDAT
; _this$ = ecx

; 1895 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1896 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1897 : 	return m_piGlobalYieldModifier ? m_piGlobalYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+900]
	test	eax, eax
	je	SHORT $LN3@GetGlobalY
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1898 : }

	ret	4
$LN3@GetGlobalY:

; 1895 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1896 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1897 : 	return m_piGlobalYieldModifier ? m_piGlobalYieldModifier[i] : -1;

	or	eax, -1

; 1898 : }

	ret	4
?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetGlobalYieldModifier
_TEXT	ENDS
PUBLIC	?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetGlobalYieldModifierArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetGlobalYieldModifierArray, COMDAT
; _this$ = ecx

; 1903 : 	return m_piGlobalYieldModifier;

	mov	eax, DWORD PTR [ecx+900]

; 1904 : }

	ret	0
?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetGlobalYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetTechEnhancedYieldChange, COMDAT
; _this$ = ecx

; 1909 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1910 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1911 : 	return m_piTechEnhancedYieldChange ? m_piTechEnhancedYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+904]
	test	eax, eax
	je	SHORT $LN3@GetTechEnh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1912 : }

	ret	4
$LN3@GetTechEnh:

; 1909 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1910 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1911 : 	return m_piTechEnhancedYieldChange ? m_piTechEnhancedYieldChange[i] : -1;

	or	eax, -1

; 1912 : }

	ret	4
?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetTechEnhancedYieldChange
_TEXT	ENDS
PUBLIC	?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetTechEnhancedYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetTechEnhancedYieldChangeArray, COMDAT
; _this$ = ecx

; 1917 : 	return m_piTechEnhancedYieldChange;

	mov	eax, DWORD PTR [ecx+904]

; 1918 : }

	ret	0
?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetTechEnhancedYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetSeaPlotYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetSeaPlotYieldChange, COMDAT
; _this$ = ecx

; 1923 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1924 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1925 : 	return m_piSeaPlotYieldChange ? m_piSeaPlotYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+864]
	test	eax, eax
	je	SHORT $LN3@GetSeaPlot
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1926 : }

	ret	4
$LN3@GetSeaPlot:

; 1923 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1924 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1925 : 	return m_piSeaPlotYieldChange ? m_piSeaPlotYieldChange[i] : -1;

	or	eax, -1

; 1926 : }

	ret	4
?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetSeaPlotYieldChange
_TEXT	ENDS
PUBLIC	?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetSeaPlotYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetSeaPlotYieldChangeArray, COMDAT
; _this$ = ecx

; 1931 : 	return m_piSeaPlotYieldChange;

	mov	eax, DWORD PTR [ecx+864]

; 1932 : }

	ret	0
?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetSeaPlotYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetRiverPlotYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetRiverPlotYieldChange, COMDAT
; _this$ = ecx

; 1937 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1938 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1939 : 	return m_piRiverPlotYieldChange ? m_piRiverPlotYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+868]
	test	eax, eax
	je	SHORT $LN3@GetRiverPl
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1940 : }

	ret	4
$LN3@GetRiverPl:

; 1937 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1938 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1939 : 	return m_piRiverPlotYieldChange ? m_piRiverPlotYieldChange[i] : -1;

	or	eax, -1

; 1940 : }

	ret	4
?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetRiverPlotYieldChange
_TEXT	ENDS
PUBLIC	?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetRiverPlotYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetRiverPlotYieldChangeArray, COMDAT
; _this$ = ecx

; 1945 : 	return m_piRiverPlotYieldChange;

	mov	eax, DWORD PTR [ecx+868]

; 1946 : }

	ret	0
?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetRiverPlotYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetLakePlotYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLakePlotYieldChange, COMDAT
; _this$ = ecx

; 1951 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1952 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1953 : 	return m_piLakePlotYieldChange ? m_piLakePlotYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+872]
	test	eax, eax
	je	SHORT $LN3@GetLakePlo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1954 : }

	ret	4
$LN3@GetLakePlo:

; 1951 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1952 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1953 : 	return m_piLakePlotYieldChange ? m_piLakePlotYieldChange[i] : -1;

	or	eax, -1

; 1954 : }

	ret	4
?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLakePlotYieldChange
_TEXT	ENDS
PUBLIC	?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetLakePlotYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetLakePlotYieldChangeArray, COMDAT
; _this$ = ecx

; 1959 : 	return m_piLakePlotYieldChange;

	mov	eax, DWORD PTR [ecx+872]

; 1960 : }

	ret	0
?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetLakePlotYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetSeaResourceYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetSeaResourceYieldChange, COMDAT
; _this$ = ecx

; 1965 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1966 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1967 : 	return m_piSeaResourceYieldChange ? m_piSeaResourceYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+876]
	test	eax, eax
	je	SHORT $LN3@GetSeaReso
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1968 : }

	ret	4
$LN3@GetSeaReso:

; 1965 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1966 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1967 : 	return m_piSeaResourceYieldChange ? m_piSeaResourceYieldChange[i] : -1;

	or	eax, -1

; 1968 : }

	ret	4
?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetSeaResourceYieldChange
_TEXT	ENDS
PUBLIC	?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetSeaResourceYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetSeaResourceYieldChangeArray, COMDAT
; _this$ = ecx

; 1973 : 	return m_piSeaResourceYieldChange;

	mov	eax, DWORD PTR [ecx+876]

; 1974 : }

	ret	0
?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetSeaResourceYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetUnitCombatFreeExperience
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetUnitCombatFreeExperience, COMDAT
; _this$ = ecx

; 1979 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1980 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1981 : 	return m_piUnitCombatFreeExperience ? m_piUnitCombatFreeExperience[i] : -1;

	mov	eax, DWORD PTR [ecx+908]
	test	eax, eax
	je	SHORT $LN3@GetUnitCom
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1982 : }

	ret	4
$LN3@GetUnitCom:

; 1979 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1980 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1981 : 	return m_piUnitCombatFreeExperience ? m_piUnitCombatFreeExperience[i] : -1;

	or	eax, -1

; 1982 : }

	ret	4
?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetUnitCombatFreeExperience
_TEXT	ENDS
PUBLIC	?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetUnitCombatProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetUnitCombatProductionModifier, COMDAT
; _this$ = ecx

; 1987 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1988 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1989 : 	return m_piUnitCombatProductionModifiers ? m_piUnitCombatProductionModifiers[i] : -1;

	mov	eax, DWORD PTR [ecx+912]
	test	eax, eax
	je	SHORT $LN3@GetUnitCom@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1990 : }

	ret	4
$LN3@GetUnitCom@2:

; 1987 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1988 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1989 : 	return m_piUnitCombatProductionModifiers ? m_piUnitCombatProductionModifiers[i] : -1;

	or	eax, -1

; 1990 : }

	ret	4
?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetUnitCombatProductionModifier
_TEXT	ENDS
PUBLIC	?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainFreeExperience
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetDomainFreeExperience, COMDAT
; _this$ = ecx

; 1995 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 1996 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1997 : 	return m_piDomainFreeExperience ? m_piDomainFreeExperience[i] : -1;

	mov	eax, DWORD PTR [ecx+916]
	test	eax, eax
	je	SHORT $LN3@GetDomainF
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1998 : }

	ret	4
$LN3@GetDomainF:

; 1995 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 1996 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1997 : 	return m_piDomainFreeExperience ? m_piDomainFreeExperience[i] : -1;

	or	eax, -1

; 1998 : }

	ret	4
?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetDomainFreeExperience
_TEXT	ENDS
PUBLIC	?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainFreeExperiencePerGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetDomainFreeExperiencePerGreatWork, COMDAT
; _this$ = ecx

; 2003 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 2004 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2005 : 	return m_piDomainFreeExperiencePerGreatWork ? m_piDomainFreeExperiencePerGreatWork[i] : -1;

	mov	eax, DWORD PTR [ecx+920]
	test	eax, eax
	je	SHORT $LN3@GetDomainF@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2006 : }

	ret	4
$LN3@GetDomainF@2:

; 2003 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 2004 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2005 : 	return m_piDomainFreeExperiencePerGreatWork ? m_piDomainFreeExperiencePerGreatWork[i] : -1;

	or	eax, -1

; 2006 : }

	ret	4
?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetDomainFreeExperiencePerGreatWork
_TEXT	ENDS
PUBLIC	?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetDomainProductionModifier, COMDAT
; _this$ = ecx

; 2011 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 2012 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2013 : 	return m_piDomainProductionModifier ? m_piDomainProductionModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+924]
	test	eax, eax
	je	SHORT $LN3@GetDomainP
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2014 : }

	ret	4
$LN3@GetDomainP:

; 2011 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 2012 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2013 : 	return m_piDomainProductionModifier ? m_piDomainProductionModifier[i] : -1;

	or	eax, -1

; 2014 : }

	ret	4
?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetDomainProductionModifier
_TEXT	ENDS
PUBLIC	?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetLockedBuildingClasses
; Function compile flags: /Ogtpy
;	COMDAT ?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLockedBuildingClasses, COMDAT
; _this$ = ecx

; 2019 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2020 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2021 : 	return m_piLockedBuildingClasses ? m_piLockedBuildingClasses[i] : -1;

	mov	eax, DWORD PTR [ecx+836]
	test	eax, eax
	je	SHORT $LN3@GetLockedB
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2022 : }

	ret	4
$LN3@GetLockedB:

; 2019 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2020 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2021 : 	return m_piLockedBuildingClasses ? m_piLockedBuildingClasses[i] : -1;

	or	eax, -1

; 2022 : }

	ret	4
?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLockedBuildingClasses
_TEXT	ENDS
PUBLIC	?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetPrereqAndTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetPrereqAndTechs, COMDAT
; _this$ = ecx

; 2027 : 	CvAssertMsg(i < GC.getNUM_BUILDING_AND_TECH_PREREQS(), "Index out of bounds");
; 2028 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2029 : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	mov	eax, DWORD PTR [ecx+840]
	test	eax, eax
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2030 : }

	ret	4
$LN3@GetPrereqA:

; 2027 : 	CvAssertMsg(i < GC.getNUM_BUILDING_AND_TECH_PREREQS(), "Index out of bounds");
; 2028 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2029 : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	or	eax, -1

; 2030 : }

	ret	4
?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetPrereqAndTechs
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceQuantityRequirement
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 2035 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2036 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2037 : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	mov	eax, DWORD PTR [ecx+844]
	test	eax, eax
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2038 : }

	ret	4
$LN3@GetResourc:

; 2035 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2036 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2037 : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	or	eax, -1

; 2038 : }

	ret	4
?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetResourceQuantity
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetResourceQuantity, COMDAT
; _this$ = ecx

; 2043 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2044 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2045 : 	return m_piResourceQuantity ? m_piResourceQuantity[i] : -1;

	mov	eax, DWORD PTR [ecx+848]
	test	eax, eax
	je	SHORT $LN3@GetResourc@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2046 : }

	ret	4
$LN3@GetResourc@2:

; 2043 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2044 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2045 : 	return m_piResourceQuantity ? m_piResourceQuantity[i] : -1;

	or	eax, -1

; 2046 : }

	ret	4
?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetResourceQuantity
_TEXT	ENDS
PUBLIC	?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceCultureChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetResourceCultureChange, COMDAT
; _this$ = ecx

; 2051 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2052 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2053 : 	return m_piResourceCultureChanges ? m_piResourceCultureChanges[i] : -1;

	mov	eax, DWORD PTR [ecx+852]
	test	eax, eax
	je	SHORT $LN3@GetResourc@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2054 : }

	ret	4
$LN3@GetResourc@3:

; 2051 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2052 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2053 : 	return m_piResourceCultureChanges ? m_piResourceCultureChanges[i] : -1;

	or	eax, -1

; 2054 : }

	ret	4
?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetResourceCultureChange
_TEXT	ENDS
PUBLIC	?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceFaithChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetResourceFaithChange, COMDAT
; _this$ = ecx

; 2059 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2060 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2061 : 	return m_piResourceFaithChanges ? m_piResourceFaithChanges[i] : -1;

	mov	eax, DWORD PTR [ecx+856]
	test	eax, eax
	je	SHORT $LN3@GetResourc@4
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2062 : }

	ret	4
$LN3@GetResourc@4:

; 2059 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2060 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2061 : 	return m_piResourceFaithChanges ? m_piResourceFaithChanges[i] : -1;

	or	eax, -1

; 2062 : }

	ret	4
?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetResourceFaithChange
_TEXT	ENDS
PUBLIC	?GetProductionTraits@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetProductionTraits
; Function compile flags: /Ogtpy
;	COMDAT ?GetProductionTraits@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetProductionTraits@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetProductionTraits, COMDAT
; _this$ = ecx

; 2067 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 2068 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2069 : 	return m_piProductionTraits ? m_piProductionTraits[i] : 0;

	mov	eax, DWORD PTR [ecx+860]
	test	eax, eax
	je	SHORT $LN3@GetProduct
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2070 : }

	ret	4
$LN3@GetProduct:

; 2067 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 2068 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2069 : 	return m_piProductionTraits ? m_piProductionTraits[i] : 0;

	xor	eax, eax

; 2070 : }

	ret	4
?GetProductionTraits@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetProductionTraits
_TEXT	ENDS
PUBLIC	?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetPrereqNumOfBuildingClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetPrereqNumOfBuildingClass, COMDAT
; _this$ = ecx

; 2075 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2076 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2077 : 	return m_piPrereqNumOfBuildingClass ? m_piPrereqNumOfBuildingClass[i] : -1;

	mov	eax, DWORD PTR [ecx+928]
	test	eax, eax
	je	SHORT $LN3@GetPrereqN
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2078 : }

	ret	4
$LN3@GetPrereqN:

; 2075 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2076 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2077 : 	return m_piPrereqNumOfBuildingClass ? m_piPrereqNumOfBuildingClass[i] : -1;

	or	eax, -1

; 2078 : }

	ret	4
?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetPrereqNumOfBuildingClass
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 2083 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 2084 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2085 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR [ecx+932]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2086 : }

	ret	4
$LN3@GetFlavorV:

; 2083 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 2084 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2085 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	xor	eax, eax

; 2086 : }

	ret	4
?GetFlavorValue@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetLocalResourceAnd
; Function compile flags: /Ogtpy
;	COMDAT ?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLocalResourceAnd, COMDAT
; _this$ = ecx

; 2091 : 	CvAssertMsg(i < GC.getNUM_BUILDING_RESOURCE_PREREQS(), "Index out of bounds");
; 2092 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2093 : 	return m_piLocalResourceAnds ? m_piLocalResourceAnds[i] : -1;

	mov	eax, DWORD PTR [ecx+936]
	test	eax, eax
	je	SHORT $LN3@GetLocalRe
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2094 : }

	ret	4
$LN3@GetLocalRe:

; 2091 : 	CvAssertMsg(i < GC.getNUM_BUILDING_RESOURCE_PREREQS(), "Index out of bounds");
; 2092 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2093 : 	return m_piLocalResourceAnds ? m_piLocalResourceAnds[i] : -1;

	or	eax, -1

; 2094 : }

	ret	4
?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLocalResourceAnd
_TEXT	ENDS
PUBLIC	?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetLocalResourceOr
; Function compile flags: /Ogtpy
;	COMDAT ?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLocalResourceOr, COMDAT
; _this$ = ecx

; 2099 : 	CvAssertMsg(i < GC.getNUM_BUILDING_RESOURCE_PREREQS(), "Index out of bounds");
; 2100 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2101 : 	return m_piLocalResourceOrs ? m_piLocalResourceOrs[i] : -1;

	mov	eax, DWORD PTR [ecx+940]
	test	eax, eax
	je	SHORT $LN3@GetLocalRe@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2102 : }

	ret	4
$LN3@GetLocalRe@2:

; 2099 : 	CvAssertMsg(i < GC.getNUM_BUILDING_RESOURCE_PREREQS(), "Index out of bounds");
; 2100 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2101 : 	return m_piLocalResourceOrs ? m_piLocalResourceOrs[i] : -1;

	or	eax, -1

; 2102 : }

	ret	4
?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLocalResourceOr
_TEXT	ENDS
PUBLIC	?GetHurryModifier@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetHurryModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetHurryModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetHurryModifier@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetHurryModifier, COMDAT
; _this$ = ecx

; 2107 : 	CvAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
; 2108 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2109 : 	return m_paiHurryModifier ? m_paiHurryModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+944]
	test	eax, eax
	je	SHORT $LN3@GetHurryMo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2110 : }

	ret	4
$LN3@GetHurryMo:

; 2107 : 	CvAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
; 2108 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2109 : 	return m_paiHurryModifier ? m_paiHurryModifier[i] : -1;

	or	eax, -1

; 2110 : }

	ret	4
?GetHurryModifier@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetHurryModifier
_TEXT	ENDS
PUBLIC	?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z ; CvBuildingEntry::IsBuildingClassNeededInCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z PROC ; CvBuildingEntry::IsBuildingClassNeededInCity, COMDAT
; _this$ = ecx

; 2115 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2116 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2117 : 	return m_pbBuildingClassNeededInCity ? m_pbBuildingClassNeededInCity[i] : false;

	mov	eax, DWORD PTR [ecx+948]
	test	eax, eax
	je	SHORT $LN3@IsBuilding
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 2118 : }

	ret	4
$LN3@IsBuilding:

; 2115 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2116 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2117 : 	return m_pbBuildingClassNeededInCity ? m_pbBuildingClassNeededInCity[i] : false;

	xor	al, al

; 2118 : }

	ret	4
?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z ENDP ; CvBuildingEntry::IsBuildingClassNeededInCity
_TEXT	ENDS
PUBLIC	?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetNumFreeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetNumFreeUnits, COMDAT
; _this$ = ecx

; 2123 : 	CvAssertMsg(i < GC.getNumUnitInfos(), "Index out of bounds");
; 2124 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2125 : 	return m_piNumFreeUnits ? m_piNumFreeUnits[i] : -1;

	mov	eax, DWORD PTR [ecx+952]
	test	eax, eax
	je	SHORT $LN3@GetNumFree
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2126 : }

	ret	4
$LN3@GetNumFree:

; 2123 : 	CvAssertMsg(i < GC.getNumUnitInfos(), "Index out of bounds");
; 2124 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2125 : 	return m_piNumFreeUnits ? m_piNumFreeUnits[i] : -1;

	or	eax, -1

; 2126 : }

	ret	4
?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetNumFreeUnits
_TEXT	ENDS
PUBLIC	?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetResourceYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z PROC	; CvBuildingEntry::GetResourceYieldChange, COMDAT
; _this$ = ecx

; 2131 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2132 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2133 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2134 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2135 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2136 : 	return m_ppaiResourceYieldChange.first ? (m_ppaiResourceYieldChange.first)[i][j] : -1;
; 2137 : #else
; 2138 : 	return m_ppaiResourceYieldChange ? m_ppaiResourceYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+956]
	test	eax, eax
	je	SHORT $LN3@GetResourc@5
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2139 : #endif
; 2140 : }

	ret	8
$LN3@GetResourc@5:

; 2131 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2132 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2133 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2134 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2135 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2136 : 	return m_ppaiResourceYieldChange.first ? (m_ppaiResourceYieldChange.first)[i][j] : -1;
; 2137 : #else
; 2138 : 	return m_ppaiResourceYieldChange ? m_ppaiResourceYieldChange[i][j] : -1;

	or	eax, -1

; 2139 : #endif
; 2140 : }

	ret	8
?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP	; CvBuildingEntry::GetResourceYieldChange
_TEXT	ENDS
PUBLIC	?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetResourceYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetResourceYieldChangeArray, COMDAT
; _this$ = ecx

; 2145 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2146 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2147 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2148 : 	return m_ppaiResourceYieldChange.first ? m_ppaiResourceYieldChange.first[i] : NULL;
; 2149 : #else
; 2150 : 	return m_ppaiResourceYieldChange[i];

	mov	eax, DWORD PTR [ecx+956]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2151 : #endif
; 2152 : }

	ret	4
?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetResourceYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetFeatureYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z PROC	; CvBuildingEntry::GetFeatureYieldChange, COMDAT
; _this$ = ecx

; 2175 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2176 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2177 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2178 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2179 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2180 : 	return m_ppaiFeatureYieldChange.first ? (m_ppaiFeatureYieldChange.first)[i][j] : -1;
; 2181 : #else
; 2182 : 	return m_ppaiFeatureYieldChange ? m_ppaiFeatureYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+960]
	test	eax, eax
	je	SHORT $LN3@GetFeature
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2183 : #endif
; 2184 : }

	ret	8
$LN3@GetFeature:

; 2175 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2176 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2177 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2178 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2179 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2180 : 	return m_ppaiFeatureYieldChange.first ? (m_ppaiFeatureYieldChange.first)[i][j] : -1;
; 2181 : #else
; 2182 : 	return m_ppaiFeatureYieldChange ? m_ppaiFeatureYieldChange[i][j] : -1;

	or	eax, -1

; 2183 : #endif
; 2184 : }

	ret	8
?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP	; CvBuildingEntry::GetFeatureYieldChange
_TEXT	ENDS
PUBLIC	?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetFeatureYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetFeatureYieldChangeArray, COMDAT
; _this$ = ecx

; 2189 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2190 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2191 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2192 : 	return m_ppaiFeatureYieldChange.first ? m_ppaiFeatureYieldChange.first[i] : NULL;
; 2193 : #else
; 2194 : 	return m_ppaiFeatureYieldChange[i];

	mov	eax, DWORD PTR [ecx+960]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2195 : #endif
; 2196 : }

	ret	4
?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetFeatureYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChange, COMDAT
; _this$ = ecx

; 2200 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2201 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2202 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2203 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2204 : 	return m_ppaiImprovementYieldChange ? m_ppaiImprovementYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+976]
	test	eax, eax
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2205 : }

	ret	8
$LN3@GetImprove:

; 2200 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2201 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2202 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2203 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2204 : 	return m_ppaiImprovementYieldChange ? m_ppaiImprovementYieldChange[i][j] : -1;

	or	eax, -1

; 2205 : }

	ret	8
?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChange
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetImprovementYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChangeArray, COMDAT
; _this$ = ecx

; 2210 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2211 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2212 : 	return m_ppaiImprovementYieldChange[i];

	mov	eax, DWORD PTR [ecx+976]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2213 : }

	ret	4
?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetImprovementYieldChangeGlobal
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChangeGlobal, COMDAT
; _this$ = ecx

; 2217 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2218 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2219 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2220 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2221 : 	return m_ppaiImprovementYieldChangeGlobal ? m_ppaiImprovementYieldChangeGlobal[i][j] : -1;

	mov	eax, DWORD PTR [ecx+980]
	test	eax, eax
	je	SHORT $LN3@GetImprove@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2222 : }

	ret	8
$LN3@GetImprove@2:

; 2217 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2218 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2219 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2220 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2221 : 	return m_ppaiImprovementYieldChangeGlobal ? m_ppaiImprovementYieldChangeGlobal[i][j] : -1;

	or	eax, -1

; 2222 : }

	ret	8
?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChangeGlobal
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetImprovementYieldChangeGlobalArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChangeGlobalArray, COMDAT
; _this$ = ecx

; 2227 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2228 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2229 : 	return m_ppaiImprovementYieldChangeGlobal[i];

	mov	eax, DWORD PTR [ecx+980]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2230 : }

	ret	4
?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChangeGlobalArray
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetSpecialistYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetSpecialistYieldChange, COMDAT
; _this$ = ecx

; 2239 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2240 : #ifndef AUI_WARNING_FIXES
; 2241 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2242 : #endif
; 2243 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2244 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2245 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2246 : 	return m_ppaiSpecialistYieldChange.first ? (m_ppaiSpecialistYieldChange.first)[i][j] : -1;
; 2247 : #else
; 2248 : 	return m_ppaiSpecialistYieldChange ? m_ppaiSpecialistYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+984]
	test	eax, eax
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2249 : #endif
; 2250 : }

	ret	8
$LN3@GetSpecial:

; 2239 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2240 : #ifndef AUI_WARNING_FIXES
; 2241 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2242 : #endif
; 2243 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2244 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2245 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2246 : 	return m_ppaiSpecialistYieldChange.first ? (m_ppaiSpecialistYieldChange.first)[i][j] : -1;
; 2247 : #else
; 2248 : 	return m_ppaiSpecialistYieldChange ? m_ppaiSpecialistYieldChange[i][j] : -1;

	or	eax, -1

; 2249 : #endif
; 2250 : }

	ret	8
?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetSpecialistYieldChange
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetSpecialistYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetSpecialistYieldChangeArray, COMDAT
; _this$ = ecx

; 2255 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2256 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2257 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2258 : 	return m_ppaiSpecialistYieldChange.first ? m_ppaiSpecialistYieldChange.first[i] : NULL;
; 2259 : #else
; 2260 : 	return m_ppaiSpecialistYieldChange[i];

	mov	eax, DWORD PTR [ecx+984]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2261 : #endif
; 2262 : }

	ret	4
?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetSpecialistYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetResourceYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetResourceYieldModifier, COMDAT
; _this$ = ecx

; 2267 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2268 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2269 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2270 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2271 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2272 : 	return m_ppaiResourceYieldModifier.first ? (m_ppaiResourceYieldModifier.first)[i][j] : -1;
; 2273 : #else
; 2274 : 	return m_ppaiResourceYieldModifier ? m_ppaiResourceYieldModifier[i][j] : -1;

	mov	eax, DWORD PTR [ecx+988]
	test	eax, eax
	je	SHORT $LN3@GetResourc@6
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2275 : #endif
; 2276 : }

	ret	8
$LN3@GetResourc@6:

; 2267 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2268 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2269 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2270 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2271 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2272 : 	return m_ppaiResourceYieldModifier.first ? (m_ppaiResourceYieldModifier.first)[i][j] : -1;
; 2273 : #else
; 2274 : 	return m_ppaiResourceYieldModifier ? m_ppaiResourceYieldModifier[i][j] : -1;

	or	eax, -1

; 2275 : #endif
; 2276 : }

	ret	8
?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetResourceYieldModifier
_TEXT	ENDS
PUBLIC	?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetResourceYieldModifierArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetResourceYieldModifierArray, COMDAT
; _this$ = ecx

; 2281 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2282 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2283 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2284 : 	return m_ppaiResourceYieldModifier.first ? m_ppaiResourceYieldModifier.first[i] : NULL;
; 2285 : #else
; 2286 : 	return m_ppaiResourceYieldModifier[i];

	mov	eax, DWORD PTR [ecx+988]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2287 : #endif
; 2288 : }

	ret	4
?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetResourceYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetTerrainYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z PROC	; CvBuildingEntry::GetTerrainYieldChange, COMDAT
; _this$ = ecx

; 2293 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 2294 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2295 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2296 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2297 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2298 : 	return m_ppaiTerrainYieldChange.first ? (m_ppaiTerrainYieldChange.first)[i][j] : -1;
; 2299 : #else
; 2300 : 	return m_ppaiTerrainYieldChange ? m_ppaiTerrainYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+992]
	test	eax, eax
	je	SHORT $LN3@GetTerrain
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2301 : #endif
; 2302 : }

	ret	8
$LN3@GetTerrain:

; 2293 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 2294 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2295 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2296 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2297 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2298 : 	return m_ppaiTerrainYieldChange.first ? (m_ppaiTerrainYieldChange.first)[i][j] : -1;
; 2299 : #else
; 2300 : 	return m_ppaiTerrainYieldChange ? m_ppaiTerrainYieldChange[i][j] : -1;

	or	eax, -1

; 2301 : #endif
; 2302 : }

	ret	8
?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP	; CvBuildingEntry::GetTerrainYieldChange
_TEXT	ENDS
PUBLIC	?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetTerrainYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetTerrainYieldChangeArray, COMDAT
; _this$ = ecx

; 2307 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 2308 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2309 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2310 : 	return m_ppaiTerrainYieldChange.first ? m_ppaiTerrainYieldChange.first[i] : NULL;
; 2311 : #else
; 2312 : 	return m_ppaiTerrainYieldChange[i];

	mov	eax, DWORD PTR [ecx+992]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2313 : #endif
; 2314 : }

	ret	4
?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetTerrainYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetBuildingClassYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetBuildingClassYieldChange, COMDAT
; _this$ = ecx

; 2319 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2320 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2321 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2322 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2323 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2324 : 	return m_ppiBuildingClassYieldChanges.first ? (m_ppiBuildingClassYieldChanges.first)[i][j] : -1;
; 2325 : #else
; 2326 : 	return m_ppiBuildingClassYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+996]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2327 : #endif
; 2328 : }

	ret	8
?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetBuildingClassYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetBuildingClassHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetBuildingClassHappiness, COMDAT
; _this$ = ecx

; 2333 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2334 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2335 : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	mov	eax, DWORD PTR [ecx+1000]
	test	eax, eax
	je	SHORT $LN3@GetBuildin@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2336 : }

	ret	4
$LN3@GetBuildin@2:

; 2333 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2334 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2335 : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	or	eax, -1

; 2336 : }

	ret	4
?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetBuildingClassHappiness
_TEXT	ENDS
PUBLIC	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z PROC ; CvBuildingEntry::GetThemingBonusInfo, COMDAT
; _this$ = ecx

; 2340 : 	CvAssertMsg(i < MAX_THEMING_BONUSES, "Index out of bounds");
; 2341 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2342 : 
; 2343 : 	if (m_paThemingBonusInfo[0].m_iBonus == 0)

	mov	ecx, DWORD PTR [ecx+1004]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN2@GetTheming

; 2344 : 	{
; 2345 : 		return NULL;

	xor	eax, eax

; 2350 : 	}
; 2351 : }

	ret	4
$LN2@GetTheming:

; 2346 : 	}
; 2347 : 	else
; 2348 : 	{
; 2349 : 		return &m_paThemingBonusInfo[i];

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx

; 2350 : 	}
; 2351 : }

	ret	4
?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ENDP ; CvBuildingEntry::GetThemingBonusInfo
_TEXT	ENDS
PUBLIC	?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ; CvBuildingXMLEntries::GetBuildingEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ PROC ; CvBuildingXMLEntries::GetBuildingEntries, COMDAT
; _this$ = ecx

; 2370 : {

	mov	eax, ecx

; 2371 : 	return m_paBuildingEntries;
; 2372 : }

	ret	0
?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ENDP ; CvBuildingXMLEntries::GetBuildingEntries
_TEXT	ENDS
PUBLIC	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ
_TEXT	SEGMENT
?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ PROC ; CvCityBuildings::GetBuildings, COMDAT
; _this$ = ecx

; 2607 : 	return m_pBuildings;

	mov	eax, DWORD PTR [ecx+108]

; 2608 : }

	ret	0
?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ENDP ; CvCityBuildings::GetBuildings
_TEXT	ENDS
PUBLIC	?GetNumBuildings@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetNumBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumBuildings@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetNumBuildings@CvCityBuildings@@QBEHXZ PROC		; CvCityBuildings::GetNumBuildings, COMDAT
; _this$ = ecx

; 2613 : 	return m_iNumBuildings;

	mov	eax, DWORD PTR [ecx]

; 2614 : }

	ret	0
?GetNumBuildings@CvCityBuildings@@QBEHXZ ENDP		; CvCityBuildings::GetNumBuildings
_TEXT	ENDS
PUBLIC	?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z	; CvCityBuildings::ChangeNumBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z PROC	; CvCityBuildings::ChangeNumBuildings, COMDAT
; _this$ = ecx

; 2619 : 	m_iNumBuildings = (m_iNumBuildings + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx], eax

; 2620 : 	CvAssert(GetNumBuildings() >= 0);
; 2621 : 
; 2622 : //	GET_PLAYER(m_pCity->getOwner()).updateNumResourceUsed();
; 2623 : }

	ret	4
?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z ENDP	; CvCityBuildings::ChangeNumBuildings
_TEXT	ENDS
PUBLIC	?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ ; CvCityBuildings::IsSoldBuildingThisTurn
; Function compile flags: /Ogtpy
;	COMDAT ?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ
_TEXT	SEGMENT
?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ PROC	; CvCityBuildings::IsSoldBuildingThisTurn, COMDAT
; _this$ = ecx

; 2765 : 	return m_bSoldBuildingThisTurn;

	mov	al, BYTE PTR [ecx+32]

; 2766 : }

	ret	0
?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ ENDP	; CvCityBuildings::IsSoldBuildingThisTurn
_TEXT	ENDS
PUBLIC	?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z ; CvCityBuildings::SetSoldBuildingThisTurn
; Function compile flags: /Ogtpy
;	COMDAT ?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z PROC	; CvCityBuildings::SetSoldBuildingThisTurn, COMDAT
; _this$ = ecx

; 2771 : 	if(IsSoldBuildingThisTurn() != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [ecx+32], al
	je	SHORT $LN1@SetSoldBui

; 2772 : 		m_bSoldBuildingThisTurn = bValue;

	mov	BYTE PTR [ecx+32], al
$LN1@SetSoldBui:

; 2773 : }

	ret	4
?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z ENDP	; CvCityBuildings::SetSoldBuildingThisTurn
_TEXT	ENDS
PUBLIC	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProduction
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingProduction, COMDAT
; _this$ = ecx

; 2802 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2803 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2804 : 	return m_paiBuildingProduction[eIndex] / 100;

	mov	eax, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 2805 : }

	ret	4
?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingProduction
_TEXT	ENDS
PUBLIC	?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingProductionTimes100, COMDAT
; _this$ = ecx

; 2810 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2811 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2812 : 	return m_paiBuildingProduction[eIndex];

	mov	eax, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2813 : }

	ret	4
?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingProductionTimes100
_TEXT	ENDS
PUBLIC	?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTime
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingProductionTime, COMDAT
; _this$ = ecx

; 2863 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2864 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2865 : 	return m_paiBuildingProductionTime[eIndex];

	mov	eax, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2866 : }

	ret	4
?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingProductionTime
_TEXT	ENDS
PUBLIC	?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTime
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingProductionTime, COMDAT
; _this$ = ecx

; 2871 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2872 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2873 : 	m_paiBuildingProductionTime[eIndex] = iNewValue;

	mov	eax, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 2874 : 	CvAssert(GetBuildingProductionTime(eIndex) >= 0);
; 2875 : }

	ret	8
?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingProductionTime
_TEXT	ENDS
PUBLIC	?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProductionTime
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingProductionTime, COMDAT
; _this$ = ecx

; 2880 : 	SetBuildingProductionTime(eIndex, (GetBuildingProductionTime(eIndex) + iChange));

	mov	eax, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 2881 : }

	ret	8
?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingProductionTime
_TEXT	ENDS
PUBLIC	?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingOriginalOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingOriginalOwner, COMDAT
; _this$ = ecx

; 2886 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2887 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2888 : 	return m_paiBuildingOriginalOwner[eIndex];

	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2889 : }

	ret	4
?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingOriginalOwner
_TEXT	ENDS
PUBLIC	?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalOwner
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingOriginalOwner, COMDAT
; _this$ = ecx

; 2894 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2895 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2896 : 	m_paiBuildingOriginalOwner[eIndex] = iNewValue;

	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 2897 : }

	ret	8
?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingOriginalOwner
_TEXT	ENDS
PUBLIC	?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingOriginalTime
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingOriginalTime, COMDAT
; _this$ = ecx

; 2902 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2903 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2904 : 	return m_paiBuildingOriginalTime[eIndex];

	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2905 : }

	ret	4
?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingOriginalTime
_TEXT	ENDS
PUBLIC	?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalTime
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingOriginalTime, COMDAT
; _this$ = ecx

; 2910 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2911 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2912 : 	m_paiBuildingOriginalTime[eIndex] = iNewValue;

	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 2913 : }

	ret	8
?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingOriginalTime
_TEXT	ENDS
PUBLIC	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumRealBuilding, COMDAT
; _this$ = ecx

; 2918 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2919 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2920 : 	return m_paiNumRealBuilding[eIndex];

	mov	eax, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2921 : }

	ret	4
?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumRealBuilding
_TEXT	ENDS
PUBLIC	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumFreeBuilding, COMDAT
; _this$ = ecx

; 3160 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 3161 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 3162 : 	return m_paiNumFreeBuilding[eIndex];

	mov	eax, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3163 : }

	ret	4
?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumFreeBuilding
_TEXT	ENDS
PUBLIC	?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetLandmarksTourismPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetLandmarksTourismPercent, COMDAT
; _this$ = ecx

; 3682 : 	return m_iLandmarksTourismPercent;

	mov	eax, DWORD PTR [ecx+24]

; 3683 : }

	ret	0
?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetLandmarksTourismPercent
_TEXT	ENDS
PUBLIC	?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeLandmarksTourismPercent
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeLandmarksTourismPercent, COMDAT
; _this$ = ecx

; 3688 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeLand

; 3689 : 	{
; 3690 : 		m_iLandmarksTourismPercent = (m_iLandmarksTourismPercent + iChange);

	add	DWORD PTR [ecx+24], eax
$LN1@ChangeLand:

; 3691 : 		CvAssert(m_iLandmarksTourismPercent >= 0);
; 3692 : 	}
; 3693 : }

	ret	4
?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeLandmarksTourismPercent
_TEXT	ENDS
PUBLIC	?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetGreatWorksTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetGreatWorksTourismModifier, COMDAT
; _this$ = ecx

; 3698 : 	return m_iGreatWorksTourismModifier;

	mov	eax, DWORD PTR [ecx+28]

; 3699 : }

	ret	0
?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetGreatWorksTourismModifier
_TEXT	ENDS
PUBLIC	?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeGreatWorksTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeGreatWorksTourismModifier, COMDAT
; _this$ = ecx

; 3704 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeGrea

; 3705 : 	{
; 3706 : 		m_iGreatWorksTourismModifier = (m_iGreatWorksTourismModifier + iChange);

	add	DWORD PTR [ecx+28], eax
$LN1@ChangeGrea:

; 3707 : 		CvAssert(m_iGreatWorksTourismModifier >= 0);
; 3708 : 	}
; 3709 : }

	ret	4
?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeGreatWorksTourismModifier
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 3854 : 	return m_iBuildingProductionModifier;

	mov	eax, DWORD PTR [ecx+4]

; 3855 : }

	ret	0
?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeBuildingProductionModifier, COMDAT
; _this$ = ecx

; 3860 : 	m_iBuildingProductionModifier = (m_iBuildingProductionModifier + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+4], eax

; 3861 : 	CvAssert(GetBuildingProductionModifier() >= 0);
; 3862 : }

	ret	4
?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingDefense@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetBuildingDefense
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingDefense@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingDefense@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetBuildingDefense, COMDAT
; _this$ = ecx

; 3867 : 	return m_iBuildingDefense;

	mov	eax, DWORD PTR [ecx+8]

; 3868 : }

	ret	0
?GetBuildingDefense@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetBuildingDefense
_TEXT	ENDS
PUBLIC	?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z	; CvCityBuildings::ChangeBuildingDefense
EXTRN	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::plotAction
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z:PROC	; PUF_makeInfoBarDirty
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z PROC	; CvCityBuildings::ChangeBuildingDefense, COMDAT
; _this$ = ecx

; 3873 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeBuil

; 3874 : 	{
; 3875 : 		m_iBuildingDefense = (m_iBuildingDefense + iChange);

	add	DWORD PTR [ecx+8], eax

; 3876 : 		CvAssert(GetBuildingDefense() >= 0);
; 3877 : 
; 3878 : 		m_pCity->plot()->plotAction(PUF_makeInfoBarDirty);

	mov	ecx, DWORD PTR [ecx+112]
	push	-1
	push	-1
	push	-1
	push	-1
	push	OFFSET ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ; PUF_makeInfoBarDirty
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
$LN1@ChangeBuil:

; 3879 : 	}
; 3880 : }

	ret	4
?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z ENDP	; CvCityBuildings::ChangeBuildingDefense
_TEXT	ENDS
PUBLIC	?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetBuildingDefensePerCitizen
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetBuildingDefensePerCitizen, COMDAT
; _this$ = ecx

; 3886 : 	return m_iBuildingDefensePerCitizen;

	mov	eax, DWORD PTR [ecx+12]

; 3887 : }

	ret	0
?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetBuildingDefensePerCitizen
_TEXT	ENDS
PUBLIC	?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingDefensePerCitizen
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeBuildingDefensePerCitizen, COMDAT
; _this$ = ecx

; 3892 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeBuil@2

; 3893 : 	{
; 3894 : 		m_iBuildingDefensePerCitizen = (m_iBuildingDefensePerCitizen + iChange);

	add	DWORD PTR [ecx+12], eax

; 3895 : 		CvAssert(GetBuildingDefensePerCitizen() >= 0);
; 3896 : 
; 3897 : 		m_pCity->plot()->plotAction(PUF_makeInfoBarDirty);

	mov	ecx, DWORD PTR [ecx+112]
	push	-1
	push	-1
	push	-1
	push	-1
	push	OFFSET ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ; PUF_makeInfoBarDirty
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
$LN1@ChangeBuil@2:

; 3898 : 	}
; 3899 : }

	ret	4
?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeBuildingDefensePerCitizen
_TEXT	ENDS
PUBLIC	?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetBuildingDefenseMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetBuildingDefenseMod, COMDAT
; _this$ = ecx

; 3906 : 	return m_iBuildingDefenseMod;

	mov	eax, DWORD PTR [ecx+16]

; 3907 : }

	ret	0
?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetBuildingDefenseMod
_TEXT	ENDS
PUBLIC	?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingDefenseMod
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z PROC	; CvCityBuildings::ChangeBuildingDefenseMod, COMDAT
; _this$ = ecx

; 3912 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeBuil@3

; 3913 : 	{
; 3914 : 		m_iBuildingDefenseMod = (m_iBuildingDefenseMod + iChange);

	add	DWORD PTR [ecx+16], eax

; 3915 : 		CvAssert(m_iBuildingDefenseMod >= 0);
; 3916 : 
; 3917 : 		m_pCity->plot()->plotAction(PUF_makeInfoBarDirty);

	mov	ecx, DWORD PTR [ecx+112]
	push	-1
	push	-1
	push	-1
	push	-1
	push	OFFSET ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ; PUF_makeInfoBarDirty
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
$LN1@ChangeBuil@3:

; 3918 : 	}
; 3919 : }

	ret	4
?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z ENDP	; CvCityBuildings::ChangeBuildingDefenseMod
_TEXT	ENDS
PUBLIC	?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetMissionaryExtraSpreads
; Function compile flags: /Ogtpy
;	COMDAT ?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetMissionaryExtraSpreads, COMDAT
; _this$ = ecx

; 3924 : 	return m_iMissionaryExtraSpreads;

	mov	eax, DWORD PTR [ecx+20]

; 3925 : }

	ret	0
?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetMissionaryExtraSpreads
_TEXT	ENDS
PUBLIC	?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeMissionaryExtraSpreads
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeMissionaryExtraSpreads, COMDAT
; _this$ = ecx

; 3930 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeMiss

; 3931 : 	{
; 3932 : 		m_iMissionaryExtraSpreads = (m_iMissionaryExtraSpreads + iChange);

	add	DWORD PTR [ecx+20], eax
$LN1@ChangeMiss:

; 3933 : 		CvAssert(m_iMissionaryExtraSpreads >= 0);
; 3934 : 	}
; 3935 : }

	ret	4
?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeMissionaryExtraSpreads
_TEXT	ENDS
PUBLIC	?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z ; CvCityBuildings::NotifyNewBuildingStarted
; Function compile flags: /Ogtpy
;	COMDAT ?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z PROC ; CvCityBuildings::NotifyNewBuildingStarted, COMDAT
; _this$ = ecx

; 4178 : 	// JON: Disabling this notification
; 4179 : 	return;
; 4180 : 
; 4181 : 	// is this city starting a wonder? If so, send a notification
; 4182 : 	//CvBuildingEntry* buildingEntry = GC.getBuildingInfo(eIndex);
; 4183 : 	//if (isLimitedWonderClass((BuildingClassTypes)(buildingEntry->GetBuildingClassType())) && GetBuildingProductionTimes100(eIndex) == 0)
; 4184 : 	//{
; 4185 : 	//	Localization::String locString;
; 4186 : 	//	Localization::String locSummaryString;
; 4187 : 
; 4188 : 	//	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4189 : 	//	{
; 4190 : 	//		PlayerTypes ePlayer = (PlayerTypes)ui;
; 4191 : 
; 4192 : 	//		if (ePlayer == m_pCity->getOwner() || !GET_PLAYER(ePlayer).isAlive())
; 4193 : 	//		{
; 4194 : 	//			continue;
; 4195 : 	//		}
; 4196 : 
; 4197 : 	//		int iX = -1;
; 4198 : 	//		int iY = -1;
; 4199 : 	//		int iPlayerID = -1;
; 4200 : 
; 4201 : 	//		if (GET_TEAM(m_pCity->getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
; 4202 : 	//		{
; 4203 : 	//			if (m_pCity->isRevealed(GET_PLAYER(ePlayer).getTeam(), false))
; 4204 : 	//			{
; 4205 : 	//				locString = Localization::Lookup("TXT_KEY_NOTIFICATION_WONDER_STARTED");
; 4206 : 	//				locString << GET_PLAYER(m_pCity->getOwner()).getNameKey() << buildingEntry->GetTextKey() << m_pCity->getNameKey();
; 4207 : 	//			}
; 4208 : 	//			else
; 4209 : 	//			{
; 4210 : 	//				locString = Localization::Lookup("TXT_KEY_NOTIFICATION_WONDER_STARTED_UNKNOWN_LOCATION");
; 4211 : 	//				locString << GET_PLAYER(m_pCity->getOwner()).getNameKey() << buildingEntry->GetTextKey();
; 4212 : 	//			}
; 4213 : 
; 4214 : 
; 4215 : 	//			locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_WONDER_STARTED");
; 4216 : 	//			locSummaryString << GET_PLAYER(m_pCity->getOwner()).getNameKey() << buildingEntry->GetTextKey();
; 4217 : 
; 4218 : 	//		}
; 4219 : 	//		else
; 4220 : 	//		{
; 4221 : 	//			locString = Localization::Lookup("TXT_KEY_NOTIFICATION_WONDER_STARTED_UNMET");
; 4222 : 	//			locString << buildingEntry->GetTextKey();
; 4223 : 	//			locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_WONDER_STARTED_UNKNOWN");
; 4224 : 	//			locSummaryString << buildingEntry->GetTextKey();
; 4225 : 	//		}
; 4226 : 
; 4227 : 	//		CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
; 4228 : 	//		if (pNotifications)
; 4229 : 	//		{
; 4230 : 	//			pNotifications->Add(NOTIFICATION_WONDER_STARTED, locString.toUTF8(), locSummaryString.toUTF8(), iX, iY, eIndex);
; 4231 : 	//		}
; 4232 : 	//	}
; 4233 : 	//}
; 4234 : }

	ret	4
?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z ENDP ; CvCityBuildings::NotifyNewBuildingStarted
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::size
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z PROC ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ENDP ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ; std::auto_ptr<ICvCity1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ PROC ; std::auto_ptr<ICvCity1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ENDP ; std::auto_ptr<ICvCity1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ; std::auto_ptr<ICvPlot1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ PROC ; std::auto_ptr<ICvPlot1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ENDP ; std::auto_ptr<ICvPlot1>::get
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEABUBuildingYieldChange@@XZ ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEABUBuildingYieldChange@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEABUBuildingYieldChange@@XZ PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEABUBuildingYieldChange@@XZ ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEAAUBuildingYieldChange@@XZ ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEAAUBuildingYieldChange@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEAAUBuildingYieldChange@@XZ PROC ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEAAUBuildingYieldChange@@XZ ENDP ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 12			; 0000000cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEABUBuildingGreatWork@@XZ ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEABUBuildingGreatWork@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEABUBuildingGreatWork@@XZ PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEABUBuildingGreatWork@@XZ ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEAAUBuildingGreatWork@@XZ ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEAAUBuildingGreatWork@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEAAUBuildingGreatWork@@XZ PROC ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEAAUBuildingGreatWork@@XZ ENDP ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 12			; 0000000cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator++
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 144  : 		}

	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::key_comp
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@XZ	; std::allocator<CvBuildingEntry *>::allocator<CvBuildingEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@XZ PROC	; std::allocator<CvBuildingEntry *>::allocator<CvBuildingEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvBuildingEntry *>::allocator<CvBuildingEntry *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ PROC	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >::~_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >::~_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >::~_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBuildingYieldChange@@@std@@QAE@XZ ; std::allocator<BuildingYieldChange>::allocator<BuildingYieldChange>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBuildingYieldChange@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UBuildingYieldChange@@@std@@QAE@XZ PROC	; std::allocator<BuildingYieldChange>::allocator<BuildingYieldChange>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UBuildingYieldChange@@@std@@QAE@XZ ENDP	; std::allocator<BuildingYieldChange>::allocator<BuildingYieldChange>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@2

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >::~_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >::~_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >::~_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBuildingGreatWork@@@std@@QAE@XZ	; std::allocator<BuildingGreatWork>::allocator<BuildingGreatWork>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBuildingGreatWork@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UBuildingGreatWork@@@std@@QAE@XZ PROC	; std::allocator<BuildingGreatWork>::allocator<BuildingGreatWork>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UBuildingGreatWork@@@std@@QAE@XZ ENDP	; std::allocator<BuildingGreatWork>::allocator<BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBHH@std@@QAE@ABH0@Z		; std::pair<int const ,int>::pair<int const ,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBHH@std@@QAE@ABH0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBHH@std@@QAE@ABH0@Z PROC			; std::pair<int const ,int>::pair<int const ,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@$$CBHH@std@@QAE@ABH0@Z ENDP			; std::pair<int const ,int>::pair<int const ,int>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEABQAVCvBuildingEntry@@XZ ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEABQAVCvBuildingEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEABQAVCvBuildingEntry@@XZ PROC ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEABQAVCvBuildingEntry@@XZ ENDP ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z PROC ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@PAUBuildingYieldChange@@@Z ENDP ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z PROC ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@PAUBuildingGreatWork@@@Z ENDP ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 29					; 0000001dH

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T227069 = -80						; size = 28
$T227068 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T227069[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227068[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227069[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227068[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227068[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T227068[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227068[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T227069[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T227068[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvBuildingEntry *>::allocator<CvBuildingEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvBuildingEntry *>::allocator<CvBuildingEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvBuildingEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvBuildingEntry *>::allocator<CvBuildingEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEXPAPAVCvBuildingEntry@@I@Z ; std::allocator<CvBuildingEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEXPAPAVCvBuildingEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEXPAPAVCvBuildingEntry@@I@Z PROC ; std::allocator<CvBuildingEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEXPAPAVCvBuildingEntry@@I@Z ENDP ; std::allocator<CvBuildingEntry *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T227104 = -80						; size = 28
$T227103 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T227104[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227103[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227104[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227103[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227103[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T227103[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227103[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T227104[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T227103[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z ; std::allocator<enum BuildingTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z PROC ; std::allocator<enum BuildingTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z ENDP ; std::allocator<enum BuildingTypes>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T227138 = -80						; size = 28
$T227137 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T227138[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227137[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227138[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227137[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227137[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T227137[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227137[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T227138[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T227137[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >::_Container_base_aux_alloc_empty<std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBuildingYieldChange@@@std@@QAE@ABV01@@Z ; std::allocator<BuildingYieldChange>::allocator<BuildingYieldChange>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBuildingYieldChange@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UBuildingYieldChange@@@std@@QAE@ABV01@@Z PROC ; std::allocator<BuildingYieldChange>::allocator<BuildingYieldChange>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UBuildingYieldChange@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<BuildingYieldChange>::allocator<BuildingYieldChange>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@I@Z ; std::allocator<BuildingYieldChange>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@I@Z PROC ; std::allocator<BuildingYieldChange>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@I@Z ENDP ; std::allocator<BuildingYieldChange>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T227172 = -80						; size = 28
$T227171 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T227172[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227171[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227172[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227171[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227171[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T227171[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227171[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T227172[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T227171[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >::_Container_base_aux_alloc_empty<std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBuildingGreatWork@@@std@@QAE@ABV01@@Z ; std::allocator<BuildingGreatWork>::allocator<BuildingGreatWork>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBuildingGreatWork@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UBuildingGreatWork@@@std@@QAE@ABV01@@Z PROC ; std::allocator<BuildingGreatWork>::allocator<BuildingGreatWork>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UBuildingGreatWork@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<BuildingGreatWork>::allocator<BuildingGreatWork>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@I@Z ; std::allocator<BuildingGreatWork>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@I@Z PROC ; std::allocator<BuildingGreatWork>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@I@Z ENDP ; std::allocator<BuildingGreatWork>::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z PROC ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z ENDP ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z PROC ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ENDP ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 28					; 0000001cH

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvBuildingEntry@@@std@@QBEIXZ ; std::allocator<CvBuildingEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvBuildingEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvBuildingEntry@@@std@@QBEIXZ PROC ; std::allocator<CvBuildingEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvBuildingEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvBuildingEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ ; std::allocator<enum BuildingTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ PROC ; std::allocator<enum BuildingTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum BuildingTypes>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBuildingYieldChange@@@std@@QBEIXZ ; std::allocator<BuildingYieldChange>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UBuildingYieldChange@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UBuildingYieldChange@@@std@@QBEIXZ PROC ; std::allocator<BuildingYieldChange>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@UBuildingYieldChange@@@std@@QBEIXZ ENDP ; std::allocator<BuildingYieldChange>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBuildingGreatWork@@@std@@QBEIXZ ; std::allocator<BuildingGreatWork>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UBuildingGreatWork@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UBuildingGreatWork@@@std@@QBEIXZ PROC ; std::allocator<BuildingGreatWork>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@UBuildingGreatWork@@@std@@QBEIXZ ENDP ; std::allocator<BuildingGreatWork>::max_size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::get_allocator
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::key_comp
; Function compile flags: /Ogtpy
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+29], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+29], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+29], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,int> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >::max_size
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max@2
	npad	3
$LL2@Max@2:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max@2
$LN1@Max@2:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min@2
	npad	4
$LL2@Min@2:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min@2
$LN1@Min@2:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+=
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??$?8U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@0@0@Z ; std::operator==<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >,std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?8U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@0@0@Z PROC ; std::operator==<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >,std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@0@0@Z ENDP ; std::operator==<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >,std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@0@Z ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@0@Z PROC ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *><std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *><std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *><std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ; std::_Allocate<CvBuildingEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T227654 = -12						; size = 12
$T227658 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvBuildingEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227658[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227654[esp+16]
	mov	DWORD PTR $T227658[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227654[esp+16]
	push	ecx
	mov	DWORD PTR $T227654[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvBuildingEntry *>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T227664 = -12						; size = 12
$T227668 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z PROC ; std::_Allocate<enum BuildingTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227668[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227664[esp+16]
	mov	DWORD PTR $T227668[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227664[esp+16]
	push	ecx
	mov	DWORD PTR $T227664[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z
_TEXT	SEGMENT
$T227674 = -12						; size = 12
$T227678 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z PROC ; std::_Allocate<BuildingYieldChange>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227678[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227674[esp+16]
	mov	DWORD PTR $T227678[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227674[esp+16]
	push	ecx
	mov	DWORD PTR $T227674[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ENDP ; std::_Allocate<BuildingYieldChange>
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z
_TEXT	SEGMENT
$T227699 = -12						; size = 12
$T227703 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z PROC ; std::_Allocate<BuildingGreatWork>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227703[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227699[esp+16]
	mov	DWORD PTR $T227703[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227699[esp+16]
	push	ecx
	mov	DWORD PTR $T227699[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ENDP ; std::_Allocate<BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node><std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node><std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node><std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T227712 = -12						; size = 12
$T227716 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227716[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227712[esp+16]
	mov	DWORD PTR $T227716[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227712[esp+16]
	push	ecx
	mov	DWORD PTR $T227712[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T227737 = -12						; size = 12
$T227741 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227741[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227737[esp+16]
	mov	DWORD PTR $T227741[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227737[esp+16]
	push	ecx
	mov	DWORD PTR $T227737[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::swap<std::less<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC	; std::swap<std::less<int> >, COMDAT

; 18   : 	if (&_Left != &_Right)
; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;
; 21   : 
; 22   : 		_Left = _Right;
; 23   : 		_Right = _Tmp;
; 24   : 		}
; 25   : 	}

	ret	0
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP	; std::swap<std::less<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUBuildingYieldChange@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingYieldChange@@0@Z ; std::_Iter_random<BuildingYieldChange *,BuildingYieldChange *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUBuildingYieldChange@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingYieldChange@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUBuildingYieldChange@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingYieldChange@@0@Z PROC ; std::_Iter_random<BuildingYieldChange *,BuildingYieldChange *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUBuildingYieldChange@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingYieldChange@@0@Z ENDP ; std::_Iter_random<BuildingYieldChange *,BuildingYieldChange *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUBuildingYieldChange@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingYieldChange@@0@Z ; std::_Ptr_cat<BuildingYieldChange *,BuildingYieldChange *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUBuildingYieldChange@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingYieldChange@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUBuildingYieldChange@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingYieldChange@@0@Z PROC ; std::_Ptr_cat<BuildingYieldChange *,BuildingYieldChange *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUBuildingYieldChange@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingYieldChange@@0@Z ENDP ; std::_Ptr_cat<BuildingYieldChange *,BuildingYieldChange *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUBuildingGreatWork@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingGreatWork@@0@Z ; std::_Iter_random<BuildingGreatWork *,BuildingGreatWork *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUBuildingGreatWork@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingGreatWork@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUBuildingGreatWork@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingGreatWork@@0@Z PROC ; std::_Iter_random<BuildingGreatWork *,BuildingGreatWork *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUBuildingGreatWork@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUBuildingGreatWork@@0@Z ENDP ; std::_Iter_random<BuildingGreatWork *,BuildingGreatWork *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUBuildingGreatWork@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingGreatWork@@0@Z ; std::_Ptr_cat<BuildingGreatWork *,BuildingGreatWork *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUBuildingGreatWork@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingGreatWork@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUBuildingGreatWork@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingGreatWork@@0@Z PROC ; std::_Ptr_cat<BuildingGreatWork *,BuildingGreatWork *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUBuildingGreatWork@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUBuildingGreatWork@@0@Z ENDP ; std::_Ptr_cat<BuildingGreatWork *,BuildingGreatWork *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingEntry@@0@Z ; std::_Iter_random<CvBuildingEntry * *,CvBuildingEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingEntry@@0@Z PROC ; std::_Iter_random<CvBuildingEntry * *,CvBuildingEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingEntry@@0@Z ENDP ; std::_Iter_random<CvBuildingEntry * *,CvBuildingEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingEntry@@0@Z ; std::_Ptr_cat<CvBuildingEntry * *,CvBuildingEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingEntry@@0@Z PROC ; std::_Ptr_cat<CvBuildingEntry * *,CvBuildingEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvBuildingEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingEntry@@0@Z ENDP ; std::_Ptr_cat<CvBuildingEntry * *,CvBuildingEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvBuildingEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBuildingEntry * *,CvBuildingEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvBuildingEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvBuildingEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBuildingEntry * *,CvBuildingEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@3:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvBuildingEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBuildingEntry * *,CvBuildingEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z ; std::_Iter_random<enum BuildingTypes *,enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z PROC ; std::_Iter_random<enum BuildingTypes *,enum BuildingTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z ENDP ; std::_Iter_random<enum BuildingTypes *,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z ; std::_Ptr_cat<enum BuildingTypes *,enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z PROC ; std::_Ptr_cat<enum BuildingTypes *,enum BuildingTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z ENDP ; std::_Ptr_cat<enum BuildingTypes *,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ; CvPopupInfo::CvPopupInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z
_TEXT	SEGMENT
_buttonPopupType$ = 8					; size = 4
_data1$ = 12						; size = 4
_data2$ = 16						; size = 4
_data3$ = 20						; size = 4
_flags$ = 24						; size = 4
_option1$ = 28						; size = 1
_option2$ = 32						; size = 1
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z PROC	; CvPopupInfo::CvPopupInfo, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	edx, DWORD PTR _data2$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _data1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _data3$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _flags$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _option1$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _option2$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _buttonPopupType$[esp-4]
	mov	BYTE PTR [eax+17], dl
	mov	DWORD PTR [eax+20], ecx

; 120  : 		//Nothing
; 121  : 		szText[0] = 0;

	mov	BYTE PTR [eax+24], 0

; 122  : 	}

	ret	28					; 0000001cH
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ENDP	; CvPopupInfo::CvPopupInfo
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@4
	push	esi
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@4
	pop	esi
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBuildingEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z ; std::_Fill<BuildingYieldChange *,BuildingYieldChange>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z PROC ; std::_Fill<BuildingYieldChange *,BuildingYieldChange>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z ENDP ; std::_Fill<BuildingYieldChange *,BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUBuildingYieldChange@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingYieldChange@@@Z ; std::_Move_cat<BuildingYieldChange *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUBuildingYieldChange@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingYieldChange@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUBuildingYieldChange@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingYieldChange@@@Z PROC ; std::_Move_cat<BuildingYieldChange *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUBuildingYieldChange@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingYieldChange@@@Z ENDP ; std::_Move_cat<BuildingYieldChange *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z ; std::_Fill<BuildingGreatWork *,BuildingGreatWork>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z PROC ; std::_Fill<BuildingGreatWork *,BuildingGreatWork>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z ENDP ; std::_Fill<BuildingGreatWork *,BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUBuildingGreatWork@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingGreatWork@@@Z ; std::_Move_cat<BuildingGreatWork *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUBuildingGreatWork@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingGreatWork@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUBuildingGreatWork@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingGreatWork@@@Z PROC ; std::_Move_cat<BuildingGreatWork *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUBuildingGreatWork@@@std@@YA?AU_Undefined_move_tag@0@ABQAUBuildingGreatWork@@@Z ENDP ; std::_Move_cat<BuildingGreatWork *>
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAEXABUBuildingYieldChange@@@Z ; SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >::operator()
EXTRN	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAEXABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAEXABUBuildingYieldChange@@@Z PROC ; SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAEXABUBuildingYieldChange@@@Z ENDP ; SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >::operator()
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAEXABUBuildingGreatWork@@@Z ; SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >::operator()
EXTRN	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAEXABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAEXABUBuildingGreatWork@@@Z PROC ; SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z ; operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAEXABUBuildingGreatWork@@@Z ENDP ; SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >::operator()
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z ; std::_Destroy<enum BuildingTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z PROC ; std::_Destroy<enum BuildingTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z ENDP ; std::_Destroy<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$_Construct@UBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@ABU1@@Z ; std::_Construct<BuildingYieldChange,BuildingYieldChange>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@UBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@ABU1@@Z PROC ; std::_Construct<BuildingYieldChange,BuildingYieldChange>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@UBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@ABU1@@Z ENDP ; std::_Construct<BuildingYieldChange,BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$_Destroy@UBuildingYieldChange@@@std@@YAXPAUBuildingYieldChange@@@Z ; std::_Destroy<BuildingYieldChange>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UBuildingYieldChange@@@std@@YAXPAUBuildingYieldChange@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UBuildingYieldChange@@@std@@YAXPAUBuildingYieldChange@@@Z PROC ; std::_Destroy<BuildingYieldChange>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UBuildingYieldChange@@@std@@YAXPAUBuildingYieldChange@@@Z ENDP ; std::_Destroy<BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$_Construct@UBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@ABU1@@Z ; std::_Construct<BuildingGreatWork,BuildingGreatWork>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@UBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@ABU1@@Z PROC ; std::_Construct<BuildingGreatWork,BuildingGreatWork>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@UBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@ABU1@@Z ENDP ; std::_Construct<BuildingGreatWork,BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??$_Destroy@UBuildingGreatWork@@@std@@YAXPAUBuildingGreatWork@@@Z ; std::_Destroy<BuildingGreatWork>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UBuildingGreatWork@@@std@@YAXPAUBuildingGreatWork@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UBuildingGreatWork@@@std@@YAXPAUBuildingGreatWork@@@Z PROC ; std::_Destroy<BuildingGreatWork>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UBuildingGreatWork@@@std@@YAXPAUBuildingGreatWork@@@Z ENDP ; std::_Destroy<BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??0BuildingYieldChange@@QAE@XZ			; BuildingYieldChange::BuildingYieldChange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvstructs.h
;	COMDAT ??0BuildingYieldChange@@QAE@XZ
_TEXT	SEGMENT
??0BuildingYieldChange@@QAE@XZ PROC			; BuildingYieldChange::BuildingYieldChange, COMDAT
; _this$ = ecx

; 161  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], 0

; 162  : 	}

	ret	0
??0BuildingYieldChange@@QAE@XZ ENDP			; BuildingYieldChange::BuildingYieldChange
_TEXT	ENDS
PUBLIC	??0BuildingGreatWork@@QAE@XZ			; BuildingGreatWork::BuildingGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ??0BuildingGreatWork@@QAE@XZ
_TEXT	SEGMENT
??0BuildingGreatWork@@QAE@XZ PROC			; BuildingGreatWork::BuildingGreatWork, COMDAT
; _this$ = ecx

; 182  : 	{

	mov	eax, ecx
	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 183  : 	}

	ret	0
??0BuildingGreatWork@@QAE@XZ ENDP			; BuildingGreatWork::BuildingGreatWork
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator@2

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator@2:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getCITY_MAX_NUM_BUILDINGS@CvGlobals@@QAEHXZ	; CvGlobals::getCITY_MAX_NUM_BUILDINGS
; Function compile flags: /Ogtpy
;	COMDAT ?getCITY_MAX_NUM_BUILDINGS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCITY_MAX_NUM_BUILDINGS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCITY_MAX_NUM_BUILDINGS, COMDAT
; _this$ = ecx

; 5968 : 		return m_iCITY_MAX_NUM_BUILDINGS;

	mov	eax, DWORD PTR [ecx+6892]

; 5969 : 	}

	ret	0
?getCITY_MAX_NUM_BUILDINGS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCITY_MAX_NUM_BUILDINGS
_TEXT	ENDS
PUBLIC	?getBUILDING_SALE_DIVISOR@CvGlobals@@QAEHXZ	; CvGlobals::getBUILDING_SALE_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDING_SALE_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDING_SALE_DIVISOR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBUILDING_SALE_DIVISOR, COMDAT
; _this$ = ecx

; 6961 : 		return m_iBUILDING_SALE_DIVISOR;

	mov	eax, DWORD PTR [ecx+7832]

; 6962 : 	}

	ret	0
?getBUILDING_SALE_DIVISOR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBUILDING_SALE_DIVISOR
_TEXT	ENDS
PUBLIC	?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ ; CvGlobals::getBASE_CULTURE_PER_GREAT_WORK
; Function compile flags: /Ogtpy
;	COMDAT ?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBASE_CULTURE_PER_GREAT_WORK, COMDAT
; _this$ = ecx

; 7511 : 		return m_iBASE_CULTURE_PER_GREAT_WORK;

	mov	eax, DWORD PTR [ecx+8208]

; 7512 : 	}

	ret	0
?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBASE_CULTURE_PER_GREAT_WORK
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ ; CvPlayer::GetPlayerAchievements
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ
_TEXT	SEGMENT
?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ PROC ; CvPlayer::GetPlayerAchievements, COMDAT
; _this$ = ecx

; 1717 : 	CvPlayerAchievements& GetPlayerAchievements(){return m_kPlayerAchievements;}

	lea	eax, DWORD PTR [ecx+63156]
	ret	0
?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ ENDP ; CvPlayer::GetPlayerAchievements
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvThemingBonusInfo@@QAE@XZ			; CvThemingBonusInfo::CvThemingBonusInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
;	COMDAT ??0CvThemingBonusInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvThemingBonusInfo@@QAE@XZ PROC			; CvThemingBonusInfo::CvThemingBonusInfo, COMDAT
; _this$ = ecx

; 37   : 	  {

	push	ebx
	push	esi
	mov	esi, ecx
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR [esi+32], bl
	mov	BYTE PTR [esi+33], bl
	mov	BYTE PTR [esi+34], bl
	mov	BYTE PTR [esi+35], bl
	mov	BYTE PTR [esi+36], bl
	mov	BYTE PTR [esi+37], bl
	mov	BYTE PTR [esi+38], bl
	mov	BYTE PTR [esi+39], bl
	mov	BYTE PTR [esi+40], bl
	mov	DWORD PTR [esi+44], ebx

; 38   : 
; 39   : 	  };

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	0
??0CvThemingBonusInfo@@QAE@XZ ENDP			; CvThemingBonusInfo::CvThemingBonusInfo
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?IsTechBoostFromCapitalScienceBuildings@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsTechBoostFromCapitalScienceBuildings
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?IsTechBoostFromCapitalScienceBuildings@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsTechBoostFromCapitalScienceBuildings@CvPlayerTraits@@QBE_NXZ PROC ; CvPlayerTraits::IsTechBoostFromCapitalScienceBuildings, COMDAT
; _this$ = ecx

; 740  : 		return m_bTechBoostFromCapitalScienceBuildings;

	mov	al, BYTE PTR [ecx+331]

; 741  : 	};

	ret	0
?IsTechBoostFromCapitalScienceBuildings@CvPlayerTraits@@QBE_NXZ ENDP ; CvPlayerTraits::IsTechBoostFromCapitalScienceBuildings
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1CvThemingBonusInfo@@QAE@XZ			; CvThemingBonusInfo::~CvThemingBonusInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvThemingBonusInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvThemingBonusInfo@@QAE@XZ PROC			; CvThemingBonusInfo::~CvThemingBonusInfo, COMDAT
; _this$ = ecx
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvThemingBonusInfo@@QAE@XZ ENDP			; CvThemingBonusInfo::~CvThemingBonusInfo
_TEXT	ENDS
PUBLIC	?GetEra@CvBuildingEntry@@QBEHXZ			; CvBuildingEntry::GetEra
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?GetEra@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEra@CvBuildingEntry@@QBEHXZ PROC			; CvBuildingEntry::GetEra, COMDAT
; _this$ = ecx

; 942  : 	TechTypes eTech = (TechTypes)GetPrereqAndTech();

	mov	eax, DWORD PTR [ecx+312]

; 943  : 	if (eTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN1@GetEra

; 944  : 	{
; 945  : 		CvTechEntry* pTech = GC.getTechInfo((TechTypes)GetPrereqAndTech());

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 946  : 		return pTech->GetEra();

	mov	ecx, eax
	jmp	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
$LN1@GetEra:

; 947  : 	}
; 948  : 
; 949  : 	return -1;

	or	eax, -1

; 950  : }

	ret	0
?GetEra@CvBuildingEntry@@QBEHXZ ENDP			; CvBuildingEntry::GetEra
_TEXT	ENDS
PUBLIC	?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsScienceBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsScienceBuilding, COMDAT
; _this$ = ecx

; 1750 : 	bool bRtnValue = false;

	xor	dl, dl

; 1751 : 
; 1752 : 	if(IsCapital())

	cmp	BYTE PTR [ecx+727], dl
	je	SHORT $LN11@IsScienceB

; 1753 : 	{
; 1754 : 		bRtnValue = false;

	xor	al, al

; 1778 : }

	ret	0
$LN11@IsScienceB:

; 1755 : 	}
; 1756 : 	else if(GetYieldChange(YIELD_SCIENCE) > 0)

	mov	eax, DWORD PTR [ecx+880]
	test	eax, eax
	je	SHORT $LN9@IsScienceB
	cmp	DWORD PTR [eax+12], 0

; 1757 : 	{
; 1758 : 		bRtnValue = true;

	jg	SHORT $LN33@IsScienceB
$LN9@IsScienceB:

; 1759 : 	}
; 1760 : 	else if(GetYieldChangePerPop(YIELD_SCIENCE) > 0)

	mov	eax, DWORD PTR [ecx+884]
	test	eax, eax
	je	SHORT $LN7@IsScienceB
	cmp	DWORD PTR [eax+12], 0

; 1761 : 	{
; 1762 : 		bRtnValue = true;

	jg	SHORT $LN33@IsScienceB
$LN7@IsScienceB:

; 1763 : 	}
; 1764 : 	else if(GetYieldChangePerReligion(YIELD_SCIENCE) > 0)

	mov	eax, DWORD PTR [ecx+888]
	test	eax, eax
	je	SHORT $LN5@IsScienceB
	cmp	DWORD PTR [eax+12], 0

; 1765 : 	{
; 1766 : 		bRtnValue = true;

	jg	SHORT $LN33@IsScienceB
$LN5@IsScienceB:

; 1767 : 	}
; 1768 : 	else if(GetTechEnhancedYieldChange(YIELD_SCIENCE) > 0)

	mov	eax, DWORD PTR [ecx+904]
	test	eax, eax
	je	SHORT $LN3@IsScienceB
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN3@IsScienceB
$LN33@IsScienceB:

; 1769 : 	{
; 1770 : 		bRtnValue = true;

	mov	al, 1

; 1778 : }

	ret	0
$LN3@IsScienceB:

; 1771 : 	}
; 1772 : 	else if(GetYieldModifier(YIELD_SCIENCE) > 0)

	push	3
	call	?GetYieldModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldModifier
	test	eax, eax

; 1773 : 	{
; 1774 : 		bRtnValue = true;

	mov	al, 1
	jg	SHORT $LN1@IsScienceB

; 1775 : 	}
; 1776 : 
; 1777 : 	return bRtnValue;

	mov	al, dl
$LN1@IsScienceB:

; 1778 : }

	ret	0
?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsScienceBuilding
_TEXT	ENDS
PUBLIC	?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z	; CvBuildingEntry::SetArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z PROC	; CvBuildingEntry::SetArtDefineTag, COMDAT
; _this$ = ecx

; 1789 : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 752				; 000002f0H
	test	eax, eax
	je	SHORT $LN4@SetArtDefi
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetArtDefi:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 1790 : }

	ret	4
?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z ENDP	; CvBuildingEntry::SetArtDefineTag
_TEXT	ENDS
PUBLIC	?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ ; CvBuildingEntry::GetThemingBonusHelp
; Function compile flags: /Ogtpy
;	COMDAT ?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T228136 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ PROC ; CvBuildingEntry::GetThemingBonusHelp, COMDAT
; _this$ = ecx

; 1816 : {

	push	ecx
	push	esi

; 1817 : 	return m_strThemingBonusHelp;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 808				; 00000328H
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T228136[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi

; 1818 : }

	pop	ecx
	ret	4
?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ ENDP ; CvBuildingEntry::GetThemingBonusHelp
_TEXT	ENDS
PUBLIC	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ	; CvBuildingXMLEntries::GetNumBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ PROC	; CvBuildingXMLEntries::GetNumBuildings, COMDAT
; _this$ = ecx

; 2381 : 	return m_paBuildingEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 2382 : }

	ret	0
?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ENDP	; CvBuildingXMLEntries::GetNumBuildings
_TEXT	ENDS
PUBLIC	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z PROC ; CvBuildingXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 2402 : 	return m_paBuildingEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2403 : }

	ret	4
?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ENDP ; CvBuildingXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvCityBuildings@@QAEXXZ			; CvCityBuildings::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvCityBuildings@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvCityBuildings@@QAEXXZ PROC			; CvCityBuildings::Uninit, COMDAT
; _this$ = ecx

; 2484 : {

	push	esi
	mov	esi, ecx

; 2485 : 	SAFE_DELETE_ARRAY(m_paiBuildingProduction);

	mov	eax, DWORD PTR [esi+36]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+36], edi

; 2486 : 	SAFE_DELETE_ARRAY(m_paiBuildingProductionTime);

	mov	ecx, DWORD PTR [esi+40]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+40], edi

; 2487 : 	SAFE_DELETE_ARRAY(m_paiBuildingOriginalOwner);

	mov	edx, DWORD PTR [esi+44]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+44], edi

; 2488 : 	SAFE_DELETE_ARRAY(m_paiBuildingOriginalTime);

	mov	eax, DWORD PTR [esi+48]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+48], edi

; 2489 : 	SAFE_DELETE_ARRAY(m_paiNumRealBuilding);

	mov	ecx, DWORD PTR [esi+52]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+52], edi

; 2490 : 	SAFE_DELETE_ARRAY(m_paiNumFreeBuilding);

	mov	edx, DWORD PTR [esi+56]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+56], edi
	pop	edi
	pop	esi

; 2491 : }

	ret	0
?Uninit@CvCityBuildings@@QAEXXZ ENDP			; CvCityBuildings::Uninit
_TEXT	ENDS
PUBLIC	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
$T228197 = -4						; size = 4
$T228196 = 8						; size = 4
_eIndex$ = 8						; size = 4
?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumBuilding, COMDAT
; _this$ = ecx

; 2627 : {

	push	ecx

; 2628 : 	CvAssertMsg(eIndex != NO_BUILDING, "BuildingType eIndex is expected to not be NO_BUILDING");
; 2629 : 
; 2630 : 	if(GC.getCITY_MAX_NUM_BUILDINGS() <= 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	jg	SHORT $LN2@GetNumBuil

; 2631 : 	{
; 2632 : 		return std::max(GetNumRealBuilding(eIndex), GetNumFreeBuilding(eIndex));

	mov	eax, DWORD PTR _eIndex$[esp]
	mov	edx, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T228197[esp+4], eax
	cmp	eax, edx
	mov	DWORD PTR $T228196[esp], edx
	lea	eax, DWORD PTR $T228196[esp]
	jl	SHORT $LN14@GetNumBuil
	lea	eax, DWORD PTR $T228197[esp+4]
$LN14@GetNumBuil:
	mov	eax, DWORD PTR [eax]

; 2637 : 	}
; 2638 : }

	pop	ecx
	ret	4
$LN2@GetNumBuil:

; 2633 : 	}
; 2634 : 	else
; 2635 : 	{
; 2636 : 		return (GetNumRealBuilding(eIndex) + GetNumFreeBuilding(eIndex));

	mov	edx, DWORD PTR _eIndex$[esp]
	mov	eax, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, DWORD PTR [ecx+edx*4]

; 2637 : 	}
; 2638 : }

	pop	ecx
	ret	4
?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumBuilding
_TEXT	ENDS
PUBLIC	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
EXTRN	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z:PROC ; CvTeam::isObsoleteBuilding
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumActiveBuilding, COMDAT
; _this$ = ecx

; 2657 : {

	push	esi
	mov	esi, ecx

; 2658 : 	CvAssertMsg(eIndex != NO_BUILDING, "BuildingType eIndex is expected to not be NO_BUILDING");
; 2659 : 
; 2660 : 	if(GET_TEAM(m_pCity->getTeam()).isObsoleteBuilding(eIndex))

	mov	ecx, DWORD PTR [esi+112]
	push	edi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edi, DWORD PTR _eIndex$[esp+4]
	push	edi
	mov	ecx, eax
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	test	al, al
	je	SHORT $LN1@GetNumActi
	pop	edi

; 2661 : 	{
; 2662 : 		return 0;

	xor	eax, eax
	pop	esi

; 2666 : }

	ret	4
$LN1@GetNumActi:

; 2663 : 	}
; 2664 : 
; 2665 : 	return (GetNumBuilding(eIndex));

	push	edi
	mov	ecx, esi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	pop	edi
	pop	esi

; 2666 : }

	ret	4
?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumActiveBuilding
_TEXT	ENDS
PUBLIC	?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetTotalBaseBuildingMaintenance
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_iTotalCost$ = -12					; size = 4
$T228333 = -8						; size = 4
$T228274 = -8						; size = 4
$T228332 = -4						; size = 4
$T228275 = -4						; size = 4
?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetTotalBaseBuildingMaintenance, COMDAT
; _this$ = ecx

; 2777 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 2778 : 	int iTotalCost = 0;

	xor	edi, edi

; 2779 : 
; 2780 : #ifdef AUI_WARNING_FIXES
; 2781 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 2782 : #else
; 2783 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iTotalCost$[esp+24], edi
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN48@GetTotalBa
	push	ebp
$LL50@GetTotalBa:

; 2784 : #endif
; 2785 : 	{
; 2786 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 2787 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 2788 : 
; 2789 : 		if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN4@GetTotalBa

; 2790 : 		{
; 2791 : 			if(GetNumBuilding(eBuilding))

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892
	cmp	ebp, 1
	mov	ecx, DWORD PTR [ebx+56]
	mov	edx, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [edx+esi*4]
	jg	SHORT $LN9@GetTotalBa
	cmp	edx, ecx
	mov	DWORD PTR $T228274[esp+28], ecx
	mov	DWORD PTR $T228275[esp+28], edx
	lea	edi, DWORD PTR $T228274[esp+28]
	jl	SHORT $LN21@GetTotalBa
	lea	edi, DWORD PTR $T228275[esp+28]
$LN21@GetTotalBa:
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN8@GetTotalBa
$LN9@GetTotalBa:
	lea	edi, DWORD PTR [edx+ecx]
$LN8@GetTotalBa:
	test	edi, edi
	je	SHORT $LN4@GetTotalBa

; 2792 : 				iTotalCost += (pkBuildingInfo->GetGoldMaintenance() * GetNumBuilding(eBuilding));

	cmp	ebp, 1
	mov	edi, DWORD PTR [eax+300]
	jg	SHORT $LN29@GetTotalBa
	cmp	edx, ecx
	mov	DWORD PTR $T228332[esp+28], ecx
	mov	DWORD PTR $T228333[esp+28], edx
	lea	eax, DWORD PTR $T228332[esp+28]
	jl	SHORT $LN41@GetTotalBa
	lea	eax, DWORD PTR $T228333[esp+28]
$LN41@GetTotalBa:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN28@GetTotalBa
$LN29@GetTotalBa:
	lea	eax, DWORD PTR [edx+ecx]
$LN28@GetTotalBa:
	imul	eax, edi
	add	DWORD PTR _iTotalCost$[esp+28], eax
$LN4@GetTotalBa:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	$LL50@GetTotalBa

; 2793 : 		}
; 2794 : 	}
; 2795 : 
; 2796 : 	return iTotalCost;

	mov	eax, DWORD PTR _iTotalCost$[esp+28]
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 2797 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN48@GetTotalBa:

; 2793 : 		}
; 2794 : 	}
; 2795 : 
; 2796 : 	return iTotalCost;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2797 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetTotalBaseBuildingMaintenance
_TEXT	ENDS
PUBLIC	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetNumGreatWorks
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorks@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetNumGreatWorks@CvCityBuildings@@QBEHXZ PROC		; CvCityBuildings::GetNumGreatWorks, COMDAT
; _this$ = ecx

; 3640 : 	// Simple if want total of all types
; 3641 : 	return m_aBuildingGreatWork.size();

	mov	edx, DWORD PTR [ecx+100]
	sub	edx, DWORD PTR [ecx+96]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 3642 : }

	ret	0
?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ENDP		; CvCityBuildings::GetNumGreatWorks
_TEXT	ENDS
PUBLIC	?GetThemingBonuses@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetThemingBonuses
EXTRN	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvCityCulture::GetThemingBonus
EXTRN	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ:PROC ; CvCity::GetCityCulture
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvCity::getCivilizationType
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetThemingBonuses@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
$T228398 = -8						; size = 4
$T228399 = -4						; size = 4
?GetThemingBonuses@CvCityBuildings@@QBEHXZ PROC		; CvCityBuildings::GetThemingBonuses, COMDAT
; _this$ = ecx

; 3713 : {

	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3714 : 	int iBonus = 0;
; 3715 : 
; 3716 : #ifdef AUI_WARNING_FIXES
; 3717 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3718 : #else
; 3719 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN29@GetTheming@2
	npad	6
$LL6@GetTheming@2:

; 3720 : #endif
; 3721 : 	{
; 3722 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3723 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [esi+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3724 : 		if (pkCivInfo)

	test	eax, eax
	je	SHORT $LN5@GetTheming@2

; 3725 : 		{
; 3726 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3727 : 			if(NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	SHORT $LN5@GetTheming@2

; 3728 : 			{
; 3729 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN10@GetTheming@2
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T228399[esp+20], eax
	cmp	eax, ecx
	mov	DWORD PTR $T228398[esp+20], ecx
	lea	eax, DWORD PTR $T228398[esp+20]
	jl	SHORT $LN22@GetTheming@2
	lea	eax, DWORD PTR $T228399[esp+20]
$LN22@GetTheming@2:
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN9@GetTheming@2
$LN10@GetTheming@2:
	add	ecx, DWORD PTR [edx+eax*4]
$LN9@GetTheming@2:
	test	ecx, ecx
	jle	SHORT $LN5@GetTheming@2

; 3730 : 				{
; 3731 : 					iBonus += m_pCity->GetCityCulture()->GetThemingBonus(eLoopBuildingClass);

	mov	ecx, DWORD PTR [esi+112]
	push	edi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonus
	add	ebx, eax
$LN5@GetTheming@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL6@GetTheming@2
$LN29@GetTheming@2:
	pop	edi
	pop	esi

; 3732 : 				}
; 3733 : 			}
; 3734 : 		}
; 3735 : 	}
; 3736 : 
; 3737 : 	return iBonus;

	mov	eax, ebx
	pop	ebx

; 3738 : }

	add	esp, 8
	ret	0
?GetThemingBonuses@CvCityBuildings@@QBEHXZ ENDP		; CvCityBuildings::GetThemingBonuses
_TEXT	ENDS
PUBLIC	?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumBuildingsFromFaith
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
$T228458 = -8						; size = 4
$T228459 = -4						; size = 4
?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetNumBuildingsFromFaith, COMDAT
; _this$ = ecx

; 3742 : {

	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3743 : 	int iRtnValue = 0;
; 3744 : 
; 3745 : #ifdef AUI_WARNING_FIXES
; 3746 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3747 : #else
; 3748 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN37@GetNumBuil@2
	npad	2
$LL8@GetNumBuil@2:

; 3749 : #endif
; 3750 : 	{
; 3751 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3752 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [esi+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3753 : 		if (pkCivInfo)

	test	eax, eax
	je	SHORT $LN7@GetNumBuil@2

; 3754 : 		{
; 3755 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3756 : 			if (NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	SHORT $LN7@GetNumBuil@2

; 3757 : 			{
; 3758 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN12@GetNumBuil@2
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T228458[esp+20], ecx
	cmp	edx, ecx
	mov	DWORD PTR $T228459[esp+20], edx
	lea	ecx, DWORD PTR $T228458[esp+20]
	jl	SHORT $LN24@GetNumBuil@2
	lea	ecx, DWORD PTR $T228459[esp+20]
$LN24@GetNumBuil@2:
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN11@GetNumBuil@2
$LN12@GetNumBuil@2:
	add	ecx, DWORD PTR [edx+eax*4]
$LN11@GetNumBuil@2:
	test	ecx, ecx
	jle	SHORT $LN7@GetNumBuil@2

; 3759 : 				{
; 3760 : 					CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3761 : 					if (pkEntry)

	test	eax, eax
	je	SHORT $LN7@GetNumBuil@2

; 3762 : 					{
; 3763 : 						if (pkEntry->GetFaithCost() > 0 && pkEntry->IsUnlockedByBelief() && pkEntry->GetProductionCost() == -1)

	cmp	DWORD PTR [eax+372], 0
	jle	SHORT $LN7@GetNumBuil@2
	cmp	BYTE PTR [eax+737], 0
	je	SHORT $LN7@GetNumBuil@2
	cmp	DWORD PTR [eax+368], -1
	jne	SHORT $LN7@GetNumBuil@2

; 3764 : 						{
; 3765 : 							iRtnValue++;

	inc	ebx
$LN7@GetNumBuil@2:

; 3743 : 	int iRtnValue = 0;
; 3744 : 
; 3745 : #ifdef AUI_WARNING_FIXES
; 3746 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3747 : #else
; 3748 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	$LL8@GetNumBuil@2
$LN37@GetNumBuil@2:
	pop	edi
	pop	esi

; 3766 : 						}
; 3767 : 					}
; 3768 : 				}
; 3769 : 			}
; 3770 : 		}
; 3771 : 	}
; 3772 : 
; 3773 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 3774 : }

	add	esp, 8
	ret	0
?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetNumBuildingsFromFaith
_TEXT	ENDS
PUBLIC	?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForAllWondersBuilt
; Function compile flags: /Ogtpy
;	COMDAT ?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ
_TEXT	SEGMENT
_nStat$ = -4						; size = 4
?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ PROC	; CvCityBuildings::CheckForAllWondersBuilt, COMDAT
; _this$ = ecx

; 4118 : {

	push	ecx
	push	esi

; 4119 : 	int iI;
; 4120 : 	int iStartStatWonder = ESTEAMSTAT_ANGKORWAT;
; 4121 : 	int iEndStatWonder = ESTEAMSTAT_PYRAMIDS;		//Don't include the united nations because it was removed in BNW.
; 4122 : 	int32 nStat;
; 4123 : 
; 4124 : 	for(iI = iStartStatWonder; iI < iEndStatWonder; iI++)

	mov	esi, 80					; 00000050H
	npad	9
$LL5@CheckForAl:

; 4125 : 	{
; 4126 : 		if(gDLL->GetSteamStat((ESteamStat)iI, &nStat))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+836]
	lea	edx, DWORD PTR _nStat$[esp+8]
	push	edx
	push	esi
	call	eax
	test	al, al
	je	SHORT $LN4@CheckForAl

; 4127 : 		{
; 4128 : 			if(nStat <= 0)

	cmp	DWORD PTR _nStat$[esp+8], 0
	jle	SHORT $LN11@CheckForAl
$LN4@CheckForAl:

; 4119 : 	int iI;
; 4120 : 	int iStartStatWonder = ESTEAMSTAT_ANGKORWAT;
; 4121 : 	int iEndStatWonder = ESTEAMSTAT_PYRAMIDS;		//Don't include the united nations because it was removed in BNW.
; 4122 : 	int32 nStat;
; 4123 : 
; 4124 : 	for(iI = iStartStatWonder; iI < iEndStatWonder; iI++)

	inc	esi
	cmp	esi, 106				; 0000006aH
	jl	SHORT $LL5@CheckForAl

; 4131 : 			}
; 4132 : 		}
; 4133 : 	}
; 4134 : 	return true;

	mov	al, 1
	pop	esi

; 4135 : }

	pop	ecx
	ret	0
$LN11@CheckForAl:

; 4129 : 			{
; 4130 : 				return false;

	xor	al, al
	pop	esi

; 4135 : }

	pop	ecx
	ret	0
?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ ENDP	; CvCityBuildings::CheckForAllWondersBuilt
_TEXT	ENDS
PUBLIC	?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForSevenAncientWondersBuilt
EXTRN	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z:PROC	; ExtractGUID
; Function compile flags: /Ogtpy
;	COMDAT ?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ
_TEXT	SEGMENT
_nStat$221711 = -48					; size = 4
_guid$ = -44						; size = 16
_arrWonderStats$221710 = -28				; size = 28
?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ PROC ; CvCityBuildings::CheckForSevenAncientWondersBuilt, COMDAT
; _this$ = ecx

; 4138 : {

	sub	esp, 48					; 00000030H

; 4139 : 	GUID guid;
; 4140 : 	ExtractGUID(CIV5_DLC_06_PACKAGEID, guid);

	push	0
	lea	eax, DWORD PTR _guid$[esp+52]
	push	eax
	push	OFFSET $SG92494
	call	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z	; ExtractGUID

; 4141 : 
; 4142 : 	if(gDLL->IsDLCValid(guid))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+48]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _guid$[esp+48]
	push	eax
	call	edx
	test	al, al
	je	SHORT $LN7@CheckForSe
	push	esi

; 4143 : 	{
; 4144 : 		ESteamStat arrWonderStats[7] =
; 4145 : 		{
; 4146 : 			ESTEAMSTAT_COLOSSUS,

	mov	DWORD PTR _arrWonderStats$221710[esp+52], 95 ; 0000005fH

; 4147 : 			ESTEAMSTAT_GREATLIGHTHOUSE,

	mov	DWORD PTR _arrWonderStats$221710[esp+56], 98 ; 00000062H

; 4148 : 			ESTEAMSTAT_HANGINGGARDENS,

	mov	DWORD PTR _arrWonderStats$221710[esp+60], 101 ; 00000065H

; 4149 : 			ESTEAMSTAT_PYRAMIDS,

	mov	DWORD PTR _arrWonderStats$221710[esp+64], 106 ; 0000006aH

; 4150 : 			ESTEAMSTAT_STATUEOFZEUS,

	mov	DWORD PTR _arrWonderStats$221710[esp+68], 132 ; 00000084H

; 4151 : 			ESTEAMSTAT_TEMPLEOFARTEMIS,

	mov	DWORD PTR _arrWonderStats$221710[esp+72], 133 ; 00000085H

; 4152 : 			ESTEAMSTAT_MAUSOLEUMOFHALICARNASSUS
; 4153 : 		};

	mov	DWORD PTR _arrWonderStats$221710[esp+76], 134 ; 00000086H

; 4154 : 		int32 nStat;
; 4155 : 		for(int iI = 0; iI < 7; iI++)

	xor	esi, esi
	npad	8
$LL6@CheckForSe:

; 4156 : 		{
; 4157 : 			if(gDLL->GetSteamStat(arrWonderStats[iI], &nStat))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+836]
	lea	edx, DWORD PTR _nStat$221711[esp+52]
	push	edx
	mov	edx, DWORD PTR _arrWonderStats$221710[esp+esi*4+56]
	push	edx
	call	eax
	test	al, al
	je	SHORT $LN3@CheckForSe

; 4158 : 			{
; 4159 : 				if(nStat <= 0)

	cmp	DWORD PTR _nStat$221711[esp+52], 0
	jle	SHORT $LN3@CheckForSe
	inc	esi
	cmp	esi, 7
	jl	SHORT $LL6@CheckForSe

; 4168 : 			}
; 4169 : 		}
; 4170 : 		return true;

	mov	al, 1
	pop	esi

; 4173 : }

	add	esp, 48					; 00000030H
	ret	0
$LN3@CheckForSe:

; 4160 : 				{
; 4161 : 					return false;
; 4162 : 				}
; 4163 : 			}
; 4164 : 			else
; 4165 : 			{
; 4166 : 				// Couldn't get one of the SteamStats for some reason
; 4167 : 				return false;

	xor	al, al
	pop	esi

; 4173 : }

	add	esp, 48					; 00000030H
	ret	0
$LN7@CheckForSe:

; 4171 : 	}
; 4172 : 	return false;

	xor	al, al

; 4173 : }

	add	esp, 48					; 00000030H
	ret	0
?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ ENDP ; CvCityBuildings::CheckForSevenAncientWondersBuilt
_TEXT	ENDS
PUBLIC	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0
__ehfuncinfo$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_bValid$221733 = -49					; size = 1
_iNumEntries$ = -48					; size = 4
_iDummy$221740 = -44					; size = 4
_szError$221738 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiBuildingArray$ = 12					; size = 4
?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC ; BuildingArrayHelpers::Read, COMDAT

; 4238 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebp
	push	esi

; 4239 : 	int iNumEntries;
; 4240 : 	int iType;
; 4241 : 
; 4242 : 	kStream >> iNumEntries;

	mov	esi, DWORD PTR _kStream$[esp+56]
	lea	eax, DWORD PTR _iNumEntries$[esp+60]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4243 : 
; 4244 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumEntries$[esp+60], ebp
	jle	SHORT $LN5@Read
$LL7@Read:

; 4245 : 	{
; 4246 : 		bool bValid = true;
; 4247 : 		iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$221733[esp+60]
	push	ecx
	push	esi
	mov	BYTE PTR _bValid$221733[esp+68], 1
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 4248 : 		if(iType != -1 || !bValid)

	cmp	eax, -1
	jne	SHORT $LN27@Read
	cmp	BYTE PTR _bValid$221733[esp+60], 0
	jne	SHORT $LN6@Read

; 4255 : 			{
; 4256 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$221738[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4257 : 				szError.Format("LOAD ERROR: Building Type not found");

	lea	ecx, DWORD PTR _szError$221738[esp+60]
	push	OFFSET $SG221739
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4258 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$221738[esp+60]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 4259 : 				CvAssertMsg(false, szError);
; 4260 : 				int iDummy;
; 4261 : 				kStream >> iDummy; // Skip it.

	lea	edx, DWORD PTR _iDummy$221740[esp+60]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4262 : 			}

	lea	ecx, DWORD PTR _szError$221738[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@Read:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumEntries$[esp+60]
	jl	SHORT $LL7@Read
$LN5@Read:

; 4263 : 		}
; 4264 : 	}
; 4265 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
$LN27@Read:

; 4249 : 		{
; 4250 : 			if(iType != -1)
; 4251 : 			{
; 4252 : 				kStream >> paiBuildingArray[iType];

	mov	edx, DWORD PTR _paiBuildingArray$[esp+56]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4253 : 			}
; 4254 : 			else

	jmp	SHORT $LN6@Read
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0:
	lea	ecx, DWORD PTR _szError$221738[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP ; BuildingArrayHelpers::Read
PUBLIC	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
$T228556 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiBuildingArray$ = 12					; size = 4
_iArraySize$ = 16					; size = 4
?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC ; BuildingArrayHelpers::Write, COMDAT

; 4269 : {

	push	ecx
	push	esi
	push	edi

; 4270 : 	kStream << iArraySize;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _iArraySize$[esp+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4271 : 
; 4272 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iArraySize$[esp+8], esi
	jle	SHORT $LN3@Write
	push	ebx
	mov	ebx, DWORD PTR _paiBuildingArray$[esp+12]
$LL5@Write:

; 4273 : 	{
; 4274 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
; 4275 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 4276 : 		if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN2@Write

; 4277 : 		{
; 4278 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkBuildingInfo);;

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 4279 : 			kStream << paiBuildingArray[iI];

	push	ebx

; 4280 : 		}
; 4281 : 		else

	jmp	SHORT $LN16@Write
$LN2@Write:

; 4282 : 		{
; 4283 : 			kStream << (int)0;

	lea	ecx, DWORD PTR $T228556[esp+16]
	mov	DWORD PTR $T228556[esp+16], 0
	push	ecx
$LN16@Write:
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	add	ebx, 4
	cmp	esi, DWORD PTR _iArraySize$[esp+12]
	jl	SHORT $LL5@Write
	pop	ebx
$LN3@Write:
	pop	edi
	pop	esi

; 4284 : 		}
; 4285 : 	}
; 4286 : }

	pop	ecx
	ret	0
?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP ; BuildingArrayHelpers::Write
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@XZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::end
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEAAPAVCvBuildingEntry@@XZ ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEAAPAVCvBuildingEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEAAPAVCvBuildingEntry@@XZ PROC ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEAAPAVCvBuildingEntry@@XZ ENDP ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::~_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::~_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::~_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Key
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::end
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z PROC ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingEntry@@@1@@Z ENDP ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z PROC ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ENDP ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z PROC ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE@V?$allocator@UBuildingYieldChange@@@1@@Z ENDP ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z PROC ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE@V?$allocator@UBuildingGreatWork@@@1@@Z ENDP ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z PROC ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@PAPAVCvBuildingEntry@@@Z ENDP ; std::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Vector_iterator<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN3@Lbound@2
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound@2:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound@2

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@2:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL4@Lbound@2
$LN3@Lbound@2:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEPAPAVCvBuildingEntry@@I@Z ; std::allocator<CvBuildingEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEPAPAVCvBuildingEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEPAPAVCvBuildingEntry@@I@Z PROC ; std::allocator<CvBuildingEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ; std::_Allocate<CvBuildingEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvBuildingEntry@@@std@@QAEPAPAVCvBuildingEntry@@I@Z ENDP ; std::allocator<CvBuildingEntry *>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z ; std::allocator<enum BuildingTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z PROC ; std::allocator<enum BuildingTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z ENDP ; std::allocator<enum BuildingTypes>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UBuildingYieldChange@@@std@@QAEPAUBuildingYieldChange@@I@Z ; std::allocator<BuildingYieldChange>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UBuildingYieldChange@@@std@@QAEPAUBuildingYieldChange@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UBuildingYieldChange@@@std@@QAEPAUBuildingYieldChange@@I@Z PROC ; std::allocator<BuildingYieldChange>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UBuildingYieldChange@@@std@@QAEPAUBuildingYieldChange@@I@Z ENDP ; std::allocator<BuildingYieldChange>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UBuildingGreatWork@@@std@@QAEPAUBuildingGreatWork@@I@Z ; std::allocator<BuildingGreatWork>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UBuildingGreatWork@@@std@@QAEPAUBuildingGreatWork@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UBuildingGreatWork@@@std@@QAEPAUBuildingGreatWork@@I@Z PROC ; std::allocator<BuildingGreatWork>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UBuildingGreatWork@@@std@@QAEPAUBuildingGreatWork@@I@Z ENDP ; std::allocator<BuildingGreatWork>::allocate
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Lbound@3
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound@3:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound@3

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@3:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Lbound@3
$LN3@Lbound@3:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+29], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+29], 0
	jne	SHORT $LN5@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate@2:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@2:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@2:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate@2:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@2:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@2:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec@2:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN43@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN24@Dec@2
	npad	1
$LL25@Dec@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL25@Dec@2
$LN24@Dec@2:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec@2:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Dec@2
$LL4@Dec@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL4@Dec@2
$LN3@Dec@2:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN1@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec@2:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc@2
	npad	7
$LL18@Inc@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc@2
$LN17@Inc@2:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc@2:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc@2
$LL2@Inc@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc@2:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+=
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ PROC ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ENDP ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::_Swap_adl<std::less<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC ; std::_Swap_adl<std::less<int> >, COMDAT

; 31   : 	swap(_Left, _Right);
; 32   : 	}

	ret	0
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP ; std::_Swap_adl<std::less<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z ; stdext::unchecked_copy<BuildingYieldChange *,BuildingYieldChange *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z PROC ; stdext::unchecked_copy<BuildingYieldChange *,BuildingYieldChange *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z ENDP ; stdext::unchecked_copy<BuildingYieldChange *,BuildingYieldChange *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z ; stdext::unchecked_copy<BuildingGreatWork *,BuildingGreatWork *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z PROC ; stdext::unchecked_copy<BuildingGreatWork *,BuildingGreatWork *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL9@unchecked_@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z ENDP ; stdext::unchecked_copy<BuildingGreatWork *,BuildingGreatWork *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum BuildingTypes *,enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum BuildingTypes *,enum BuildingTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum BuildingTypes *,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBuildingEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@YAXPAPAVCvBuildingEntry@@0AAV?$allocator@PAVCvBuildingEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??$fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z ; std::fill<BuildingYieldChange *,BuildingYieldChange>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z PROC ; std::fill<BuildingYieldChange *,BuildingYieldChange>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z ENDP ; std::fill<BuildingYieldChange *,BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z ; std::fill<BuildingGreatWork *,BuildingGreatWork>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z PROC ; std::fill<BuildingGreatWork *,BuildingGreatWork>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z ENDP ; std::fill<BuildingGreatWork *,BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >::SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
$T229807 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >::SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T229807[esp]
	push	edx
	mov	DWORD PTR $T229807[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >::SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const >
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >::SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
$T229818 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >::SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T229818[esp]
	push	edx
	mov	DWORD PTR $T229818[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >::SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >,SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >,SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each
	npad	2
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z ; operator<<
	add	esi, 12					; 0000000cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingYieldChange@@$$CBV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >,SerializeFromSequenceContainer<BuildingYieldChange const ,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > const > >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >,SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const > >
; Function compile flags: /Ogtpy
;	COMDAT ??$for_each@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >,SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each@2
	npad	2
$LL6@for_each@2:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z ; operator<<
	add	esi, 12					; 0000000cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each@2
$LN1@for_each@2:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUBuildingGreatWork@@$$CBV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >,SerializeFromSequenceContainer<BuildingGreatWork const ,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > const > >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUBuildingYieldChange@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<BuildingYieldChange *,BuildingYieldChange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@2
	push	esi
$LL6@Move_backw@2:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@2
	pop	esi
$LN5@Move_backw@2:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUBuildingGreatWork@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<BuildingGreatWork *,BuildingGreatWork *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z ; std::allocator<enum BuildingTypes>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z PROC ; std::allocator<enum BuildingTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z ENDP ; std::allocator<enum BuildingTypes>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@ABU3@@Z ; std::allocator<BuildingYieldChange>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@ABU3@@Z PROC ; std::allocator<BuildingYieldChange>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@ABU3@@Z ENDP ; std::allocator<BuildingYieldChange>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@@Z ; std::allocator<BuildingYieldChange>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@@Z PROC ; std::allocator<BuildingYieldChange>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UBuildingYieldChange@@@std@@QAEXPAUBuildingYieldChange@@@Z ENDP ; std::allocator<BuildingYieldChange>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@ABU3@@Z ; std::allocator<BuildingGreatWork>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@ABU3@@Z PROC ; std::allocator<BuildingGreatWork>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct@4:

; 156  : 		}

	ret	8
?construct@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@ABU3@@Z ENDP ; std::allocator<BuildingGreatWork>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@@Z ; std::allocator<BuildingGreatWork>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@@Z PROC ; std::allocator<BuildingGreatWork>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UBuildingGreatWork@@@std@@QAEXPAUBuildingGreatWork@@@Z ENDP ; std::allocator<BuildingGreatWork>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL6@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop@2:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	??_ECvThemingBonusInfo@@QAEPAXI@Z		; CvThemingBonusInfo::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvThemingBonusInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvThemingBonusInfo@@QAEPAXI@Z PROC			; CvThemingBonusInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvThemingBonusInfo@@QAE@XZ
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	48					; 00000030H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	lea	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvThemingBonusInfo@@QAEPAXI@Z ENDP			; CvThemingBonusInfo::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ; CvCityBuildings::HasBuildingClass
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
$T230201 = -4						; size = 4
$T230200 = 8						; size = 4
_eIndex$ = 8						; size = 4
?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::HasBuildingClass, COMDAT
; _this$ = ecx

; 2642 : {

	push	ecx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2643 : 	CvAssertMsg(eIndex != NO_BUILDINGCLASS, "BuildingClassTypes eIndex is expected to not be NO_BUILDINGCLASS");
; 2644 : 
; 2645 : 	for (std::vector<BuildingTypes>::const_iterator iI = m_buildingsThatExistAtLeastOnce.begin(); iI != m_buildingsThatExistAtLeastOnce.end(); ++iI)

	mov	edi, DWORD PTR [esi+64]
	cmp	edi, DWORD PTR [esi+68]
	je	SHORT $LN2@HasBuildin
	mov	ebp, DWORD PTR _eIndex$[esp+12]
$LL11@HasBuildin:

; 2646 : 	{
; 2647 : 		CvBuildingEntry* pkInfo = GC.getBuildingInfo(*iI);

	mov	eax, DWORD PTR [edi]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 2648 : 		if (pkInfo && pkInfo->GetBuildingClassType() == eIndex && GetNumBuilding(*iI) > 0)

	test	eax, eax
	je	SHORT $LN3@HasBuildin
	cmp	DWORD PTR [eax+260], ebp
	jne	SHORT $LN3@HasBuildin
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN28@HasBuildin
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T230201[esp+16], eax
	cmp	eax, ecx
	mov	DWORD PTR $T230200[esp+12], ecx
	lea	eax, DWORD PTR $T230200[esp+12]
	jl	SHORT $LN40@HasBuildin
	lea	eax, DWORD PTR $T230201[esp+16]
$LN40@HasBuildin:
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN27@HasBuildin
$LN28@HasBuildin:
	add	ecx, DWORD PTR [edx+eax*4]
$LN27@HasBuildin:
	test	ecx, ecx
	jg	SHORT $LN46@HasBuildin
$LN3@HasBuildin:

; 2643 : 	CvAssertMsg(eIndex != NO_BUILDINGCLASS, "BuildingClassTypes eIndex is expected to not be NO_BUILDINGCLASS");
; 2644 : 
; 2645 : 	for (std::vector<BuildingTypes>::const_iterator iI = m_buildingsThatExistAtLeastOnce.begin(); iI != m_buildingsThatExistAtLeastOnce.end(); ++iI)

	add	edi, 4
	cmp	edi, DWORD PTR [esi+68]
	jne	SHORT $LL11@HasBuildin
$LN2@HasBuildin:
	pop	edi
	pop	esi

; 2651 : 		}
; 2652 : 	}
; 2653 : 	return false;

	xor	al, al
	pop	ebp

; 2654 : }

	pop	ecx
	ret	4
$LN46@HasBuildin:
	pop	edi
	pop	esi

; 2649 : 		{
; 2650 : 			return true;

	mov	al, 1
	pop	ebp

; 2654 : }

	pop	ecx
	ret	4
?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::HasBuildingClass
_TEXT	ENDS
PUBLIC	?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetSellBuildingRefund
EXTRN	?getProductionNeeded@CvPlayer@@QBEHW4BuildingTypes@@@Z:PROC ; CvPlayer::getProductionNeeded
; Function compile flags: /Ogtpy
;	COMDAT ?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetSellBuildingRefund, COMDAT
; _this$ = ecx

; 2753 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2754 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2755 : 
; 2756 : 	int iRefund = GET_PLAYER(m_pCity->getOwner()).getProductionNeeded(eIndex);

	mov	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getProductionNeeded@CvPlayer@@QBEHW4BuildingTypes@@@Z ; CvPlayer::getProductionNeeded

; 2757 : 	iRefund /= /*10*/ GC.getBUILDING_SALE_DIVISOR();

	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7832

; 2758 : 
; 2759 : 	return iRefund;
; 2760 : }

	ret	4
?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetSellBuildingRefund
_TEXT	ENDS
PUBLIC	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100
EXTRN	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z:PROC ; CvGlobals::WrapCityPointer
EXTRN	?isCitySelected@CvCity@@QAE_NXZ:PROC		; CvCity::isCitySelected
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z$1
__ehfuncinfo$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T230245 = 8						; size = 4
_eIndex$ = 8						; size = 4
_pCity$220619 = 12					; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingProductionTimes100, COMDAT
; _this$ = ecx

; 2823 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 2824 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2825 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings())");
; 2826 : 
; 2827 : 	if(GetBuildingProductionTimes100(eIndex) != iNewValue)

	mov	edx, DWORD PTR _iNewValue$[esp+8]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _eIndex$[esp+12]
	mov	eax, DWORD PTR [esi+36]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	edi
	cmp	ecx, edx
	je	$LN39@SetBuildin

; 2828 : 	{
; 2829 : 		if(GetBuildingProductionTimes100(eIndex) == 0)
; 2830 : 		{
; 2831 : 			NotifyNewBuildingStarted(eIndex);
; 2832 : 		}
; 2833 : 
; 2834 : 		m_paiBuildingProduction[eIndex] = iNewValue;

	mov	DWORD PTR [eax], edx

; 2835 : 		CvAssert(GetBuildingProductionTimes100(eIndex) >= 0);
; 2836 : 
; 2837 : 		if((m_pCity->getOwner() == GC.getGame().getActivePlayer()) && m_pCity->isCitySelected())

	mov	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [edx+84]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	SHORT $LN1@SetBuildin
	mov	ecx, DWORD PTR [esi+112]
	call	?isCitySelected@CvCity@@QAE_NXZ		; CvCity::isCitySelected
	test	al, al
	je	SHORT $LN1@SetBuildin

; 2838 : 		{
; 2839 : 			GC.GetEngineUserInterface()->setDirty(CityScreen_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	21					; 00000015H
	call	edx
$LN1@SetBuildin:

; 2840 : 		}
; 2841 : 
; 2842 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(m_pCity);

	mov	eax, DWORD PTR [esi+112]
	push	eax
	lea	ecx, DWORD PTR $T230245[esp+20]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pCity$220619[esp+16], esi
	mov	eax, DWORD PTR $T230245[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	je	SHORT $LN30@SetBuildin
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN30@SetBuildin:

; 2843 : 
; 2844 : 		GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+440]
	push	0
	push	esi
	call	eax

; 2845 : 	}

	mov	DWORD PTR __$EHRec$[esp+28], -1
	test	esi, esi
	je	SHORT $LN39@SetBuildin
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN39@SetBuildin:

; 2846 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z$1:
	lea	ecx, DWORD PTR _pCity$220619[ebp-4]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingProductionTimes100
PUBLIC	?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProductionTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingProductionTimes100, COMDAT
; _this$ = ecx

; 2857 : 	SetBuildingProductionTimes100(eIndex, (GetBuildingProductionTimes100(eIndex) + iChange));

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx+eax*4]
	add	edx, DWORD PTR _iChange$[esp-4]
	mov	DWORD PTR _eIndex$[esp-4], eax
	mov	DWORD PTR _iChange$[esp-4], edx
	jmp	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100
?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingProductionTimes100
_TEXT	ENDS
PUBLIC	?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvCityBuildings::GetBuildingYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z PROC ; CvCityBuildings::GetBuildingYieldChange, COMDAT
; _this$ = ecx

; 3197 : 	for(std::vector<BuildingYieldChange>::const_iterator it = m_aBuildingYieldChange.begin(); it != m_aBuildingYieldChange.end(); ++it)

	mov	eax, DWORD PTR [ecx+80]
	mov	ecx, DWORD PTR [ecx+84]
	push	esi
	cmp	eax, ecx
	je	SHORT $LN2@GetBuildin@3
	mov	edx, DWORD PTR _eYield$[esp]
	mov	esi, DWORD PTR _eBuildingClass$[esp]
$LL11@GetBuildin@3:

; 3198 : 	{
; 3199 : 		if((*it).eBuildingClass == eBuildingClass && (*it).eYield == eYield)

	cmp	DWORD PTR [eax], esi
	jne	SHORT $LN3@GetBuildin@3
	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN28@GetBuildin@3
$LN3@GetBuildin@3:

; 3197 : 	for(std::vector<BuildingYieldChange>::const_iterator it = m_aBuildingYieldChange.begin(); it != m_aBuildingYieldChange.end(); ++it)

	add	eax, 12					; 0000000cH
	cmp	eax, ecx
	jne	SHORT $LL11@GetBuildin@3
$LN2@GetBuildin@3:

; 3202 : 		}
; 3203 : 	}
; 3204 : 
; 3205 : 	return 0;

	xor	eax, eax
	pop	esi

; 3206 : }

	ret	8
$LN28@GetBuildin@3:

; 3200 : 		{
; 3201 : 			return (*it).iChange;

	mov	eax, DWORD PTR [eax+8]
	pop	esi

; 3206 : }

	ret	8
?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z ENDP ; CvCityBuildings::GetBuildingYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
_iSlot$ = 12						; size = 4
?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z PROC ; CvCityBuildings::GetBuildingGreatWork, COMDAT
; _this$ = ecx

; 3283 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR [ecx+96]
	mov	ecx, DWORD PTR [ecx+100]
	push	esi
	cmp	eax, ecx
	je	SHORT $LN2@GetBuildin@4
	mov	edx, DWORD PTR _iSlot$[esp]
	mov	esi, DWORD PTR _eBuildingClass$[esp]
$LL11@GetBuildin@4:

; 3284 : 	{
; 3285 : 		if((*it).eBuildingClass == eBuildingClass && (*it).iSlot == iSlot)

	cmp	DWORD PTR [eax], esi
	jne	SHORT $LN3@GetBuildin@4
	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN28@GetBuildin@4
$LN3@GetBuildin@4:

; 3283 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	add	eax, 12					; 0000000cH
	cmp	eax, ecx
	jne	SHORT $LL11@GetBuildin@4
$LN2@GetBuildin@4:

; 3288 : 		}
; 3289 : 	}
; 3290 : 
; 3291 : 	return -1;

	or	eax, -1
	pop	esi

; 3292 : }

	ret	8
$LN28@GetBuildin@4:

; 3286 : 		{
; 3287 : 			return (*it).iGreatWorkIndex;

	mov	eax, DWORD PTR [eax+8]
	pop	esi

; 3292 : }

	ret	8
?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ENDP ; CvCityBuildings::GetBuildingGreatWork
_TEXT	ENDS
PUBLIC	?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ; CvCityBuildings::IsHoldingGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::IsHoldingGreatWork, COMDAT
; _this$ = ecx

; 3338 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR [ecx+96]
	mov	ecx, DWORD PTR [ecx+100]
	cmp	eax, ecx
	je	SHORT $LN2@IsHoldingG
	mov	edx, DWORD PTR _eBuildingClass$[esp-4]
	npad	2
$LL11@IsHoldingG:

; 3339 : 	{
; 3340 : 		if((*it).eBuildingClass == eBuildingClass)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN24@IsHoldingG
	add	eax, 12					; 0000000cH
	cmp	eax, ecx
	jne	SHORT $LL11@IsHoldingG
$LN2@IsHoldingG:

; 3343 : 		}
; 3344 : 	}
; 3345 : 	return false;

	xor	al, al

; 3346 : }

	ret	4
$LN24@IsHoldingG:

; 3341 : 		{
; 3342 : 			return true;

	mov	al, 1

; 3346 : }

	ret	4
?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::IsHoldingGreatWork
_TEXT	ENDS
PUBLIC	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ; CvCityBuildings::GetNumGreatWorksInBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::GetNumGreatWorksInBuilding, COMDAT
; _this$ = ecx

; 3356 : 	int iCount = 0;
; 3357 : #endif
; 3358 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	edx, DWORD PTR [ecx+96]
	mov	ecx, DWORD PTR [ecx+100]
	xor	eax, eax
	cmp	edx, ecx
	je	SHORT $LN2@GetNumGrea
	push	esi
	mov	esi, DWORD PTR _eBuildingClass$[esp]
$LL11@GetNumGrea:

; 3359 : 	{
; 3360 : 		if((*it).eBuildingClass == eBuildingClass)

	cmp	DWORD PTR [edx], esi
	jne	SHORT $LN3@GetNumGrea

; 3361 : 		{
; 3362 : 			iCount++;

	inc	eax
$LN3@GetNumGrea:

; 3356 : 	int iCount = 0;
; 3357 : #endif
; 3358 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	add	edx, 12					; 0000000cH
	cmp	edx, ecx
	jne	SHORT $LL11@GetNumGrea
	pop	esi
$LN2@GetNumGrea:

; 3363 : 		}
; 3364 : 	}
; 3365 : 	return iCount;
; 3366 : }

	ret	4
?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::GetNumGreatWorksInBuilding
_TEXT	ENDS
PUBLIC	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumAvailableGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
$T230550 = -8						; size = 4
$T230551 = -4						; size = 4
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetNumAvailableGreatWorkSlots, COMDAT
; _this$ = ecx

; 3403 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3404 : 	int iCount = 0;
; 3405 : 
; 3406 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN57@GetNumAvai
	push	edi
	npad	1
$LL60@GetNumAvai:

; 3407 : #endif
; 3408 : 	{
; 3409 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3410 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [esi+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3411 : 		if (pkCivInfo)

	test	eax, eax
	je	$LN7@GetNumAvai

; 3412 : 		{
; 3413 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	push	ebx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3414 : 			if(NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	SHORT $LN7@GetNumAvai

; 3415 : 			{
; 3416 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN12@GetNumAvai
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T230550[esp+24], ecx
	cmp	edx, ecx
	mov	DWORD PTR $T230551[esp+24], edx
	lea	ecx, DWORD PTR $T230550[esp+24]
	jl	SHORT $LN24@GetNumAvai
	lea	ecx, DWORD PTR $T230551[esp+24]
$LN24@GetNumAvai:
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN11@GetNumAvai
$LN12@GetNumAvai:
	add	ecx, DWORD PTR [edx+eax*4]
$LN11@GetNumAvai:
	test	ecx, ecx
	jle	SHORT $LN7@GetNumAvai

; 3417 : 				{
; 3418 : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3419 : 					if (pkBuilding)

	test	eax, eax
	je	SHORT $LN7@GetNumAvai

; 3420 : 					{
; 3421 : #ifdef AUI_WARNING_FIXES
; 3422 : 						uint iNumSlots = pkBuilding->GetGreatWorkCount();
; 3423 : 						uint iNumGreatWorksInBuilding = GetNumGreatWorksInBuilding(eLoopBuildingClass);
; 3424 : 						if (iNumSlots > iNumGreatWorksInBuilding)
; 3425 : 						{
; 3426 : 							iCount += iNumSlots - iNumGreatWorksInBuilding;
; 3427 : #else
; 3428 : 						int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	edx, DWORD PTR [eax+340]

; 3429 : 						int iNumOpenSlots = iNumSlots - GetNumGreatWorksInBuilding(eLoopBuildingClass);

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+100]
	xor	edi, edi
	cmp	eax, ecx
	je	SHORT $LN32@GetNumAvai
	npad	3
$LL41@GetNumAvai:
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN33@GetNumAvai
	inc	edi
$LN33@GetNumAvai:
	add	eax, 12					; 0000000cH
	cmp	eax, ecx
	jne	SHORT $LL41@GetNumAvai
$LN32@GetNumAvai:
	sub	edx, edi

; 3430 : 						if(iNumOpenSlots > 0)

	test	edx, edx
	jle	SHORT $LN7@GetNumAvai

; 3431 : 						{
; 3432 : 							iCount += iNumOpenSlots;

	add	ebp, edx
$LN7@GetNumAvai:

; 3404 : 	int iCount = 0;
; 3405 : 
; 3406 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	$LL60@GetNumAvai
	pop	edi
$LN57@GetNumAvai:
	pop	esi

; 3433 : #endif
; 3434 : 						}
; 3435 : 					}
; 3436 : 				}
; 3437 : 			}
; 3438 : 		}
; 3439 : 	}
; 3440 : 
; 3441 : 	return iCount;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 3442 : }

	add	esp, 8
	ret	0
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetNumAvailableGreatWorkSlots
_TEXT	ENDS
PUBLIC	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
$T230681 = -8						; size = 4
$T230682 = -4						; size = 4
_eSlotType$ = 8						; size = 4
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvCityBuildings::GetNumAvailableGreatWorkSlots, COMDAT
; _this$ = ecx

; 3453 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	edi
	mov	edi, ecx

; 3454 : 	int iCount = 0;
; 3455 : 
; 3456 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN36@GetNumAvai@2
	push	esi
	npad	1
$LL39@GetNumAvai@2:

; 3457 : #endif
; 3458 : 	{
; 3459 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3460 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [edi+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3461 : 		if (pkCivInfo)

	test	eax, eax
	je	SHORT $LN8@GetNumAvai@2

; 3462 : 		{
; 3463 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	push	ebx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3464 : 			if(NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	SHORT $LN8@GetNumAvai@2

; 3465 : 			{
; 3466 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN13@GetNumAvai@2
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T230681[esp+24], ecx
	cmp	edx, ecx
	mov	DWORD PTR $T230682[esp+24], edx
	lea	ecx, DWORD PTR $T230681[esp+24]
	jl	SHORT $LN25@GetNumAvai@2
	lea	ecx, DWORD PTR $T230682[esp+24]
$LN25@GetNumAvai@2:
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN12@GetNumAvai@2
$LN13@GetNumAvai@2:
	add	ecx, DWORD PTR [edx+eax*4]
$LN12@GetNumAvai@2:
	test	ecx, ecx
	jle	SHORT $LN8@GetNumAvai@2

; 3467 : 				{
; 3468 : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 3469 : 					if (pkBuilding)

	test	esi, esi
	je	SHORT $LN8@GetNumAvai@2

; 3470 : 					{
; 3471 : 						if (pkBuilding->GetGreatWorkSlotType() == eSlotType)

	mov	eax, DWORD PTR _eSlotType$[esp+20]
	cmp	DWORD PTR [esi+336], eax
	jne	SHORT $LN8@GetNumAvai@2

; 3472 : 						{
; 3473 : #ifdef AUI_WARNING_FIXES
; 3474 : 							uint iNumSlots = pkBuilding->GetGreatWorkCount();
; 3475 : 							uint iNumGreatWorksInBuilding = GetNumGreatWorksInBuilding(eLoopBuildingClass);
; 3476 : 							if (iNumSlots > iNumGreatWorksInBuilding)
; 3477 : 							{
; 3478 : 								iCount += iNumSlots - iNumGreatWorksInBuilding;
; 3479 : #else
; 3480 : 							int iNumSlots = pkBuilding->GetGreatWorkCount();
; 3481 : 							int iNumOpenSlots = iNumSlots - GetNumGreatWorksInBuilding(eLoopBuildingClass);

	push	ebx
	mov	ecx, edi
	call	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ; CvCityBuildings::GetNumGreatWorksInBuilding
	mov	ecx, DWORD PTR [esi+340]
	sub	ecx, eax

; 3482 : 							if(iNumOpenSlots > 0)

	test	ecx, ecx
	jle	SHORT $LN8@GetNumAvai@2

; 3483 : 							{
; 3484 : 								iCount += iNumOpenSlots;

	add	ebp, ecx
$LN8@GetNumAvai@2:

; 3454 : 	int iCount = 0;
; 3455 : 
; 3456 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	$LL39@GetNumAvai@2
	pop	esi
$LN36@GetNumAvai@2:
	pop	edi

; 3485 : #endif
; 3486 : 							}
; 3487 : 						}
; 3488 : 					}
; 3489 : 				}
; 3490 : 			}
; 3491 : 		}
; 3492 : 	}
; 3493 : 
; 3494 : 	return iCount;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 3495 : }

	add	esp, 8
	ret	4
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvCityBuildings::GetNumAvailableGreatWorkSlots
_TEXT	ENDS
PUBLIC	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z
_TEXT	SEGMENT
$T230751 = -8						; size = 4
$T230752 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_iSlot$ = 12						; size = 4
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z PROC ; CvCityBuildings::GetNextAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3503 : {

	sub	esp, 8

; 3504 : 	if (eBuildingClass && iSlot)

	cmp	DWORD PTR _eBuildingClass$[esp+4], 0
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	je	$LN7@GetNextAva
	cmp	DWORD PTR _iSlot$[esp+20], 0
	je	$LN7@GetNextAva

; 3505 : 	{
; 3506 : #ifdef AUI_WARNING_FIXES
; 3507 : 		CvBuildingEntry* pBuildingInfo;
; 3508 : 		CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3509 : 		if (!pCivInfo)
; 3510 : 			return false;
; 3511 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3512 : #else
; 3513 : 		for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN7@GetNextAva
$LL9@GetNextAva:

; 3514 : #endif
; 3515 : 		{
; 3516 : 			BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3517 : #ifdef AUI_WARNING_FIXES
; 3518 : 			BuildingTypes eBuilding = (BuildingTypes)pCivInfo->getCivilizationBuildings(eLoopBuildingClass);
; 3519 : #else
; 3520 : 			BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(m_pCity->getCivilizationType())->getCivilizationBuildings(eLoopBuildingClass);

	mov	ecx, DWORD PTR [edi+112]
	push	ebp
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3521 : #endif
; 3522 : 			if(NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	$LN8@GetNextAva

; 3523 : 			{
; 3524 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN14@GetNextAva
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T230751[esp+24], ecx
	cmp	edx, ecx
	mov	DWORD PTR $T230752[esp+24], edx
	lea	ecx, DWORD PTR $T230751[esp+24]
	jl	SHORT $LN26@GetNextAva
	lea	ecx, DWORD PTR $T230752[esp+24]
$LN26@GetNextAva:
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN13@GetNextAva
$LN14@GetNextAva:
	add	ecx, DWORD PTR [edx+eax*4]
$LN13@GetNextAva:
	test	ecx, ecx
	jle	SHORT $LN8@GetNextAva

; 3525 : 				{
; 3526 : #ifdef AUI_WARNING_FIXES
; 3527 : 					uint iNumSlots = 0;
; 3528 : 					pBuildingInfo = GC.getBuildingInfo(eBuilding);
; 3529 : 					if (pBuildingInfo)
; 3530 : 						iNumSlots = pBuildingInfo->GetGreatWorkCount();
; 3531 : 					for (uint jJ = 0; jJ < iNumSlots; jJ++)
; 3532 : #else
; 3533 : 					int iNumSlots = GC.getBuildingInfo(eBuilding)->GetGreatWorkCount();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, DWORD PTR [eax+340]

; 3534 : 					for (int jJ = 0; jJ < iNumSlots; jJ++)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN8@GetNextAva
	mov	ebx, DWORD PTR [edi+96]
	mov	edx, DWORD PTR [edi+100]
$LL4@GetNextAva:

; 3535 : #endif
; 3536 : 					{
; 3537 : 						if (GetBuildingGreatWork (eLoopBuildingClass, jJ) == NO_GREAT_WORK)

	mov	eax, ebx
	cmp	eax, edx
	je	SHORT $LN63@GetNextAva
	npad	2
$LL43@GetNextAva:
	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN35@GetNextAva
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN62@GetNextAva
$LN35@GetNextAva:
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL43@GetNextAva
$LN63@GetNextAva:

; 3538 : 						{
; 3539 : 							*eBuildingClass = eLoopBuildingClass;

	mov	eax, DWORD PTR _eBuildingClass$[esp+20]

; 3540 : 							*iSlot = jJ;

	mov	edx, DWORD PTR _iSlot$[esp+20]
	pop	edi
	mov	DWORD PTR [eax], ebp
	pop	esi
	pop	ebp
	mov	DWORD PTR [edx], ecx

; 3541 : 							return true;

	mov	al, 1
	pop	ebx

; 3550 : }

	add	esp, 8
	ret	8
$LN62@GetNextAva:

; 3535 : #endif
; 3536 : 					{
; 3537 : 						if (GetBuildingGreatWork (eLoopBuildingClass, jJ) == NO_GREAT_WORK)

	cmp	DWORD PTR [eax+8], -1
	je	SHORT $LN63@GetNextAva
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL4@GetNextAva
$LN8@GetNextAva:

; 3505 : 	{
; 3506 : #ifdef AUI_WARNING_FIXES
; 3507 : 		CvBuildingEntry* pBuildingInfo;
; 3508 : 		CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3509 : 		if (!pCivInfo)
; 3510 : 			return false;
; 3511 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3512 : #else
; 3513 : 		for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	$LL9@GetNextAva
$LN7@GetNextAva:
	pop	edi
	pop	esi
	pop	ebp

; 3542 : 						}
; 3543 : 					}
; 3544 : 				}
; 3545 : 			}
; 3546 : 		}
; 3547 : 	}
; 3548 : 
; 3549 : 	return false;

	xor	al, al
	pop	ebx

; 3550 : }

	add	esp, 8
	ret	8
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z ENDP ; CvCityBuildings::GetNextAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z
_TEXT	SEGMENT
$T230894 = -8						; size = 4
$T230895 = -4						; size = 4
_eGreatWorkSlot$ = 8					; size = 4
_eBuildingClass$ = 12					; size = 4
_iSlot$ = 16						; size = 4
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z PROC ; CvCityBuildings::GetNextAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3558 : {

	sub	esp, 8

; 3559 : 	if (eBuildingClass && iSlot)

	cmp	DWORD PTR _eBuildingClass$[esp+4], 0
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	je	$LN8@GetNextAva@2
	cmp	DWORD PTR _iSlot$[esp+20], 0
	je	$LN8@GetNextAva@2

; 3560 : 	{
; 3561 : #ifdef AUI_WARNING_FIXES
; 3562 : 		CvBuildingEntry* pBuildingInfo;
; 3563 : 		CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3564 : 		if (!pCivInfo)
; 3565 : 			return false;
; 3566 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3567 : #else
; 3568 : 		for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN8@GetNextAva@2
$LL10@GetNextAva@2:

; 3569 : #endif
; 3570 : 		{
; 3571 : 			BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3572 : #ifdef AUI_WARNING_FIXES
; 3573 : 			BuildingTypes eBuilding = (BuildingTypes)pCivInfo->getCivilizationBuildings(eLoopBuildingClass);
; 3574 : #else
; 3575 : 			BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(m_pCity->getCivilizationType())->getCivilizationBuildings(eLoopBuildingClass);

	mov	ecx, DWORD PTR [edi+112]
	push	ebp
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 3576 : #endif
; 3577 : 			if(NO_BUILDING != eBuilding)

	cmp	esi, -1
	je	$LN9@GetNextAva@2

; 3578 : 			{
; 3579 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [edi+52]
	jg	SHORT $LN15@GetNextAva@2
	mov	eax, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR $T230894[esp+24], eax
	cmp	ecx, eax
	mov	DWORD PTR $T230895[esp+24], ecx
	lea	eax, DWORD PTR $T230894[esp+24]
	jl	SHORT $LN27@GetNextAva@2
	lea	eax, DWORD PTR $T230895[esp+24]
$LN27@GetNextAva@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@GetNextAva@2
$LN15@GetNextAva@2:
	mov	edx, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [edx+esi*4]
	add	eax, DWORD PTR [ecx+esi*4]
$LN14@GetNextAva@2:
	test	eax, eax
	jle	SHORT $LN9@GetNextAva@2

; 3580 : 				{
; 3581 : #ifdef AUI_WARNING_FIXES
; 3582 : 					pBuildingInfo = GC.getBuildingInfo(eBuilding);
; 3583 : 					if (pBuildingInfo && pBuildingInfo->GetGreatWorkSlotType() == eGreatWorkSlot)
; 3584 : #else
; 3585 : 					if (GC.getBuildingInfo(eBuilding)->GetGreatWorkSlotType() == eGreatWorkSlot)

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edx, DWORD PTR _eGreatWorkSlot$[esp+20]
	cmp	DWORD PTR [eax+336], edx
	jne	SHORT $LN9@GetNextAva@2

; 3586 : #endif
; 3587 : 					{
; 3588 : #ifdef AUI_WARNING_FIXES
; 3589 : 						uint iNumSlots = pBuildingInfo->GetGreatWorkCount();
; 3590 : 						for (uint jJ = 0; jJ < iNumSlots; jJ++)
; 3591 : #else
; 3592 : 						int iNumSlots = GC.getBuildingInfo(eBuilding)->GetGreatWorkCount();

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, DWORD PTR [eax+340]

; 3593 : 						for (int jJ = 0; jJ < iNumSlots; jJ++)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN9@GetNextAva@2
	mov	ebx, DWORD PTR [edi+96]
	mov	edx, DWORD PTR [edi+100]
$LL4@GetNextAva@2:

; 3594 : #endif
; 3595 : 						{
; 3596 : 							if (GetBuildingGreatWork (eLoopBuildingClass, jJ) == NO_GREAT_WORK)

	mov	eax, ebx
	cmp	eax, edx
	je	SHORT $LN66@GetNextAva@2
	npad	3
$LL46@GetNextAva@2:
	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN38@GetNextAva@2
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN65@GetNextAva@2
$LN38@GetNextAva@2:
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL46@GetNextAva@2
$LN66@GetNextAva@2:

; 3597 : 							{
; 3598 : 								*eBuildingClass = eLoopBuildingClass;

	mov	eax, DWORD PTR _eBuildingClass$[esp+20]

; 3599 : 								*iSlot = jJ;

	mov	edx, DWORD PTR _iSlot$[esp+20]
	pop	edi
	mov	DWORD PTR [eax], ebp
	pop	esi
	pop	ebp
	mov	DWORD PTR [edx], ecx

; 3600 : 								return true;

	mov	al, 1
	pop	ebx

; 3610 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN65@GetNextAva@2:

; 3594 : #endif
; 3595 : 						{
; 3596 : 							if (GetBuildingGreatWork (eLoopBuildingClass, jJ) == NO_GREAT_WORK)

	cmp	DWORD PTR [eax+8], -1
	je	SHORT $LN66@GetNextAva@2
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL4@GetNextAva@2
$LN9@GetNextAva@2:

; 3560 : 	{
; 3561 : #ifdef AUI_WARNING_FIXES
; 3562 : 		CvBuildingEntry* pBuildingInfo;
; 3563 : 		CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3564 : 		if (!pCivInfo)
; 3565 : 			return false;
; 3566 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3567 : #else
; 3568 : 		for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	$LL10@GetNextAva@2
$LN8@GetNextAva@2:
	pop	edi
	pop	esi
	pop	ebp

; 3601 : 							}
; 3602 : 						}
; 3603 : 					}
; 3604 : 				}
; 3605 : 			}
; 3606 : 		}
; 3607 : 	}
; 3608 : 
; 3609 : 	return false;

	xor	al, al
	pop	ebx

; 3610 : }

	add	esp, 8
	ret	12					; 0000000cH
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ENDP ; CvCityBuildings::GetNextAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetCultureFromGreatWorks
EXTRN	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetGreatWorkYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetCultureFromGreatWorks, COMDAT
; _this$ = ecx

; 3614 : {

	push	ebx

; 3615 : 	int iCulturePerWork = GC.getBASE_CULTURE_PER_GREAT_WORK();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8208
	push	esi
	mov	esi, ecx

; 3616 : 	iCulturePerWork += GET_PLAYER(m_pCity->getOwner()).GetGreatWorkYieldChange(YIELD_CULTURE);

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	push	4
	call	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetGreatWorkYieldChange

; 3617 : 
; 3618 : 	int iRtnValue = iCulturePerWork * m_aBuildingGreatWork.size();

	mov	ecx, DWORD PTR [esi+100]
	sub	ecx, DWORD PTR [esi+96]
	add	ebx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edi, ecx

; 3619 : 	iRtnValue += GetThemingBonuses();

	mov	ecx, esi
	imul	edi, ebx
	call	?GetThemingBonuses@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetThemingBonuses
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3620 : 
; 3621 : 	return iRtnValue;
; 3622 : }

	ret	0
?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetCultureFromGreatWorks
_TEXT	ENDS
PUBLIC	?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z ; CvCityBuildings::GetYieldFromGreatWorks
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z PROC ; CvCityBuildings::GetYieldFromGreatWorks, COMDAT
; _this$ = ecx

; 3628 : 	int iYieldPerWork = GET_PLAYER(m_pCity->getOwner()).GetGreatWorkYieldChange(eIndex);

	mov	edx, DWORD PTR _eIndex$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	push	edx
	call	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetGreatWorkYieldChange

; 3629 : 	int iRtnValue = iYieldPerWork * m_aBuildingGreatWork.size();

	mov	ecx, DWORD PTR [esi+100]
	sub	ecx, DWORD PTR [esi+96]
	mov	edi, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	eax, edi
	pop	edi
	pop	esi

; 3630 : 	return iRtnValue;
; 3631 : }

	ret	4
?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z ENDP ; CvCityBuildings::GetYieldFromGreatWorks
_TEXT	ENDS
PUBLIC	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_iRtnValue$ = -4					; size = 4
_eGreatWorkSlot$ = 8					; size = 4
?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvCityBuildings::GetNumGreatWorks, COMDAT
; _this$ = ecx

; 3651 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 3652 : 	int iRtnValue = 0;
; 3653 : #endif
; 3654 : 
; 3655 : 	CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [ebp+112]
	xor	esi, esi
	mov	DWORD PTR _iRtnValue$[esp+16], esi
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ebx, eax

; 3656 : 	if (pkCivInfo)

	test	ebx, ebx
	je	SHORT $LN31@GetNumGrea@2
	push	edi

; 3657 : 	{
; 3658 : 		for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	edi, DWORD PTR [ebp+96]
	cmp	edi, DWORD PTR [ebp+100]
	je	SHORT $LN30@GetNumGrea@2
	npad	2
$LL14@GetNumGrea@2:

; 3659 : 		{
; 3660 : 			BuildingClassTypes eBldgClass = (*it).eBuildingClass;

	mov	esi, DWORD PTR [edi]

; 3661 : 			CvBuildingClassInfo *pkClassInfo = GC.getBuildingClassInfo(eBldgClass);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 3662 : 			if (pkClassInfo)

	test	eax, eax
	je	SHORT $LN5@GetNumGrea@2

; 3663 : 			{
; 3664 : 				BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eBldgClass);

	push	esi
	mov	ecx, ebx
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3665 : 				CvBuildingEntry *pkInfo = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3666 : 				if (pkInfo)

	test	eax, eax
	je	SHORT $LN5@GetNumGrea@2

; 3667 : 				{
; 3668 : 					if (pkInfo->GetGreatWorkSlotType() == eGreatWorkSlot)

	mov	ecx, DWORD PTR _eGreatWorkSlot$[esp+16]
	cmp	DWORD PTR [eax+336], ecx
	jne	SHORT $LN5@GetNumGrea@2

; 3669 : 					{
; 3670 : 						iRtnValue++;

	inc	DWORD PTR _iRtnValue$[esp+20]
$LN5@GetNumGrea@2:

; 3657 : 	{
; 3658 : 		for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	add	edi, 12					; 0000000cH
	cmp	edi, DWORD PTR [ebp+100]
	jne	SHORT $LL14@GetNumGrea@2

; 3671 : 					}
; 3672 : 				}
; 3673 : 			}
; 3674 : 		}
; 3675 : 	}
; 3676 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3677 : }

	pop	ecx
	ret	4
$LN30@GetNumGrea@2:
	pop	edi

; 3671 : 					}
; 3672 : 				}
; 3673 : 			}
; 3674 : 		}
; 3675 : 	}
; 3676 : 	return iRtnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 3677 : }

	pop	ecx
	ret	4
$LN31@GetNumGrea@2:

; 3671 : 					}
; 3672 : 				}
; 3673 : 			}
; 3674 : 		}
; 3675 : 	}
; 3676 : 	return iRtnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 3677 : }

	pop	ecx
	ret	4
?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvCityBuildings::GetNumGreatWorks
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetCityStateTradeRouteProductionModifier
EXTRN	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ:PROC ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
$T231130 = -8						; size = 4
$T231131 = -4						; size = 4
?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetCityStateTradeRouteProductionModifier, COMDAT
; _this$ = ecx

; 3778 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3779 : 	int iRtnValue = 0;
; 3780 : 
; 3781 : #ifdef AUI_WARNING_FIXES
; 3782 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3783 : #else
; 3784 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN39@GetCitySta
	push	edi
	npad	1
$LL42@GetCitySta:

; 3785 : #endif
; 3786 : 	{
; 3787 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3788 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [esi+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3789 : 		if (pkCivInfo)

	test	eax, eax
	je	$LN7@GetCitySta

; 3790 : 		{
; 3791 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	push	ebx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3792 : 			if (NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	SHORT $LN7@GetCitySta

; 3793 : 			{
; 3794 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN12@GetCitySta
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T231130[esp+24], ecx
	cmp	edx, ecx
	mov	DWORD PTR $T231131[esp+24], edx
	lea	ecx, DWORD PTR $T231130[esp+24]
	jl	SHORT $LN24@GetCitySta
	lea	ecx, DWORD PTR $T231131[esp+24]
$LN24@GetCitySta:
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN11@GetCitySta
$LN12@GetCitySta:
	add	ecx, DWORD PTR [edx+eax*4]
$LN11@GetCitySta:
	test	ecx, ecx
	jle	SHORT $LN7@GetCitySta

; 3795 : 				{
; 3796 : 					CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3797 : 					if (pkEntry)

	test	eax, eax
	je	SHORT $LN7@GetCitySta

; 3798 : 					{
; 3799 : 						int iProductionModifier = pkEntry->GetCityStateTradeRouteProductionModifier();

	mov	edi, DWORD PTR [eax+692]

; 3800 : 						int iCityStates = GET_PLAYER(m_pCity->getOwner()).GetTrade()->GetNumberOfCityStateTradeRoutes();

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes

; 3801 : 						if (iProductionModifier > 0  && iCityStates > 0)

	test	edi, edi
	jle	SHORT $LN7@GetCitySta
	test	eax, eax
	jle	SHORT $LN7@GetCitySta

; 3802 : 						{
; 3803 : 							iRtnValue = iProductionModifier * iCityStates;

	imul	eax, edi
	mov	ebp, eax
$LN7@GetCitySta:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	$LL42@GetCitySta
	pop	edi
$LN39@GetCitySta:
	pop	esi

; 3804 : 						}
; 3805 : 					}
; 3806 : 				}
; 3807 : 			}
; 3808 : 		}
; 3809 : 	}
; 3810 : 
; 3811 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 3812 : }

	add	esp, 8
	ret	0
?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetCityStateTradeRouteProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetCityStateTradeRouteGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
$T231209 = -8						; size = 4
$T231210 = -4						; size = 4
?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetCityStateTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 3817 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3818 : 	int iRtnValue = 0;
; 3819 : 
; 3820 : 	for(uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jbe	$LN39@GetCitySta@2
	push	edi
	npad	1
$LL42@GetCitySta@2:

; 3821 : 	{
; 3822 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;
; 3823 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [esi+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3824 : 		if (pkCivInfo)

	test	eax, eax
	je	$LN7@GetCitySta@2

; 3825 : 		{
; 3826 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	push	ebx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 3827 : 			if (NO_BUILDING != eBuilding)

	cmp	eax, -1
	je	SHORT $LN7@GetCitySta@2

; 3828 : 			{
; 3829 : 				if (GetNumBuilding(eBuilding) > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jg	SHORT $LN12@GetCitySta@2
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T231209[esp+24], ecx
	cmp	edx, ecx
	mov	DWORD PTR $T231210[esp+24], edx
	lea	ecx, DWORD PTR $T231209[esp+24]
	jl	SHORT $LN24@GetCitySta@2
	lea	ecx, DWORD PTR $T231210[esp+24]
$LN24@GetCitySta@2:
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN11@GetCitySta@2
$LN12@GetCitySta@2:
	add	ecx, DWORD PTR [edx+eax*4]
$LN11@GetCitySta@2:
	test	ecx, ecx
	jle	SHORT $LN7@GetCitySta@2

; 3830 : 				{
; 3831 : 					CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3832 : 					if (pkEntry)

	test	eax, eax
	je	SHORT $LN7@GetCitySta@2

; 3833 : 					{
; 3834 : 						int iGoldModifier = pkEntry->GetCityStateTradeRouteGoldModifier();

	mov	edi, DWORD PTR [eax+696]

; 3835 : 						int iCityStates = GET_PLAYER(m_pCity->getOwner()).GetTrade()->GetNumberOfCityStateTradeRoutes();

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes

; 3836 : 						if (iGoldModifier > 0  && iCityStates > 0)

	test	edi, edi
	jle	SHORT $LN7@GetCitySta@2
	test	eax, eax
	jle	SHORT $LN7@GetCitySta@2

; 3837 : 						{
; 3838 : 							iRtnValue = iGoldModifier * iCityStates;

	imul	eax, edi
	mov	ebp, eax
$LN7@GetCitySta@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jb	$LL42@GetCitySta@2
	pop	edi
$LN39@GetCitySta@2:
	pop	esi

; 3839 : 						}
; 3840 : 					}
; 3841 : 				}
; 3842 : 			}
; 3843 : 		}
; 3844 : 	}
; 3845 : 
; 3846 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 3847 : }

	add	esp, 8
	ret	0
?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetCityStateTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ; CvCityBuildings::IncrementWonderStats
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z$0
__ehfuncinfo$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_szWonderType$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::IncrementWonderStats, COMDAT
; _this$ = ecx

; 3938 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
	push	eax

; 3939 : 	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	edi
	mov	edi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 3940 : 	if(pkBuildingClassInfo == NULL)

	test	eax, eax
	je	$LN78@IncrementW

; 3941 : 		return;
; 3942 : 
; 3943 : 	const char* szWonderTypeChar = pkBuildingClassInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 3944 : 	CvString szWonderType = szWonderTypeChar;

	test	eax, eax
	jne	SHORT $LN86@IncrementW
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN86@IncrementW:
	push	esi
	push	eax
	lea	ecx, DWORD PTR _szWonderType$[esp+52]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3945 : 
; 3946 : 	if(szWonderType == "BUILDINGCLASS_HEROIC_EPIC")

	mov	esi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221578
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN76@IncrementW

; 3947 : 	{
; 3948 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HEROICEPIC);

	push	109					; 0000006dH
	jmp	$LN170@IncrementW
$LN76@IncrementW:

; 3949 : 	}
; 3950 : 	else if(szWonderType == "BUILDINGCLASS_NATIONAL_COLLEGE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221581
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN74@IncrementW

; 3951 : 	{
; 3952 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_NATIONALCOLLEGE);

	push	111					; 0000006fH
	jmp	$LN170@IncrementW
$LN74@IncrementW:

; 3953 : 	}
; 3954 : 	else if(szWonderType == "BUILDINGCLASS_NATIONAL_EPIC")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221584
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN72@IncrementW

; 3955 : 	{
; 3956 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_NATIONALEPIC);

	push	112					; 00000070H
	jmp	$LN170@IncrementW
$LN72@IncrementW:

; 3957 : 	}
; 3958 : 	else if(szWonderType == "BUILDINGCLASS_IRONWORKS")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221587
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN70@IncrementW

; 3959 : 	{
; 3960 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_IRONWORKS);

	push	110					; 0000006eH
	jmp	$LN170@IncrementW
$LN70@IncrementW:

; 3961 : 	}
; 3962 : 	else if(szWonderType == "BUILDINGCLASS_OXFORD_UNIVERSITY")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221590
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN68@IncrementW

; 3963 : 	{
; 3964 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_OXFORDUNIVERSITY);

	push	113					; 00000071H
	jmp	$LN170@IncrementW
$LN68@IncrementW:

; 3965 : 	}
; 3966 : 	else if(szWonderType == "BUILDINGCLASS_HERMITAGE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221593
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN66@IncrementW

; 3967 : 	{
; 3968 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HERMITAGE);

	push	108					; 0000006cH
	jmp	$LN170@IncrementW
$LN66@IncrementW:

; 3969 : 	}
; 3970 : 	else if(szWonderType == "BUILDINGCLASS_GREAT_LIGHTHOUSE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221596
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN64@IncrementW

; 3971 : 	{
; 3972 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATLIGHTHOUSE);

	push	98					; 00000062H
	jmp	$LN170@IncrementW
$LN64@IncrementW:

; 3973 : 	}
; 3974 : 	else if(szWonderType == "BUILDINGCLASS_STONEHENGE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221599
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN62@IncrementW

; 3975 : 	{
; 3976 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_STONEHENGE);

	push	92					; 0000005cH
	jmp	$LN170@IncrementW
$LN62@IncrementW:

; 3977 : 	}
; 3978 : 	else if(szWonderType == "BUILDINGCLASS_GREAT_LIBRARY")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221602
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN60@IncrementW

; 3979 : 	{
; 3980 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATLIBRARY);

	push	97					; 00000061H
	jmp	$LN170@IncrementW
$LN60@IncrementW:

; 3981 : 	}
; 3982 : 	else if(szWonderType == "BUILDINGCLASS_PYRAMID")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221605
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN58@IncrementW

; 3983 : 	{
; 3984 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_PYRAMIDS);

	push	106					; 0000006aH
	jmp	$LN170@IncrementW
$LN58@IncrementW:

; 3985 : 	}
; 3986 : 	else if(szWonderType == "BUILDINGCLASS_COLOSSUS")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221608
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN56@IncrementW

; 3987 : 	{
; 3988 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_COLOSSUS);

	push	95					; 0000005fH
	jmp	$LN170@IncrementW
$LN56@IncrementW:

; 3989 : 	}
; 3990 : 	else if(szWonderType == "BUILDINGCLASS_ORACLE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221611
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN54@IncrementW

; 3991 : 	{
; 3992 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_ORACLE);

	push	104					; 00000068H
	jmp	$LN170@IncrementW
$LN54@IncrementW:

; 3993 : 	}
; 3994 : 	else if(szWonderType == "BUILDINGCLASS_HANGING_GARDEN")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221614
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN52@IncrementW

; 3995 : 	{
; 3996 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HANGINGGARDENS);

	push	101					; 00000065H
	jmp	$LN170@IncrementW
$LN52@IncrementW:

; 3997 : 	}
; 3998 : 	else if(szWonderType == "BUILDINGCLASS_GREAT_WALL")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221617
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN50@IncrementW

; 3999 : 	{
; 4000 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATWALL);

	push	99					; 00000063H
	jmp	$LN170@IncrementW
$LN50@IncrementW:

; 4001 : 	}
; 4002 : 	else if(szWonderType == "BUILDINGCLASS_ANGKOR_WAT")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221620
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN48@IncrementW

; 4003 : 	{
; 4004 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_ANGKORWAT);

	push	80					; 00000050H
	jmp	$LN170@IncrementW
$LN48@IncrementW:

; 4005 : 	}
; 4006 : 	else if(szWonderType == "BUILDINGCLASS_HAGIA_SOPHIA")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221623
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN46@IncrementW

; 4007 : 	{
; 4008 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HAGIASOPHIA);

	push	100					; 00000064H
	jmp	$LN170@IncrementW
$LN46@IncrementW:

; 4009 : 	}
; 4010 : 	else if(szWonderType == "BUILDINGCLASS_CHICHEN_ITZA")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221626
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN44@IncrementW

; 4011 : 	{
; 4012 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_CHICHENITZA);

	push	83					; 00000053H
	jmp	$LN170@IncrementW
$LN44@IncrementW:

; 4013 : 	}
; 4014 : 	else if(szWonderType == "BUILDINGCLASS_MACHU_PICHU")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221629
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN42@IncrementW

; 4015 : 	{
; 4016 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_MACHUPICCHU);

	push	87					; 00000057H
	jmp	$LN170@IncrementW
$LN42@IncrementW:

; 4017 : 	}
; 4018 : 	else if(szWonderType == "BUILDINGCLASS_NOTRE_DAME")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221632
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN40@IncrementW

; 4019 : 	{
; 4020 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_NOTREDAME);

	push	88					; 00000058H
	jmp	$LN170@IncrementW
$LN40@IncrementW:

; 4021 : 	}
; 4022 : 	else if(szWonderType == "BUILDINGCLASS_PORCELAIN_TOWER")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221635
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN38@IncrementW

; 4023 : 	{
; 4024 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_PORCELAINTOWER);

	push	105					; 00000069H
	jmp	$LN170@IncrementW
$LN38@IncrementW:

; 4025 : 	}
; 4026 : 	else if(szWonderType == "BUILDINGCLASS_HIMEJI_CASTLE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221638
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN36@IncrementW

; 4027 : 	{
; 4028 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HIMEJICASTLE);

	push	86					; 00000056H
	jmp	$LN170@IncrementW
$LN36@IncrementW:

; 4029 : 	}
; 4030 : 	else if(szWonderType == "BUILDINGCLASS_SISTINE_CHAPEL")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221641
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN34@IncrementW

; 4031 : 	{
; 4032 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_SISTINECHAPEL);

	push	90					; 0000005aH
	jmp	$LN170@IncrementW
$LN34@IncrementW:

; 4033 : 	}
; 4034 : 	else if(szWonderType == "BUILDINGCLASS_KREMLIN")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221644
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN32@IncrementW

; 4035 : 	{
; 4036 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_KREMLIN);

	push	102					; 00000066H
	jmp	$LN170@IncrementW
$LN32@IncrementW:

; 4037 : 	}
; 4038 : 	else if(szWonderType == "BUILDINGCLASS_FORBIDDEN_PALACE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221647
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN30@IncrementW

; 4039 : 	{
; 4040 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_FORBIDDENPALACE);

	push	96					; 00000060H
	jmp	$LN170@IncrementW
$LN30@IncrementW:

; 4041 : 	}
; 4042 : 	else if(szWonderType == "BUILDINGCLASS_TAJ_MAHAL")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221650
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN28@IncrementW

; 4043 : 	{
; 4044 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_TAJMAHAL);

	push	94					; 0000005eH
	jmp	$LN170@IncrementW
$LN28@IncrementW:

; 4045 : 	}
; 4046 : 	else if(szWonderType == "BUILDINGCLASS_BIG_BEN")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221653
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN26@IncrementW

; 4047 : 	{
; 4048 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_BIGBEN);

	push	81					; 00000051H
	jmp	$LN170@IncrementW
$LN26@IncrementW:

; 4049 : 	}
; 4050 : 	else if(szWonderType == "BUILDINGCLASS_LOUVRE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221656
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN24@IncrementW

; 4051 : 	{
; 4052 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_LOUVRE);

	push	103					; 00000067H
	jmp	$LN170@IncrementW
$LN24@IncrementW:

; 4053 : 	}
; 4054 : 	else if(szWonderType == "BUILDINGCLASS_BRANDENBURG_GATE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221659
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN22@IncrementW

; 4055 : 	{
; 4056 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_BRANDENBURGGATE);

	push	82					; 00000052H
	jmp	$LN170@IncrementW
$LN22@IncrementW:

; 4057 : 	}
; 4058 : 	else if(szWonderType == "BUILDINGCLASS_STATUE_OF_LIBERTY")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221662
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN20@IncrementW

; 4059 : 	{
; 4060 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_STATUEOFLIBERTY);

	push	91					; 0000005bH
	jmp	$LN170@IncrementW
$LN20@IncrementW:

; 4061 : 	}
; 4062 : 	else if(szWonderType == "BUILDINGCLASS_CRISTO_REDENTOR")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221665
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN18@IncrementW

; 4063 : 	{
; 4064 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_CRISTOREDENTOR);

	push	84					; 00000054H
	jmp	$LN170@IncrementW
$LN18@IncrementW:

; 4065 : 	}
; 4066 : 	else if(szWonderType == "BUILDINGCLASS_EIFFEL_TOWER")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221668
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN16@IncrementW

; 4067 : 	{
; 4068 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_EIFFELTOWER);

	push	85					; 00000055H
	jmp	$LN170@IncrementW
$LN16@IncrementW:

; 4069 : 	}
; 4070 : 	else if(szWonderType == "BUILDINGCLASS_PENTAGON")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221671
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN14@IncrementW

; 4071 : 	{
; 4072 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_PENTAGON);

	push	89					; 00000059H
	jmp	SHORT $LN170@IncrementW
$LN14@IncrementW:

; 4073 : 	}
; 4074 : 	else if(szWonderType == "BUILDINGCLASS_UNITED_NATIONS")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221674
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN12@IncrementW

; 4075 : 	{
; 4076 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_UNITEDNATION);

	push	107					; 0000006bH
	jmp	SHORT $LN170@IncrementW
$LN12@IncrementW:

; 4077 : 	}
; 4078 : 	else if(szWonderType == "BUILDINGCLASS_SYDNEY_OPERA_HOUSE")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221677
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN10@IncrementW

; 4079 : 	{
; 4080 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_SYDNEYOPERAHOUSE);

	push	93					; 0000005dH
	jmp	SHORT $LN170@IncrementW
$LN10@IncrementW:

; 4081 : 	}
; 4082 : 	else if(szWonderType == "BUILDINGCLASS_STATUE_ZEUS")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221680
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN8@IncrementW

; 4083 : 	{
; 4084 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_STATUEOFZEUS);

	push	132					; 00000084H
	jmp	SHORT $LN170@IncrementW
$LN8@IncrementW:

; 4085 : 	}
; 4086 : 	else if(szWonderType == "BUILDINGCLASS_TEMPLE_ARTEMIS")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221683
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN6@IncrementW

; 4087 : 	{
; 4088 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_TEMPLEOFARTEMIS);

	push	133					; 00000085H
	jmp	SHORT $LN170@IncrementW
$LN6@IncrementW:

; 4089 : 	}
; 4090 : 	else if(szWonderType == "BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS")

	lea	ecx, DWORD PTR _szWonderType$[esp+48]
	push	OFFSET $SG221686
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN4@IncrementW

; 4091 : 	{
; 4092 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_MAUSOLEUMOFHALICARNASSUS);

	push	134					; 00000086H
$LN170@IncrementW:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+844]
	call	eax
$LN4@IncrementW:

; 4093 : 	}
; 4094 : 	else
; 4095 : 	{
; 4096 : 		OutputDebugString("\nNo Stat for selected Wonder: ");
; 4097 : 		OutputDebugString(szWonderType);
; 4098 : 		OutputDebugString("\n");
; 4099 : 	}
; 4100 : 
; 4101 : 	bool bCheckForWonders = false;
; 4102 : 	bCheckForWonders = CheckForAllWondersBuilt();

	mov	ecx, edi
	call	?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForAllWondersBuilt
	pop	esi

; 4103 : 	if(bCheckForWonders)

	test	al, al
	je	SHORT $LN2@IncrementW

; 4104 : 	{
; 4105 : 		gDLL->UnlockAchievement(ACHIEVEMENT_ALL_WONDERS);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	52					; 00000034H
	call	eax
$LN2@IncrementW:

; 4106 : 	}
; 4107 : 
; 4108 : 	//DLC_06
; 4109 : 	bool bCheckForAncientWonders = false;
; 4110 : 	bCheckForAncientWonders = CheckForSevenAncientWondersBuilt();

	mov	ecx, edi
	call	?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForSevenAncientWondersBuilt

; 4111 : 	if(bCheckForAncientWonders)

	test	al, al
	je	SHORT $LN1@IncrementW

; 4112 : 	{
; 4113 : 		gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ANCIENT_WONDERS);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	177					; 000000b1H
	call	eax
$LN1@IncrementW:

; 4114 : 	}
; 4115 : 
; 4116 : }

	lea	ecx, DWORD PTR _szWonderType$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN78@IncrementW:
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z$0:
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::IncrementWonderStats
PUBLIC	?begin@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@XZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::end
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN30@lower_boun@2
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@2:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun@2
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@2:
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL6@lower_boun@2
$LN30@lower_boun@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ; std::_Allocate<CvBuildingEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN32@lower_boun@3
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@3:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun@3
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@3
$LN4@lower_boun@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@3:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun@3
$LN32@lower_boun@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@lower_boun@4
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@4:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun@4
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@4
$LN4@lower_boun@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@4:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun@4
$LN30@lower_boun@4:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode
	mov	DWORD PTR [eax], 0
$LN27@Buynode:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode
	mov	DWORD PTR [ecx], 0
$LN37@Buynode:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode
	mov	DWORD PTR [ecx], 0
$LN47@Buynode:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+28], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+29], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXPAPAVCvBuildingEntry@@0@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXPAPAVCvBuildingEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXPAPAVCvBuildingEntry@@0@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXPAPAVCvBuildingEntry@@0@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<BuildingYieldChange,std::allocator<BuildingYieldChange> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<BuildingGreatWork,std::allocator<BuildingGreatWork> >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0
$LN4@Buynode@2:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T232129 = -80						; size = 28
$T232128 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T232129[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232128[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232129[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T232128[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T232128[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T232128[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T232128[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase:
$LN40@erase:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+21], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN288@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase
	mov	eax, esi
	jmp	SHORT $LN44@erase
$LN43@erase:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
	add	esp, 4
$LN44@erase:
	mov	DWORD PTR [ebx], eax
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN173@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	6
$LL18@erase:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+20], bl
	je	SHORT $LN292@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN4@erase
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase
$LN292@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+20], 0
$LN291@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T232129[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T232128[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@3
	mov	DWORD PTR [eax], 0
$LN27@Buynode@3:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@3:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@3:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+21], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvThemingBonusInfo@@@@YAXAAPAVCvThemingBonusInfo@@@Z ; SAFE_DELETE_ARRAY<CvThemingBonusInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvThemingBonusInfo@@@@YAXAAPAVCvThemingBonusInfo@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvThemingBonusInfo@@@@YAXAAPAVCvThemingBonusInfo@@@Z PROC ; SAFE_DELETE_ARRAY<CvThemingBonusInfo>, COMDAT

; 311  : {

	push	edi

; 312  : 	delete[] pkInstanceArray;

	mov	edi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN16@SAFE_DELET
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvThemingBonusInfo@@QAE@XZ
	push	ecx
	push	48					; 00000030H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN16@SAFE_DELET:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvThemingBonusInfo@@@@YAXAAPAVCvThemingBonusInfo@@@Z ENDP ; SAFE_DELETE_ARRAY<CvThemingBonusInfo>
_TEXT	ENDS
PUBLIC	??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator<<<BuildingYieldChange>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T232787 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; operator<<<BuildingYieldChange>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T232787[esp+8]
	add	eax, edx
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T232787[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@3
	npad	5
$LL22@operator@3:
	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z ; operator<<
	add	esi, 12					; 0000000cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@3
$LN34@operator@3:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; operator<<<BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator<<<BuildingGreatWork>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T232870 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; operator<<<BuildingGreatWork>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T232870[esp+8]
	add	eax, edx
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T232870[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@4
	npad	5
$LL22@operator@4:
	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z ; operator<<
	add	esi, 12					; 0000000cH
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@4
$LN34@operator@4:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; operator<<<BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z ; stdext::_Unchecked_move_backward<BuildingYieldChange *,BuildingYieldChange *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<BuildingYieldChange *,BuildingYieldChange *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<BuildingYieldChange *,BuildingYieldChange *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z ; stdext::_Unchecked_move_backward<BuildingGreatWork *,BuildingGreatWork *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<BuildingGreatWork *,BuildingGreatWork *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@2
	push	esi
$LL12@Unchecked_@2:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@2
	pop	esi
$LN11@Unchecked_@2:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<BuildingGreatWork *,BuildingGreatWork *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<BuildingYieldChange> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<BuildingGreatWork> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum BuildingTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z
_TEXT	SEGMENT
$T233125 = -4						; size = 1
__Cat$233129 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T233125[esp+4], 0
	mov	eax, DWORD PTR $T233125[esp+4]
	mov	ecx, DWORD PTR __Cat$233129[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z
_TEXT	SEGMENT
$T233134 = -4						; size = 1
__Cat$233138 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T233134[esp+4], 0
	mov	eax, DWORD PTR $T233134[esp+4]
	mov	ecx, DWORD PTR __Cat$233138[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z	; CvCityBuildings::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z PROC	; CvCityBuildings::Write, COMDAT
; _this$ = ecx

; 2565 : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 2566 : 	CvAssertMsg(m_pBuildings != NULL && m_pBuildings->GetNumBuildings() > 0, "Number of buildings to serialize is expected to greater than 0");
; 2567 : 
; 2568 : 	// Current version number
; 2569 : 	uint uiVersion = 1;
; 2570 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2571 : 
; 2572 : 	kStream << m_iNumBuildings;

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2573 : 	kStream << m_iBuildingProductionModifier;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2574 : 	kStream << m_iBuildingDefense;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2575 : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 2576 : 	kStream << m_iBuildingDefensePerCitizen;

	lea	eax, DWORD PTR [esi+12]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2577 : #endif
; 2578 : 	kStream << m_iBuildingDefenseMod;

	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2579 : 	kStream << m_iMissionaryExtraSpreads;

	lea	edx, DWORD PTR [esi+20]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2580 : 	kStream << m_iLandmarksTourismPercent;

	lea	eax, DWORD PTR [esi+24]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2581 : 	kStream << m_iGreatWorksTourismModifier;

	lea	ecx, DWORD PTR [esi+28]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2582 : 	kStream << m_bSoldBuildingThisTurn;

	lea	edx, DWORD PTR [esi+32]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2583 : 
; 2584 : #ifdef _MSC_VER
; 2585 : #pragma warning ( push )
; 2586 : #pragma warning ( disable : 6011 ) // if m_pBuildings is NULL during load, we're screwed. Redesign the class or the loader code.
; 2587 : #endif//_MSC_VER
; 2588 : 	int iNumBuildings = m_pBuildings->GetNumBuildings();

	mov	eax, DWORD PTR [esi+108]
	mov	ebx, DWORD PTR [eax+8]
	sub	ebx, DWORD PTR [eax+4]

; 2589 : #ifdef _MSC_VER
; 2590 : #pragma warning ( pop )
; 2591 : #endif//_MSC_VER
; 2592 : 
; 2593 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingProduction, iNumBuildings);

	mov	eax, DWORD PTR [esi+36]
	sar	ebx, 2
	push	ebx
	push	eax
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write

; 2594 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingProductionTime, iNumBuildings);

	mov	ecx, DWORD PTR [esi+40]
	push	ebx
	push	ecx
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write

; 2595 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingOriginalOwner, iNumBuildings);

	mov	edx, DWORD PTR [esi+44]
	push	ebx
	push	edx
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write

; 2596 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingOriginalTime, iNumBuildings);

	mov	eax, DWORD PTR [esi+48]
	push	ebx
	push	eax
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write

; 2597 : 	BuildingArrayHelpers::Write(kStream, m_paiNumRealBuilding, iNumBuildings);

	mov	ecx, DWORD PTR [esi+52]
	push	ebx
	push	ecx
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write

; 2598 : 	BuildingArrayHelpers::Write(kStream, m_paiNumFreeBuilding, iNumBuildings);

	mov	edx, DWORD PTR [esi+56]
	push	ebx
	push	edx
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 72					; 00000048H

; 2599 : 
; 2600 : 	kStream << m_aBuildingYieldChange;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	push	edi
	call	??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator<<<BuildingYieldChange>

; 2601 : 	kStream << m_aBuildingGreatWork;

	add	esi, 92					; 0000005cH
	push	esi
	push	edi
	call	??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator<<<BuildingGreatWork>
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 2602 : }

	pop	ecx
	ret	4
?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z ENDP	; CvCityBuildings::Write
_TEXT	ENDS
PUBLIC	?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z ; CvCityBuildings::IsBuildingSellable
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z$0
__ehfuncinfo$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
_TEXT	SEGMENT
_args$220511 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bResult$220512 = 8					; size = 1
_kBuilding$ = 8						; size = 4
?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z PROC ; CvCityBuildings::IsBuildingSellable, COMDAT
; _this$ = ecx

; 2670 : {

	push	-1
	push	__ehhandler$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 2671 : 	// Can't sell more than one building per turn
; 2672 : 	if(IsSoldBuildingThisTurn())

	mov	al, BYTE PTR [esi+32]
	test	al, al
	je	SHORT $LN9@IsBuilding@2

; 2673 : 		return false;

	xor	al, al
	pop	esi

; 2720 : 
; 2721 : 	return true;
; 2722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN9@IsBuilding@2:
	push	edi

; 2674 : 
; 2675 : 	// Can't sell a building if it doesn't cost us anything
; 2676 : 	
; 2677 : 	if(kBuilding.GetGoldMaintenance() <= 0)

	mov	edi, DWORD PTR _kBuilding$[esp+20]
	cmp	DWORD PTR [edi+300], 0
	jg	SHORT $LN8@IsBuilding@2
	pop	edi

; 2678 : 		return false;

	xor	al, al
	pop	esi

; 2720 : 
; 2721 : 	return true;
; 2722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN8@IsBuilding@2:
	push	ebp

; 2679 : 
; 2680 : 	// Can't sell a building if it's a shrine (no exploits)
; 2681 :     if (kBuilding.GetBuildingClassType() == (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_SHRINE"))

	mov	ebp, DWORD PTR [edi+260]
	push	0
	push	OFFSET $SG220502
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebp, eax

; 2682 :         return false;

	je	$LN50@IsBuilding@2

; 2683 : 
; 2684 : 	// Is this a free building?
; 2685 : 	if(GetNumFreeBuilding((BuildingTypes)kBuilding.GetID()) > 0)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+56]
	cmp	DWORD PTR [ecx+eax*4], 0

; 2686 : 		return false;

	jg	$LN50@IsBuilding@2

; 2687 : 
; 2688 : 	// Science building in capital that has given us a tech boost?
; 2689 : 	if(m_pCity->isCapital() && kBuilding.IsScienceBuilding())

	mov	ecx, DWORD PTR [esi+112]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN5@IsBuilding@2
	mov	ecx, edi
	call	?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsScienceBuilding
	test	al, al
	je	SHORT $LN5@IsBuilding@2

; 2690 : 	{
; 2691 : 		return !(GET_PLAYER(m_pCity->getOwner()).GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings());

	mov	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	xor	ecx, ecx
	cmp	BYTE PTR [eax+331], cl
	pop	ebp
	sete	cl
	pop	edi
	mov	al, cl
	pop	esi

; 2720 : 
; 2721 : 	return true;
; 2722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN5@IsBuilding@2:

; 2692 : 	}
; 2693 : 
; 2694 : 	// Great Work present in this one?
; 2695 : 	const BuildingClassTypes buildingClassType = (BuildingClassTypes) kBuilding.GetBuildingClassType();

	mov	eax, DWORD PTR [edi+260]

; 2696 : 	if (IsHoldingGreatWork(buildingClassType))

	push	eax
	mov	ecx, esi
	call	?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ; CvCityBuildings::IsHoldingGreatWork
	test	al, al

; 2697 : 	{
; 2698 : 		return false;

	jne	$LN50@IsBuilding@2

; 2699 : 	}
; 2700 : 
; 2701 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ebp, eax

; 2702 : 	if(pkScriptSystem)

	test	ebp, ebp
	je	$LN3@IsBuilding@2

; 2703 : 	{
; 2704 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$220511[esp+28]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 2705 : 		args->Push(m_pCity->getOwner());

	mov	ecx, DWORD PTR [esi+112]
	mov	eax, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR _args$220511[esp+28]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	eax

; 2706 : 		args->Push(kBuilding.GetID());

	mov	ecx, DWORD PTR _args$220511[esp+28]
	mov	edi, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 2707 : 
; 2708 : 		// Attempt to execute the game events.
; 2709 : 		// Will return false if there are no registered listeners.
; 2710 : 		bool bResult = false;
; 2711 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "CityBuildingsIsBuildingSellable", args.get(), bResult))

	mov	edx, DWORD PTR _args$220511[esp+28]
	lea	ecx, DWORD PTR _bResult$220512[esp+24]
	push	ecx
	push	edx
	push	OFFSET $SG220514
	push	ebp
	mov	BYTE PTR _bResult$220512[esp+40], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN1@IsBuilding@2

; 2712 : 		{
; 2713 : 			// Check the result.
; 2714 : 			if(bResult == false)

	cmp	BYTE PTR _bResult$220512[esp+24], 0
	jne	SHORT $LN1@IsBuilding@2

; 2715 : 			{
; 2716 : 				return false;

	lea	ecx, DWORD PTR _args$220511[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN50@IsBuilding@2:
	pop	ebp
	pop	edi
	xor	al, al
	pop	esi

; 2720 : 
; 2721 : 	return true;
; 2722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN1@IsBuilding@2:

; 2717 : 			}
; 2718 : 		}
; 2719 : 	}

	lea	ecx, DWORD PTR _args$220511[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@IsBuilding@2:

; 2720 : 
; 2721 : 	return true;
; 2722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	ebp
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z$0:
	lea	ecx, DWORD PTR _args$220511[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z ENDP ; CvCityBuildings::IsBuildingSellable
PUBLIC	?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProduction
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingProduction, COMDAT
; _this$ = ecx

; 2818 : 	SetBuildingProductionTimes100(eIndex, iNewValue*100);

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iNewValue$[esp-4], eax
	jmp	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100
?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingProduction
_TEXT	ENDS
PUBLIC	?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProduction
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingProduction, COMDAT
; _this$ = ecx

; 2851 : 	ChangeBuildingProductionTimes100(eIndex, iChange*100);

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR [ecx+36]
	push	esi
	mov	esi, DWORD PTR _iChange$[esp]
	imul	esi, 100				; 00000064H
	add	esi, DWORD PTR [edx+eax*4]
	push	esi
	push	eax
	call	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100
	pop	esi

; 2852 : }

	ret	8
?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingProduction
_TEXT	ENDS
PUBLIC	?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ; CvCityBuildings::SetNumRealBuildingTimed
EXTRN	??3CvDllPlot@@SAXPAX@Z:PROC			; CvDllPlot::operator delete
EXTRN	??3CvDllCity@@SAXPAX@Z:PROC			; CvDllCity::operator delete
EXTRN	?FinishedBuilding@CvPlayerAchievements@@QAEXPAVCvCity@@W4BuildingTypes@@@Z:PROC ; CvPlayerAchievements::FinishedBuilding
EXTRN	?updateStrengthValue@CvCity@@QAEXXZ:PROC	; CvCity::updateStrengthValue
EXTRN	?incrementBuildingClassCreatedCount@CvGame@@QAEXW4BuildingClassTypes@@@Z:PROC ; CvGame::incrementBuildingClassCreatedCount
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z:PROC ; CvGame::addReplayMessage
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	?isFinalInitialized@CvGame@@QBE_NXZ:PROC	; CvGame::isFinalInitialized
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	??0CvDllPlot@@QAE@PAVCvPlot@@@Z:PROC		; CvDllPlot::CvDllPlot
EXTRN	??2CvDllPlot@@SAPAXI@Z:PROC			; CvDllPlot::operator new
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvCity@@QBE_NXZ:PROC			; CvCity::isHuman
EXTRN	?changeNumNationalWonders@CvCity@@QAEXH@Z:PROC	; CvCity::changeNumNationalWonders
EXTRN	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isNationalWonderClass
EXTRN	?changeNumTeamWonders@CvCity@@QAEXH@Z:PROC	; CvCity::changeNumTeamWonders
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
EXTRN	?ChangeNumWonders@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumWonders
EXTRN	?changeNumWorldWonders@CvCity@@QAEXH@Z:PROC	; CvCity::changeNumWorldWonders
EXTRN	?isNoLimit@CvBuildingClassInfo@@QBE_NXZ:PROC	; CvBuildingClassInfo::isNoLimit
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	??0CvDllCity@@QAE@PAVCvCity@@@Z:PROC		; CvDllCity::CvDllCity
EXTRN	??2CvDllCity@@SAPAXI@Z:PROC			; CvDllCity::operator new
EXTRN	?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeBaseBuildingGoldMaintenance
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z:PROC ; CvCity::processBuilding
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_pPlayer$ = -792					; size = 4
_buildingEntry$ = -788					; size = 4
tv1399 = -784						; size = 4
$T233302 = -784						; size = 4
$T233288 = -784						; size = 4
_pDllPlot$220788 = -784					; size = 4
$T233284 = -784						; size = 4
_pDllCity$220721 = -784					; size = 4
_iI$220833 = -780					; size = 4
_kBuildingClassInfo$ = -780				; size = 4
tv1564 = -776						; size = 4
$T233609 = -776						; size = 4
_iNumResources$220798 = -776				; size = 4
_this$ = -772						; size = 4
_pCity$220859 = -768					; size = 4
_buildingClassType$ = -768				; size = 4
_localizedText$220809 = -764				; size = 80
$T233293 = -684						; size = 28
_szBuildingType$220711 = -656				; size = 28
$T233300 = -628						; size = 80
$T233297 = -628						; size = 80
$T233294 = -628						; size = 80
_kPopup$220831 = -548					; size = 536
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
_bFirst$ = 16						; size = 1
_eOriginalOwner$ = 20					; size = 4
_iOriginalTime$ = 24					; size = 4
?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z PROC ; CvCityBuildings::SetNumRealBuildingTimed, COMDAT
; _this$ = ecx

; 2932 : {

	push	-1
	push	__ehhandler$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 780				; 0000030cH
	push	ebx

; 2933 : 	CvPlayer* pPlayer = &GET_PLAYER(m_pCity->getOwner());
; 2934 : 
; 2935 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2936 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2937 : 
; 2938 : 	int iChangeNumRealBuilding = iNewValue - GetNumRealBuilding(eIndex);

	mov	ebx, DWORD PTR _eIndex$[esp+792]
	push	ebp
	mov	ebp, DWORD PTR _iNewValue$[esp+796]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+112]
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [esi+52]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	DWORD PTR _pPlayer$[esp+808], eax
	mov	eax, DWORD PTR [ecx+ebx*4]

; 2939 : 
; 2940 : 	CvBuildingEntry* buildingEntry = GC.getBuildingInfo(eIndex);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+812], esi
	sub	ebp, eax
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 2941 : 	const BuildingClassTypes buildingClassType = (BuildingClassTypes) buildingEntry->GetBuildingClassType();
; 2942 : 	const CvBuildingClassInfo& kBuildingClassInfo = buildingEntry->GetBuildingClassInfo();

	cmp	DWORD PTR [edi+264], 0
	mov	edx, DWORD PTR [edi+260]
	mov	DWORD PTR _buildingEntry$[esp+808], edi
	mov	DWORD PTR _buildingClassType$[esp+808], edx
	jne	SHORT $LN78@SetNumReal
	push	OFFSET $SG219105
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage
$LN78@SetNumReal:
	mov	eax, DWORD PTR [edi+264]
	mov	DWORD PTR _kBuildingClassInfo$[esp+808], eax

; 2943 : 
; 2944 : 	if(iChangeNumRealBuilding != 0)

	test	ebp, ebp
	je	$LN49@SetNumReal

; 2945 : 	{
; 2946 : 		int iOldNumBuilding = GetNumBuilding(eIndex);

	push	ebx
	mov	ecx, esi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding

; 2947 : 
; 2948 : 		m_paiNumRealBuilding[eIndex] = iNewValue;

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR _iNewValue$[esp+804]
	mov	edi, eax
	mov	DWORD PTR [ecx+ebx*4], edx

; 2949 : 
; 2950 : 		if(GetNumRealBuilding(eIndex) > 0)

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+ebx*4]
	test	eax, eax
	jle	SHORT $LN48@SetNumReal

; 2951 : 		{
; 2952 : 			SetBuildingOriginalOwner(eIndex, eOriginalOwner);

	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR _eOriginalOwner$[esp+804]
	mov	DWORD PTR [ecx+ebx*4], edx

; 2953 : 			SetBuildingOriginalTime(eIndex, iOriginalTime);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _iOriginalTime$[esp+804]
	mov	DWORD PTR [eax+ebx*4], ecx

; 2954 : 		}
; 2955 : 		else

	jmp	SHORT $LN89@SetNumReal
$LN48@SetNumReal:

; 2956 : 		{
; 2957 : 			SetBuildingOriginalOwner(eIndex, NO_PLAYER);

	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [edx+ebx*4], -1

; 2958 : 			SetBuildingOriginalTime(eIndex, MIN_INT);

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax+ebx*4], -2147483648	; 80000000H
$LN89@SetNumReal:

; 2959 : 		}
; 2960 : 
; 2961 : 		// Process building effects
; 2962 : 		if(iOldNumBuilding != GetNumBuilding(eIndex))

	push	ebx
	mov	ecx, esi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	cmp	edi, eax
	je	SHORT $LN334@SetNumReal

; 2963 : 		{
; 2964 : 			m_pCity->processBuilding(eIndex, iChangeNumRealBuilding, bFirst);

	mov	ecx, DWORD PTR _bFirst$[esp+804]
	push	0
	push	0
	push	ecx
	mov	ecx, DWORD PTR [esi+112]
	push	ebp
	push	ebx
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding
$LN334@SetNumReal:

; 2965 : 		}
; 2966 : 
; 2967 : 		// Maintenance cost
; 2968 : 		if(buildingEntry->GetGoldMaintenance() != 0)

	mov	edi, DWORD PTR _buildingEntry$[esp+808]
	mov	eax, DWORD PTR [edi+300]
	test	eax, eax
	je	SHORT $LN335@SetNumReal

; 2969 : 		{
; 2970 : 			pPlayer->GetTreasury()->ChangeBaseBuildingGoldMaintenance(buildingEntry->GetGoldMaintenance() * iChangeNumRealBuilding);

	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	imul	eax, ebp
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseBuildingGoldMaintenance
$LN335@SetNumReal:

; 2971 : 		}
; 2972 : 
; 2973 : 		//Achievement for Temples
; 2974 : 		const char* szBuildingTypeC = buildingEntry->GetType();

	lea	ecx, DWORD PTR [edi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 2975 : 		CvString szBuildingType = szBuildingTypeC;

	test	eax, eax
	jne	SHORT $LN100@SetNumReal
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN100@SetNumReal:
	push	eax
	lea	ecx, DWORD PTR _szBuildingType$220711[esp+812]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2976 : 		if(szBuildingType == "BUILDING_TEMPLE")

	lea	edx, DWORD PTR _szBuildingType$220711[esp+808]
	push	OFFSET $SG220713
	push	edx
	mov	DWORD PTR __$EHRec$[esp+824], 0
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN336@SetNumReal

; 2977 : 		{
; 2978 : 			if(m_pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [eax+84]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	SHORT $LN336@SetNumReal

; 2979 : 			{
; 2980 : 				gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_TEMPLES, 1000, ACHIEVEMENT_1000TEMPLES);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+848]
	push	97					; 00000061H
	push	1000					; 000003e8H
	push	121					; 00000079H
	call	eax
$LN336@SetNumReal:

; 2981 : 			}
; 2982 : 		}
; 2983 : 
; 2984 : 		if(buildingEntry->GetPreferredDisplayPosition() > 0)

	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	mov	eax, DWORD PTR [ecx+708]
	test	eax, eax
	jle	$LN337@SetNumReal

; 2985 : 		{
; 2986 : 			auto_ptr<ICvCity1> pDllCity(new CvDllCity(m_pCity)); //-V689

	push	12					; 0000000cH
	call	??2CvDllCity@@SAPAXI@Z			; CvDllCity::operator new
	add	esp, 4
	mov	DWORD PTR $T233284[esp+808], eax
	mov	BYTE PTR __$EHRec$[esp+816], 1
	test	eax, eax
	je	SHORT $LN52@SetNumReal
	mov	edx, DWORD PTR [esi+112]
	push	edx
	mov	ecx, eax
	call	??0CvDllCity@@QAE@PAVCvCity@@@Z		; CvDllCity::CvDllCity
	mov	edi, eax
	jmp	SHORT $LN53@SetNumReal
$LN52@SetNumReal:
	xor	edi, edi
$LN53@SetNumReal:
	mov	DWORD PTR _pDllCity$220721[esp+808], edi

; 2987 : 
; 2988 : 			if(iNewValue > 0)

	cmp	DWORD PTR _iNewValue$[esp+804], 0
	mov	BYTE PTR __$EHRec$[esp+816], 2
	jle	SHORT $LN41@SetNumReal

; 2989 : 			{
; 2990 : 				// if this is a WW that (likely has a half-built state)
; 2991 : 				if(isWorldWonderClass(kBuildingClassInfo))

	mov	eax, DWORD PTR _kBuildingClassInfo$[esp+808]
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4

; 2992 : 				{
; 2993 : 					if(GetBuildingProduction(eIndex))
; 2994 : 					{
; 2995 : 						GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_EDITED, pDllCity.get(), eIndex, 1);

	push	1
	push	ebx
	push	edi
	test	al, al
	je	SHORT $LN40@SetNumReal
	mov	ecx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+532]
	je	SHORT $LN39@SetNumReal
	push	2

; 2996 : 					}
; 2997 : 					else

	jmp	SHORT $LN340@SetNumReal
$LN39@SetNumReal:

; 2998 : 					{
; 2999 : 						GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_CREATED, pDllCity.get(), eIndex, 1);

	push	1

; 3000 : 					}
; 3001 : 				}
; 3002 : 				else

	jmp	SHORT $LN340@SetNumReal
$LN40@SetNumReal:

; 3003 : 				{
; 3004 : 					GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_CREATED, pDllCity.get(), eIndex, 1);

	push	1

; 3005 : 				}
; 3006 : 			}
; 3007 : 			else

	jmp	SHORT $LN341@SetNumReal
$LN41@SetNumReal:

; 3008 : 			{
; 3009 : 				GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), eIndex, 0);

	push	0
	push	ebx
	push	edi
	push	3
$LN341@SetNumReal:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+532]
$LN340@SetNumReal:
	call	eax

; 3010 : 			}
; 3011 : 		}

	mov	BYTE PTR __$EHRec$[esp+816], 0
	test	edi, edi
	je	SHORT $LN337@SetNumReal
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN337@SetNumReal:

; 3012 : 
; 3013 : 		if(!(kBuildingClassInfo.isNoLimit()))

	mov	edi, DWORD PTR _kBuildingClassInfo$[esp+808]
	mov	ecx, edi
	call	?isNoLimit@CvBuildingClassInfo@@QBE_NXZ	; CvBuildingClassInfo::isNoLimit
	test	al, al
	jne	SHORT $LN139@SetNumReal

; 3014 : 		{
; 3015 : 			if(isWorldWonderClass(kBuildingClassInfo))

	push	edi
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN34@SetNumReal

; 3016 : 			{
; 3017 : 				m_pCity->changeNumWorldWonders(iChangeNumRealBuilding);

	mov	ecx, DWORD PTR [esi+112]
	push	ebp
	call	?changeNumWorldWonders@CvCity@@QAEXH@Z	; CvCity::changeNumWorldWonders

; 3018 : 				pPlayer->ChangeNumWonders(iChangeNumRealBuilding);

	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	push	ebp
	call	?ChangeNumWonders@CvPlayer@@QAEXH@Z	; CvPlayer::ChangeNumWonders
	jmp	SHORT $LN139@SetNumReal
$LN34@SetNumReal:

; 3019 : 			}
; 3020 : 			else if(isTeamWonderClass(kBuildingClassInfo))

	push	edi
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN32@SetNumReal

; 3021 : 			{
; 3022 : 				m_pCity->changeNumTeamWonders(iChangeNumRealBuilding);

	mov	ecx, DWORD PTR [esi+112]
	push	ebp
	call	?changeNumTeamWonders@CvCity@@QAEXH@Z	; CvCity::changeNumTeamWonders
	jmp	SHORT $LN139@SetNumReal
$LN32@SetNumReal:

; 3023 : 			}
; 3024 : 			else if(isNationalWonderClass(kBuildingClassInfo))

	push	edi
	call	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isNationalWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN30@SetNumReal

; 3025 : 			{
; 3026 : 				m_pCity->changeNumNationalWonders(iChangeNumRealBuilding);

	mov	ecx, DWORD PTR [esi+112]
	push	ebp
	call	?changeNumNationalWonders@CvCity@@QAEXH@Z ; CvCity::changeNumNationalWonders

; 3027 : 				if(m_pCity->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR [esi+112]
	call	?isHuman@CvCity@@QBE_NXZ		; CvCity::isHuman
	test	al, al
	je	SHORT $LN139@SetNumReal
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN139@SetNumReal

; 3028 : 				{
; 3029 : 					IncrementWonderStats(buildingClassType);

	mov	eax, DWORD PTR _buildingClassType$[esp+808]
	push	eax
	mov	ecx, esi
	call	?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ; CvCityBuildings::IncrementWonderStats

; 3030 : 				}
; 3031 : 			}
; 3032 : 			else

	jmp	SHORT $LN139@SetNumReal
$LN30@SetNumReal:

; 3033 : 			{
; 3034 : 				ChangeNumBuildings(iChangeNumRealBuilding);

	add	DWORD PTR [esi], ebp
$LN139@SetNumReal:

; 3035 : 			}
; 3036 : 		}
; 3037 : 
; 3038 : 		if(buildingEntry->IsCityWall())

	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	cmp	BYTE PTR [ecx+736], 0
	je	SHORT $LN151@SetNumReal

; 3039 : 		{
; 3040 : 			auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(m_pCity->plot()));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T233288[esp+808], edi
	mov	BYTE PTR __$EHRec$[esp+816], 3
	test	edi, edi
	je	SHORT $LN54@SetNumReal
	mov	ecx, DWORD PTR [esi+112]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, edi
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	edi, eax
	jmp	SHORT $LN55@SetNumReal
$LN54@SetNumReal:
	xor	edi, edi
$LN55@SetNumReal:
	mov	DWORD PTR _pDllPlot$220788[esp+808], edi

; 3041 : 			gDLL->GameplayWallCreated(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+704]
	push	edi
	mov	BYTE PTR __$EHRec$[esp+820], 4
	call	eax

; 3042 : 		}

	mov	BYTE PTR __$EHRec$[esp+816], 0
	test	edi, edi
	je	SHORT $LN151@SetNumReal
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN151@SetNumReal:

; 3043 : 
; 3044 : 		// Update the amount of a Resource used up by this Building
; 3045 : 		int iNumResources = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos

; 3046 : 		for(int iResourceLoop = 0; iResourceLoop < iNumResources; iResourceLoop++)

	xor	edi, edi
	mov	DWORD PTR _iNumResources$220798[esp+808], eax
	test	eax, eax
	jle	SHORT $LN338@SetNumReal
$LL26@SetNumReal:

; 3047 : 		{
; 3048 : 			if(buildingEntry->GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	eax, DWORD PTR _buildingEntry$[esp+808]
	mov	eax, DWORD PTR [eax+844]
	test	eax, eax
	je	SHORT $LN25@SetNumReal
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	jle	SHORT $LN25@SetNumReal

; 3049 : 			{
; 3050 : 				pPlayer->changeNumResourceUsed((ResourceTypes) iResourceLoop, iChangeNumRealBuilding * buildingEntry->GetResourceQuantityRequirement(iResourceLoop));

	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	imul	eax, ebp
	push	eax
	push	edi
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN25@SetNumReal:
	inc	edi
	cmp	edi, DWORD PTR _iNumResources$220798[esp+808]
	jl	SHORT $LL26@SetNumReal
$LN338@SetNumReal:

; 3051 : 			}
; 3052 : 		}
; 3053 : 
; 3054 : 		if(iChangeNumRealBuilding > 0)

	test	ebp, ebp
	jle	$LN21@SetNumReal

; 3055 : 		{
; 3056 : 			if(bFirst)

	cmp	BYTE PTR _bFirst$[esp+804], 0
	je	$LN21@SetNumReal

; 3057 : 			{
; 3058 : 				if(GC.getGame().isFinalInitialized()/* && !(gDLL->GetWorldBuilderMode() )*/)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN19@SetNumReal

; 3059 : 				{
; 3060 : 					// World Wonder Notification
; 3061 : 					if(isWorldWonderClass(kBuildingClassInfo))

	mov	ecx, DWORD PTR _kBuildingClassInfo$[esp+808]
	push	ecx
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	je	$LN19@SetNumReal

; 3062 : 					{
; 3063 : 						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_COMPLETES_WONDER");

	lea	edx, DWORD PTR _localizedText$220809[esp+808]
	push	OFFSET $SG220811
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 3064 : 						localizedText << pPlayer->getNameKey() << buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 5
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	mov	edi, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp
	push	edi
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp

; 3065 : 						GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_pCity->getOwner(), localizedText.toUTF8(), m_pCity->getX(), m_pCity->getY());

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _localizedText$220809[esp+808]
	call	edi
	test	eax, eax
	jne	SHORT $LN171@SetNumReal
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN171@SetNumReal:
	push	eax
	lea	ecx, DWORD PTR $T233293[esp+812]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	mov	eax, DWORD PTR [eax+84]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T233293[esp+816]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	mov	BYTE PTR __$EHRec$[esp+836], 6
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
	lea	ecx, DWORD PTR $T233293[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3066 : 
; 3067 : 						bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+456]
	call	eax

; 3068 : 
; 3069 : 						// Notification in MP games
; 3070 : 						if(bDontShowRewardPopup || GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)

	test	al, al
	jne	$LN17@SetNumReal
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	$LN17@SetNumReal

; 3078 : 							}
; 3079 : 						}
; 3080 : 						// Popup in SP games
; 3081 : 						else
; 3082 : 						{
; 3083 : 							if(m_pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR [esi+112]
	mov	edx, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233609[esp+808], edx
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T233609[esp+808], eax
	jne	$LN332@SetNumReal

; 3084 : 							{
; 3085 : 								CvPopupInfo kPopup(BUTTONPOPUP_WONDER_COMPLETED_ACTIVE_PLAYER, eIndex);
; 3086 : 								GC.GetEngineUserInterface()->AddPopup(kPopup);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	or	eax, -1
	mov	DWORD PTR _kPopup$220831[esp+812], eax
	mov	DWORD PTR _kPopup$220831[esp+816], eax
	mov	DWORD PTR _kPopup$220831[esp+808], ebx
	mov	DWORD PTR _kPopup$220831[esp+820], 0
	mov	BYTE PTR _kPopup$220831[esp+824], 0
	mov	BYTE PTR _kPopup$220831[esp+825], 0
	mov	DWORD PTR _kPopup$220831[esp+828], 69	; 00000045H
	mov	BYTE PTR _kPopup$220831[esp+832], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+180]
	lea	edx, DWORD PTR _kPopup$220831[esp+808]
	push	edx
	call	eax

; 3087 : 
; 3088 : 								if(GET_PLAYER(GC.getGame().getActivePlayer()).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN332@SetNumReal

; 3089 : 								{
; 3090 : 									gDLL->UnlockAchievement(ACHIEVEMENT_BUILD_WONDER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	44					; 0000002cH
	call	eax

; 3091 : 
; 3092 : 									//look to see if all wonders have been built to unlock the other one
; 3093 : 									IncrementWonderStats(buildingClassType);

	mov	ecx, DWORD PTR _buildingClassType$[esp+808]
	push	ecx
	mov	ecx, esi
	call	?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ; CvCityBuildings::IncrementWonderStats
	jmp	$LN332@SetNumReal
$LN17@SetNumReal:

; 3071 : 						{
; 3072 : 							CvNotifications* pNotifications = GET_PLAYER(m_pCity->getOwner()).GetNotifications();

	mov	edx, DWORD PTR [esi+112]
	mov	eax, DWORD PTR [edx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3073 : 							if(pNotifications)

	test	esi, esi
	je	$LN332@SetNumReal

; 3074 : 							{
; 3075 : 								localizedText = Localization::Lookup("TXT_KEY_MISC_WONDER_COMPLETED");

	lea	eax, DWORD PTR $T233294[esp+808]
	push	OFFSET $SG220826
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	mov	BYTE PTR __$EHRec$[esp+820], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T233294[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 5
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3076 : 								localizedText << pPlayer->getNameKey() << buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	mov	ebx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp
	push	ebx
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp

; 3077 : 								pNotifications->Add(NOTIFICATION_WONDER_COMPLETED_ACTIVE_PLAYER, localizedText.toUTF8(), localizedText.toUTF8(), m_pCity->getX(), m_pCity->getY(), eIndex, pPlayer->GetID());

	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _this$[esp+808]
	mov	eax, DWORD PTR [edx+112]
	mov	edx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ecx
	mov	ecx, DWORD PTR _eIndex$[esp+808]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+824]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+828]
	call	edi
	push	eax
	push	-1686889601				; 9b741b7fH
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN332@SetNumReal:

; 3094 : 
; 3095 : 								}
; 3096 : 							}
; 3097 : 						}
; 3098 : 
; 3099 : 						// Wonder notification for all other players
; 3100 : 						for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	xor	eax, eax
	mov	DWORD PTR _iI$220833[esp+808], eax
	mov	DWORD PTR tv1564[esp+808], eax
	npad	9
$LL333@SetNumReal:

; 3101 : 						{
; 3102 : 							CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1564[esp+808]

; 3103 : 							if(thisPlayer.isAlive())

	cmp	BYTE PTR [eax+edx+2256], 0
	lea	esi, DWORD PTR [eax+edx]
	je	$LN2@SetNumReal

; 3104 : 							{
; 3105 : 								// Owner already got his messaging
; 3106 : 								if(iI != m_pCity->getOwner())

	mov	ecx, DWORD PTR _this$[esp+808]
	mov	ecx, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _iI$220833[esp+808]
	cmp	edx, DWORD PTR [ecx+84]
	je	$LN2@SetNumReal

; 3107 : 								{
; 3108 : 									// If the builder is met, and the city is revealed
; 3109 : 									// Special case for DLC_06 Scenario: Always show the more informative notification
; 3110 : 									if((m_pCity->plot()->isRevealed(thisPlayer.getTeam()) && GET_TEAM(thisPlayer.getTeam()).isHasMet(m_pCity->getTeam())) || gDLL->IsModActivated(CIV5_DLC_06_SCENARIO_MODID))

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN246@SetNumReal
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN247@SetNumReal
$LN246@SetNumReal:
	or	ebx, -1
$LN247@SetNumReal:
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, ebx
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv1399[esp+808], ecx
	mov	ecx, ebx
	mov	ebx, DWORD PTR tv1399[esp+808]
	sub	ecx, ebx
	mov	ebx, 1
	shl	ebx, cl
	test	ebx, DWORD PTR [eax+edx*4+8]
	je	SHORT $LN331@SetNumReal
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN259@SetNumReal
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN260@SetNumReal
$LN259@SetNumReal:
	or	eax, -1
$LN260@SetNumReal:
	mov	edx, DWORD PTR _this$[esp+808]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [edx+112]
	mov	ebx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	jne	SHORT $LN6@SetNumReal
$LN331@SetNumReal:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+44]
	push	OFFSET $SG92486
	call	edx
	test	al, al
	je	$LN7@SetNumReal
$LN6@SetNumReal:

; 3111 : 									{
; 3112 : 										CvNotifications* pNotifications = thisPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 3113 : 										if(pNotifications)

	test	ebx, ebx
	je	$LN2@SetNumReal

; 3114 : 										{
; 3115 : 											localizedText = Localization::Lookup("TXT_KEY_MISC_WONDER_COMPLETED");

	lea	eax, DWORD PTR $T233297[esp+808]
	push	OFFSET $SG220847
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	mov	BYTE PTR __$EHRec$[esp+820], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T233297[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 5
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3116 : 											localizedText << pPlayer->getNameKey() << buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	mov	esi, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp
	push	esi
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp

; 3117 : 											pNotifications->Add(NOTIFICATION_WONDER_COMPLETED, localizedText.toUTF8(), localizedText.toUTF8(), m_pCity->getX(), m_pCity->getY(), eIndex, pPlayer->GetID());

	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _this$[esp+808]
	mov	eax, DWORD PTR [edx+112]
	mov	edx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ecx
	mov	ecx, DWORD PTR _eIndex$[esp+808]
	push	ecx
	push	edx
	push	eax

; 3118 : 										}
; 3119 : 									}
; 3120 : 									else

	jmp	SHORT $LN342@SetNumReal
$LN7@SetNumReal:

; 3121 : 									{
; 3122 : 										CvNotifications* pNotifications = thisPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 3123 : 										if(pNotifications)

	test	ebx, ebx
	je	SHORT $LN2@SetNumReal

; 3124 : 										{
; 3125 : 											localizedText = Localization::Lookup("TXT_KEY_MISC_WONDER_COMPLETED_UNKNOWN");

	lea	edx, DWORD PTR $T233300[esp+808]
	push	OFFSET $SG220854
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	mov	BYTE PTR __$EHRec$[esp+820], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T233300[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 5
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3126 : 											localizedText <<  buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+812]
	call	ebp

; 3127 : 											pNotifications->Add(NOTIFICATION_WONDER_COMPLETED, localizedText.toUTF8(), localizedText.toUTF8(), -1, -1, eIndex, -1);

	mov	eax, DWORD PTR _eIndex$[esp+804]
	push	-1
	push	eax
	push	-1
	push	-1
$LN342@SetNumReal:
	lea	ecx, DWORD PTR _localizedText$220809[esp+824]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _localizedText$220809[esp+828]
	call	edi
	push	eax
	push	2091697919				; 7cacc6ffH
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN2@SetNumReal:

; 3128 : 										}
; 3129 : 									}
; 3130 : 								}
; 3131 : 							}
; 3132 : 
; 3133 : 							//Achievements!
; 3134 : 							if(pPlayer->GetID() == GC.getGame().getActivePlayer() && strcmp(buildingEntry->GetType(), "BUILDING_GREAT_FIREWALL") == 0)

	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	mov	esi, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN11@SetNumReal
	mov	ecx, DWORD PTR _buildingEntry$[esp+808]
	add	ecx, 176				; 000000b0H
	mov	ebx, OFFSET $SG220857
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	7
$LL327@SetNumReal:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [ebx]
	jne	SHORT $LN328@SetNumReal
	test	cl, cl
	je	SHORT $LN329@SetNumReal
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [ebx+1]
	jne	SHORT $LN328@SetNumReal
	add	eax, 2
	add	ebx, 2
	test	cl, cl
	jne	SHORT $LL327@SetNumReal
$LN329@SetNumReal:
	xor	eax, eax
	jmp	SHORT $LN330@SetNumReal
$LN328@SetNumReal:
	sbb	eax, eax
	sbb	eax, -1
$LN330@SetNumReal:
	test	eax, eax
	jne	SHORT $LN11@SetNumReal

; 3135 : 							{
; 3136 : 								gDLL->UnlockAchievement(ACHIEVEMENT_XP1_16);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	206					; 000000ceH
	call	eax
$LN11@SetNumReal:
	mov	eax, DWORD PTR tv1564[esp+808]
	inc	DWORD PTR _iI$220833[esp+808]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv1564[esp+808], eax
	jl	$LL333@SetNumReal

; 3137 : 							}
; 3138 : 						}
; 3139 : 					}

	lea	ecx, DWORD PTR _localizedText$220809[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebx, DWORD PTR _eIndex$[esp+804]
	mov	esi, DWORD PTR _this$[esp+808]
$LN19@SetNumReal:

; 3140 : 				}
; 3141 : 
; 3142 : 				GC.getGame().incrementBuildingClassCreatedCount(buildingClassType);

	mov	ecx, DWORD PTR _buildingClassType$[esp+808]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?incrementBuildingClassCreatedCount@CvGame@@QAEXW4BuildingClassTypes@@@Z ; CvGame::incrementBuildingClassCreatedCount
$LN21@SetNumReal:

; 3143 : 			}
; 3144 : 		}
; 3145 : 
; 3146 : 		m_pCity->updateStrengthValue();

	mov	ecx, DWORD PTR [esi+112]
	call	?updateStrengthValue@CvCity@@QAEXXZ	; CvCity::updateStrengthValue

; 3147 : 
; 3148 : 		// Building might affect City Banner stats
; 3149 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(m_pCity);

	mov	edx, DWORD PTR [esi+112]
	push	edx
	lea	eax, DWORD PTR $T233302[esp+812]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pCity$220859[esp+808], edi
	mov	eax, DWORD PTR $T233302[esp+808]
	mov	BYTE PTR __$EHRec$[esp+816], 10		; 0000000aH
	test	eax, eax
	je	SHORT $LN306@SetNumReal
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN306@SetNumReal:

; 3150 : 		GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+440]
	push	0
	push	edi
	call	edx

; 3151 : 
; 3152 : 		//Test for any achievements being unlocked.
; 3153 : 		pPlayer->GetPlayerAchievements().FinishedBuilding(m_pCity, eIndex);

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR _pPlayer$[esp+808]
	push	ebx
	push	eax
	add	ecx, 63156				; 0000f6b4H
	call	?FinishedBuilding@CvPlayerAchievements@@QAEXPAVCvCity@@W4BuildingTypes@@@Z ; CvPlayerAchievements::FinishedBuilding

; 3154 : 	}

	mov	BYTE PTR __$EHRec$[esp+816], 0
	test	edi, edi
	je	SHORT $LN317@SetNumReal
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN317@SetNumReal:
	lea	ecx, DWORD PTR _szBuildingType$220711[esp+808]
	mov	DWORD PTR __$EHRec$[esp+816], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN49@SetNumReal:

; 3155 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+808]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 792				; 00000318H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$0:
	lea	ecx, DWORD PTR _szBuildingType$220711[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$1:
	mov	eax, DWORD PTR $T233284[ebp]
	push	eax
	call	??3CvDllCity@@SAXPAX@Z			; CvDllCity::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$2:
	lea	ecx, DWORD PTR _pDllCity$220721[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$3:
	mov	eax, DWORD PTR $T233288[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$4:
	lea	ecx, DWORD PTR _pDllPlot$220788[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$5:
	lea	ecx, DWORD PTR _localizedText$220809[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$6:
	lea	ecx, DWORD PTR $T233293[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$7:
	lea	ecx, DWORD PTR $T233294[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$8:
	lea	ecx, DWORD PTR $T233297[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$9:
	lea	ecx, DWORD PTR $T233300[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$11:
	lea	ecx, DWORD PTR _pCity$220859[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ENDP ; CvCityBuildings::SetNumRealBuildingTimed
PUBLIC	?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ ; CvCityBuildings::HasAnyAvailableGreatWorkSlot
; Function compile flags: /Ogtpy
;	COMDAT ?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ
_TEXT	SEGMENT
_iSlot$ = -8						; size = 4
_eBuildingClass$ = -4					; size = 4
?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ PROC ; CvCityBuildings::HasAnyAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3370 : {

	sub	esp, 8

; 3371 : 	BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below
; 3372 : #ifdef AUI_WARNING_FIXES
; 3373 : 	uint iSlot = MAX_UNSIGNED_INT;
; 3374 : #else
; 3375 : 	int iSlot = -1; // Passed by reference below
; 3376 : #endif
; 3377 : 
; 3378 : 	return GetNextAvailableGreatWorkSlot (&eBuildingClass, &iSlot);

	lea	eax, DWORD PTR _iSlot$[esp+8]
	push	eax
	lea	edx, DWORD PTR _eBuildingClass$[esp+12]
	push	edx
	call	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot

; 3379 : }

	add	esp, 8
	ret	0
?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ ENDP ; CvCityBuildings::HasAnyAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z ; CvCityBuildings::HasAvailableGreatWorkSlot
; Function compile flags: /Ogtpy
;	COMDAT ?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = -4					; size = 4
_iSlot$ = 8						; size = 4
_eSlotType$ = 8						; size = 4
?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z PROC ; CvCityBuildings::HasAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3383 : {

	push	ecx

; 3384 : 	BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below
; 3385 : #ifdef AUI_WARNING_FIXES
; 3386 : 	uint iSlot = MAX_UNSIGNED_INT;
; 3387 : #else
; 3388 : 	int iSlot = -1; // Passed by reference below
; 3389 : #endif
; 3390 : 
; 3391 : 	return GetNextAvailableGreatWorkSlot (eSlotType, &eBuildingClass, &iSlot);

	lea	eax, DWORD PTR _iSlot$[esp]
	push	eax
	mov	eax, DWORD PTR _eSlotType$[esp+4]
	lea	edx, DWORD PTR _eBuildingClass$[esp+8]
	push	edx
	push	eax
	call	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot

; 3392 : }

	pop	ecx
	ret	4
?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z ENDP ; CvCityBuildings::HasAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
$T233877 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+29], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jge	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jl	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T233877[esp+8], eax
	lea	eax, DWORD PTR $T233877[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??0?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
$T234428 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find@2
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find@2:
	cmp	DWORD PTR [eax+12], esi
	jge	SHORT $LN8@find@2
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find@2
$LN8@find@2:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find@2:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@find@2
	pop	esi
$LN9@find@2:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find@2
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jl	SHORT $LN3@find@2
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find@2:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T234428[esp+8], eax
	lea	eax, DWORD PTR $T234428[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+29], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_ptr<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T234750 = -80						; size = 28
$T234749 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 536870910		; 1ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T234750[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T234749[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T234750[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T234749[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T234749[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T234749[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T234749[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+20], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+20], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T234750[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$2:
	lea	ecx, DWORD PTR $T234749[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+21], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+20]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+21], 0
	mov	edi, eax
	je	SHORT $LN2@Copy

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy:
$LN28@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@@Z ; std::_Destroy_range<std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BuildingYieldChange> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@0AAV?$allocator@UBuildingYieldChange@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@std@@@Z
_TEXT	SEGMENT
$T235318 = -4						; size = 1
__Cat$235322 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T235318[esp+4], 0
	mov	eax, DWORD PTR $T235318[esp+4]
	mov	ecx, DWORD PTR __Cat$235322[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@@Z ; std::_Destroy_range<std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BuildingGreatWork> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@0AAV?$allocator@UBuildingGreatWork@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@std@@@Z
_TEXT	SEGMENT
$T235335 = -4						; size = 1
__Cat$235339 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T235335[esp+4], 0
	mov	eax, DWORD PTR $T235335[esp+4]
	mov	ecx, DWORD PTR __Cat$235339[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum BuildingTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T235361 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$235364 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$235364[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T235361[esp+4], 0
	mov	eax, DWORD PTR $T235361[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T235380 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$235383 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$235383[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T235380[esp+4], 0
	mov	eax, DWORD PTR $T235380[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@U_Undefined_move_tag@3@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetResourceYieldChangeGlobal
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_itResource$ = -4					; size = 4
_itYield$219936 = 8					; size = 4
_iResource$ = 8						; size = 4
_iYieldType$ = 12					; size = 4
?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetResourceYieldChangeGlobal, COMDAT
; _this$ = ecx

; 2155 : {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 2156 : 	CvAssertMsg(iResource < GC.getNumResourceInfos(), "Index out of bounds");
; 2157 : 	CvAssertMsg(iResource > -1, "Index out of bounds");
; 2158 : 	CvAssertMsg(iYieldType < NUM_YIELD_TYPES, "Index out of bounds");
; 2159 : 	CvAssertMsg(iYieldType > -1, "Index out of bounds");
; 2160 : 	std::map<int, std::map<int, int>>::const_iterator itResource = m_ppiResourceYieldChangeGlobal.find(iResource);

	lea	eax, DWORD PTR _iResource$[esp+8]
	push	eax
	lea	ecx, DWORD PTR _itResource$[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [esi+964]
	call	?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find

; 2161 : 	if (itResource != m_ppiResourceYieldChangeGlobal.end()) // find returns the iterator to map::end if the key iResource is not present in the map

	mov	edi, DWORD PTR _itResource$[esp+12]
	cmp	edi, DWORD PTR [esi+968]
	je	SHORT $LN1@GetResourc@7

; 2162 : 	{
; 2163 : 		std::map<int, int>::const_iterator itYield = itResource->second.find(iYieldType);

	lea	edx, DWORD PTR _iYieldType$[esp+8]
	push	edx
	lea	eax, DWORD PTR _itYield$219936[esp+12]
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find

; 2164 : 		if (itYield != itResource->second.end()) // find returns the iterator to map::end if the key iYield is not present in the map

	mov	eax, DWORD PTR _itYield$219936[esp+8]
	cmp	eax, DWORD PTR [edi+20]
	je	SHORT $LN1@GetResourc@7

; 2165 : 		{
; 2166 : 			return itYield->second;

	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi

; 2171 : }

	pop	ecx
	ret	8
$LN1@GetResourc@7:
	pop	edi

; 2167 : 		}
; 2168 : 	}
; 2169 : 
; 2170 : 	return 0;

	xor	eax, eax
	pop	esi

; 2171 : }

	pop	ecx
	ret	8
?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetResourceYieldChangeGlobal
_TEXT	ENDS
PUBLIC	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
EXTRN	?getGameTurnYear@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurnYear
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetNumRealBuilding, COMDAT
; _this$ = ecx

; 2925 : {

	push	esi
	mov	esi, ecx

; 2926 : 	SetNumRealBuildingTimed(eIndex, iNewValue, true, m_pCity->getOwner(), GC.getGame().getGameTurnYear());

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	edi, DWORD PTR [eax+84]
	call	?getGameTurnYear@CvGame@@QAEHXZ		; CvGame::getGameTurnYear
	mov	ecx, DWORD PTR _iNewValue$[esp+4]
	mov	edx, DWORD PTR _eIndex$[esp+4]
	push	eax
	push	edi
	push	1
	push	ecx
	push	edx
	mov	ecx, esi
	call	?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ; CvCityBuildings::SetNumRealBuildingTimed
	pop	edi
	pop	esi

; 2927 : 
; 2928 : }

	ret	8
?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetNumRealBuilding
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::clear
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXPAUBuildingYieldChange@@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXPAUBuildingYieldChange@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXPAUBuildingYieldChange@@0@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXPAUBuildingYieldChange@@0@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU3@IABU3@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T235769 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$235773 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU3@IABU3@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$235773[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T235769[esp+12], 0
	mov	eax, DWORD PTR $T235769[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU3@IABU3@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXPAUBuildingGreatWork@@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXPAUBuildingGreatWork@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXPAUBuildingGreatWork@@0@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXPAUBuildingGreatWork@@0@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU3@IABU3@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T235798 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$235802 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU3@IABU3@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$235802[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T235798[esp+12], 0
	mov	eax, DWORD PTR $T235798[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU3@IABU3@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Ufill
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T235822 = 12						; size = 4
$T235820 = 12						; size = 4
__Where$223128 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setl	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$223128[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T235820[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$223128[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jge	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T235822[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T235954 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@3
	cmp	edx, eax
	jne	SHORT $LN101@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@3:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@3
	npad	2
$LL2@erase@3:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+21], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@3
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN103@erase@3
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN79@erase@3
	npad	5
$LL80@erase@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL80@erase@3
$LN79@erase@3:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@3
$LN103@erase@3:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN63@erase@3
	npad	7
$LL64@erase@3:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@3
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL64@erase@3
$LN63@erase@3:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@3:
	push	edx
	lea	eax, DWORD PTR $T235954[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN2@Copy@2

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN25@Copy@2
$LL26@Copy@2:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL26@Copy@2
$LN25@Copy@2:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN43@Copy@2
$LL44@Copy@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL44@Copy@2
$LN43@Copy@2:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@2:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z
_TEXT	SEGMENT
$T236516 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$236519 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$236519[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T236516[esp+4], 0
	mov	eax, DWORD PTR $T236516[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z
_TEXT	SEGMENT
$T236556 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$236550 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$236550[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T236556[esp+4], 0
	mov	eax, DWORD PTR $T236556[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??0CvBuildingXMLEntries@@QAE@XZ			; CvBuildingXMLEntries::CvBuildingXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ??0CvBuildingXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvBuildingXMLEntries@@QAE@XZ PROC			; CvBuildingXMLEntries::CvBuildingXMLEntries, COMDAT
; _this$ = ecx

; 2358 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 2359 : 
; 2360 : }

	ret	0
??0CvBuildingXMLEntries@@QAE@XZ ENDP			; CvBuildingXMLEntries::CvBuildingXMLEntries
_TEXT	ENDS
PUBLIC	?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z ; CvCityBuildings::DoSellBuilding
EXTRN	?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z:PROC ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
; Function compile flags: /Ogtpy
;	COMDAT ?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z PROC ; CvCityBuildings::DoSellBuilding, COMDAT
; _this$ = ecx

; 2726 : {

	push	esi
	push	edi

; 2727 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2728 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2729 : 
; 2730 : 	CvBuildingEntry* pkBuildingEntry = GC.getBuildingInfo(eIndex);

	mov	edi, DWORD PTR _eIndex$[esp+4]
	mov	esi, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 2731 : 	if(!pkBuildingEntry)

	test	eax, eax
	je	$LN29@DoSellBuil

; 2732 : 		return;
; 2733 : 
; 2734 : 	// Can we actually do this?
; 2735 : 	if(!IsBuildingSellable(*pkBuildingEntry))

	push	eax
	mov	ecx, esi
	call	?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z ; CvCityBuildings::IsBuildingSellable
	test	al, al
	je	SHORT $LN29@DoSellBuil

; 2736 : 		return;
; 2737 : 
; 2738 : 	// Gold refund
; 2739 : 	int iRefund = GetSellBuildingRefund(eIndex);

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	edi
	call	?getProductionNeeded@CvPlayer@@QBEHW4BuildingTypes@@@Z ; CvPlayer::getProductionNeeded
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7832

; 2740 : 	GET_PLAYER(m_pCity->getOwner()).GetTreasury()->ChangeGold(iRefund);

	mov	ecx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2741 : 
; 2742 : 	// Kick everyone out
; 2743 : 	m_pCity->GetCityCitizens()->DoRemoveAllSpecialistsFromBuilding(eIndex);

	mov	ecx, DWORD PTR [esi+112]
	push	0
	push	edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding

; 2744 : 
; 2745 : 	SetNumRealBuilding(eIndex, 0);

	mov	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edx+84]
	call	?getGameTurnYear@CvGame@@QAEHXZ		; CvGame::getGameTurnYear
	push	eax
	push	ebx
	mov	ebx, 1
	push	ebx
	push	0
	push	edi
	mov	ecx, esi
	call	?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ; CvCityBuildings::SetNumRealBuildingTimed

; 2746 : 
; 2747 : 	SetSoldBuildingThisTurn(true);

	cmp	BYTE PTR [esi+32], bl
	je	SHORT $LN34@DoSellBuil
	mov	BYTE PTR [esi+32], bl
$LN34@DoSellBuil:
	pop	ebx
$LN29@DoSellBuil:
	pop	edi
	pop	esi

; 2748 : }

	ret	4
?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z ENDP ; CvCityBuildings::DoSellBuilding
_TEXT	ENDS
PUBLIC	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
tv164 = 8						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetNumFreeBuilding, COMDAT
; _this$ = ecx

; 3167 : {

	push	ebx

; 3168 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 3169 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 3170 : 
; 3171 : 	if (GetNumFreeBuilding(eIndex) != iNewValue)

	mov	ebx, DWORD PTR _eIndex$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+56]
	push	edi
	mov	edi, DWORD PTR _iNewValue$[esp+8]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR tv164[esp+8], eax
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN1@SetNumFree
	push	ebp

; 3172 : 	{
; 3173 : 		int iOldNumBuilding = GetNumBuilding(eIndex);

	push	ebx
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	mov	ebp, eax

; 3174 : 
; 3175 : 		if (iOldNumBuilding > 0 && iNewValue > 0)

	test	ebp, ebp
	jle	SHORT $LN3@SetNumFree
	test	edi, edi
	jle	SHORT $LN3@SetNumFree

; 3176 : 		{
; 3177 : 			DoSellBuilding(eIndex);

	push	ebx
	mov	ecx, esi
	call	?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z ; CvCityBuildings::DoSellBuilding

; 3178 : 			m_paiNumFreeBuilding[eIndex] = iNewValue;

	mov	ecx, DWORD PTR [esi+56]
	mov	DWORD PTR [ecx+ebx*4], edi

; 3179 : 			m_pCity->processBuilding(eIndex, iNewValue, true);			
; 3180 : 		}
; 3181 : 		
; 3182 : 		else

	jmp	SHORT $LN10@SetNumFree
$LN3@SetNumFree:

; 3183 : 		{
; 3184 : 			m_paiNumFreeBuilding[eIndex] = iNewValue;

	mov	edx, DWORD PTR tv164[esp+12]

; 3185 : 
; 3186 : 			if (iOldNumBuilding != GetNumBuilding(eIndex))

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [edx], edi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	cmp	ebp, eax
	je	SHORT $LN9@SetNumFree

; 3187 : 			{
; 3188 : 				m_pCity->processBuilding(eIndex, iNewValue - iOldNumBuilding, true);

	sub	edi, ebp
$LN10@SetNumFree:
	mov	ecx, DWORD PTR [esi+112]
	push	0
	push	0
	push	1
	push	edi
	push	ebx
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding
$LN9@SetNumFree:
	pop	ebp
$LN1@SetNumFree:
	pop	edi
	pop	esi
	pop	ebx

; 3189 : 			}
; 3190 : 		}
; 3191 : 	}
; 3192 : }

	ret	8
?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetNumFreeBuilding
_TEXT	ENDS
PUBLIC	??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+12]
	cmp	eax, esi
	je	SHORT $LN9@erase@4
	push	edi
$LL11@erase@4:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], edi
	add	eax, 12					; 0000000cH
	add	edx, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL11@erase@4
	mov	edx, DWORD PTR __Where$[esp+4]
	pop	edi
$LN9@erase@4:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [ecx+8], -12			; fffffff4H
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
_TEXT	ENDS
PUBLIC	??1?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+12]
	cmp	eax, esi
	je	SHORT $LN9@erase@5
	push	edi
$LL11@erase@5:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], edi
	add	eax, 12					; 0000000cH
	add	edx, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL11@erase@5
	mov	edx, DWORD PTR __Where$[esp+4]
	pop	edi
$LN9@erase@5:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [ecx+8], -12			; fffffff4H
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+29], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@6
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@6
	push	ebx
	npad	4
$LL28@erase@6:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@6
	pop	ebx
$LN26@erase@6:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@6:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@7
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@7
	push	ebx
	npad	4
$LL28@erase@7:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], ebx
	add	edx, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edx, edi
	jne	SHORT $LL28@erase@7
	pop	ebx
$LN26@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@7:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@8
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@8
	push	ebx
	npad	4
$LL28@erase@8:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], ebx
	add	edx, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edx, edi
	jne	SHORT $LL28@erase@8
	pop	ebx
$LN26@erase@8:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@8:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T237375 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@2

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@2:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@2
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jge	$LN1@insert@2

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@2:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@2

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jge	$LN1@insert@2

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@2:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jle	SHORT $LN305@insert@2
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jge	SHORT $LN8@insert@2

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@2
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@2:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@2:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@2:
	jge	SHORT $LN1@insert@2
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@2
	cmp	ebp, DWORD PTR [eax+12]
	jge	SHORT $LN1@insert@2
$LN3@insert@2:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+21], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@2
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@2:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@2:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T237375[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T238065 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T238065[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUBuildingYieldChange@@@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU2@00@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Umove<BuildingYieldChange *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUBuildingYieldChange@@@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU2@00@Z
_TEXT	SEGMENT
$T238173 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$238176 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUBuildingYieldChange@@@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU2@00@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Umove<BuildingYieldChange *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$238176[esp]
	mov	BYTE PTR $T238173[esp+4], 0
	mov	eax, DWORD PTR $T238173[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUBuildingYieldChange@@@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU2@00@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Umove<BuildingYieldChange *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUBuildingGreatWork@@@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU2@00@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Umove<BuildingGreatWork *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUBuildingGreatWork@@@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU2@00@Z
_TEXT	SEGMENT
$T238228 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$238231 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUBuildingGreatWork@@@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU2@00@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Umove<BuildingGreatWork *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$238231[esp]
	mov	BYTE PTR $T238228[esp+4], 0
	mov	eax, DWORD PTR $T238228[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUBuildingGreatWork@@@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU2@00@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Umove<BuildingGreatWork *>
_TEXT	ENDS
PUBLIC	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear@2
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear@2
	push	edi
$LL42@clear@2:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear@2
	pop	edi
$LN40@clear@2:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear@2:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T238416 = -4						; size = 4
?clear@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T238416[esp+12]
	push	eax
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T238456 = -4						; size = 4
?clear@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T238456[esp+12]
	push	eax
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::clear
_TEXT	ENDS
PUBLIC	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
$T238493 = -8						; size = 8
$T238496 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	esp, 8
	cmp	BYTE PTR [eax+21], 0
	push	esi
	mov	esi, DWORD PTR __Keyval$[esp+8]
	jne	SHORT $LN9@operator@5
	push	edi
	mov	edi, DWORD PTR [esi]
$LL10@operator@5:
	cmp	DWORD PTR [eax+12], edi
	jge	SHORT $LN8@operator@5
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@operator@5
$LN8@operator@5:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@operator@5:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@operator@5
	pop	edi
$LN9@operator@5:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@operator@5
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $LN62@operator@5
$LN1@operator@5:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T238493[esp+12], eax
	lea	eax, DWORD PTR $T238493[esp+12]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T238496[esp+16]
	push	edx
	mov	DWORD PTR $T238493[esp+28], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 174  : 		return ((*_Where).second);

	add	eax, 16					; 00000010H
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
$LN62@operator@5:

; 174  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [edx+16]
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T238729 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T238729[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$2
__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$0
__unwindtable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
__Tmp$222975 = -32					; size = 12
__Tmp$222965 = -32					; size = 12
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$238960 = 8					; size = 1
__Cat$238889 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$222950 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T238957 = 16						; size = 1
$T238885 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 357913941				; 15555555H
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 1
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$222950[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU3@IABU3@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$238889[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T238885[ebp], 0
	mov	ecx, DWORD PTR $T238885[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$222950[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$222950[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T238957[ebp], 0
	mov	edx, DWORD PTR $T238957[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$238960[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$222950[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$222950[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$222965[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$222965[ebp+8], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$222965[ebp+4], edx
	call	??$_Umove@PAUBuildingYieldChange@@@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU2@00@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Umove<BuildingYieldChange *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$222965[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU3@IABU3@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$222965[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z ; std::fill<BuildingYieldChange *,BuildingYieldChange>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$222975[ebp+8], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$222975[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$222975[ebp+4], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAUBuildingYieldChange@@@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEPAUBuildingYieldChange@@PAU2@00@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Umove<BuildingYieldChange *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUBuildingYieldChange@@PAU1@@stdext@@YAPAUBuildingYieldChange@@PAU1@00@Z ; stdext::_Unchecked_move_backward<BuildingYieldChange *,BuildingYieldChange *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$222975[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$fill@PAUBuildingYieldChange@@U1@@std@@YAXPAUBuildingYieldChange@@0ABU1@@Z ; std::fill<BuildingYieldChange *,BuildingYieldChange>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$2
__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$0
__unwindtable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
__Tmp$223038 = -32					; size = 12
__Tmp$223028 = -32					; size = 12
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$239196 = 8					; size = 1
__Cat$239124 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$223013 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T239193 = 16						; size = 1
$T239121 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 357913941				; 15555555H
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 1
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$223013[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU3@IABU3@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$239124[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T239121[ebp], 0
	mov	ecx, DWORD PTR $T239121[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$223013[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$223013[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T239193[ebp], 0
	mov	edx, DWORD PTR $T239193[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$239196[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$223013[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$223013[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@2
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$223028[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$223028[ebp+8], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$223028[ebp+4], edx
	call	??$_Umove@PAUBuildingGreatWork@@@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU2@00@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Umove<BuildingGreatWork *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$223028[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU3@IABU3@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$223028[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z ; std::fill<BuildingGreatWork *,BuildingGreatWork>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$223038[ebp+8], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$223038[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$223038[ebp+4], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAUBuildingGreatWork@@@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEPAUBuildingGreatWork@@PAU2@00@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Umove<BuildingGreatWork *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUBuildingGreatWork@@PAU1@@stdext@@YAPAUBuildingGreatWork@@PAU1@00@Z ; stdext::_Unchecked_move_backward<BuildingGreatWork *,BuildingGreatWork *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$223038[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$fill@PAUBuildingGreatWork@@U1@@std@@YAXPAUBuildingGreatWork@@0ABU1@@Z ; std::fill<BuildingGreatWork *,BuildingGreatWork>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree:
$LN56@Tree:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0CvCityBuildings@@QAE@XZ			; CvCityBuildings::CvCityBuildings
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvCityBuildings@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$1
__ehfuncinfo$??0CvCityBuildings@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvCityBuildings@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvCityBuildings@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCityBuildings@@QAE@XZ PROC				; CvCityBuildings::CvCityBuildings, COMDAT
; _this$ = ecx

; 2437 : {

	push	-1
	push	__ehhandler$??0CvCityBuildings@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	BYTE PTR [eax+32], cl
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+100], ecx
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+108], ecx
	mov	DWORD PTR [eax+112], ecx

; 2438 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
__ehhandler$??0CvCityBuildings@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvCityBuildings@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCityBuildings@@QAE@XZ ENDP				; CvCityBuildings::CvCityBuildings
PUBLIC	??1CvCityBuildings@@QAE@XZ			; CvCityBuildings::~CvCityBuildings
; Function compile flags: /Ogtpy
;	COMDAT ??1CvCityBuildings@@QAE@XZ
_TEXT	SEGMENT
??1CvCityBuildings@@QAE@XZ PROC				; CvCityBuildings::~CvCityBuildings, COMDAT
; _this$ = ecx

; 2442 : {

	push	esi
	mov	esi, ecx

; 2443 : }

	mov	eax, DWORD PTR [esi+96]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN11@CvCityBuil
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@CvCityBuil:
	mov	DWORD PTR [esi+96], edi
	mov	DWORD PTR [esi+100], edi
	mov	DWORD PTR [esi+104], edi
	mov	eax, DWORD PTR [esi+80]
	cmp	eax, edi
	je	SHORT $LN18@CvCityBuil
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@CvCityBuil:
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	eax, DWORD PTR [esi+64]
	cmp	eax, edi
	je	SHORT $LN25@CvCityBuil
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@CvCityBuil:
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+72], edi
	pop	edi
	pop	esi
	ret	0
??1CvCityBuildings@@QAE@XZ ENDP				; CvCityBuildings::~CvCityBuildings
_TEXT	ENDS
PUBLIC	?Reset@CvCityBuildings@@QAEXXZ			; CvCityBuildings::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvCityBuildings@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvCityBuildings@@QAEXXZ PROC			; CvCityBuildings::Reset, COMDAT
; _this$ = ecx

; 2496 : #ifdef AUI_WARNING_FIXES
; 2497 : 	uint iI;
; 2498 : #else
; 2499 : 	int iI;
; 2500 : #endif
; 2501 : 
; 2502 : 	// Initialize non-arrays
; 2503 : 	m_iNumBuildings = 0;
; 2504 : 	m_iBuildingProductionModifier = 0;
; 2505 : 	m_iBuildingDefense = 0;
; 2506 : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 2507 : 	m_iBuildingDefensePerCitizen = 0;
; 2508 : #endif
; 2509 : 	m_iBuildingDefenseMod = 0;
; 2510 : 	m_iMissionaryExtraSpreads = 0;
; 2511 : 	m_iLandmarksTourismPercent = 0;
; 2512 : 	m_iGreatWorksTourismModifier = 0;
; 2513 : 
; 2514 : 	m_bSoldBuildingThisTurn = false;
; 2515 : 
; 2516 : 	for(iI = 0; iI < m_pBuildings->GetNumBuildings(); iI++)

	mov	edx, DWORD PTR [ecx+108]
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], ebx
	mov	DWORD PTR [ecx+16], ebx
	mov	DWORD PTR [ecx+20], ebx
	mov	DWORD PTR [ecx+24], ebx
	mov	DWORD PTR [ecx+28], ebx
	mov	BYTE PTR [ecx+32], bl
	mov	esi, DWORD PTR [edx+8]
	sub	esi, DWORD PTR [edx+4]
	xor	eax, eax
	test	esi, -4					; fffffffcH
	jle	SHORT $LN1@Reset
$LL3@Reset:

; 2517 : 	{
; 2518 : 		m_paiBuildingProduction[iI] = 0;

	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+eax*4], ebx

; 2519 : 		m_paiBuildingProductionTime[iI] = 0;

	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+eax*4], ebx

; 2520 : 		m_paiBuildingOriginalOwner[iI] = NO_PLAYER;

	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [edx+eax*4], -1

; 2521 : 		m_paiBuildingOriginalTime[iI] = MIN_INT;

	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [edx+eax*4], -2147483648	; 80000000H

; 2522 : 		m_paiNumRealBuilding[iI] = 0;

	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [edx+eax*4], ebx

; 2523 : 		m_paiNumFreeBuilding[iI] = 0;

	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [edx+eax*4], ebx
	mov	edx, DWORD PTR [ecx+108]
	mov	esi, DWORD PTR [edx+8]
	sub	esi, DWORD PTR [edx+4]
	inc	eax
	sar	esi, 2
	cmp	eax, esi
	jl	SHORT $LL3@Reset
$LN1@Reset:

; 2524 : 	}
; 2525 : 
; 2526 : 	m_buildingsThatExistAtLeastOnce.clear();

	mov	esi, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR [ecx+68]
	cmp	esi, edx
	je	SHORT $LN24@Reset
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN49@Reset
	push	edi
	npad	1
$LL51@Reset:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL51@Reset
	pop	edi
$LN49@Reset:
	mov	DWORD PTR [ecx+68], esi
$LN24@Reset:
	pop	esi
	pop	ebx

; 2527 : }

	ret	0
?Reset@CvCityBuildings@@QAEXXZ ENDP			; CvCityBuildings::Reset
_TEXT	ENDS
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T240243 = -4						; size = 4
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T240243[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::~pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T240413 = -4						; size = 4
??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ PROC ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::~pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx
	push	ecx
	mov	eax, DWORD PTR [ecx+8]
	push	esi
	lea	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T240413[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::~pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert
_TEXT	ENDS
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABU01@@Z ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
_TEXT	ENDS
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::~_Node
; Function compile flags: /Ogtpy
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T240978 = -4						; size = 4
??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	push	ecx
	mov	eax, DWORD PTR [ecx+20]
	push	esi
	lea	esi, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T240978[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z ; CvCityBuildings::Init
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T241127 = 8						; size = 4
$T241069 = 8						; size = 4
_pBuildings$ = 8					; size = 4
_pCity$ = 12						; size = 4
?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z PROC ; CvCityBuildings::Init, COMDAT
; _this$ = ecx

; 2448 : 	// Store off the pointers to objects we'll need later
; 2449 : 	m_pBuildings = pBuildings;

	mov	eax, DWORD PTR _pBuildings$[esp-4]
	push	esi
	mov	esi, ecx

; 2450 : 	m_pCity = pCity;

	mov	ecx, DWORD PTR _pCity$[esp]
	mov	DWORD PTR [esi+112], ecx
	mov	DWORD PTR [esi+108], eax
	push	edi

; 2451 : 
; 2452 : 	// Initialize status arrays
; 2453 : 
; 2454 : 	int iNumBuildings = m_pBuildings->GetNumBuildings();

	mov	edi, DWORD PTR [eax+8]
	sub	edi, DWORD PTR [eax+4]

; 2455 : 
; 2456 : 	CvAssertMsg((0 < iNumBuildings),  "m_pBuildings->GetNumBuildings() is not greater than zero but an array is being allocated in CvCityBuildings::Init");
; 2457 : 
; 2458 : 	CvAssertMsg(m_paiBuildingProduction==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingProduction");
; 2459 : 	m_paiBuildingProduction = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	sar	edi, 2
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+36], eax

; 2460 : 
; 2461 : 	CvAssertMsg(m_paiBuildingProductionTime==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingProductionTime");
; 2462 : 	m_paiBuildingProductionTime = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+40], eax

; 2463 : 
; 2464 : 	CvAssertMsg(m_paiBuildingOriginalOwner==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingOriginalOwner");
; 2465 : 	m_paiBuildingOriginalOwner = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+44], eax

; 2466 : 
; 2467 : 	CvAssertMsg(m_paiBuildingOriginalTime==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingOriginalTime");
; 2468 : 	m_paiBuildingOriginalTime = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+48], eax

; 2469 : 
; 2470 : 	CvAssertMsg(m_paiNumRealBuilding==NULL, "about to leak memory, CvCityBuildings::m_paiNumRealBuilding");
; 2471 : 	m_paiNumRealBuilding = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+52], eax

; 2472 : 
; 2473 : 	CvAssertMsg(m_paiNumFreeBuilding==NULL, "about to leak memory, CvCityBuildings::m_paiNumFreeBuilding");
; 2474 : 	m_paiNumFreeBuilding = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+56], eax

; 2475 : 
; 2476 : 	m_aBuildingYieldChange.clear();

	mov	eax, DWORD PTR [esi+84]
	mov	edx, DWORD PTR [esi+80]
	lea	ecx, DWORD PTR [esi+76]
	add	esp, 24					; 00000018H
	push	eax
	push	edx
	lea	eax, DWORD PTR $T241069[esp+12]
	push	eax
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 2477 : 	m_aBuildingGreatWork.clear();

	mov	eax, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T241127[esp+12]
	push	edx
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 2478 : 
; 2479 : 	Reset();

	mov	ecx, esi
	call	?Reset@CvCityBuildings@@QAEXXZ		; CvCityBuildings::Reset
	pop	edi
	pop	esi

; 2480 : }

	ret	8
?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z ENDP ; CvCityBuildings::Init
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
$T241177 = -4						; size = 1
__Cat$241180 = 8					; size = 1
$T241147 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$241180[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T241177[esp+16], 0
	mov	ecx, DWORD PTR $T241177[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T241147[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
$T241235 = -4						; size = 1
__Cat$241238 = 8					; size = 1
$T241205 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@2
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$241238[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T241235[esp+16], 0
	mov	ecx, DWORD PTR $T241235[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T241205[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABHABV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@@Z ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABHABV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABHABV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@@Z PROC ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 51   : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@ABHABV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@@Z ENDP ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	eax, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Rarg$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Parg$[esp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	dl, BYTE PTR __Carg$[esp]
	mov	BYTE PTR [esi+28], dl
	mov	BYTE PTR [esi+29], 0

; 39   : 			}

	mov	eax, esi
	pop	esi
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T241507 = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [eax]
	lea	esi, DWORD PTR [edi+16]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T241507[esp+20]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	test	BYTE PTR ___flags$[esp+8], 1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN41@scalar@5
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@scalar@5:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ecx
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >
EXTRN	??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
$T241583 = -16						; size = 4
_v$224526 = -12						; size = 12
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >, COMDAT

; 83   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi

; 84   : 	container.clear();

	mov	edi, DWORD PTR _container$[esp+24]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T241583[esp+36]
	push	eax
	mov	ecx, edi
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+24]
	lea	ecx, DWORD PTR _count$[esp+24]
	push	ecx
	xor	esi, esi
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+28], esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	cmp	DWORD PTR _count$[esp+24], esi
	jbe	SHORT $LN1@SerializeT
	push	ebp
	or	ebp, -1
	npad	2
$LL3@SerializeT:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$224526[esp+32]
	push	edx
	push	ebx
	mov	DWORD PTR _v$224526[esp+40], ebp
	mov	DWORD PTR _v$224526[esp+44], ebp
	mov	DWORD PTR _v$224526[esp+48], 0
	call	??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$224526[esp+32]
	push	eax
	mov	ecx, edi
	call	?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back
	inc	esi
	cmp	esi, DWORD PTR _count$[esp+28]
	jb	SHORT $LL3@SerializeT
	pop	ebp
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 16					; 00000010H
	ret	0
??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
EXTRN	??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
$T241651 = -16						; size = 4
_v$224536 = -12						; size = 12
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >, COMDAT

; 83   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+20]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T241651[esp+36]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+24]
	lea	ecx, DWORD PTR _count$[esp+24]
	push	ecx
	xor	edi, edi
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+28], edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	cmp	DWORD PTR _count$[esp+24], edi
	jbe	SHORT $LN1@SerializeT@2
	push	ebp
	or	ebp, -1
	npad	2
$LL3@SerializeT@2:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$224536[esp+32]
	push	edx
	push	ebx
	mov	DWORD PTR _v$224536[esp+40], ebp
	mov	DWORD PTR _v$224536[esp+44], ebp
	mov	DWORD PTR _v$224536[esp+48], ebp
	call	??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$224536[esp+32]
	push	eax
	mov	ecx, esi
	call	?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
	inc	edi
	cmp	edi, DWORD PTR _count$[esp+28]
	jb	SHORT $LL3@SerializeT@2
	pop	ebp
$LN1@SerializeT@2:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 16					; 00000010H
	ret	0
??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
_TEXT	ENDS
PUBLIC	?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::SetBuildingYieldChange
EXTRN	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromBuildings
EXTRN	?getCivilizationInfo@CvCity@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvCity::getCivilizationInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_kChange$221067 = -12					; size = 12
_eBuildingClass$ = 8					; size = 4
$T241837 = 12						; size = 4
_eYield$ = 12						; size = 4
$T241838 = 16						; size = 4
$T241677 = 16						; size = 4
_iChange$ = 16						; size = 4
?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z PROC ; CvCityBuildings::SetBuildingYieldChange, COMDAT
; _this$ = ecx

; 3210 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3211 : #ifdef AUI_WARNING_FIXES
; 3212 : 	CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3213 : 	if (!pCivInfo)
; 3214 : 		return;
; 3215 : #endif
; 3216 : 	for(std::vector<BuildingYieldChange>::iterator it = m_aBuildingYieldChange.begin(); it != m_aBuildingYieldChange.end(); ++it)

	mov	eax, DWORD PTR [esi+80]
	mov	ecx, DWORD PTR [esi+84]
	push	edi
	mov	edi, DWORD PTR _eBuildingClass$[esp+24]
	cmp	eax, ecx
	je	SHORT $LN10@SetBuildin@2
$LL23@SetBuildin@2:

; 3217 : 	{
; 3218 : 		if((*it).eBuildingClass == eBuildingClass && (*it).eYield == eYield)

	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN11@SetBuildin@2
	mov	edx, DWORD PTR _eYield$[esp+24]
	cmp	DWORD PTR [eax+4], edx
	je	$LN87@SetBuildin@2
$LN11@SetBuildin@2:

; 3211 : #ifdef AUI_WARNING_FIXES
; 3212 : 	CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3213 : 	if (!pCivInfo)
; 3214 : 		return;
; 3215 : #endif
; 3216 : 	for(std::vector<BuildingYieldChange>::iterator it = m_aBuildingYieldChange.begin(); it != m_aBuildingYieldChange.end(); ++it)

	add	eax, 12					; 0000000cH
	cmp	eax, ecx
	jne	SHORT $LL23@SetBuildin@2
$LN10@SetBuildin@2:

; 3243 : 					}
; 3244 : 				}
; 3245 : 			}
; 3246 : 
; 3247 : 			return;
; 3248 : 		}
; 3249 : 	}
; 3250 : 
; 3251 : 	if(0 != iChange)

	mov	ebx, DWORD PTR _iChange$[esp+24]
	test	ebx, ebx
	je	$LN1@SetBuildin@2

; 3252 : 	{
; 3253 : 		BuildingYieldChange kChange;
; 3254 : 		kChange.eBuildingClass = eBuildingClass;
; 3255 : 		kChange.eYield = eYield;

	mov	ebp, DWORD PTR _eYield$[esp+24]

; 3256 : 		kChange.iChange = iChange;
; 3257 : 		m_aBuildingYieldChange.push_back(kChange);

	lea	edx, DWORD PTR _kChange$221067[esp+28]
	push	edx
	lea	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR _kChange$221067[esp+32], edi
	mov	DWORD PTR _kChange$221067[esp+36], ebp
	mov	DWORD PTR _kChange$221067[esp+40], ebx
	call	?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back

; 3258 : 
; 3259 : 		BuildingTypes eBuilding = (BuildingTypes)m_pCity->getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	mov	ecx, DWORD PTR [esi+112]
	push	edi
	call	?getCivilizationInfo@CvCity@@QBEAAVCvCivilizationInfo@@XZ ; CvCity::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	edi, eax

; 3260 : 		if(NO_BUILDING != eBuilding)

	cmp	edi, -1
	je	$LN1@SetBuildin@2

; 3261 : 		{
; 3262 : 			if(GetNumActiveBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [esi+112]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	test	al, al
	jne	$LN1@SetBuildin@2
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892, 1
	mov	ecx, DWORD PTR [esi+52]
	jg	$LN64@SetBuildin@2
	mov	eax, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR $T241837[esp+24], eax
	cmp	ecx, eax
	mov	DWORD PTR $T241838[esp+24], ecx
	lea	eax, DWORD PTR $T241837[esp+24]
	jl	SHORT $LN76@SetBuildin@2
	lea	eax, DWORD PTR $T241838[esp+24]
$LN76@SetBuildin@2:
	mov	eax, DWORD PTR [eax]
	jmp	$LN63@SetBuildin@2
$LN87@SetBuildin@2:

; 3219 : 		{
; 3220 : 			int iOldChange = (*it).iChange;

	mov	ebp, DWORD PTR [eax+8]

; 3221 : 			if(iOldChange != iChange)

	mov	ebx, DWORD PTR _iChange$[esp+24]
	cmp	ebp, ebx
	je	$LN1@SetBuildin@2

; 3222 : 			{
; 3223 : 
; 3224 : 				if(iChange == 0)

	test	ebx, ebx
	jne	SHORT $LN7@SetBuildin@2

; 3225 : 				{
; 3226 : 					m_aBuildingYieldChange.erase(it);

	push	eax
	lea	eax, DWORD PTR $T241677[esp+28]
	push	eax
	lea	ecx, DWORD PTR [esi+76]
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 3227 : 				}
; 3228 : 				else

	jmp	SHORT $LN6@SetBuildin@2
$LN7@SetBuildin@2:

; 3229 : 				{
; 3230 : 					(*it).iChange = iChange;

	mov	DWORD PTR [eax+8], ebx
$LN6@SetBuildin@2:

; 3231 : 				}
; 3232 : 
; 3233 : #ifdef AUI_WARNING_FIXES
; 3234 : 				BuildingTypes eBuilding = (BuildingTypes)pCivInfo->getCivilizationBuildings(eBuildingClass);
; 3235 : #else
; 3236 : 				BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(m_pCity->getCivilizationType())->getCivilizationBuildings(eBuildingClass);

	mov	ecx, DWORD PTR [esi+112]
	push	edi
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	edi, eax

; 3237 : #endif
; 3238 : 				if(NO_BUILDING != eBuilding)

	cmp	edi, -1
	je	$LN1@SetBuildin@2

; 3239 : 				{
; 3240 : 					if(GetNumActiveBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [esi+112]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	test	al, al
	jne	SHORT $LN1@SetBuildin@2
	push	edi
	mov	ecx, esi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN1@SetBuildin@2

; 3241 : 					{
; 3242 : 						m_pCity->ChangeBaseYieldRateFromBuildings(eYield, (iChange - iOldChange) * GetNumActiveBuilding(eBuilding));

	push	edi
	mov	ecx, esi
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	mov	ecx, DWORD PTR _eYield$[esp+24]
	sub	ebx, ebp
	imul	eax, ebx
	push	eax
	push	ecx

; 3263 : 			{
; 3264 : 				m_pCity->ChangeBaseYieldRateFromBuildings(eYield, iChange * GetNumActiveBuilding(eBuilding));

	mov	ecx, DWORD PTR [esi+112]
	call	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromBuildings
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3265 : 			}
; 3266 : 		}
; 3267 : 	}
; 3268 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH

; 3261 : 		{
; 3262 : 			if(GetNumActiveBuilding(eBuilding) > 0)

$LN64@SetBuildin@2:
	mov	edx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [edx+edi*4]
	add	eax, DWORD PTR [ecx+edi*4]
$LN63@SetBuildin@2:
	test	eax, eax
	jle	SHORT $LN1@SetBuildin@2

; 3263 : 			{
; 3264 : 				m_pCity->ChangeBaseYieldRateFromBuildings(eYield, iChange * GetNumActiveBuilding(eBuilding));

	mov	ecx, DWORD PTR [esi+112]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	test	al, al
	je	SHORT $LN81@SetBuildin@2
	xor	eax, eax
	jmp	SHORT $LN82@SetBuildin@2
$LN81@SetBuildin@2:
	push	edi
	mov	ecx, esi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
$LN82@SetBuildin@2:
	mov	ecx, DWORD PTR [esi+112]
	imul	eax, ebx
	push	eax
	push	ebp
	call	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromBuildings
$LN1@SetBuildin@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3265 : 			}
; 3266 : 		}
; 3267 : 	}
; 3268 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingYieldChange
_TEXT	ENDS
PUBLIC	?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::ChangeBuildingYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
_eYield$ = 12						; size = 4
_iChange$ = 16						; size = 4
?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingYieldChange, COMDAT
; _this$ = ecx

; 3273 : 	SetBuildingYieldChange(eBuildingClass, eYield, GetBuildingYieldChange(eBuildingClass, eYield) + iChange);

	mov	eax, DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [ecx+84]
	push	esi
	mov	esi, DWORD PTR _eYield$[esp]
	push	edi
	mov	edi, DWORD PTR _eBuildingClass$[esp+4]
	cmp	eax, edx
	je	SHORT $LN4@ChangeBuil@4
$LL13@ChangeBuil@4:
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN5@ChangeBuil@4
	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN30@ChangeBuil@4
$LN5@ChangeBuil@4:
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL13@ChangeBuil@4
$LN4@ChangeBuil@4:
	mov	edx, DWORD PTR _iChange$[esp+4]
	xor	eax, eax
	mov	eax, edx
	push	eax
	push	esi
	push	edi
	call	?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::SetBuildingYieldChange
	pop	edi
	pop	esi

; 3274 : }

	ret	12					; 0000000cH
$LN30@ChangeBuil@4:

; 3273 : 	SetBuildingYieldChange(eBuildingClass, eYield, GetBuildingYieldChange(eBuildingClass, eYield) + iChange);

	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iChange$[esp+4]
	add	eax, edx
	push	eax
	push	esi
	push	edi
	call	?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::SetBuildingYieldChange
	pop	edi
	pop	esi

; 3274 : }

	ret	12					; 0000000cH
?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingYieldChange
_TEXT	ENDS
PUBLIC	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z
_TEXT	SEGMENT
_kWork$221265 = -12					; size = 12
_eBuildingClass$ = 8					; size = 4
_iSlot$ = 12						; size = 4
$T241958 = 16						; size = 4
_iGreatWorkIndex$ = 16					; size = 4
?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z PROC ; CvCityBuildings::SetBuildingGreatWork, COMDAT
; _this$ = ecx

; 3301 : 	for(std::vector<BuildingGreatWork>::iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR [ecx+100]
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, DWORD PTR _iSlot$[esp+12]
	push	edi
	mov	edi, DWORD PTR _eBuildingClass$[esp+16]
	cmp	eax, edx
	je	SHORT $LN6@SetBuildin@3
$LL19@SetBuildin@3:

; 3302 : 	{
; 3303 : 		if((*it).eBuildingClass == eBuildingClass && (*it).iSlot == iSlot)

	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN7@SetBuildin@3
	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN54@SetBuildin@3
$LN7@SetBuildin@3:

; 3301 : 	for(std::vector<BuildingGreatWork>::iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL19@SetBuildin@3
$LN6@SetBuildin@3:

; 3319 : 			return;
; 3320 : 		}
; 3321 : 	}
; 3322 : 
; 3323 : 	if (iGreatWorkIndex != -1)

	mov	eax, DWORD PTR _iGreatWorkIndex$[esp+16]
	cmp	eax, -1
	je	SHORT $LN1@SetBuildin@3

; 3324 : 	{
; 3325 : 		BuildingGreatWork kWork;
; 3326 : 		kWork.eBuildingClass = eBuildingClass;
; 3327 : 		kWork.iSlot = iSlot;
; 3328 : 		kWork.iGreatWorkIndex = iGreatWorkIndex;
; 3329 : 		m_aBuildingGreatWork.push_back(kWork);

	lea	edx, DWORD PTR _kWork$221265[esp+20]
	push	edx
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _kWork$221265[esp+24], edi
	mov	DWORD PTR _kWork$221265[esp+28], esi
	mov	DWORD PTR _kWork$221265[esp+32], eax
	call	?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
$LN1@SetBuildin@3:

; 3330 : 	}
; 3331 : 
; 3332 : 	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	18					; 00000012H
	call	edx
	pop	edi
	pop	esi

; 3333 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN54@SetBuildin@3:

; 3304 : 		{
; 3305 : 			int iOldGreatWorkIndex = (*it).iGreatWorkIndex;
; 3306 : 			if (iOldGreatWorkIndex != iGreatWorkIndex)

	mov	edx, DWORD PTR _iGreatWorkIndex$[esp+16]
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN2@SetBuildin@3

; 3307 : 			{
; 3308 : 				if (iGreatWorkIndex == -1)

	cmp	edx, -1
	jne	SHORT $LN3@SetBuildin@3

; 3309 : 				{
; 3310 : 					m_aBuildingGreatWork.erase(it);

	push	eax
	lea	eax, DWORD PTR $T241958[esp+20]
	push	eax
	add	ecx, 92					; 0000005cH
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 3311 : 				}
; 3312 : 				else

	jmp	SHORT $LN2@SetBuildin@3
$LN3@SetBuildin@3:

; 3313 : 				{
; 3314 : 					(*it).iGreatWorkIndex = iGreatWorkIndex;

	mov	DWORD PTR [eax+8], edx
$LN2@SetBuildin@3:

; 3315 : 				}
; 3316 : 			}
; 3317 : 
; 3318 : 			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
	pop	edi
	pop	esi

; 3333 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ENDP ; CvCityBuildings::SetBuildingGreatWork
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$6
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
_TEXT	SEGMENT
$T242058 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR __Wherenode$[ebp], esi

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	DWORD PTR $T242058[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN4@Buynode@4
	mov	eax, DWORD PTR __Larg$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [esi+16]
	push	eax
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [esi+28], dl
	mov	BYTE PTR [esi+29], 0
$LN4@Buynode@4:

; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN38@Buynode@4:
$LN37@Buynode@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242058[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
PUBLIC	??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator>><BuildingYieldChange>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; operator>><BuildingYieldChange>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; operator>><BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator>><BuildingGreatWork>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; operator>><BuildingGreatWork>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; operator>><BuildingGreatWork>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
$T242404 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	esi

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	add	esi, 16					; 00000010H
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T242404[esp+8]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z	; CvCityBuildings::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z PROC	; CvCityBuildings::Read, COMDAT
; _this$ = ecx

; 2532 : {

	push	esi
	push	edi

; 2533 : 	CvAssertMsg(m_pBuildings != NULL && m_pBuildings->GetNumBuildings() > 0, "Number of buildings to serialize is expected to greater than 0");
; 2534 : 
; 2535 : 	// Version number to maintain backwards compatibility
; 2536 : 	uint uiVersion;
; 2537 : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiVersion$[esp+4]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2538 : 
; 2539 : 	kStream >> m_iNumBuildings;

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2540 : 	kStream >> m_iBuildingProductionModifier;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2541 : 	kStream >> m_iBuildingDefense;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2542 : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 2543 : 	kStream >> m_iBuildingDefensePerCitizen;

	lea	eax, DWORD PTR [esi+12]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2544 : #endif
; 2545 : 	kStream >> m_iBuildingDefenseMod;

	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2546 : 	kStream >> m_iMissionaryExtraSpreads;

	lea	edx, DWORD PTR [esi+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2547 : 	kStream >> m_iLandmarksTourismPercent;

	lea	eax, DWORD PTR [esi+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2548 : 	kStream >> m_iGreatWorksTourismModifier;

	lea	ecx, DWORD PTR [esi+28]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2549 : 
; 2550 : 	kStream >> m_bSoldBuildingThisTurn;

	lea	edx, DWORD PTR [esi+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2551 : 
; 2552 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingProduction);

	mov	eax, DWORD PTR [esi+36]
	push	eax
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 2553 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingProductionTime);

	mov	ecx, DWORD PTR [esi+40]
	push	ecx
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 2554 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingOriginalOwner);

	mov	edx, DWORD PTR [esi+44]
	push	edx
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 2555 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingOriginalTime);

	mov	eax, DWORD PTR [esi+48]
	push	eax
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 2556 : 	BuildingArrayHelpers::Read(kStream, m_paiNumRealBuilding);

	mov	ecx, DWORD PTR [esi+52]
	push	ecx
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 2557 : 	BuildingArrayHelpers::Read(kStream, m_paiNumFreeBuilding);

	mov	edx, DWORD PTR [esi+56]
	push	edx
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 2558 : 
; 2559 : 	kStream >> m_aBuildingYieldChange;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	push	edi
	call	??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >

; 2560 : 	kStream >> m_aBuildingGreatWork;

	add	esi, 92					; 0000005cH
	push	esi
	push	edi
	call	??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
	add	esp, 64					; 00000040H
	pop	edi
	pop	esi

; 2561 : }

	ret	4
?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z ENDP	; CvCityBuildings::Read
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T242475 = -80						; size = 28
$T242474 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 268435454		; 0ffffffeH
	jb	SHORT $LN17@Insert@2

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T242475[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T242474[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T242475[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T242474[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T242474[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T242474[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T242474[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert@2:
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@2
$LN14@Insert@2:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@2

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+28], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert@2
	npad	5
$LL10@Insert@2:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+28], 0
	jne	SHORT $LN7@Insert@2

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+28], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+28], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+28], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert@2
$LN7@Insert@2:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate
$LN5@Insert@2:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+28], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+28], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert@2
$LN8@Insert@2:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+28], 0
	jne	SHORT $LN3@Insert@2

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+28], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+28], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+28], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert@2
$LN3@Insert@2:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
$LN1@Insert@2:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+28], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+28], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+29], 0
	jne	SHORT $LN170@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN170@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert@2
$LN169@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert@2
$LN167@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert@2:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+28], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert@2
$LN9@Insert@2:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+28], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T242475[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z$2:
	lea	ecx, DWORD PTR $T242474[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T243182 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	esi

; 160  : 		_Destroy(_Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	add	esi, 16					; 00000010H
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T243182[esp+8]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T243957 = -84						; size = 4
$T243215 = -80						; size = 28
$T243214 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+84]
	cmp	BYTE PTR [eax+29], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+92], ebx
	je	SHORT $LN40@erase@9

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T243215[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T243214[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T243215[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T243214[esp+108]
	mov	BYTE PTR __$EHRec$[esp+104], 1
	mov	DWORD PTR $T243214[esp+96], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T243214[esp+96]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+108], 0
	mov	DWORD PTR $T243214[esp+100], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN337@erase@9:
$LN40@erase@9:
	push	ebp
	push	esi
	push	edi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+100]
	mov	ebp, eax
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LN39@erase@9

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]
	jmp	SHORT $LN332@erase@9
$LN39@erase@9:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebp+8]
	cmp	BYTE PTR [edx+29], 0
	je	SHORT $LN37@erase@9

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN332@erase@9
$LN37@erase@9:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+100]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebp
	jne	SHORT $LN35@erase@9
$LN332@erase@9:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+29], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN34@erase@9

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@9:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN33@erase@9

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@9
$LN33@erase@9:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN31@erase@9

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@9
$LN31@erase@9:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@9:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ebx], ebp
	jne	SHORT $LN29@erase@9

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+29], 0
	je	SHORT $LN43@erase@9
	mov	eax, esi
	jmp	SHORT $LN44@erase@9
$LN43@erase@9:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Min
	add	esp, 4
$LN44@erase@9:
	mov	DWORD PTR [ebx], eax
$LN29@erase@9:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[esp+104]
	mov	ebx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ebx+8], ebp
	jne	SHORT $LN173@erase@9

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+29], 0
	je	SHORT $LN45@erase@9
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@9
$LN45@erase@9:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@9
$LN35@erase@9:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebp+8]
	jne	SHORT $LN26@erase@9

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@9
$LN26@erase@9:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+29], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@9

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@9:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@9:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+4], ebp
	jne	SHORT $LN23@erase@9

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@9
$LN23@erase@9:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx], ebp
	jne	SHORT $LN21@erase@9

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@9
$LN21@erase@9:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@9:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebp+28]
	add	eax, 28					; 0000001cH
	cmp	eax, ecx
	je	SHORT $LN173@erase@9
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@9:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	bl, 1
	cmp	BYTE PTR [ebp+28], bl
	jne	$LN19@erase@9

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR _this$[esp+104]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx+4]
	je	$LN16@erase@9
	npad	8
$LL18@erase@9:
	cmp	BYTE PTR [edi+28], bl
	jne	$LN16@erase@9

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@9

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+28], 0
	jne	SHORT $LN14@erase@9

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+28], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+28], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+104]
$LN14@erase@9:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+29], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN335@erase@9

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN11@erase@9
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+28], bl
	je	SHORT $LN336@erase@9
$LN11@erase@9:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN9@erase@9

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+28], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+28], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+104]
$LN9@erase@9:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+28]
	mov	BYTE PTR [eax+28], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+28], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+28], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@9
$LN15@erase@9:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+28], 0
	jne	SHORT $LN7@erase@9

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+28], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+28], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+104]
$LN7@erase@9:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+29], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN335@erase@9

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN4@erase@9
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN4@erase@9
$LN336@erase@9:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+28], 0
$LN335@erase@9:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ecx+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@9

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@9
$LN4@erase@9:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN2@erase@9

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+28], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+28], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+104]
$LN2@erase@9:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+28]
	mov	BYTE PTR [eax+28], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+28], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+28], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
$LN16@erase@9:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+28], bl
$LN19@erase@9:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [eax]
	lea	esi, DWORD PTR [ebp+16]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T243957[esp+112]
	push	ecx
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	xor	edi, edi

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	ebp
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[esp+112]
	mov	eax, DWORD PTR [ecx+8]
	add	esp, 8
	cmp	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	jbe	SHORT $LN1@erase@9

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@9:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+88]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
$LN334@erase@9:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T243215[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T243214[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T244376 = 8						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	ebp

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebp, DWORD PTR __Rootnode$[esp+4]
	cmp	BYTE PTR [ebp+29], 0
	push	edi
	mov	ebx, ecx
	mov	edi, ebp
	jne	SHORT $LN1@Erase@2
	push	esi
$LL3@Erase@2:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [edi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);
; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edi]
	lea	esi, DWORD PTR [ebp+16]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T244376[esp+20]
	push	ecx
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
	cmp	BYTE PTR [edi+29], 0
	mov	ebp, edi
	je	SHORT $LL3@Erase@2
	pop	esi
$LN1@Erase@2:
	pop	edi
	pop	ebp
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T244421 = 12						; size = 4
$T244419 = 12						; size = 4
__Where$222757 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+29], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@5
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@5:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setl	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@5
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@5
$LN13@insert@5:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@5:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL10@insert@5
$LN9@insert@5:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$222757[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@5

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T244419[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@5
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@5:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$222757[esp+12]
$LN57@insert@5:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jge	SHORT $LN2@insert@5

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T244421[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@5:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+29], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy@3

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+28]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+29], 0
	mov	edi, eax
	je	SHORT $LN2@Copy@3

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy@3:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy@3:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy@3:
$LN28@Copy@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T244633 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@6

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@6:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@6
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jge	$LN1@insert@6

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@6:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@6

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jge	$LN1@insert@6

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@6:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jle	SHORT $LN305@insert@6
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jge	SHORT $LN8@insert@6

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+29], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@6
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@6:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@6:
	jge	SHORT $LN1@insert@6
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@6
	cmp	ebp, DWORD PTR [eax+12]
	jge	SHORT $LN1@insert@6
$LN3@insert@6:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+29], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@6
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@6:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T244633[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN2@Copy@4

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN25@Copy@4
$LL26@Copy@4:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL26@Copy@4
$LN25@Copy@4:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN43@Copy@4
$LL44@Copy@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL44@Copy@4
$LN43@Copy@4:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@4:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T245290 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@10
	cmp	edx, eax
	jne	SHORT $LN101@erase@10

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@10:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@10
	npad	2
$LL2@erase@10:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+29], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@10
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN103@erase@10
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN79@erase@10
	npad	5
$LL80@erase@10:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL80@erase@10
$LN79@erase@10:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@10
$LN103@erase@10:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN63@erase@10
	npad	7
$LL64@erase@10:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@10
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL64@erase@10
$LN63@erase@10:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@10:
	push	edx
	lea	eax, DWORD PTR $T245290[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@10
$LN1@erase@10:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
_TEXT	ENDS
PUBLIC	??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$1
__ehfuncinfo$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
_TEXT	SEGMENT
$T246387 = -44						; size = 4
$T246219 = -44						; size = 4
$T245611 = -40						; size = 12
$T245610 = -28						; size = 16
__$EHRec$ = -12						; size = 12
$T245613 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	ebp, DWORD PTR __Keyval$[esp+48]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	xor	ebx, ebx
	cmp	BYTE PTR [eax+29], bl
	jne	SHORT $LN11@operator@6
	mov	ecx, DWORD PTR [ebp]
$LL12@operator@6:
	cmp	DWORD PTR [eax+12], ecx
	jge	SHORT $LN10@operator@6
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN9@operator@6
$LN10@operator@6:
	mov	esi, eax
	mov	eax, DWORD PTR [eax]
$LN9@operator@6:
	cmp	BYTE PTR [eax+29], bl
	je	SHORT $LL12@operator@6
$LN11@operator@6:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN1@operator@6
	mov	eax, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [esi+12]
	jge	$LN182@operator@6
$LN1@operator@6:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	lea	ecx, DWORD PTR $T245611[esp+60]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR $T245611[esp+64], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR $T245611[esp+64]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR $T245611[esp+64]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR $T245611[esp+64]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR $T245611[esp+68], ebx
	mov	ecx, DWORD PTR [ebp]
	lea	edx, DWORD PTR $T245611[esp+60]
	mov	DWORD PTR $T245610[esp+60], ecx
	push	edx
	lea	ecx, DWORD PTR $T245610[esp+68]
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	lea	eax, DWORD PTR $T245610[esp+60]
	push	eax
	push	esi
	lea	ecx, DWORD PTR $T245613[esp+64]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+80], 1
	call	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR $T245610[esp+68]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T246219[esp+68]
	push	edx
	lea	ecx, DWORD PTR $T245610[esp+76]
	mov	BYTE PTR __$EHRec$[esp+80], bl
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	eax, DWORD PTR $T245610[esp+68]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR $T245611[esp+68]
	add	esp, 4
	mov	DWORD PTR $T245610[esp+68], ebx
	mov	DWORD PTR $T245610[esp+72], ebx
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T246387[esp+68]
	push	ecx
	lea	ecx, DWORD PTR $T245611[esp+72]
	mov	DWORD PTR __$EHRec$[esp+80], -1
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	mov	edx, DWORD PTR $T245611[esp+64]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN182@operator@6:

; 174  : 		return ((*_Where).second);
; 175  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	lea	eax, DWORD PTR [esi+16]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$0:
	lea	ecx, DWORD PTR $T245611[ebp]
	jmp	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$1:
	lea	ecx, DWORD PTR $T245610[ebp]
	jmp	??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z:
	mov	eax, OFFSET __ehfuncinfo$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[]
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T246444 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	esi
	push	edi

; 545  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN20@operator@7

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T246444[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
$LN20@operator@7:
	pop	edi

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, esi
	pop	esi

; 552  : 		}

	ret	4
??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T246498 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T246498[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+29], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree@2:
$LN56@Tree@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T246837 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T246837[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 1034 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp+16]
	push	edi
	cmp	ecx, esi
	je	SHORT $LN23@swap@4

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())
; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	je	SHORT $LN20@swap@4
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN20@swap@4:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	lea	eax, DWORD PTR [esi+8]
	add	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN23@swap@4
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN23@swap@4:

; 1048 : 			}
; 1049 : 		else
; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);
; 1052 : 
; 1053 : 			_Myt _Tmp = *this;
; 1054 : 
; 1055 : 			*this = _Right;
; 1056 : 			_Right = _Tmp;
; 1057 : 			}
; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap
PUBLIC	??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T247283 = -4						; size = 4
??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T247283[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??_7CvBuildingEntry@@6B@			; CvBuildingEntry::`vftable'
PUBLIC	??1CvBuildingEntry@@QAE@XZ			; CvBuildingEntry::~CvBuildingEntry
PUBLIC	??_R4CvBuildingEntry@@6B@			; CvBuildingEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvBuildingEntry@@@8			; CvBuildingEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvBuildingEntry@@8				; CvBuildingEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBuildingEntry@@8				; CvBuildingEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvBuildingEntry@@8		; CvBuildingEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBuildingEntry::CacheResults
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBuildingEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBuildingEntry@@8 DD FLAT:??_R0?AVCvBuildingEntry@@@8 ; CvBuildingEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBuildingEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvBuildingEntry@@8
rdata$r	SEGMENT
??_R2CvBuildingEntry@@8 DD FLAT:??_R1A@?0A@EA@CvBuildingEntry@@8 ; CvBuildingEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvBuildingEntry@@8
rdata$r	SEGMENT
??_R3CvBuildingEntry@@8 DD 00H				; CvBuildingEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvBuildingEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBuildingEntry@@@8
_DATA	SEGMENT
??_R0?AVCvBuildingEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvBuildingEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBuildingEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvBuildingEntry@@6B@
rdata$r	SEGMENT
??_R4CvBuildingEntry@@6B@ DD 00H			; CvBuildingEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvBuildingEntry@@@8
	DD	FLAT:??_R3CvBuildingEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvBuildingEntry@@6B@
CONST	SEGMENT
??_7CvBuildingEntry@@6B@ DD FLAT:??_R4CvBuildingEntry@@6B@ ; CvBuildingEntry::`vftable'
	DD	FLAT:?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBuildingEntry@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CvBuildingEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBuildingEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvBuildingEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T247741 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBuildingEntry@@QAE@XZ PROC				; CvBuildingEntry::~CvBuildingEntry, COMDAT
; _this$ = ecx

; 237  : {

	push	-1
	push	__ehhandler$??1CvBuildingEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildingEntry@@6B@

; 238  : 	SAFE_DELETE_ARRAY(m_piLockedBuildingClasses);

	mov	eax, DWORD PTR [esi+836]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+44], 4
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+836], ebx

; 239  : 	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);

	mov	eax, DWORD PTR [esi+840]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+840], ebx

; 240  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	eax, DWORD PTR [esi+844]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+844], ebx

; 241  : 	SAFE_DELETE_ARRAY(m_piResourceQuantity);

	mov	eax, DWORD PTR [esi+848]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+848], ebx

; 242  : 	SAFE_DELETE_ARRAY(m_piResourceCultureChanges);

	mov	eax, DWORD PTR [esi+852]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+852], ebx

; 243  : 	SAFE_DELETE_ARRAY(m_piResourceFaithChanges);

	mov	eax, DWORD PTR [esi+856]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+856], ebx

; 244  : 	SAFE_DELETE_ARRAY(m_piProductionTraits);

	mov	eax, DWORD PTR [esi+860]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+860], ebx

; 245  : 	SAFE_DELETE_ARRAY(m_piSeaPlotYieldChange);

	mov	eax, DWORD PTR [esi+864]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+864], ebx

; 246  : 	SAFE_DELETE_ARRAY(m_piRiverPlotYieldChange);

	mov	eax, DWORD PTR [esi+868]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+868], ebx

; 247  : 	SAFE_DELETE_ARRAY(m_piLakePlotYieldChange);

	mov	eax, DWORD PTR [esi+872]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+872], ebx

; 248  : 	SAFE_DELETE_ARRAY(m_piSeaResourceYieldChange);

	mov	eax, DWORD PTR [esi+876]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+876], ebx

; 249  : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+880]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+880], ebx

; 250  : 	SAFE_DELETE_ARRAY(m_piYieldChangePerPop);

	mov	eax, DWORD PTR [esi+884]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+884], ebx

; 251  : 	SAFE_DELETE_ARRAY(m_piYieldChangePerReligion);

	mov	eax, DWORD PTR [esi+888]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+888], ebx

; 252  : 	SAFE_DELETE_ARRAY(m_piYieldModifier);

	mov	eax, DWORD PTR [esi+892]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+892], ebx

; 253  : 	SAFE_DELETE_ARRAY(m_piAreaYieldModifier);

	mov	eax, DWORD PTR [esi+896]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+896], ebx

; 254  : 	SAFE_DELETE_ARRAY(m_piGlobalYieldModifier);

	mov	eax, DWORD PTR [esi+900]
	add	esp, 64					; 00000040H
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+900], ebx

; 255  : 	SAFE_DELETE_ARRAY(m_piTechEnhancedYieldChange);

	mov	eax, DWORD PTR [esi+904]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+904], ebx

; 256  : 	SAFE_DELETE_ARRAY(m_piUnitCombatFreeExperience);

	mov	eax, DWORD PTR [esi+908]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+908], ebx

; 257  : 	SAFE_DELETE_ARRAY(m_piUnitCombatProductionModifiers);

	mov	eax, DWORD PTR [esi+912]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+912], ebx

; 258  : 	SAFE_DELETE_ARRAY(m_piDomainFreeExperience);

	mov	eax, DWORD PTR [esi+916]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+916], ebx

; 259  : 	SAFE_DELETE_ARRAY(m_piDomainFreeExperiencePerGreatWork);

	mov	eax, DWORD PTR [esi+920]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+920], ebx

; 260  : 	SAFE_DELETE_ARRAY(m_piDomainProductionModifier);

	mov	eax, DWORD PTR [esi+924]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+924], ebx

; 261  : 	SAFE_DELETE_ARRAY(m_piPrereqNumOfBuildingClass);

	mov	eax, DWORD PTR [esi+928]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+928], ebx

; 262  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+932]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+932], ebx

; 263  : 	SAFE_DELETE_ARRAY(m_piLocalResourceAnds);

	mov	eax, DWORD PTR [esi+936]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+936], ebx

; 264  : 	SAFE_DELETE_ARRAY(m_piLocalResourceOrs);

	mov	eax, DWORD PTR [esi+940]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+940], ebx

; 265  : 	SAFE_DELETE_ARRAY(m_paiHurryModifier);

	mov	eax, DWORD PTR [esi+944]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+944], ebx

; 266  : 	SAFE_DELETE_ARRAY(m_pbBuildingClassNeededInCity);

	mov	eax, DWORD PTR [esi+948]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+948], ebx

; 267  : 	SAFE_DELETE_ARRAY(m_piNumFreeUnits);

	mov	eax, DWORD PTR [esi+952]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+952], ebx

; 268  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassHappiness);

	mov	eax, DWORD PTR [esi+1000]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1000], ebx

; 269  : 	SAFE_DELETE_ARRAY(m_paThemingBonusInfo);

	mov	eax, DWORD PTR [esi+1004]
	add	esp, 60					; 0000003cH
	cmp	eax, ebx
	je	SHORT $LN72@CvBuilding
	mov	ecx, DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvThemingBonusInfo@@QAE@XZ
	push	ecx
	push	48					; 00000030H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN72@CvBuilding:

; 270  : 
; 271  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 272  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldChange.first, m_ppaiResourceYieldChange.second);
; 273  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiFeatureYieldChange.first, m_ppaiFeatureYieldChange.second);
; 274  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiSpecialistYieldChange.first, m_ppaiSpecialistYieldChange.second);
; 275  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldModifier.first, m_ppaiResourceYieldModifier.second);
; 276  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiTerrainYieldChange.first, m_ppaiTerrainYieldChange.second);
; 277  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges.first, m_ppiBuildingClassYieldChanges.second);
; 278  : #else
; 279  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldChange);

	lea	edx, DWORD PTR [esi+956]
	push	edx
	mov	DWORD PTR [esi+1004], ebx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 280  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiFeatureYieldChange);

	lea	eax, DWORD PTR [esi+960]
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 281  : 	m_ppiResourceYieldChangeGlobal.clear();

	mov	ecx, DWORD PTR [esi+968]
	mov	edx, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [esi+964]
	add	esp, 8
	push	edx
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax

; 282  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiImprovementYieldChange);

	lea	eax, DWORD PTR [esi+976]
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 283  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiImprovementYieldChangeGlobal);

	lea	ecx, DWORD PTR [esi+980]
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 284  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiSpecialistYieldChange);

	lea	edx, DWORD PTR [esi+984]
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 285  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldModifier);

	lea	eax, DWORD PTR [esi+988]
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 286  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiTerrainYieldChange);

	lea	ecx, DWORD PTR [esi+992]
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 287  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges);

	lea	edx, DWORD PTR [esi+996]
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 288  : #endif
; 289  : }

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	add	esp, 24					; 00000018H
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T247741[esp+40]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+52], 3
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR [esi+808]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	BYTE PTR __$EHRec$[esp+40], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+780]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+752]
	mov	BYTE PTR __$EHRec$[esp+40], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 808				; 00000328H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	jmp	??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
__ehhandler$??1CvBuildingEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBuildingEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBuildingEntry@@QAE@XZ ENDP				; CvBuildingEntry::~CvBuildingEntry
PUBLIC	??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+29], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??_GCvBuildingEntry@@QAEPAXI@Z			; CvBuildingEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvBuildingEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBuildingEntry@@QAEPAXI@Z PROC			; CvBuildingEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBuildingEntry@@QAE@XZ		; CvBuildingEntry::~CvBuildingEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBuildingEntry@@QAEPAXI@Z ENDP			; CvBuildingEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvBuildingEntry@@QAE@XZ			; CvBuildingEntry::CvBuildingEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0CvBuildingEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$3
__ehfuncinfo$??0CvBuildingEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvBuildingEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvBuildingEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvBuildingEntry@@QAE@XZ PROC				; CvBuildingEntry::CvBuildingEntry, COMDAT
; _this$ = ecx

; 232  : {

	push	-1
	push	__ehhandler$??0CvBuildingEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildingEntry@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], eax
	mov	DWORD PTR [esi+312], eax
	mov	DWORD PTR [esi+316], eax
	mov	DWORD PTR [esi+320], eax
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], eax
	mov	DWORD PTR [esi+340], ebx
	mov	DWORD PTR [esi+344], eax
	mov	DWORD PTR [esi+348], eax
	mov	DWORD PTR [esi+352], eax
	mov	DWORD PTR [esi+356], eax
	mov	DWORD PTR [esi+360], eax
	mov	DWORD PTR [esi+364], eax
	mov	DWORD PTR [esi+368], ebx
	mov	DWORD PTR [esi+372], ebx
	mov	DWORD PTR [esi+376], ebx
	mov	DWORD PTR [esi+380], ebx
	mov	DWORD PTR [esi+384], ebx
	mov	DWORD PTR [esi+388], ebx
	mov	DWORD PTR [esi+392], ebx
	mov	DWORD PTR [esi+396], ebx
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+420], ebx
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+428], ebx
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	BYTE PTR [esi+440], bl
	mov	DWORD PTR [esi+444], ebx
	mov	DWORD PTR [esi+448], ebx
	mov	DWORD PTR [esi+452], ebx
	mov	DWORD PTR [esi+456], ebx
	mov	DWORD PTR [esi+460], ebx
	mov	DWORD PTR [esi+464], ebx
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+508], ebx
	mov	DWORD PTR [esi+512], ebx
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	DWORD PTR [esi+528], ebx
	mov	DWORD PTR [esi+532], ebx
	mov	DWORD PTR [esi+536], ebx
	mov	DWORD PTR [esi+540], ebx
	mov	BYTE PTR [esi+544], bl
	mov	DWORD PTR [esi+548], ebx
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+556], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	DWORD PTR [esi+572], ebx
	mov	DWORD PTR [esi+576], ebx
	mov	DWORD PTR [esi+580], ebx
	mov	DWORD PTR [esi+584], ebx
	mov	BYTE PTR [esi+588], bl
	mov	BYTE PTR [esi+589], bl
	mov	DWORD PTR [esi+592], ebx
	mov	DWORD PTR [esi+596], ebx
	mov	DWORD PTR [esi+600], ebx
	mov	DWORD PTR [esi+604], ebx
	mov	DWORD PTR [esi+608], eax
	mov	DWORD PTR [esi+612], ebx
	mov	DWORD PTR [esi+616], ebx
	mov	DWORD PTR [esi+620], ebx
	mov	DWORD PTR [esi+624], ebx
	mov	DWORD PTR [esi+628], ebx
	mov	DWORD PTR [esi+632], ebx
	mov	DWORD PTR [esi+636], ebx
	mov	DWORD PTR [esi+640], ebx
	mov	DWORD PTR [esi+644], ebx
	mov	DWORD PTR [esi+648], ebx
	mov	DWORD PTR [esi+652], ebx
	mov	DWORD PTR [esi+656], ebx
	mov	DWORD PTR [esi+660], ebx
	mov	DWORD PTR [esi+664], ebx
	mov	DWORD PTR [esi+668], ebx
	mov	DWORD PTR [esi+672], ebx
	mov	DWORD PTR [esi+676], ebx
	mov	DWORD PTR [esi+680], ebx
	mov	DWORD PTR [esi+684], ebx
	mov	DWORD PTR [esi+688], ebx
	mov	DWORD PTR [esi+692], ebx
	mov	DWORD PTR [esi+696], ebx
	mov	DWORD PTR [esi+700], ebx
	mov	DWORD PTR [esi+704], ebx
	mov	DWORD PTR [esi+708], ebx
	mov	DWORD PTR [esi+712], eax
	mov	BYTE PTR [esi+716], bl
	mov	BYTE PTR [esi+717], bl
	mov	BYTE PTR [esi+718], bl
	mov	BYTE PTR [esi+719], bl
	mov	BYTE PTR [esi+720], bl
	mov	BYTE PTR [esi+721], bl
	mov	BYTE PTR [esi+722], bl
	mov	BYTE PTR [esi+723], bl
	mov	BYTE PTR [esi+724], bl
	mov	BYTE PTR [esi+725], bl
	mov	BYTE PTR [esi+726], bl
	mov	BYTE PTR [esi+727], bl
	mov	BYTE PTR [esi+728], bl
	mov	BYTE PTR [esi+729], bl
	mov	BYTE PTR [esi+730], bl
	mov	BYTE PTR [esi+731], bl
	mov	BYTE PTR [esi+732], bl
	mov	BYTE PTR [esi+733], bl
	mov	BYTE PTR [esi+734], bl
	mov	BYTE PTR [esi+735], bl
	mov	BYTE PTR [esi+736], bl
	mov	BYTE PTR [esi+737], bl
	mov	BYTE PTR [esi+738], bl
	mov	BYTE PTR [esi+739], bl
	mov	BYTE PTR [esi+740], bl
	mov	BYTE PTR [esi+741], bl
	mov	BYTE PTR [esi+742], bl
	mov	BYTE PTR [esi+743], bl
	mov	BYTE PTR [esi+744], bl
	mov	BYTE PTR [esi+745], bl
	mov	BYTE PTR [esi+746], bl
	mov	BYTE PTR [esi+747], bl
	lea	ecx, DWORD PTR [esi+752]
	mov	BYTE PTR [esi+748], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+780]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+808]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+36], 3
	mov	DWORD PTR [esi+836], ebx
	mov	DWORD PTR [esi+840], ebx
	mov	DWORD PTR [esi+844], ebx
	mov	DWORD PTR [esi+848], ebx
	mov	DWORD PTR [esi+852], ebx
	mov	DWORD PTR [esi+856], ebx
	mov	DWORD PTR [esi+860], ebx
	mov	DWORD PTR [esi+864], ebx
	mov	DWORD PTR [esi+868], ebx
	mov	DWORD PTR [esi+872], ebx
	mov	DWORD PTR [esi+876], ebx
	mov	DWORD PTR [esi+880], ebx
	mov	DWORD PTR [esi+884], ebx
	mov	DWORD PTR [esi+888], ebx
	mov	DWORD PTR [esi+892], ebx
	mov	DWORD PTR [esi+896], ebx
	mov	DWORD PTR [esi+900], ebx
	mov	DWORD PTR [esi+904], ebx
	mov	DWORD PTR [esi+908], ebx
	mov	DWORD PTR [esi+912], ebx
	mov	DWORD PTR [esi+916], ebx
	mov	DWORD PTR [esi+920], ebx
	mov	DWORD PTR [esi+924], ebx
	mov	DWORD PTR [esi+928], ebx
	mov	DWORD PTR [esi+932], ebx
	mov	DWORD PTR [esi+936], ebx
	mov	DWORD PTR [esi+940], ebx
	mov	DWORD PTR [esi+944], ebx
	mov	DWORD PTR [esi+948], ebx
	mov	DWORD PTR [esi+952], ebx
	lea	edi, DWORD PTR [esi+964]
	mov	DWORD PTR [esi+956], ebx
	mov	ecx, edi
	mov	DWORD PTR [esi+960], ebx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	mov	BYTE PTR [eax+29], 1
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]

; 233  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [esi+976], ebx
	mov	DWORD PTR [esi+980], ebx
	mov	DWORD PTR [esi+984], ebx
	mov	DWORD PTR [esi+988], ebx
	mov	DWORD PTR [esi+992], ebx
	mov	DWORD PTR [esi+996], ebx
	mov	DWORD PTR [esi+1000], ebx
	mov	DWORD PTR [esi+1004], ebx
	mov	DWORD PTR [esi+1008], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 808				; 00000328H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvBuildingEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvBuildingEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBuildingEntry@@QAE@XZ ENDP				; CvBuildingEntry::CvBuildingEntry
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_iResource$218450 = -88					; size = 4
_YieldID$218440 = -88					; size = 4
_iYieldID$219053 = -84					; size = 4
_YieldID$219040 = -84					; size = 4
_YieldID$219027 = -84					; size = 4
_YieldID$219014 = -84					; size = 4
_YieldID$219001 = -84					; size = 4
_YieldID$218988 = -84					; size = 4
_YieldID$218975 = -84					; size = 4
_iYield$218452 = -84					; size = 4
$T248322 = -80						; size = 12
_strKey$219044 = -68					; size = 28
_strKey$219031 = -68					; size = 28
_strKey$219018 = -68					; size = 28
_strKey$219005 = -68					; size = 28
_strKey$218992 = -68					; size = 28
_strKey$218979 = -68					; size = 28
_strKey$218966 = -68					; size = 28
_strKey$218442 = -68					; size = 28
_strKey$218431 = -68					; size = 28
_strResourceTypesKey$219063 = -40			; size = 28
__$EHRec$ = -12						; size = 12
_idx$219062 = 8						; size = 4
$T248324 = 8						; size = 4
_BuildingClassID$219052 = 8				; size = 4
_ResourceID$219039 = 8					; size = 4
_SpecialistID$219026 = 8				; size = 4
_TerrainID$219013 = 8					; size = 4
_ImprovementID$219000 = 8				; size = 4
_ImprovementID$218987 = 8				; size = 4
_FeatureID$218974 = 8					; size = 4
_iYieldType$218451 = 8					; size = 4
_ResourceID$218439 = 8					; size = 4
_kResults$ = 8						; size = 4
tv2860 = 12						; size = 4
tv2529 = 12						; size = 4
$T248513 = 12						; size = 4
_pResourceTypes$219065 = 12				; size = 4
_pResults$219046 = 12					; size = 4
_pResults$219033 = 12					; size = 4
_pResults$219020 = 12					; size = 4
_pResults$219007 = 12					; size = 4
_pResults$218994 = 12					; size = 4
_pResults$218981 = 12					; size = 4
_pResults$218968 = 12					; size = 4
_pResults$218444 = 12					; size = 4
_pResults$218433 = 12					; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvBuildingEntry::CacheResults, COMDAT
; _this$ = ecx

; 293  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx

; 294  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebx, DWORD PTR _kUtility$[esp+88]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+96]
	push	ebx
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN31@CacheResul
	pop	edi
	pop	esi
	pop	ebx

; 848  : 
; 849  : 	return true;
; 850  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
$LN31@CacheResul:
	push	ebp

; 295  : 		return false;
; 296  : 
; 297  : 	//Basic Properties
; 298  : 	m_iGoldMaintenance = kResults.GetInt("GoldMaintenance");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG218166
	mov	ecx, edi
	call	ebp

; 299  : 	m_iMutuallyExclusiveGroup = kResults.GetInt("MutuallyExclusiveGroup");

	push	OFFSET $SG218167
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebp

; 300  : 	m_bTeamShare = kResults.GetBool("TeamShare");

	push	OFFSET $SG218168
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 301  : 	m_bWater = kResults.GetBool("Water");

	push	OFFSET $SG218169
	mov	ecx, edi
	mov	BYTE PTR [esi+716], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 302  : 	m_bRiver = kResults.GetBool("River");

	push	OFFSET $SG218170
	mov	ecx, edi
	mov	BYTE PTR [esi+717], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 303  : 	m_bFreshWater = kResults.GetBool("FreshWater");

	push	OFFSET $SG218171
	mov	ecx, edi
	mov	BYTE PTR [esi+718], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 304  : 	m_bMountain = kResults.GetBool("Mountain");

	push	OFFSET $SG218172
	mov	ecx, edi
	mov	BYTE PTR [esi+719], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 305  : 	m_bHill = kResults.GetBool("Hill");

	push	OFFSET $SG218173
	mov	ecx, edi
	mov	BYTE PTR [esi+720], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 306  : 	m_bFlat = kResults.GetBool("Flat");

	push	OFFSET $SG218174
	mov	ecx, edi
	mov	BYTE PTR [esi+721], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 307  : 	m_bFoundsReligion = kResults.GetBool("FoundsReligion");

	push	OFFSET $SG218175
	mov	ecx, edi
	mov	BYTE PTR [esi+722], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 308  : 	m_bIsReligious = kResults.GetBool("IsReligious");

	push	OFFSET $SG218176
	mov	ecx, edi
	mov	BYTE PTR [esi+723], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 309  : 	m_bBorderObstacle = kResults.GetBool("BorderObstacle");

	push	OFFSET $SG218177
	mov	ecx, edi
	mov	BYTE PTR [esi+724], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 310  : 	m_bPlayerBorderObstacle = kResults.GetBool("PlayerBorderObstacle");

	push	OFFSET $SG218178
	mov	ecx, edi
	mov	BYTE PTR [esi+725], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 311  : 	m_bCapital = kResults.GetBool("Capital");

	push	OFFSET $SG218179
	mov	ecx, edi
	mov	BYTE PTR [esi+726], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 312  : 	m_bGoldenAge = kResults.GetBool("GoldenAge");

	push	OFFSET $SG218180
	mov	ecx, edi
	mov	BYTE PTR [esi+727], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 313  : 	m_bGrantsFreeCulturalGreatPersonWithTrait = kResults.GetBool("GrantsFreeCulturalGreatPersonWithTrait"); // NQMP GJS - New France UA

	push	OFFSET $SG218181
	mov	ecx, edi
	mov	BYTE PTR [esi+728], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 314  : 	m_bMapCentering = kResults.GetBool("MapCentering");

	push	OFFSET $SG218182
	mov	ecx, edi
	mov	BYTE PTR [esi+729], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 315  : 	m_bNeverCapture = kResults.GetBool("NeverCapture");

	push	OFFSET $SG218183
	mov	ecx, edi
	mov	BYTE PTR [esi+730], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 316  : 	m_bNukeImmune = kResults.GetBool("NukeImmune");

	push	OFFSET $SG218184
	mov	ecx, edi
	mov	BYTE PTR [esi+731], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 317  : 	m_bCityWall = kResults.GetBool("CityWall");

	push	OFFSET $SG218185
	mov	ecx, edi
	mov	BYTE PTR [esi+732], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 318  : 	m_bExtraLuxuries = kResults.GetBool("ExtraLuxuries");

	push	OFFSET $SG218186
	mov	ecx, edi
	mov	BYTE PTR [esi+736], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 319  : 	m_bDiplomaticVoting = kResults.GetBool("DiplomaticVoting");

	push	OFFSET $SG218187
	mov	ecx, edi
	mov	BYTE PTR [esi+733], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 320  : 	m_bAllowsWaterRoutes = kResults.GetBool("AllowsWaterRoutes");

	push	OFFSET $SG218188
	mov	ecx, edi
	mov	BYTE PTR [esi+734], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 321  : 	m_iProductionCost = kResults.GetInt("Cost");

	push	OFFSET $SG218189
	mov	ecx, edi
	mov	BYTE PTR [esi+735], al
	call	ebp

; 322  : 	m_iFaithCost = kResults.GetInt("FaithCost");

	push	OFFSET $SG218190
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebp

; 323  : 	m_iLeagueCost = kResults.GetInt("LeagueCost");

	push	OFFSET $SG218191
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebp

; 324  : 	m_bUnlockedByBelief = kResults.GetBool("UnlockedByBelief");

	push	OFFSET $SG218192
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 325  : 	m_bUnlockedByLeague = kResults.GetBool("UnlockedByLeague");

	push	OFFSET $SG218193
	mov	ecx, edi
	mov	BYTE PTR [esi+737], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 326  : 	m_bRequiresHolyCity = kResults.GetBool("HolyCity");

	push	OFFSET $SG218194
	mov	ecx, edi
	mov	BYTE PTR [esi+738], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 327  : 	m_bAffectSpiesNow = kResults.GetBool("AffectSpiesNow");

	push	OFFSET $SG218195
	mov	ecx, edi
	mov	BYTE PTR [esi+739], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 328  : 	m_bEspionage = kResults.GetBool("Espionage");

	push	OFFSET $SG218196
	mov	ecx, edi
	mov	BYTE PTR [esi+740], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 329  : #ifdef NQ_MALI_TREASURY
; 330  : 	m_bMalianTreasury = kResults.GetBool("MaliTreasury");

	push	OFFSET $SG218197
	mov	ecx, edi
	mov	BYTE PTR [esi+741], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 331  : #endif
; 332  : 	m_bAllowsFoodTradeRoutes = kResults.GetBool("AllowsFoodTradeRoutes");

	push	OFFSET $SG218198
	mov	ecx, edi
	mov	BYTE PTR [esi+742], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 333  : 	m_bAllowsProductionTradeRoutes = kResults.GetBool("AllowsProductionTradeRoutes");

	push	OFFSET $SG218199
	mov	ecx, edi
	mov	BYTE PTR [esi+743], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 334  : 	m_bNullifyInfluenceModifier = kResults.GetBool("NullifyInfluenceModifier");

	push	OFFSET $SG218200
	mov	ecx, edi
	mov	BYTE PTR [esi+744], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 335  : 	m_iNumCityCostMod = kResults.GetInt("NumCityCostMod");

	push	OFFSET $SG218201
	mov	ecx, edi
	mov	BYTE PTR [esi+745], al
	call	ebp

; 336  : 	m_iHurryCostModifier = kResults.GetInt("HurryCostModifier");

	push	OFFSET $SG218202
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebp

; 337  : 	m_iMinAreaSize = kResults.GetInt("MinAreaSize");

	push	OFFSET $SG218203
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebp

; 338  : 	m_iConquestProbability = kResults.GetInt("ConquestProb");

	push	OFFSET $SG218204
	mov	ecx, edi
	mov	DWORD PTR [esi+508], eax
	call	ebp

; 339  : 	m_iNumCitiesPrereq = kResults.GetInt("CitiesPrereq");

	push	OFFSET $SG218205
	mov	ecx, edi
	mov	DWORD PTR [esi+512], eax
	call	ebp
	mov	DWORD PTR [esi+388], eax

; 340  : 	m_iUnitLevelPrereq = kResults.GetInt("LevelPrereq");

	push	OFFSET $SG218206
	mov	ecx, edi
	call	ebp

; 341  : 	m_iCultureRateModifier = kResults.GetInt("CultureRateModifier");

	push	OFFSET $SG218207
	mov	ecx, edi
	mov	DWORD PTR [esi+392], eax
	call	ebp

; 342  : 	m_iGlobalCultureRateModifier = kResults.GetInt("GlobalCultureRateModifier");

	push	OFFSET $SG218208
	mov	ecx, edi
	mov	DWORD PTR [esi+396], eax
	call	ebp

; 343  : 	m_iGreatPeopleRateModifier = kResults.GetInt("GreatPeopleRateModifier");

	push	OFFSET $SG218209
	mov	ecx, edi
	mov	DWORD PTR [esi+400], eax
	call	ebp

; 344  : 	m_iGlobalGreatPeopleRateModifier = kResults.GetInt("GlobalGreatPeopleRateModifier");

	push	OFFSET $SG218210
	mov	ecx, edi
	mov	DWORD PTR [esi+404], eax
	call	ebp

; 345  : 	m_iGreatGeneralRateModifier = kResults.GetInt("GreatGeneralRateModifier");

	push	OFFSET $SG218211
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	ebp

; 346  : 	m_iGreatPersonExpendGold = kResults.GetInt("GreatPersonExpendGold");

	push	OFFSET $SG218212
	mov	ecx, edi
	mov	DWORD PTR [esi+412], eax
	call	ebp

; 347  : 	m_iUnitUpgradeCostMod = kResults.GetInt("UnitUpgradeCostMod");

	push	OFFSET $SG218213
	mov	ecx, edi
	mov	DWORD PTR [esi+416], eax
	call	ebp

; 348  : 	m_iGoldenAgeModifier = kResults.GetInt("GoldenAgeModifier");

	push	OFFSET $SG218214
	mov	ecx, edi
	mov	DWORD PTR [esi+420], eax
	call	ebp

; 349  : 	m_iFreeExperience = kResults.GetInt("Experience");

	push	OFFSET $SG218215
	mov	ecx, edi
	mov	DWORD PTR [esi+424], eax
	call	ebp

; 350  : 	m_iGlobalFreeExperience = kResults.GetInt("GlobalExperience");

	push	OFFSET $SG218216
	mov	ecx, edi
	mov	DWORD PTR [esi+428], eax
	call	ebp

; 351  : 	m_iFoodKept = kResults.GetInt("FoodKept");

	push	OFFSET $SG218217
	mov	ecx, edi
	mov	DWORD PTR [esi+432], eax
	call	ebp

; 352  : 	m_bAirlift = kResults.GetBool("Airlift");

	push	OFFSET $SG218218
	mov	ecx, edi
	mov	DWORD PTR [esi+436], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 353  : 	m_iAirModifier = kResults.GetInt("AirModifier");

	push	OFFSET $SG218219
	mov	ecx, edi
	mov	BYTE PTR [esi+440], al
	call	ebp

; 354  : 	m_iNukeModifier = kResults.GetInt("NukeModifier");

	push	OFFSET $SG218220
	mov	ecx, edi
	mov	DWORD PTR [esi+444], eax
	call	ebp

; 355  : 	m_iNukeExplosionRand = kResults.GetInt("NukeExplosionRand");

	push	OFFSET $SG218221
	mov	ecx, edi
	mov	DWORD PTR [esi+448], eax
	call	ebp

; 356  : 	m_iHealRateChange = kResults.GetInt("HealRateChange");

	push	OFFSET $SG218222
	mov	ecx, edi
	mov	DWORD PTR [esi+452], eax
	call	ebp

; 357  : 	m_iHappiness = kResults.GetInt("Happiness");

	push	OFFSET $SG218223
	mov	ecx, edi
	mov	DWORD PTR [esi+516], eax
	call	ebp

; 358  : 	m_iUnmoddedHappiness = kResults.GetInt("UnmoddedHappiness");

	push	OFFSET $SG218224
	mov	ecx, edi
	mov	DWORD PTR [esi+520], eax
	call	ebp

; 359  : 	m_iUnhappinessModifier = kResults.GetInt("UnhappinessModifier");

	push	OFFSET $SG218225
	mov	ecx, edi
	mov	DWORD PTR [esi+524], eax
	call	ebp
	mov	DWORD PTR [esi+528], eax

; 360  : 	m_iHappinessPerCity = kResults.GetInt("HappinessPerCity");

	push	OFFSET $SG218226
	mov	ecx, edi
	call	ebp

; 361  : 	m_iHappinessPerXPolicies = kResults.GetInt("HappinessPerXPolicies");

	push	OFFSET $SG218227
	mov	ecx, edi
	mov	DWORD PTR [esi+532], eax
	call	ebp

; 362  : 	m_iCityCountUnhappinessMod = kResults.GetInt("CityCountUnhappinessMod");

	push	OFFSET $SG218228
	mov	ecx, edi
	mov	DWORD PTR [esi+536], eax
	call	ebp

; 363  : 	m_bNoOccupiedUnhappiness = kResults.GetBool("NoOccupiedUnhappiness");

	push	OFFSET $SG218229
	mov	ecx, edi
	mov	DWORD PTR [esi+540], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 364  : 	m_iWorkerSpeedModifier = kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET $SG218230
	mov	ecx, edi
	mov	BYTE PTR [esi+544], al
	call	ebp

; 365  : 	m_iMilitaryProductionModifier = kResults.GetInt("MilitaryProductionModifier");

	push	OFFSET $SG218231
	mov	ecx, edi
	mov	DWORD PTR [esi+456], eax
	call	ebp

; 366  : 	m_iSpaceProductionModifier = kResults.GetInt("SpaceProductionModifier");

	push	OFFSET $SG218232
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebp

; 367  : 	m_iGlobalSpaceProductionModifier = kResults.GetInt("GlobalSpaceProductionModifier");

	push	OFFSET $SG218233
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebp

; 368  : 	m_iBuildingProductionModifier = kResults.GetInt("BuildingProductionModifier");

	push	OFFSET $SG218234
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	ebp

; 369  : 	m_iWonderProductionModifier = kResults.GetInt("WonderProductionModifier");

	push	OFFSET $SG218235
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	ebp

; 370  : 	m_iCityConnectionTradeRouteModifier = kResults.GetInt("CityConnectionTradeRouteModifier");

	push	OFFSET $SG218236
	mov	ecx, edi
	mov	DWORD PTR [esi+476], eax
	call	ebp

; 371  : 	m_iCapturePlunderModifier = kResults.GetInt("CapturePlunderModifier");

	push	OFFSET $SG218237
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	ebp

; 372  : 	m_iPolicyCostModifier = kResults.GetInt("PolicyCostModifier");

	push	OFFSET $SG218238
	mov	ecx, edi
	mov	DWORD PTR [esi+484], eax
	call	ebp

; 373  : 	m_iPlotCultureCostModifier = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET $SG218239
	mov	ecx, edi
	mov	DWORD PTR [esi+488], eax
	call	ebp

; 374  : 	m_iGlobalPlotCultureCostModifier = kResults.GetInt("GlobalPlotCultureCostModifier");

	push	OFFSET $SG218240
	mov	ecx, edi
	mov	DWORD PTR [esi+496], eax
	call	ebp

; 375  : 	m_iPlotBuyCostModifier = kResults.GetInt("PlotBuyCostModifier");

	push	OFFSET $SG218241
	mov	ecx, edi
	mov	DWORD PTR [esi+492], eax
	call	ebp

; 376  : 	m_iGlobalPlotBuyCostModifier = kResults.GetInt("GlobalPlotBuyCostModifier");

	push	OFFSET $SG218242
	mov	ecx, edi
	mov	DWORD PTR [esi+504], eax
	call	ebp

; 377  : 	m_iGlobalPopulationChange = kResults.GetInt("GlobalPopulationChange");

	push	OFFSET $SG218243
	mov	ecx, edi
	mov	DWORD PTR [esi+500], eax
	call	ebp

; 378  : #ifdef NQ_LOCAL_POPULATION_CHANGE_FROM_BUILDING
; 379  : 	m_iLocalPopulationChange = kResults.GetInt("LocalPopulationChange");

	push	OFFSET $SG218244
	mov	ecx, edi
	mov	DWORD PTR [esi+548], eax
	call	ebp

; 380  : #endif
; 381  : 	m_iTechShare = kResults.GetInt("TechShare");

	push	OFFSET $SG218245
	mov	ecx, edi
	mov	DWORD PTR [esi+552], eax
	call	ebp
	mov	DWORD PTR [esi+556], eax

; 382  : 	m_iFreeTechs = kResults.GetInt("FreeTechs");

	push	OFFSET $SG218246
	mov	ecx, edi
	call	ebp

; 383  : 	m_iFreePolicies = kResults.GetInt("FreePolicies");

	push	OFFSET $SG218247
	mov	ecx, edi
	mov	DWORD PTR [esi+560], eax
	call	ebp

; 384  : 	m_iFreeFlatFaith = kResults.GetInt("FreeFlatFaith"); // NQMP GJS - New Stonehenge

	push	OFFSET $SG218248
	mov	ecx, edi
	mov	DWORD PTR [esi+564], eax
	call	ebp

; 385  : 	m_iMountainScienceYield = kResults.GetInt("MountainScienceYield"); // NQMP GJS - mountain science yield

	push	OFFSET $SG218249
	mov	ecx, edi
	mov	DWORD PTR [esi+568], eax
	call	ebp

; 386  : 	m_iFreeGreatPeople = kResults.GetInt("FreeGreatPeople");

	push	OFFSET $SG218250
	mov	ecx, edi
	mov	DWORD PTR [esi+572], eax
	call	ebp

; 387  : 	m_iMedianTechPercentChange = kResults.GetInt("MedianTechPercentChange");

	push	OFFSET $SG218251
	mov	ecx, edi
	mov	DWORD PTR [esi+576], eax
	call	ebp

; 388  : 	m_iGold = kResults.GetInt("Gold");

	push	OFFSET $SG218252
	mov	ecx, edi
	mov	DWORD PTR [esi+580], eax
	call	ebp

; 389  : 	m_bNearbyMountainRequired = kResults.GetInt("NearbyMountainRequired");

	push	OFFSET $SG218253
	mov	ecx, edi
	mov	DWORD PTR [esi+584], eax
	call	ebp
	test	eax, eax
	setne	al

; 390  : 	m_bAllowsRangeStrike = kResults.GetInt("AllowsRangeStrike");

	push	OFFSET $SG218254
	mov	ecx, edi
	mov	BYTE PTR [esi+588], al
	call	ebp
	test	eax, eax
	setne	cl
	mov	BYTE PTR [esi+589], cl

; 391  : 	m_iDefenseModifier = kResults.GetInt("Defense");

	push	OFFSET $SG218255
	mov	ecx, edi
	call	ebp

; 392  : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 393  : 	m_iDefensePerCitizen = kResults.GetInt("DefensePerCitizen");

	push	OFFSET $SG218256
	mov	ecx, edi
	mov	DWORD PTR [esi+592], eax
	call	ebp

; 394  : #endif
; 395  : 	m_iGlobalDefenseModifier = kResults.GetInt("GlobalDefenseMod");

	push	OFFSET $SG218257
	mov	ecx, edi
	mov	DWORD PTR [esi+596], eax
	call	ebp

; 396  : 	m_iExtraCityHitPoints = kResults.GetInt("ExtraCityHitPoints");

	push	OFFSET $SG218258
	mov	ecx, edi
	mov	DWORD PTR [esi+600], eax
	call	ebp

; 397  : 	m_iMinorFriendshipChange = kResults.GetInt("MinorFriendshipChange");

	push	OFFSET $SG218259
	mov	ecx, edi
	mov	DWORD PTR [esi+604], eax
	call	ebp

; 398  : 	m_iVictoryPoints = kResults.GetInt("VictoryPoints");

	push	OFFSET $SG218260
	mov	ecx, edi
	mov	DWORD PTR [esi+612], eax
	call	ebp

; 399  : 	m_iExtraMissionarySpreads = kResults.GetInt("ExtraMissionarySpreads");

	push	OFFSET $SG218261
	mov	ecx, edi
	mov	DWORD PTR [esi+616], eax
	call	ebp

; 400  : 	m_iReligiousPressureModifier = kResults.GetInt("ReligiousPressureModifier");

	push	OFFSET $SG218262
	mov	ecx, edi
	mov	DWORD PTR [esi+620], eax
	call	ebp

; 401  : 	m_iEspionageModifier = kResults.GetInt("EspionageModifier");

	push	OFFSET $SG218263
	mov	ecx, edi
	mov	DWORD PTR [esi+624], eax
	call	ebp

; 402  : 	m_iGlobalEspionageModifier = kResults.GetInt("GlobalEspionageModifier");

	push	OFFSET $SG218264
	mov	ecx, edi
	mov	DWORD PTR [esi+628], eax
	call	ebp

; 403  : 	m_iExtraSpies = kResults.GetInt("ExtraSpies");

	push	OFFSET $SG218265
	mov	ecx, edi
	mov	DWORD PTR [esi+632], eax
	call	ebp

; 404  : 	m_iSpyRankChange = kResults.GetInt("SpyRankChange");

	push	OFFSET $SG218266
	mov	ecx, edi
	mov	DWORD PTR [esi+636], eax
	call	ebp

; 405  : 	m_iTradeRouteRecipientBonus = kResults.GetInt("TradeRouteRecipientBonus");

	push	OFFSET $SG218267
	mov	ecx, edi
	mov	DWORD PTR [esi+640], eax
	call	ebp

; 406  : 	m_iTradeRouteTargetBonus = kResults.GetInt("TradeRouteTargetBonus");

	push	OFFSET $SG218268
	mov	ecx, edi
	mov	DWORD PTR [esi+664], eax
	call	ebp

; 407  : 	m_iNumTradeRouteBonus = kResults.GetInt("NumTradeRouteBonus");

	push	OFFSET $SG218269
	mov	ecx, edi
	mov	DWORD PTR [esi+668], eax
	call	ebp

; 408  : 	m_iTradeRouteSeaDistanceModifier = kResults.GetInt("TradeRouteSeaDistanceModifier");

	push	OFFSET $SG218270
	mov	ecx, edi
	mov	DWORD PTR [esi+672], eax
	call	ebp

; 409  : 	m_iTradeRouteSeaGoldBonus = kResults.GetInt("TradeRouteSeaGoldBonus");

	push	OFFSET $SG218271
	mov	ecx, edi
	mov	DWORD PTR [esi+676], eax
	call	ebp

; 410  : 	m_iTradeRouteLandDistanceModifier = kResults.GetInt("TradeRouteLandDistanceModifier");

	push	OFFSET $SG218272
	mov	ecx, edi
	mov	DWORD PTR [esi+680], eax
	call	ebp

; 411  : 	m_iTradeRouteLandGoldBonus = kResults.GetInt("TradeRouteLandGoldBonus");

	push	OFFSET $SG218273
	mov	ecx, edi
	mov	DWORD PTR [esi+684], eax
	call	ebp

; 412  : 	m_iCityStateTradeRouteProductionModifier = kResults.GetInt("CityStateTradeRouteProductionModifier");

	push	OFFSET $SG218274
	mov	ecx, edi
	mov	DWORD PTR [esi+688], eax
	call	ebp

; 413  : 	m_iCityStateTradeRouteGoldModifier = kResults.GetInt("CityStateTradeRouteGoldModifier"); // NQMP GJS - new Economic Union

	push	OFFSET $SG218275
	mov	ecx, edi
	mov	DWORD PTR [esi+692], eax
	call	ebp

; 414  : 	m_iInstantSpyRankChange = kResults.GetInt("InstantSpyRankChange");

	push	OFFSET $SG218276
	mov	ecx, edi
	mov	DWORD PTR [esi+696], eax
	call	ebp

; 415  : 	m_iLandmarksTourismPercent = kResults.GetInt("LandmarksTourismPercent");

	push	OFFSET $SG218277
	mov	ecx, edi
	mov	DWORD PTR [esi+644], eax
	call	ebp

; 416  : 	m_iInstantMilitaryIncrease = kResults.GetInt("InstantMilitaryIncrease");

	push	OFFSET $SG218278
	mov	ecx, edi
	mov	DWORD PTR [esi+648], eax
	call	ebp

; 417  : 	m_iGreatWorksTourismModifier = kResults.GetInt("GreatWorksTourismModifier");

	push	OFFSET $SG218279
	mov	ecx, edi
	mov	DWORD PTR [esi+652], eax
	call	ebp

; 418  : 	m_iXBuiltTriggersIdeologyChoice = kResults.GetInt("XBuiltTriggersIdeologyChoice");

	push	OFFSET $SG218280
	mov	ecx, edi
	mov	DWORD PTR [esi+656], eax
	call	ebp

; 419  : 	m_iGreatScientistBeakerModifier = kResults.GetInt("GreatScientistBeakerModifier");

	push	OFFSET $SG218281
	mov	ecx, edi
	mov	DWORD PTR [esi+660], eax
	call	ebp

; 420  : 	m_iExtraLeagueVotes = kResults.GetInt("ExtraLeagueVotes");

	push	OFFSET $SG218282
	mov	ecx, edi
	mov	DWORD PTR [esi+700], eax
	call	ebp

; 421  : 	m_iPreferredDisplayPosition = kResults.GetInt("DisplayPosition");

	push	OFFSET $SG218283
	mov	ecx, edi
	mov	DWORD PTR [esi+704], eax
	call	ebp

; 422  : 	m_iPortraitIndex = kResults.GetInt("PortraitIndex");

	push	OFFSET $SG218284
	mov	ecx, edi
	mov	DWORD PTR [esi+708], eax
	call	ebp

; 423  : 
; 424  : 	m_bArtInfoCulturalVariation = kResults.GetBool("ArtInfoCulturalVariation");

	push	OFFSET $SG218285
	mov	ecx, edi
	mov	DWORD PTR [esi+712], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	BYTE PTR [esi+746], al

; 425  : 	m_bArtInfoEraVariation = kResults.GetBool("ArtInfoEraVariation");

	push	OFFSET $SG218286
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 426  : 	m_bArtInfoRandomVariation = kResults.GetBool("ArtInfoRandomVariation");

	push	OFFSET $SG218287
	mov	ecx, edi
	mov	BYTE PTR [esi+747], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 427  : 
; 428  : 	//References
; 429  : 	const char* szTextVal;
; 430  : 	szTextVal = kResults.GetText("BuildingClass");

	push	OFFSET $SG218289
	mov	ecx, edi
	mov	BYTE PTR [esi+748], al
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 431  : 	m_iBuildingClassType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 432  : 
; 433  : 	//This may need to be deferred to a routine that is called AFTER pre-fetch has been called for all infos.
; 434  : 	m_pkBuildingClassInfo = GC.getBuildingClassInfo(static_cast<BuildingClassTypes>(m_iBuildingClassType));

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+260], eax
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 435  : 	CvAssertMsg(m_pkBuildingClassInfo, "Could not find BuildingClassInfo for BuildingType. Have BuildingClasses been prefetched yet?");
; 436  : 
; 437  : 	szTextVal = kResults.GetText("ArtDefineTag");

	push	OFFSET $SG218291
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 438  : 	SetArtDefineTag(szTextVal);

	lea	ecx, DWORD PTR [esi+752]
	test	eax, eax
	je	SHORT $LN51@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN50@CacheResul
$LN51@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN50@CacheResul:

; 439  : 
; 440  : 	szTextVal = kResults.GetText("WonderSplashAudio");

	push	OFFSET $SG218292
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 441  : 	m_strWonderSplashAudio = szTextVal;

	lea	ecx, DWORD PTR [esi+780]
	test	eax, eax
	je	SHORT $LN55@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN54@CacheResul
$LN55@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN54@CacheResul:

; 442  : 
; 443  : 	szTextVal = kResults.GetText("ThemingBonusHelp");

	push	OFFSET $SG218293
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 444  : 	m_strThemingBonusHelp = szTextVal;

	lea	ecx, DWORD PTR [esi+808]
	test	eax, eax
	je	SHORT $LN59@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN58@CacheResul
$LN59@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN58@CacheResul:

; 445  : 
; 446  : 	szTextVal = kResults.GetText("NearbyTerrainRequired");

	push	OFFSET $SG218294
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 447  : 	m_iNearbyTerrainRequired = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 448  : 
; 449  : 	szTextVal = kResults.GetText("ProhibitedCityTerrain");

	push	OFFSET $SG218295
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 450  : 	m_iProhibitedCityTerrain = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 451  : 
; 452  : 	szTextVal = kResults.GetText("VictoryPrereq");

	push	OFFSET $SG218296
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 453  : 	m_iVictoryPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 454  : 
; 455  : 	szTextVal = kResults.GetText("FreeStartEra");

	push	OFFSET $SG218297
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 456  : 	m_iFreeStartEra = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 457  : 
; 458  : 	szTextVal = kResults.GetText("MaxStartEra");

	push	OFFSET $SG218298
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 459  : 	m_iMaxStartEra = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 460  : 
; 461  : 	szTextVal = kResults.GetText("ObsoleteTech");

	push	OFFSET $SG218299
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 462  : 	m_iObsoleteTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 463  : 
; 464  : 	szTextVal = kResults.GetText("EnhancedYieldTech");

	push	OFFSET $SG218300
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 465  : 	m_iEnhancedYieldTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 466  : 
; 467  : 	m_iTechEnhancedTourism = kResults.GetInt("TechEnhancedTourism");

	push	OFFSET $SG218301
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebp

; 468  : 
; 469  : 	szTextVal = kResults.GetText("FreeBuilding");

	push	OFFSET $SG218302
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 470  : 	m_iFreeBuildingClass = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 471  : 
; 472  : 	szTextVal = kResults.GetText("FreeBuildingThisCity");

	push	OFFSET $SG218303
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 473  : 	m_iFreeBuildingThisCity = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 474  : 
; 475  : 	szTextVal = kResults.GetText("FreePromotion");

	push	OFFSET $SG218304
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 476  : 	m_iFreePromotion = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 477  : 
; 478  : 	szTextVal = kResults.GetText("TrainedFreePromotion");

	push	OFFSET $SG218305
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 479  : 	m_iTrainedFreePromotion = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 480  : 
; 481  : 	szTextVal = kResults.GetText("FreePromotionRemoved");

	push	OFFSET $SG218306
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 482  : 	m_iFreePromotionRemoved = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 483  : 
; 484  : 	szTextVal = kResults.GetText("ReplacementBuildingClass");

	push	OFFSET $SG218307
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 485  : 	m_iReplacementBuildingClass= GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 486  : 
; 487  : 	szTextVal = kResults.GetText("PrereqTech");

	push	OFFSET $SG218308
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 488  : 	m_iPrereqAndTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 489  : 
; 490  : 	szTextVal = kResults.GetText("PolicyBranchType");

	push	OFFSET $SG218309
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 491  : 	m_iPolicyBranchType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 492  : 
; 493  : 	szTextVal = kResults.GetText("SpecialistType");

	push	OFFSET $SG218310
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 494  : 	m_iSpecialistType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 495  : 	m_iSpecialistCount = kResults.GetInt("SpecialistCount");

	push	OFFSET $SG218311
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebp

; 496  : 	m_iSpecialistExtraCulture = kResults.GetInt("SpecialistExtraCulture");

	push	OFFSET $SG218312
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebp

; 497  : 	m_iGreatPeopleRateChange= kResults.GetInt("GreatPeopleRateChange");

	push	OFFSET $SG218313
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebp

; 498  : 
; 499  : 	szTextVal = kResults.GetText("GreatWorkSlotType");

	push	OFFSET $SG218314
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 500  : 	m_eGreatWorkSlotType = (GreatWorkSlotType)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 501  : 	m_iGreatWorkCount = kResults.GetInt("GreatWorkCount");

	push	OFFSET $SG218316
	mov	ecx, edi
	mov	DWORD PTR [esi+336], eax
	call	ebp

; 502  : 	szTextVal = kResults.GetText("FreeGreatWork");

	push	OFFSET $SG218317
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 503  : 	m_eFreeGreatWork = (GreatWorkType)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 504  : 
; 505  : 	//Arrays
; 506  : 	const char* szBuildingType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+344], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 507  : 
; 508  : 	kUtility.SetFlavors(m_piFlavorValue, "Building_Flavors", "BuildingType", szBuildingType);

	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG218320
	push	OFFSET $SG218321
	lea	edx, DWORD PTR [esi+932]
	push	edx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 509  : 
; 510  : 	kUtility.SetYields(m_piSeaPlotYieldChange, "Building_SeaPlotYieldChanges", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218322
	push	OFFSET $SG218323
	lea	eax, DWORD PTR [esi+864]
	push	eax
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 511  : 	kUtility.SetYields(m_piRiverPlotYieldChange, "Building_RiverPlotYieldChanges", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218324
	push	OFFSET $SG218325
	lea	ecx, DWORD PTR [esi+868]
	push	ecx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 512  : 	kUtility.SetYields(m_piLakePlotYieldChange, "Building_LakePlotYieldChanges", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218326
	push	OFFSET $SG218327
	lea	edx, DWORD PTR [esi+872]
	push	edx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 513  : 	kUtility.SetYields(m_piSeaResourceYieldChange, "Building_SeaResourceYieldChanges", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218328
	push	OFFSET $SG218329
	lea	eax, DWORD PTR [esi+876]
	push	eax
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 514  : 	kUtility.SetYields(m_piYieldChange, "Building_YieldChanges", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218330
	push	OFFSET $SG218331
	lea	ecx, DWORD PTR [esi+880]
	push	ecx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 515  : 	kUtility.SetYields(m_piYieldChangePerPop, "Building_YieldChangesPerPop", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218332
	push	OFFSET $SG218333
	lea	edx, DWORD PTR [esi+884]
	push	edx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 516  : 	kUtility.SetYields(m_piYieldChangePerReligion, "Building_YieldChangesPerReligion", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218334
	push	OFFSET $SG218335
	lea	eax, DWORD PTR [esi+888]
	push	eax
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 517  : 	kUtility.SetYields(m_piYieldModifier, "Building_YieldModifiers", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218336
	push	OFFSET $SG218337
	lea	ecx, DWORD PTR [esi+892]
	push	ecx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 518  : 	kUtility.SetYields(m_piAreaYieldModifier, "Building_AreaYieldModifiers", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218338
	push	OFFSET $SG218339
	lea	edx, DWORD PTR [esi+896]
	push	edx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 519  : 	kUtility.SetYields(m_piGlobalYieldModifier, "Building_GlobalYieldModifiers", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218340
	push	OFFSET $SG218341
	lea	eax, DWORD PTR [esi+900]
	push	eax
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 520  : 	kUtility.SetYields(m_piTechEnhancedYieldChange, "Building_TechEnhancedYieldChanges", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218342
	push	OFFSET $SG218343
	lea	ecx, DWORD PTR [esi+904]
	push	ecx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 521  : 
; 522  : 	kUtility.PopulateArrayByValue(m_piResourceQuantityRequirements, "Resources", "Building_ResourceQuantityRequirements", "ResourceType", "BuildingType", szBuildingType, "Cost");

	push	0
	push	0
	push	OFFSET $SG218344
	push	edi
	push	OFFSET $SG218345
	push	OFFSET $SG218346
	push	OFFSET $SG218347
	push	OFFSET $SG218348
	lea	edx, DWORD PTR [esi+844]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 523  : 	kUtility.PopulateArrayByValue(m_piResourceQuantity, "Resources", "Building_ResourceQuantity", "ResourceType", "BuildingType", szBuildingType, "Quantity");

	push	0
	push	0
	push	OFFSET $SG218349
	push	edi
	push	OFFSET $SG218350
	push	OFFSET $SG218351
	push	OFFSET $SG218352
	push	OFFSET $SG218353
	lea	eax, DWORD PTR [esi+848]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 524  : 	kUtility.PopulateArrayByValue(m_piResourceCultureChanges, "Resources", "Building_ResourceCultureChanges", "ResourceType", "BuildingType", szBuildingType, "CultureChange");

	push	0
	push	0
	push	OFFSET $SG218354
	push	edi
	push	OFFSET $SG218355
	push	OFFSET $SG218356
	push	OFFSET $SG218357
	push	OFFSET $SG218358
	lea	ecx, DWORD PTR [esi+852]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 525  : 	kUtility.PopulateArrayByValue(m_piResourceFaithChanges, "Resources", "Building_ResourceFaithChanges", "ResourceType", "BuildingType", szBuildingType, "FaithChange");

	push	0
	push	0
	push	OFFSET $SG218359
	push	edi
	push	OFFSET $SG218360
	push	OFFSET $SG218361
	push	OFFSET $SG218362
	push	OFFSET $SG218363
	lea	edx, DWORD PTR [esi+856]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 526  : 
; 527  : 	kUtility.PopulateArrayByValue(m_paiHurryModifier, "HurryInfos", "Building_HurryModifiers", "HurryType", "BuildingType", szBuildingType, "HurryCostModifier");

	push	0
	push	0
	push	OFFSET $SG218364
	push	edi
	push	OFFSET $SG218365
	push	OFFSET $SG218366
	push	OFFSET $SG218367
	push	OFFSET $SG218368
	lea	eax, DWORD PTR [esi+944]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 528  : 
; 529  : 	//kUtility.PopulateArrayByValue(m_piProductionTraits, "Traits", "Building_ProductionTraits", "TraitType", "BuildingType", szBuildingType, "Trait");
; 530  : 
; 531  : 	kUtility.PopulateArrayByValue(m_piUnitCombatFreeExperience, "UnitCombatInfos", "Building_UnitCombatFreeExperiences", "UnitCombatType", "BuildingType", szBuildingType, "Experience");

	push	0
	push	0
	push	OFFSET $SG218369
	push	edi
	push	OFFSET $SG218370
	push	OFFSET $SG218371
	push	OFFSET $SG218372
	push	OFFSET $SG218373
	lea	ecx, DWORD PTR [esi+908]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 532  : 	kUtility.PopulateArrayByValue(m_piUnitCombatProductionModifiers, "UnitCombatInfos", "Building_UnitCombatProductionModifiers", "UnitCombatType", "BuildingType", szBuildingType, "Modifier");

	push	0
	push	0
	push	OFFSET $SG218374
	push	edi
	push	OFFSET $SG218375
	push	OFFSET $SG218376
	push	OFFSET $SG218377
	push	OFFSET $SG218378
	lea	edx, DWORD PTR [esi+912]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 533  : 	kUtility.PopulateArrayByValue(m_piDomainFreeExperience, "Domains", "Building_DomainFreeExperiences", "DomainType", "BuildingType", szBuildingType, "Experience", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET $SG218379
	push	edi
	push	OFFSET $SG218380
	push	OFFSET $SG218381
	push	OFFSET $SG218382
	push	OFFSET $SG218383
	lea	eax, DWORD PTR [esi+916]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 534  : 	kUtility.PopulateArrayByValue(m_piDomainFreeExperiencePerGreatWork, "Domains", "Building_DomainFreeExperiencePerGreatWork", "DomainType", "BuildingType", szBuildingType, "Experience", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET $SG218384
	push	edi
	push	OFFSET $SG218385
	push	OFFSET $SG218386
	push	OFFSET $SG218387
	push	OFFSET $SG218388
	lea	ecx, DWORD PTR [esi+920]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 535  : 	kUtility.PopulateArrayByValue(m_piDomainProductionModifier, "Domains", "Building_DomainProductionModifiers", "DomainType", "BuildingType", szBuildingType, "Modifier", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET $SG218389
	push	edi
	push	OFFSET $SG218390
	push	OFFSET $SG218391
	push	OFFSET $SG218392
	push	OFFSET $SG218393
	lea	edx, DWORD PTR [esi+924]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 536  : 
; 537  : 	kUtility.PopulateArrayByValue(m_piPrereqNumOfBuildingClass, "BuildingClasses", "Building_PrereqBuildingClasses", "BuildingClassType", "BuildingType", szBuildingType, "NumBuildingNeeded");

	push	0
	push	0
	push	OFFSET $SG218394
	push	edi
	push	OFFSET $SG218395
	push	OFFSET $SG218396
	push	OFFSET $SG218397
	push	OFFSET $SG218398
	lea	eax, DWORD PTR [esi+928]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 538  : 	kUtility.PopulateArrayByExistence(m_pbBuildingClassNeededInCity, "BuildingClasses", "Building_ClassesNeededInCity", "BuildingClassType", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218399
	push	OFFSET $SG218400
	push	OFFSET $SG218401
	push	OFFSET $SG218402
	lea	ecx, DWORD PTR [esi+948]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 539  : 	//kUtility.PopulateArrayByExistence(m_piNumFreeUnits, "Units", "Building_FreeUnits", "UnitType", "BuildingType", szBuildingType);
; 540  : 	kUtility.PopulateArrayByValue(m_piNumFreeUnits, "Units", "Building_FreeUnits", "UnitType", "BuildingType", szBuildingType, "NumUnits");

	push	0
	push	0
	push	OFFSET $SG218403
	push	edi
	push	OFFSET $SG218404
	push	OFFSET $SG218405
	push	OFFSET $SG218406
	push	OFFSET $SG218407
	lea	edx, DWORD PTR [esi+952]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 541  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassHappiness, "BuildingClasses", "Building_BuildingClassHappiness", "BuildingClassType", "BuildingType", szBuildingType, "Happiness");

	push	0
	push	0
	push	OFFSET $SG218408
	push	edi
	push	OFFSET $SG218409
	push	OFFSET $SG218410
	push	OFFSET $SG218411
	push	OFFSET $SG218412
	lea	eax, DWORD PTR [esi+1000]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 542  : 
; 543  : 	kUtility.PopulateArrayByExistence(m_piLockedBuildingClasses, "BuildingClasses", "Building_LockedBuildingClasses", "BuildingClassType", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218413
	push	OFFSET $SG218414
	push	OFFSET $SG218415
	push	OFFSET $SG218416
	lea	ecx, DWORD PTR [esi+836]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 544  : 	kUtility.PopulateArrayByExistence(m_piPrereqAndTechs, "Technologies", "Building_TechAndPrereqs", "TechType", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218417
	push	OFFSET $SG218418
	push	OFFSET $SG218419
	push	OFFSET $SG218420
	lea	edx, DWORD PTR [esi+840]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 545  : 	kUtility.PopulateArrayByExistence(m_piLocalResourceAnds, "Resources", "Building_LocalResourceAnds", "ResourceType", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218421
	push	OFFSET $SG218422
	push	OFFSET $SG218423
	push	OFFSET $SG218424
	lea	eax, DWORD PTR [esi+936]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 546  : 	kUtility.PopulateArrayByExistence(m_piLocalResourceOrs, "Resources", "Building_LocalResourceOrs", "ResourceType", "BuildingType", szBuildingType);

	push	edi
	push	OFFSET $SG218425
	push	OFFSET $SG218426
	push	OFFSET $SG218427
	push	OFFSET $SG218428
	lea	ecx, DWORD PTR [esi+940]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 547  : 
; 548  : 	//ResourceYieldChanges
; 549  : 	{
; 550  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 551  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldChange.first, "Resources", "Yields");
; 552  : 		m_ppaiResourceYieldChange.second = kUtility.MaxRows("Resources");
; 553  : #else
; 554  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldChange, "Resources", "Yields");

	push	0
	push	OFFSET $SG218429
	lea	eax, DWORD PTR [esi+956]
	push	OFFSET $SG218430
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 555  : #endif
; 556  : 
; 557  : 		std::string strKey("Building_ResourceYieldChanges");

	push	OFFSET $SG218432
	lea	ecx, DWORD PTR _strKey$218431[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 558  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218431[esp+104]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218433[esp+100], eax

; 559  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN30@CacheResul

; 560  : 		{
; 561  : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Building_ResourceYieldChanges inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG218435
	lea	eax, DWORD PTR _strKey$218431[esp+108]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218433[esp+100], eax
$LN30@CacheResul:

; 562  : 		}
; 563  : 
; 564  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 565  : 
; 566  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218433[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN28@CacheResul
$LL29@CacheResul:

; 567  : 		{
; 568  : 			const int ResourceID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218433[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 569  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218433[esp+100]
	push	1
	mov	DWORD PTR _ResourceID$218439[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 570  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218433[esp+100]
	push	2
	mov	DWORD PTR _YieldID$218440[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 571  : 
; 572  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 573  : 			m_ppaiResourceYieldChange.first[ResourceID][YieldID] = yield;
; 574  : #else
; 575  : 			m_ppaiResourceYieldChange[ResourceID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+956]
	mov	edx, DWORD PTR _ResourceID$218439[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$218440[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$218433[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL29@CacheResul
$LN28@CacheResul:

; 576  : #endif
; 577  : 		}
; 578  : 	}

	lea	ecx, DWORD PTR _strKey$218431[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 579  : 	//Building_ResourceYieldChangesGlobal
; 580  : 	{
; 581  : 		std::string strKey("Building_ResourceYieldChangesGlobal");

	push	OFFSET $SG218443
	lea	ecx, DWORD PTR _strKey$218442[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 582  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218442[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218444[esp+100], eax

; 583  : 		if (pResults == NULL)

	test	eax, eax
	jne	SHORT $LN27@CacheResul

; 584  : 		{
; 585  : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Building_ResourceYieldChangesGlobal inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG218446
	lea	ecx, DWORD PTR _strKey$218442[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218444[esp+100], eax
$LN27@CacheResul:

; 586  : 		}
; 587  : 
; 588  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 589  : 
; 590  : 		while (pResults->Step())

	mov	ecx, DWORD PTR _pResults$218444[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN25@CacheResul
	npad	4
$LL26@CacheResul:

; 591  : 		{
; 592  : 			const int iResource = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218444[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 593  : 			const int iYieldType = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218444[esp+100]
	push	1
	mov	DWORD PTR _iResource$218450[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 594  : 			const int iYield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218444[esp+100]
	push	2
	mov	DWORD PTR _iYieldType$218451[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 595  : 
; 596  : 			m_ppiResourceYieldChangeGlobal[iResource][iYieldType] += iYield;

	lea	edx, DWORD PTR _iYieldType$218451[esp+100]
	mov	DWORD PTR _iYield$218452[esp+104], eax
	push	edx
	lea	eax, DWORD PTR _iResource$218450[esp+108]
	push	eax
	lea	ecx, DWORD PTR [esi+964]
	call	??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[]
	mov	ecx, eax
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	ecx, DWORD PTR _iYield$218452[esp+104]
	add	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _pResults$218444[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL26@CacheResul
$LN25@CacheResul:

; 597  : 		}
; 598  : 
; 599  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$218444[esp+100]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 600  : 
; 601  : 		//Trim extra memory off container since this is mostly read-only.
; 602  : 		std::map<int, std::map<int, int>>(m_ppiResourceYieldChangeGlobal).swap(m_ppiResourceYieldChangeGlobal);

	lea	eax, DWORD PTR [esi+964]
	push	eax
	lea	ecx, DWORD PTR $T248322[esp+108]
	call	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
	lea	eax, DWORD PTR [esi+964]
	push	eax
	lea	ecx, DWORD PTR $T248322[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 2
	call	?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap
	mov	eax, DWORD PTR $T248322[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T248513[esp+108]
	push	edx
	lea	ecx, DWORD PTR $T248322[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 1
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
	mov	eax, DWORD PTR $T248322[esp+108]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 603  : 	}

	lea	ecx, DWORD PTR _strKey$218442[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 604  : 
; 605  : 	//FeatureYieldChanges
; 606  : 	{
; 607  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 608  : 		kUtility.Initialize2DArray(m_ppaiFeatureYieldChange.first, "Features", "Yields");
; 609  : 		m_ppaiFeatureYieldChange.second = kUtility.MaxRows("Features");
; 610  : #else
; 611  : 		kUtility.Initialize2DArray(m_ppaiFeatureYieldChange, "Features", "Yields");

	push	0
	push	OFFSET $SG218964
	lea	eax, DWORD PTR [esi+960]
	push	OFFSET $SG218965
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 612  : #endif
; 613  : 
; 614  : 		std::string strKey("Building_FeatureYieldChanges");

	push	OFFSET $SG218967
	lea	ecx, DWORD PTR _strKey$218966[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 615  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$218966[esp+104]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218968[esp+100], eax

; 616  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN24@CacheResul

; 617  : 		{
; 618  : 			pResults = kUtility.PrepareResults(strKey, "select Features.ID as FeatureID, Yields.ID as YieldID, Yield from Building_FeatureYieldChanges inner join Features on Features.Type = FeatureType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG218970
	lea	edx, DWORD PTR _strKey$218966[esp+108]
	push	edx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218968[esp+100], eax
$LN24@CacheResul:

; 619  : 		}
; 620  : 
; 621  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 622  : 
; 623  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218968[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN22@CacheResul
	npad	2
$LL23@CacheResul:

; 624  : 		{
; 625  : 			const int FeatureID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218968[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 626  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218968[esp+100]
	push	1
	mov	DWORD PTR _FeatureID$218974[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 627  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218968[esp+100]
	push	2
	mov	DWORD PTR _YieldID$218975[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 628  : 
; 629  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 630  : 			m_ppaiFeatureYieldChange.first[FeatureID][YieldID] = yield;
; 631  : #else
; 632  : 			m_ppaiFeatureYieldChange[FeatureID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+960]
	mov	edx, DWORD PTR _FeatureID$218974[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$218975[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$218968[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL23@CacheResul
$LN22@CacheResul:

; 633  : #endif
; 634  : 		}
; 635  : 	}

	lea	ecx, DWORD PTR _strKey$218966[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 636  : 	//ImprovementYieldChanges
; 637  : 	{
; 638  : 		kUtility.Initialize2DArray(m_ppaiImprovementYieldChange, "Improvements", "Yields");

	push	0
	push	OFFSET $SG218977
	lea	eax, DWORD PTR [esi+976]
	push	OFFSET $SG218978
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 639  : 
; 640  : 		std::string strKey("Building_ImprovementYieldChanges");

	push	OFFSET $SG218980
	lea	ecx, DWORD PTR _strKey$218979[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 641  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218979[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218981[esp+100], eax

; 642  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN21@CacheResul

; 643  : 		{
; 644  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Building_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG218983
	lea	ecx, DWORD PTR _strKey$218979[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218981[esp+100], eax
$LN21@CacheResul:

; 645  : 		}
; 646  : 
; 647  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 648  : 
; 649  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218981[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN19@CacheResul
	npad	11
$LL20@CacheResul:

; 650  : 		{
; 651  : 			const int ImprovementID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218981[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 652  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218981[esp+100]
	push	1
	mov	DWORD PTR _ImprovementID$218987[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 653  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218981[esp+100]
	push	2
	mov	DWORD PTR _YieldID$218988[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 654  : 
; 655  : 			m_ppaiImprovementYieldChange[ImprovementID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+976]
	mov	ecx, DWORD PTR _ImprovementID$218987[esp+100]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$218988[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _pResults$218981[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL20@CacheResul
$LN19@CacheResul:

; 656  : 		}
; 657  : 	}

	lea	ecx, DWORD PTR _strKey$218979[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 658  : 	//ImprovementYieldChangesGlobal
; 659  : 	{
; 660  : 		kUtility.Initialize2DArray(m_ppaiImprovementYieldChangeGlobal, "Improvements", "Yields");

	push	0
	push	OFFSET $SG218990
	lea	eax, DWORD PTR [esi+980]
	push	OFFSET $SG218991
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 661  : 
; 662  : 		std::string strKey("Building_ImprovementYieldChangesGlobal");

	push	OFFSET $SG218993
	lea	ecx, DWORD PTR _strKey$218992[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 663  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218992[esp+104]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 5
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218994[esp+100], eax

; 664  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN18@CacheResul

; 665  : 		{
; 666  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Building_ImprovementYieldChangesGlobal inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG218996
	lea	eax, DWORD PTR _strKey$218992[esp+108]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218994[esp+100], eax
$LN18@CacheResul:

; 667  : 		}
; 668  : 
; 669  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 670  : 
; 671  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218994[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN16@CacheResul
	npad	11
$LL17@CacheResul:

; 672  : 		{
; 673  : 			const int ImprovementID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218994[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 674  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218994[esp+100]
	push	1
	mov	DWORD PTR _ImprovementID$219000[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 675  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218994[esp+100]
	push	2
	mov	DWORD PTR _YieldID$219001[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 676  : 
; 677  : 			m_ppaiImprovementYieldChangeGlobal[ImprovementID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+980]
	mov	edx, DWORD PTR _ImprovementID$219000[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$219001[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$218994[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL17@CacheResul
$LN16@CacheResul:

; 678  : 		}
; 679  : 	}

	lea	ecx, DWORD PTR _strKey$218992[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 680  : 
; 681  : 	//TerrainYieldChanges
; 682  : 	{
; 683  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 684  : 		kUtility.Initialize2DArray(m_ppaiTerrainYieldChange.first, "Terrains", "Yields");
; 685  : 		m_ppaiTerrainYieldChange.second = kUtility.MaxRows("Terrains");
; 686  : #else
; 687  : 		kUtility.Initialize2DArray(m_ppaiTerrainYieldChange, "Terrains", "Yields");

	push	0
	push	OFFSET $SG219003
	lea	eax, DWORD PTR [esi+992]
	push	OFFSET $SG219004
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 688  : #endif
; 689  : 
; 690  : 		std::string strKey("Building_TerrainYieldChanges");

	push	OFFSET $SG219006
	lea	ecx, DWORD PTR _strKey$219005[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 691  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$219005[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 6
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$219007[esp+100], eax

; 692  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN15@CacheResul

; 693  : 		{
; 694  : 			pResults = kUtility.PrepareResults(strKey, "select Terrains.ID as TerrainID, Yields.ID as YieldID, Yield from Building_TerrainYieldChanges inner join Terrains on Terrains.Type = TerrainType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG219009
	lea	ecx, DWORD PTR _strKey$219005[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$219007[esp+100], eax
$LN15@CacheResul:

; 695  : 		}
; 696  : 
; 697  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 698  : 
; 699  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$219007[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN13@CacheResul
	npad	11
$LL14@CacheResul:

; 700  : 		{
; 701  : 			const int TerrainID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$219007[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 702  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$219007[esp+100]
	push	1
	mov	DWORD PTR _TerrainID$219013[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 703  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$219007[esp+100]
	push	2
	mov	DWORD PTR _YieldID$219014[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 704  : 
; 705  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 706  : 			m_ppaiTerrainYieldChange.first[TerrainID][YieldID] = yield;
; 707  : #else
; 708  : 			m_ppaiTerrainYieldChange[TerrainID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+992]
	mov	ecx, DWORD PTR _TerrainID$219013[esp+100]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$219014[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _pResults$219007[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL14@CacheResul
$LN13@CacheResul:

; 709  : #endif
; 710  : 		}
; 711  : 	}

	lea	ecx, DWORD PTR _strKey$219005[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 712  : 
; 713  : 	//SpecialistYieldChanges
; 714  : 	{
; 715  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 716  : 		kUtility.Initialize2DArray(m_ppaiSpecialistYieldChange.first, "Specialists", "Yields");
; 717  : 		m_ppaiSpecialistYieldChange.second = kUtility.MaxRows("Specialists");
; 718  : #else
; 719  : 		kUtility.Initialize2DArray(m_ppaiSpecialistYieldChange, "Specialists", "Yields");

	push	0
	push	OFFSET $SG219016
	lea	eax, DWORD PTR [esi+984]
	push	OFFSET $SG219017
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 720  : #endif
; 721  : 
; 722  : 		std::string strKey("Building_SpecialistYieldChanges");

	push	OFFSET $SG219019
	lea	ecx, DWORD PTR _strKey$219018[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 723  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$219018[esp+104]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 7
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$219020[esp+100], eax

; 724  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN12@CacheResul

; 725  : 		{
; 726  : 			pResults = kUtility.PrepareResults(strKey, "select Specialists.ID as SpecialistID, Yields.ID as YieldID, Yield from Building_SpecialistYieldChanges inner join Specialists on Specialists.Type = SpecialistType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG219022
	lea	eax, DWORD PTR _strKey$219018[esp+108]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$219020[esp+100], eax
$LN12@CacheResul:

; 727  : 		}
; 728  : 
; 729  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 730  : 
; 731  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$219020[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN10@CacheResul
	npad	11
$LL11@CacheResul:

; 732  : 		{
; 733  : 			const int SpecialistID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$219020[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 734  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$219020[esp+100]
	push	1
	mov	DWORD PTR _SpecialistID$219026[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 735  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$219020[esp+100]
	push	2
	mov	DWORD PTR _YieldID$219027[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 736  : 
; 737  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 738  : 			m_ppaiSpecialistYieldChange.first[SpecialistID][YieldID] = yield;
; 739  : #else
; 740  : 			m_ppaiSpecialistYieldChange[SpecialistID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+984]
	mov	edx, DWORD PTR _SpecialistID$219026[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$219027[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$219020[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL11@CacheResul
$LN10@CacheResul:

; 741  : #endif
; 742  : 		}
; 743  : 	}

	lea	ecx, DWORD PTR _strKey$219018[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 744  : 
; 745  : 	//ResourceYieldModifiers
; 746  : 	{
; 747  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 748  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldModifier.first, "Resources", "Yields");
; 749  : 		m_ppaiResourceYieldModifier.second = kUtility.MaxRows("Resources");
; 750  : #else
; 751  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldModifier, "Resources", "Yields");

	push	0
	push	OFFSET $SG219029
	lea	eax, DWORD PTR [esi+988]
	push	OFFSET $SG219030
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 752  : #endif
; 753  : 
; 754  : 		std::string strKey("Building_ResourceYieldModifiers");

	push	OFFSET $SG219032
	lea	ecx, DWORD PTR _strKey$219031[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 755  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$219031[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 8
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$219033[esp+100], eax

; 756  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN9@CacheResul

; 757  : 		{
; 758  : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Building_ResourceYieldModifiers inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG219035
	lea	ecx, DWORD PTR _strKey$219031[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$219033[esp+100], eax
$LN9@CacheResul:

; 759  : 		}
; 760  : 
; 761  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 762  : 
; 763  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$219033[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN7@CacheResul
	npad	11
$LL8@CacheResul:

; 764  : 		{
; 765  : 			const int ResourceID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$219033[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 766  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$219033[esp+100]
	push	1
	mov	DWORD PTR _ResourceID$219039[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 767  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$219033[esp+100]
	push	2
	mov	DWORD PTR _YieldID$219040[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 768  : 
; 769  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 770  : 			m_ppaiResourceYieldModifier.first[ResourceID][YieldID] = yield;
; 771  : #else
; 772  : 			m_ppaiResourceYieldModifier[ResourceID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+988]
	mov	ecx, DWORD PTR _ResourceID$219039[esp+100]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$219040[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _pResults$219033[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL8@CacheResul
$LN7@CacheResul:

; 773  : #endif
; 774  : 		}
; 775  : 	}

	lea	ecx, DWORD PTR _strKey$219031[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 
; 777  : 	//BuildingClassYieldChanges
; 778  : 	{
; 779  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 780  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges.first, "BuildingClasses", "Yields");
; 781  : 		m_ppiBuildingClassYieldChanges.second = kUtility.MaxRows("BuildingClasses");
; 782  : #else
; 783  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges, "BuildingClasses", "Yields");

	push	0
	push	OFFSET $SG219042
	lea	eax, DWORD PTR [esi+996]
	push	OFFSET $SG219043
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 784  : #endif
; 785  : 
; 786  : 		std::string strKey("Building_BuildingClassYieldChanges");

	push	OFFSET $SG219045
	lea	ecx, DWORD PTR _strKey$219044[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 787  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$219044[esp+104]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 9
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$219046[esp+100], eax

; 788  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN6@CacheResul

; 789  : 		{
; 790  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldChange from Building_BuildingClassYieldChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET $SG219048
	lea	eax, DWORD PTR _strKey$219044[esp+108]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$219046[esp+100], eax
$LN6@CacheResul:

; 791  : 		}
; 792  : 
; 793  : 		pResults->Bind(1, szBuildingType);

	push	1
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 794  : 
; 795  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$219046[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@CacheResul
	npad	11
$LL5@CacheResul:

; 796  : 		{
; 797  : 			const int BuildingClassID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$219046[esp+100]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 798  : 			const int iYieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$219046[esp+100]
	push	1
	mov	DWORD PTR _BuildingClassID$219052[esp+104], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 799  : 			const int iYieldChange = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$219046[esp+100]
	push	2
	mov	DWORD PTR _iYieldID$219053[esp+108], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 800  : 
; 801  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 802  : 			m_ppiBuildingClassYieldChanges.first[BuildingClassID][iYieldID] = iYieldChange;
; 803  : #else
; 804  : 			m_ppiBuildingClassYieldChanges[BuildingClassID][iYieldID] = iYieldChange;

	mov	ecx, DWORD PTR [esi+996]
	mov	edx, DWORD PTR _BuildingClassID$219052[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _iYieldID$219053[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$219046[esp+100]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL5@CacheResul
$LN4@CacheResul:

; 805  : #endif
; 806  : 		}
; 807  : 	}

	lea	ecx, DWORD PTR _strKey$219044[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 808  : 
; 809  : 	{
; 810  : 		//Initialize Theming Bonuses
; 811  : 		const int iNumThemes = MAX_THEMING_BONUSES; /* 12 */
; 812  : 		m_paThemingBonusInfo = FNEW(CvThemingBonusInfo[iNumThemes], c_eCiv5GameplayDLL, 0);

	push	580					; 00000244H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T248324[esp+100], eax
	mov	DWORD PTR __$EHRec$[esp+112], 10	; 0000000aH
	test	eax, eax
	je	SHORT $LN34@CacheResul
	push	OFFSET ??1CvThemingBonusInfo@@QAE@XZ
	push	OFFSET ??0CvThemingBonusInfo@@QAE@XZ	; CvThemingBonusInfo::CvThemingBonusInfo
	push	12					; 0000000cH
	mov	DWORD PTR [eax], 12			; 0000000cH
	add	eax, 4
	push	48					; 00000030H
	push	eax
	mov	DWORD PTR tv2529[esp+120], eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, DWORD PTR tv2529[esp+100]
	jmp	SHORT $LN35@CacheResul
$LN34@CacheResul:
	xor	eax, eax
$LN35@CacheResul:

; 813  : 		int idx = 0;
; 814  : 
; 815  : 		std::string strResourceTypesKey = "Building_ThemingBonuses";

	push	OFFSET $SG219064
	lea	ecx, DWORD PTR _strResourceTypesKey$219063[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], -1
	mov	DWORD PTR [esi+1004], eax
	mov	DWORD PTR _idx$219062[esp+104], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 816  : 		Database::Results* pResourceTypes = kUtility.GetResults(strResourceTypesKey);

	lea	eax, DWORD PTR _strResourceTypesKey$219063[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 11	; 0000000bH
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResourceTypes$219065[esp+100], eax

; 817  : 		if(pResourceTypes == NULL)

	test	eax, eax
	jne	SHORT $LN3@CacheResul

; 818  : 		{
; 819  : 			pResourceTypes = kUtility.PrepareResults(strResourceTypesKey, "select Bonus, Description, SameEra, UniqueEras, MustBeArt, MustBeArtifact, MustBeEqualArtArtifact, RequiresOwner, RequiresAnyButOwner, RequiresSamePlayer, RequiresUniquePlayers, AIPriority from Building_ThemingBonuses where BuildingType = ?");

	push	OFFSET $SG219067
	lea	ecx, DWORD PTR _strResourceTypesKey$219063[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResourceTypes$219065[esp+100], eax
$LN3@CacheResul:

; 820  : 		}
; 821  : 
; 822  : 		const size_t lenBuildingType = strlen(szBuildingType);

	mov	edx, edi
	lea	ebx, DWORD PTR [edx+1]
$LL122@CacheResul:
	mov	cl, BYTE PTR [edx]
	inc	edx
	test	cl, cl
	jne	SHORT $LL122@CacheResul

; 823  : 		pResourceTypes->Bind(1, szBuildingType, lenBuildingType, false);

	push	0
	sub	edx, ebx
	push	edx
	push	edi
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 824  : 
; 825  : 		while(pResourceTypes->Step())

	mov	ebx, DWORD PTR _pResourceTypes$219065[esp+100]
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN1@CacheResul

; 820  : 		}
; 821  : 
; 822  : 		const size_t lenBuildingType = strlen(szBuildingType);

	mov	DWORD PTR tv2860[esp+100], 0
	npad	9
$LL2@CacheResul:

; 826  : 		{
; 827  : 			CvThemingBonusInfo& pThemingInfo = m_paThemingBonusInfo[idx];

	mov	edi, DWORD PTR [esi+1004]
	add	edi, DWORD PTR tv2860[esp+100]

; 828  : 
; 829  : 			pThemingInfo.m_iBonus = pResourceTypes->GetInt("Bonus");

	push	OFFSET $SG219073
	mov	ecx, ebx
	call	ebp

; 830  : 			pThemingInfo.m_strDescription = pResourceTypes->GetText("Description");

	push	OFFSET $SG219074
	mov	ecx, ebx
	mov	DWORD PTR [edi], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	lea	ecx, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN99@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN98@CacheResul
$LN99@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN98@CacheResul:

; 831  : 			pThemingInfo.m_bSameEra = pResourceTypes->GetBool("SameEra");

	push	OFFSET $SG219075
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 832  : 			pThemingInfo.m_bUniqueEras = pResourceTypes->GetBool("UniqueEras");

	push	OFFSET $SG219076
	mov	ecx, ebx
	mov	BYTE PTR [edi+32], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 833  : 			pThemingInfo.m_bMustBeArt = pResourceTypes->GetBool("MustBeArt");

	push	OFFSET $SG219077
	mov	ecx, ebx
	mov	BYTE PTR [edi+33], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 834  : 			pThemingInfo.m_bMustBeArtifact = pResourceTypes->GetBool("MustBeArtifact");

	push	OFFSET $SG219078
	mov	ecx, ebx
	mov	BYTE PTR [edi+34], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 835  : 			pThemingInfo.m_bMustBeEqualArtArtifact = pResourceTypes->GetBool("MustBeEqualArtArtifact");

	push	OFFSET $SG219079
	mov	ecx, ebx
	mov	BYTE PTR [edi+35], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 836  : 			pThemingInfo.m_bRequiresOwner = pResourceTypes->GetBool("RequiresOwner");

	push	OFFSET $SG219080
	mov	ecx, ebx
	mov	BYTE PTR [edi+36], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 837  : 			pThemingInfo.m_bRequiresAnyButOwner = pResourceTypes->GetBool("RequiresAnyButOwner");

	push	OFFSET $SG219081
	mov	ecx, ebx
	mov	BYTE PTR [edi+37], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 838  : 			pThemingInfo.m_bRequiresSamePlayer = pResourceTypes->GetBool("RequiresSamePlayer");

	push	OFFSET $SG219082
	mov	ecx, ebx
	mov	BYTE PTR [edi+38], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 839  : 			pThemingInfo.m_bRequiresUniquePlayers = pResourceTypes->GetBool("RequiresUniquePlayers");

	push	OFFSET $SG219083
	mov	ecx, ebx
	mov	BYTE PTR [edi+39], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 840  : 			pThemingInfo.m_iAIPriority = pResourceTypes->GetInt("AIPriority");

	push	OFFSET $SG219084
	mov	ecx, ebx
	mov	BYTE PTR [edi+40], al
	call	ebp

; 841  : 
; 842  : 			idx++;

	inc	DWORD PTR _idx$219062[esp+100]
	add	DWORD PTR tv2860[esp+100], 48		; 00000030H
	mov	ecx, ebx
	mov	DWORD PTR [edi+44], eax
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL2@CacheResul
$LN1@CacheResul:

; 843  : 		}
; 844  : 
; 845  : 		m_iNumThemingBonuses = idx;

	mov	edx, DWORD PTR _idx$219062[esp+100]

; 846  : 		pResourceTypes->Reset();

	mov	ecx, ebx
	mov	DWORD PTR [esi+1008], edx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 847  : 	}

	lea	ecx, DWORD PTR _strResourceTypesKey$219063[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 848  : 
; 849  : 	return true;
; 850  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	ebp
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$218431[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$218442[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR $T248322[ebp]
	jmp	??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$218966[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _strKey$218979[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _strKey$218992[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$219005[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _strKey$219018[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR _strKey$219031[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9:
	lea	ecx, DWORD PTR _strKey$219044[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$10:
	mov	eax, DWORD PTR $T248324[ebp-4]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$11:
	lea	ecx, DWORD PTR _strResourceTypesKey$219063[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvBuildingEntry::CacheResults
PUBLIC	??$SAFE_DELETE@VCvBuildingEntry@@@@YAXAAPAVCvBuildingEntry@@@Z ; SAFE_DELETE<CvBuildingEntry>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvBuildingEntry@@@@YAXAAPAVCvBuildingEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBuildingEntry@@@@YAXAAPAVCvBuildingEntry@@@Z PROC ; SAFE_DELETE<CvBuildingEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@2
	mov	ecx, esi
	call	??1CvBuildingEntry@@QAE@XZ		; CvBuildingEntry::~CvBuildingEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBuildingEntry@@@@YAXAAPAVCvBuildingEntry@@@Z ENDP ; SAFE_DELETE<CvBuildingEntry>
_TEXT	ENDS
PUBLIC	?DeleteArray@CvBuildingXMLEntries@@QAEXXZ	; CvBuildingXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
;	COMDAT ?DeleteArray@CvBuildingXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvBuildingXMLEntries@@QAEXXZ PROC		; CvBuildingXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 2386 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 2387 : 	for(std::vector<CvBuildingEntry*>::iterator it = m_paBuildingEntries.begin(); it != m_paBuildingEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 2388 : 	{
; 2389 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvBuildingEntry@@QAE@XZ		; CvBuildingEntry::~CvBuildingEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 2390 : 	}
; 2391 : 
; 2392 : 	m_paBuildingEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 2393 : }

	ret	0
?DeleteArray@CvBuildingXMLEntries@@QAEXXZ ENDP		; CvBuildingXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??1CvBuildingXMLEntries@@QAE@XZ			; CvBuildingXMLEntries::~CvBuildingXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvBuildingXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuildingXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvBuildingXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvBuildingXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvBuildingXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBuildingXMLEntries@@QAE@XZ PROC			; CvBuildingXMLEntries::~CvBuildingXMLEntries, COMDAT
; _this$ = ecx

; 2364 : {

	push	-1
	push	__ehhandler$??1CvBuildingXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 2365 : 	DeleteArray();

	call	?DeleteArray@CvBuildingXMLEntries@@QAEXXZ ; CvBuildingXMLEntries::DeleteArray

; 2366 : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvBuilding@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvBuilding@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBuildingXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
__ehhandler$??1CvBuildingXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBuildingXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBuildingXMLEntries@@QAE@XZ ENDP			; CvBuildingXMLEntries::~CvBuildingXMLEntries
END
