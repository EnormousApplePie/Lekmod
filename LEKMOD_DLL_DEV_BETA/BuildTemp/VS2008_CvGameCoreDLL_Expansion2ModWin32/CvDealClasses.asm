; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDealClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG221530 DB	'IsAbleToMakePeace', 00H
$SG223147 DB	00H
	ORG $+1
$SG222823 DB	'LEADER_HARUN_AL_RASHID', 00H
	ORG $+1
$SG222835 DB	'BUILDING_BAZAAR', 00H
$SG222885 DB	'TXT_KEY_MISC_MADE_PEACE_WITH_MINOR_ALLIES', 00H
	ORG $+2
$SG222888 DB	'TXT_KEY_MISC_MADE_PEACE_WITH_MINOR_ALLIES_SUMMARY', 00H
	ORG $+2
$SG222909 DB	'[NEWLINE]', 00H
	ORG $+2
$SG223132 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_GPT_FROM_US', 00H
	ORG $+2
$SG223134 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_GPT_FROM_US', 00H
	ORG $+2
$SG223137 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_GPT_TO_US', 00H
$SG223139 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_GPT_TO_US', 00H
$SG223158 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_RESOURCE_FROM_US', 00H
	ORG $+1
$SG223161 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_RESOURCE_FROM_'
	DB	'US', 00H
	ORG $+1
$SG223165 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_RESOURCE_TO_US', 00H
	ORG $+3
$SG223168 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_RESOURCE_TO_US'
	DB	00H
	ORG $+3
$SG223173 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS_FROM_US', 00H
	ORG $+1
$SG223175 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_F'
	DB	'ROM_US', 00H
	ORG $+1
$SG223178 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS_TO_US', 00H
	ORG $+3
$SG223180 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_T'
	DB	'O_US', 00H
	ORG $+3
$SG223185 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US'
	DB	00H
	ORG $+7
$SG223187 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT'
	DB	'_FROM_US', 00H
	ORG $+3
$SG223190 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US', 00H
	ORG $+1
$SG223192 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT'
	DB	'_TO_US', 00H
	ORG $+1
$SG223210 DB	'TXT_KEY_NTFN_RA_FREE_TECH', 00H
	ORG $+2
$SG223212 DB	'TXT_KEY_NTFN_RA_FREE_TECH_S', 00H
$SG223217 DB	'TXT_KEY_NTFN_RA_FREE_TECH_WAR_CANCEL', 00H
	ORG $+3
$SG223219 DB	'TXT_KEY_NTFN_RA_FREE_TECH_WAR_CANCEL_S', 00H
	ORG $+1
$SG223222 DB	'TXT_KEY_NTFN_RA_FREE_TECH_CANCEL', 00H
	ORG $+3
$SG223224 DB	'TXT_KEY_NTFN_RA_FREE_TECH_CANCEL_S', 00H
	ORG $+1
$SG223229 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_U'
	DB	'S', 00H
	ORG $+2
$SG223231 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMEN'
	DB	'T_FROM_US', 00H
	ORG $+2
$SG223234 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US', 00H
$SG223332 DB	'DiplomacyAI_Messages_Log_', 00H
	ORG $+2
$SG223236 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMEN'
	DB	'T_TO_US', 00H
$SG223241 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE', 00H
$SG223243 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE', 00H
$SG223252 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE', 00H
$SG223254 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE', 00H
$SG223257 DB	'TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE', 00H
$SG223259 DB	'TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE', 00H
$SG223331 DB	'.csv', 00H
	ORG $+3
$SG223334 DB	'DiplomacyAI_Messages_Log.csv', 00H
	ORG $+3
$SG223345 DB	'%03d, ', 00H
	ORG $+1
$SG223347 DB	', ', 00H
	ORG $+1
$SG223349 DB	', , ', 00H
	ORG $+3
$SG223356 DB	'***** WHITE PEACE *****', 00H
$SG223358 DB	'***** ARMISTICE *****', 00H
	ORG $+2
$SG223360 DB	'***** SETTLEMENT *****', 00H
	ORG $+1
$SG223362 DB	'***** BACKDOWN *****', 00H
	ORG $+3
$SG223364 DB	'***** SUBMISSION *****', 00H
	ORG $+1
$SG223366 DB	'***** SURRENDER *****', 00H
	ORG $+2
$SG223368 DB	'***** CESSION *****', 00H
$SG223370 DB	'***** CAPITULATION *****', 00H
	ORG $+3
$SG223372 DB	'***** UNCONDITIONAL SURRENDER *****', 00H
$SG223374 DB	'XXX NO VALID PEACE TREATY!!!', 00H
	ORG $+3
$SG223376 DB	', ', 00H
	ORG $+1
$SG223380 DB	' is giving up!', 00H
	ORG $+1
$SG223381 DB	', ', 00H
	ORG $+1
$SG223384 DB	', White Peace!', 00H
	ORG $+1
$SG223388 DB	' has made a demand!', 00H
$SG223389 DB	', ', 00H
	ORG $+1
$SG223393 DB	' has made a request!', 00H
	ORG $+3
$SG223394 DB	', ', 00H
	ORG $+1
$SG223400 DB	'***** Gold Trade: %d *****', 00H
	ORG $+1
$SG223402 DB	'***** GPT Trade: %d *****', 00H
	ORG $+2
$SG223404 DB	'***** Resource Trade: ID %d *****', 00H
	ORG $+2
$SG223406 DB	'***** City Trade: ID %d %d *****', 00H
	ORG $+3
$SG223408 DB	'Open Borders Trade', 00H
	ORG $+1
$SG223410 DB	'***** Defensive Pact Trade *****', 00H
	ORG $+3
$SG223412 DB	'Research Agreement Trade', 00H
	ORG $+3
$SG223414 DB	'***** Peace Treaty Trade *****', 00H
	ORG $+1
$SG223416 DB	'***** Third Party Peace Trade *****', 00H
$SG223418 DB	'***** Third Party War Trade *****', 00H
	ORG $+2
$SG223420 DB	'***** Vote Commitment: ID %d, Choice %d *****', 00H
	ORG $+2
$SG223422 DB	'***** UNKNOWN TRADE!!! *****', 00H
	ORG $+3
$SG223424 DB	', ', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0CvTradedItem@@QAE@XZ				; CvTradedItem::CvTradedItem
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ??0CvTradedItem@@QAE@XZ
_TEXT	SEGMENT
??0CvTradedItem@@QAE@XZ PROC				; CvTradedItem::CvTradedItem, COMDAT
; _this$ = ecx

; 44   : {

	mov	eax, ecx

; 45   : 	m_eItemType = TRADE_ITEM_NONE;
; 46   : 	m_iDuration = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], ecx

; 47   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 48   : 	m_iTurnsRemaining = -1;
; 49   : #else
; 50   : 	m_iFinalTurn = 0;

	mov	DWORD PTR [eax+8], ecx

; 51   : #endif
; 52   : 	m_iData1 = 0;

	mov	DWORD PTR [eax+12], ecx

; 53   : 	m_iData2 = 0;

	mov	DWORD PTR [eax+16], ecx

; 54   : 	m_iData3 = 0;

	mov	DWORD PTR [eax+20], ecx

; 55   : 	m_bFlag1 = false;

	mov	BYTE PTR [eax+24], cl

; 56   : 	m_eFromPlayer = NO_PLAYER;

	mov	DWORD PTR [eax+28], -1

; 57   : 	m_bFromRenewed = false;

	mov	BYTE PTR [eax+32], cl

; 58   : 	m_bToRenewed = false;

	mov	BYTE PTR [eax+33], cl

; 59   : }

	ret	0
??0CvTradedItem@@QAE@XZ ENDP				; CvTradedItem::CvTradedItem
_TEXT	ENDS
PUBLIC	??8CvTradedItem@@QBE_NABU0@@Z			; CvTradedItem::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8CvTradedItem@@QBE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8CvTradedItem@@QBE_NABU0@@Z PROC			; CvTradedItem::operator==, COMDAT
; _this$ = ecx

; 64   : 	return (m_eItemType == rhs.m_eItemType &&
; 65   : 	        m_iData1 == rhs.m_iData1 &&
; 66   : 	        m_iData2 == rhs.m_iData2 &&
; 67   : 			m_iData3 == rhs.m_iData3 &&
; 68   : 			m_bFlag1 == rhs.m_bFlag1 &&
; 69   : 	        m_eFromPlayer == rhs.m_eFromPlayer &&
; 70   : 	        m_iDuration == rhs.m_iDuration &&
; 71   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 72   : 			m_iTurnsRemaining == rhs.m_iTurnsRemaining);
; 73   : #else
; 74   : 	        m_iFinalTurn == rhs.m_iFinalTurn);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _rhs$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR [eax+12]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator
	mov	dl, BYTE PTR [ecx+24]
	cmp	dl, BYTE PTR [eax+24]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator
	mov	eax, 1

; 75   : #endif
; 76   : }

	ret	4
$LN3@operator:

; 64   : 	return (m_eItemType == rhs.m_eItemType &&
; 65   : 	        m_iData1 == rhs.m_iData1 &&
; 66   : 	        m_iData2 == rhs.m_iData2 &&
; 67   : 			m_iData3 == rhs.m_iData3 &&
; 68   : 			m_bFlag1 == rhs.m_bFlag1 &&
; 69   : 	        m_eFromPlayer == rhs.m_eFromPlayer &&
; 70   : 	        m_iDuration == rhs.m_iDuration &&
; 71   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 72   : 			m_iTurnsRemaining == rhs.m_iTurnsRemaining);
; 73   : #else
; 74   : 	        m_iFinalTurn == rhs.m_iFinalTurn);

	xor	eax, eax

; 75   : #endif
; 76   : }

	ret	4
??8CvTradedItem@@QBE_NABU0@@Z ENDP			; CvTradedItem::operator==
_TEXT	ENDS
PUBLIC	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::SetFromPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::SetFromPlayer, COMDAT
; _this$ = ecx

; 265  : 	CvAssertMsg(ePlayer >= 0, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 266  : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 267  : 
; 268  : 	m_eFromPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 269  : }

	ret	4
?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::SetFromPlayer
_TEXT	ENDS
PUBLIC	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::SetToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC		; CvDeal::SetToPlayer, COMDAT
; _this$ = ecx

; 274  : 	CvAssertMsg(ePlayer >= 0, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 275  : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 276  : 
; 277  : 	m_eToPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 278  : }

	ret	4
?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP		; CvDeal::SetToPlayer
_TEXT	ENDS
PUBLIC	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z PROC	; CvDeal::GetOtherPlayer, COMDAT
; _this$ = ecx

; 283  : 	CvAssertMsg(eFromPlayer >= 0, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 284  : 	CvAssertMsg(eFromPlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 285  : 
; 286  : 	if(m_eFromPlayer != eFromPlayer)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR _eFromPlayer$[esp-4]

; 287  : 	{
; 288  : 		return m_eFromPlayer;

	jne	SHORT $LN1@GetOtherPl

; 289  : 	}
; 290  : 	else
; 291  : 	{
; 292  : 		return m_eToPlayer;

	mov	eax, DWORD PTR [ecx+8]
$LN1@GetOtherPl:

; 293  : 	}
; 294  : }

	ret	4
?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ENDP	; CvDeal::GetOtherPlayer
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ
_TEXT	SEGMENT
?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ PROC ; CvDeal::GetPeaceTreatyType, COMDAT
; _this$ = ecx

; 1058 : 	return m_ePeaceTreatyType;

	mov	eax, DWORD PTR [ecx+24]

; 1059 : }

	ret	0
?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ENDP ; CvDeal::GetPeaceTreatyType
_TEXT	ENDS
PUBLIC	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType
; Function compile flags: /Ogtpy
;	COMDAT ?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z
_TEXT	SEGMENT
_eTreaty$ = 8						; size = 4
?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z PROC ; CvDeal::SetPeaceTreatyType, COMDAT
; _this$ = ecx

; 1064 : 	CvAssertMsg(eTreaty >= NO_PEACE_TREATY_TYPE, "DEAL: Invalid PeaceTreatyType index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PEACE_TREATY_TYPE is valid because we could be clearing the deal out for other uses
; 1065 : 	CvAssertMsg(eTreaty < NUM_PEACE_TREATY_TYPES, "DEAL: Invalid PeaceTreatyType index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1066 : 
; 1067 : 	m_ePeaceTreatyType = eTreaty;

	mov	eax, DWORD PTR _eTreaty$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 1068 : }

	ret	4
?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ENDP ; CvDeal::SetPeaceTreatyType
_TEXT	ENDS
PUBLIC	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ PROC ; CvDeal::GetSurrenderingPlayer, COMDAT
; _this$ = ecx

; 1073 : 	return m_eSurrenderingPlayer;

	mov	eax, DWORD PTR [ecx+28]

; 1074 : }

	ret	0
?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ENDP ; CvDeal::GetSurrenderingPlayer
_TEXT	ENDS
PUBLIC	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC ; CvDeal::SetSurrenderingPlayer, COMDAT
; _this$ = ecx

; 1079 : 	CvAssertMsg(ePlayer >= NO_PLAYER, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because we could be clearing the deal out for other uses
; 1080 : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1081 : 
; 1082 : 	m_eSurrenderingPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+28], eax

; 1083 : }

	ret	4
?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP ; CvDeal::SetSurrenderingPlayer
_TEXT	ENDS
PUBLIC	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetDemandingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ PROC	; CvDeal::GetDemandingPlayer, COMDAT
; _this$ = ecx

; 1088 : 	return m_eDemandingPlayer;

	mov	eax, DWORD PTR [ecx+32]

; 1089 : }

	ret	0
?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ENDP	; CvDeal::GetDemandingPlayer
_TEXT	ENDS
PUBLIC	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetDemandingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::SetDemandingPlayer, COMDAT
; _this$ = ecx

; 1094 : 	CvAssertMsg(ePlayer >= NO_PLAYER, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because we could be clearing the deal out for other uses
; 1095 : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1096 : 
; 1097 : 	m_eDemandingPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+32], eax

; 1098 : }

	ret	4
?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::SetDemandingPlayer
_TEXT	ENDS
PUBLIC	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetRequestingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ PROC ; CvDeal::GetRequestingPlayer, COMDAT
; _this$ = ecx

; 1103 : 	return m_eRequestingPlayer;

	mov	eax, DWORD PTR [ecx+36]

; 1104 : }

	ret	0
?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ENDP ; CvDeal::GetRequestingPlayer
_TEXT	ENDS
PUBLIC	?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetRequestingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::SetRequestingPlayer, COMDAT
; _this$ = ecx

; 1109 : 	CvAssertMsg(ePlayer >= NO_PLAYER, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because we could be clearing the deal out for other uses
; 1110 : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1111 : 
; 1112 : 	m_eRequestingPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+36], eax

; 1113 : }

	ret	4
?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::SetRequestingPlayer
_TEXT	ENDS
PUBLIC	?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ; CvDeal::GetItemTradeableState
; Function compile flags: /Ogtpy
;	COMDAT ?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z
_TEXT	SEGMENT
_eTradeItem$ = 8					; size = 4
?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z PROC ; CvDeal::GetItemTradeableState, COMDAT

; 1879 : 	switch(eTradeItem)

	mov	eax, DWORD PTR _eTradeItem$[esp-4]
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN4@GetItemTra
	movzx	eax, BYTE PTR $LN8@GetItemTra[eax]
	jmp	DWORD PTR $LN9@GetItemTra[eax*4]
$LN2@GetItemTra:

; 1880 : 	{
; 1881 : 		// not renewable
; 1882 : 	case TRADE_ITEM_ALLOW_EMBASSY:
; 1883 : 	case TRADE_ITEM_CITIES:
; 1884 : 	case TRADE_ITEM_UNITS:
; 1885 : 	case TRADE_ITEM_SURRENDER:
; 1886 : 	case TRADE_ITEM_TRUCE:
; 1887 : 	case TRADE_ITEM_PEACE_TREATY:
; 1888 : 	case TRADE_ITEM_PERMANENT_ALLIANCE:
; 1889 : 	case TRADE_ITEM_THIRD_PARTY_PEACE:
; 1890 : 	case TRADE_ITEM_THIRD_PARTY_WAR:
; 1891 : 	case TRADE_ITEM_VOTE_COMMITMENT:
; 1892 : 		return DEAL_NONRENEWABLE;
; 1893 : 		break;
; 1894 : 
; 1895 : 		// renewable
; 1896 : 	case TRADE_ITEM_GOLD_PER_TURN:
; 1897 : 	case TRADE_ITEM_RESOURCES:
; 1898 : 	case TRADE_ITEM_OPEN_BORDERS:
; 1899 : 	case TRADE_ITEM_DEFENSIVE_PACT:
; 1900 : 	case TRADE_ITEM_THIRD_PARTY_EMBARGO: // dead!
; 1901 : 		return DEAL_RENEWABLE;

	xor	eax, eax

; 1915 : }

	ret	0
$LN1@GetItemTra:

; 1902 : 		break;
; 1903 : 
; 1904 : 		// doesn't matter
; 1905 : 	case TRADE_ITEM_TRADE_AGREEMENT:
; 1906 : 	case TRADE_ITEM_GOLD:
; 1907 : 	case TRADE_ITEM_MAPS:
; 1908 : 	case TRADE_ITEM_RESEARCH_AGREEMENT:
; 1909 : 		return DEAL_SUPPLEMENTAL;

	mov	eax, 2

; 1915 : }

	ret	0
$LN4@GetItemTra:

; 1910 : 		break;
; 1911 : 	}
; 1912 : 
; 1913 : 	CvAssertMsg(false, "unknown eTradeItem passed in");
; 1914 : 	return DEAL_NONRENEWABLE;

	mov	eax, 1

; 1915 : }

	ret	0
	npad	2
$LN9@GetItemTra:
	DD	$LN1@GetItemTra
	DD	$LN2@GetItemTra
	DD	$LN4@GetItemTra
	DD	$LN4@GetItemTra
$LN8@GetItemTra:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	2
	DB	2
	DB	1
	DB	1
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	3
	DB	2
?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ENDP ; CvDeal::GetItemTradeableState
_TEXT	ENDS
PUBLIC	??4FDataStream@@QAEAAV0@ABV0@@Z			; FDataStream::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4FDataStream@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4FDataStream@@QAEAAV0@ABV0@@Z PROC			; FDataStream::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	ret	4
??4FDataStream@@QAEAAV0@ABV0@@Z ENDP			; FDataStream::operator=
_TEXT	ENDS
PUBLIC	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ	; CvGameDeals::GetTempDeal
; Function compile flags: /Ogtpy
;	COMDAT ?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ
_TEXT	SEGMENT
?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ PROC		; CvGameDeals::GetTempDeal, COMDAT
; _this$ = ecx

; 2650 : 	return &m_TempDeal;

	lea	eax, DWORD PTR [ecx+4612]

; 2651 : }

	ret	0
?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ENDP		; CvGameDeals::GetTempDeal
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvDeal@@$0A@@@QBEIXZ	; BaseVector<CvDeal,0>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@VCvDeal@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvDeal@@$0A@@@QBEIXZ PROC		; BaseVector<CvDeal,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvDeal@@$0A@@@QBEIXZ ENDP		; BaseVector<CvDeal,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ ; BaseVector<CvDeal,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ PROC ; BaseVector<CvDeal,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ ENDP ; BaseVector<CvDeal,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ ; BaseVector<CvDeal,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ PROC	; BaseVector<CvDeal,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [ecx]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvDeal@@$0A@@@QAEPAVCvDeal@@XZ ENDP	; BaseVector<CvDeal,0>::end
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ ; BaseVector<CvDeal,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ PROC ; BaseVector<CvDeal,0>::begin, COMDAT
; _this$ = ecx

; 201  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 202  :     };

	ret	0
?begin@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ ENDP ; BaseVector<CvDeal,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ ; BaseVector<CvDeal,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ PROC	; BaseVector<CvDeal,0>::end, COMDAT
; _this$ = ecx

; 204  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [ecx]

; 205  :     };

	ret	0
?end@?$BaseVector@VCvDeal@@$0A@@@QBEPBVCvDeal@@XZ ENDP	; BaseVector<CvDeal,0>::end
_TEXT	ENDS
PUBLIC	??9?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::operator!=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??9?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::operator!=, COMDAT
; _this$ = ecx

; 353  : 			return m_uiCurrPos != rhs.m_uiCurrPos;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _rhs$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	al, cl

; 354  : 		};

	ret	4
??9?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::operator!=
_TEXT	ENDS
PUBLIC	??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator!=, COMDAT
; _this$ = ecx

; 353  : 			return m_uiCurrPos != rhs.m_uiCurrPos;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _rhs$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	al, cl

; 354  : 		};

	ret	4
??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator!=
_TEXT	ENDS
PUBLIC	??0?$pair@IPAVCvDeal@@@std@@QAE@ABIABQAVCvDeal@@@Z ; std::pair<unsigned int,CvDeal *>::pair<unsigned int,CvDeal *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@IPAVCvDeal@@@std@@QAE@ABIABQAVCvDeal@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@IPAVCvDeal@@@std@@QAE@ABIABQAVCvDeal@@@Z PROC	; std::pair<unsigned int,CvDeal *>::pair<unsigned int,CvDeal *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@IPAVCvDeal@@@std@@QAE@ABIABQAVCvDeal@@@Z ENDP	; std::pair<unsigned int,CvDeal *>::pair<unsigned int,CvDeal *>
_TEXT	ENDS
PUBLIC	?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::size, COMDAT
; _this$ = ecx

; 522  : 		return m_uiSize;

	mov	eax, DWORD PTR [ecx+20]

; 523  : 	};

	ret	0
?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::size
_TEXT	ENDS
PUBLIC	?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QBEABV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QBEABV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QBEABV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ PROC ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator, COMDAT
; _this$ = ecx

; 710  : 	const T_ALLOCATOR& get_allocator() const{ return m_kAllocator; };

	mov	eax, ecx
	ret	0
?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QBEABV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ ENDP ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator
_TEXT	ENDS
PUBLIC	?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ PROC ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator, COMDAT
; _this$ = ecx

; 711  : 	T_ALLOCATOR& get_allocator(){ return m_kAllocator; };

	mov	eax, ecx
	ret	0
?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ ENDP ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator
_TEXT	ENDS
PUBLIC	??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fire'
	DB	'place\include\fireworks\FFastVector.h', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEPAVCvDeal@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEPAVCvDeal@@I@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 20					; 00000014H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, edi
	imul	eax, 76					; 0000004cH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 20			; 00000014H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEPAVCvDeal@@I@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ		; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ PROC		; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ ENDP		; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvDeal@@$0A@@@IAE@XZ		; BaseVector<CvDeal,0>::BaseVector<CvDeal,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvDeal@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvDeal@@$0A@@@IAE@XZ PROC		; BaseVector<CvDeal,0>::BaseVector<CvDeal,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvDeal@@$0A@@@IAE@XZ ENDP		; BaseVector<CvDeal,0>::BaseVector<CvDeal,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z ; BaseVector<CvDeal,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z PROC ; BaseVector<CvDeal,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	npad	2
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z ENDP ; BaseVector<CvDeal,0>::Destroy
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocator<std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocator<std::pair<unsigned int,CvDeal *> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocator<std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
PUBLIC	?get_index@?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::get_index
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?get_index@?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ
_TEXT	SEGMENT
?get_index@?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::get_index, COMDAT
; _this$ = ecx

; 363  : 			return m_uiCurrPos;

	mov	eax, DWORD PTR [ecx+4]

; 364  : 		};

	ret	0
?get_index@?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::get_index
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEABU?$pair@IPAVCvDeal@@@1@XZ ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEABU?$pair@IPAVCvDeal@@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEABU?$pair@IPAVCvDeal@@@1@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEABU?$pair@IPAVCvDeal@@@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator==
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0?$MultiListNodePolicy@UCvTradedItem@@@@QAE@ABUCvTradedItem@@@Z ; MultiListNodePolicy<CvTradedItem>::MultiListNodePolicy<CvTradedItem>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$MultiListNodePolicy@UCvTradedItem@@@@QAE@ABUCvTradedItem@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??0?$MultiListNodePolicy@UCvTradedItem@@@@QAE@ABUCvTradedItem@@@Z PROC ; MultiListNodePolicy<CvTradedItem>::MultiListNodePolicy<CvTradedItem>, COMDAT
; _this$ = ecx

; 78   : 	MultiListNodePolicy( const T& x ) : data( x ){};

	push	esi
	mov	esi, DWORD PTR _x$[esp]
	push	edi
	mov	eax, ecx
	lea	edi, DWORD PTR [eax+8]
	mov	ecx, 9
	rep movsd
	pop	edi
	pop	esi
	ret	4
??0?$MultiListNodePolicy@UCvTradedItem@@@@QAE@ABUCvTradedItem@@@Z ENDP ; MultiListNodePolicy<CvTradedItem>::MultiListNodePolicy<CvTradedItem>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx]

; 137  : 	};

	ret	4
??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[]
_TEXT	ENDS
PUBLIC	?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ	; NullMultiListNodePolicy::LIST_GetNext
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ
_TEXT	SEGMENT
?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ PROC	; NullMultiListNodePolicy::LIST_GetNext, COMDAT
; _this$ = ecx

; 62   : 	unsigned int LIST_GetNext() const{ return node.uiNext; };

	mov	eax, DWORD PTR [ecx]
	ret	0
?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ ENDP	; NullMultiListNodePolicy::LIST_GetNext
_TEXT	ENDS
PUBLIC	?LIST_GetPrev@NullMultiListNodePolicy@@QBEIXZ	; NullMultiListNodePolicy::LIST_GetPrev
; Function compile flags: /Ogtpy
;	COMDAT ?LIST_GetPrev@NullMultiListNodePolicy@@QBEIXZ
_TEXT	SEGMENT
?LIST_GetPrev@NullMultiListNodePolicy@@QBEIXZ PROC	; NullMultiListNodePolicy::LIST_GetPrev, COMDAT
; _this$ = ecx

; 63   : 	unsigned int LIST_GetPrev() const{ return node.uiPrev; };

	mov	eax, DWORD PTR [ecx+4]
	and	eax, 2147483647				; 7fffffffH
	ret	0
?LIST_GetPrev@NullMultiListNodePolicy@@QBEIXZ ENDP	; NullMultiListNodePolicy::LIST_GetPrev
_TEXT	ENDS
PUBLIC	?LIST_SetNext@NullMultiListNodePolicy@@QAEXI@Z	; NullMultiListNodePolicy::LIST_SetNext
; Function compile flags: /Ogtpy
;	COMDAT ?LIST_SetNext@NullMultiListNodePolicy@@QAEXI@Z
_TEXT	SEGMENT
_uiNodeIndex$ = 8					; size = 4
?LIST_SetNext@NullMultiListNodePolicy@@QAEXI@Z PROC	; NullMultiListNodePolicy::LIST_SetNext, COMDAT
; _this$ = ecx

; 64   : 	void LIST_SetNext(unsigned int uiNodeIndex){ node.uiNext = uiNodeIndex; };

	mov	eax, DWORD PTR _uiNodeIndex$[esp-4]
	mov	DWORD PTR [ecx], eax
	ret	4
?LIST_SetNext@NullMultiListNodePolicy@@QAEXI@Z ENDP	; NullMultiListNodePolicy::LIST_SetNext
_TEXT	ENDS
PUBLIC	?LIST_SetPrev@NullMultiListNodePolicy@@QAEXI@Z	; NullMultiListNodePolicy::LIST_SetPrev
; Function compile flags: /Ogtpy
;	COMDAT ?LIST_SetPrev@NullMultiListNodePolicy@@QAEXI@Z
_TEXT	SEGMENT
_uiNodeIndex$ = 8					; size = 4
?LIST_SetPrev@NullMultiListNodePolicy@@QAEXI@Z PROC	; NullMultiListNodePolicy::LIST_SetPrev, COMDAT
; _this$ = ecx

; 65   : 	void LIST_SetPrev(unsigned int uiNodeIndex){ node.uiPrev = uiNodeIndex; };

	mov	eax, DWORD PTR [ecx+4]
	xor	eax, DWORD PTR _uiNodeIndex$[esp-4]
	and	eax, 2147483647				; 7fffffffH
	xor	DWORD PTR [ecx+4], eax
	ret	4
?LIST_SetPrev@NullMultiListNodePolicy@@QAEXI@Z ENDP	; NullMultiListNodePolicy::LIST_SetPrev
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T225462 = -80						; size = 28
$T225461 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T225462[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T225461[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T225462[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T225461[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T225461[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T225461[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T225461[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T225462[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T225461[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
PUBLIC	?LIST_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ ; NullMultiListNodePolicy::LIST_GetDeleted
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?LIST_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ
_TEXT	SEGMENT
?LIST_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ PROC	; NullMultiListNodePolicy::LIST_GetDeleted, COMDAT
; _this$ = ecx

; 66   : 	bool LIST_GetDeleted() const{ return !node.bValid; };

	mov	eax, DWORD PTR [ecx+4]
	shr	eax, 31					; 0000001fH
	not	eax
	and	eax, 1
	ret	0
?LIST_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ ENDP	; NullMultiListNodePolicy::LIST_GetDeleted
_TEXT	ENDS
PUBLIC	?LIST_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z ; NullMultiListNodePolicy::LIST_SetDeleted
; Function compile flags: /Ogtpy
;	COMDAT ?LIST_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z
_TEXT	SEGMENT
_bDeleted$ = 8						; size = 1
?LIST_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z PROC	; NullMultiListNodePolicy::LIST_SetDeleted, COMDAT
; _this$ = ecx

; 67   : 	void LIST_SetDeleted(bool bDeleted){ node.bValid = !bDeleted; };

	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	BYTE PTR _bDeleted$[esp-4], al
	sete	al
	and	edx, 2147483647				; 7fffffffH
	shl	eax, 31					; 0000001fH
	or	eax, edx
	mov	DWORD PTR [ecx+4], eax
	ret	4
?LIST_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z ENDP	; NullMultiListNodePolicy::LIST_SetDeleted
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	?ALLOC_GetNext@NullMultiListNodePolicy@@QBEIXZ	; NullMultiListNodePolicy::ALLOC_GetNext
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?ALLOC_GetNext@NullMultiListNodePolicy@@QBEIXZ
_TEXT	SEGMENT
?ALLOC_GetNext@NullMultiListNodePolicy@@QBEIXZ PROC	; NullMultiListNodePolicy::ALLOC_GetNext, COMDAT
; _this$ = ecx

; 70   : 	unsigned int ALLOC_GetNext() const{ return node.uiNext; };

	mov	eax, DWORD PTR [ecx]
	ret	0
?ALLOC_GetNext@NullMultiListNodePolicy@@QBEIXZ ENDP	; NullMultiListNodePolicy::ALLOC_GetNext
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocator<std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocator<std::pair<unsigned int,CvDeal *> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocator<std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
PUBLIC	?ALLOC_SetNext@NullMultiListNodePolicy@@QAEXI@Z	; NullMultiListNodePolicy::ALLOC_SetNext
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?ALLOC_SetNext@NullMultiListNodePolicy@@QAEXI@Z
_TEXT	SEGMENT
_uiNodeIndex$ = 8					; size = 4
?ALLOC_SetNext@NullMultiListNodePolicy@@QAEXI@Z PROC	; NullMultiListNodePolicy::ALLOC_SetNext, COMDAT
; _this$ = ecx

; 71   : 	void ALLOC_SetNext(unsigned int uiNodeIndex){ node.uiNext = uiNodeIndex; };

	mov	eax, DWORD PTR _uiNodeIndex$[esp-4]
	mov	DWORD PTR [ecx], eax
	ret	4
?ALLOC_SetNext@NullMultiListNodePolicy@@QAEXI@Z ENDP	; NullMultiListNodePolicy::ALLOC_SetNext
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@I@Z ; std::allocator<std::pair<unsigned int,CvDeal *> >::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@I@Z PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::deallocate
_TEXT	ENDS
PUBLIC	?ALLOC_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ ; NullMultiListNodePolicy::ALLOC_GetDeleted
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?ALLOC_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ
_TEXT	SEGMENT
?ALLOC_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ PROC	; NullMultiListNodePolicy::ALLOC_GetDeleted, COMDAT
; _this$ = ecx

; 72   : 	bool ALLOC_GetDeleted() const{ return LIST_GetDeleted(); };

	mov	eax, DWORD PTR [ecx+4]
	shr	eax, 31					; 0000001fH
	not	eax
	and	eax, 1
	ret	0
?ALLOC_GetDeleted@NullMultiListNodePolicy@@QBE_NXZ ENDP	; NullMultiListNodePolicy::ALLOC_GetDeleted
_TEXT	ENDS
PUBLIC	?ALLOC_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z ; NullMultiListNodePolicy::ALLOC_SetDeleted
; Function compile flags: /Ogtpy
;	COMDAT ?ALLOC_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z
_TEXT	SEGMENT
_bDeleted$ = 8						; size = 1
?ALLOC_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z PROC ; NullMultiListNodePolicy::ALLOC_SetDeleted, COMDAT
; _this$ = ecx

; 73   : 	void ALLOC_SetDeleted(bool bDeleted){ LIST_SetDeleted( bDeleted ); };

	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	BYTE PTR _bDeleted$[esp-4], al
	sete	al
	and	edx, 2147483647				; 7fffffffH
	shl	eax, 31					; 0000001fH
	or	eax, edx
	mov	DWORD PTR [ecx+4], eax
	ret	4
?ALLOC_SetDeleted@NullMultiListNodePolicy@@QAEX_N@Z ENDP ; NullMultiListNodePolicy::ALLOC_SetDeleted
_TEXT	ENDS
PUBLIC	??1?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>, COMDAT
; _this$ = ecx

; 299  : 		~base_iterator(){};

	ret	0
??1?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>
_TEXT	ENDS
PUBLIC	??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>, COMDAT
; _this$ = ecx

; 299  : 		~base_iterator(){};

	ret	0
??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator-
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 63			; 0000003fH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEIXZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEIXZ PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QBEIXZ ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::size
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::Destroy
_TEXT	ENDS
PUBLIC	?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z
_TEXT	SEGMENT
_uiIndex$ = 8						; size = 4
?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted, COMDAT
; _this$ = ecx

; 238  : 	{

	push	esi

; 239  : 		T& element = m_vec[uiIndex];

	mov	esi, DWORD PTR _uiIndex$[esp]
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	push	edi
	mov	edi, DWORD PTR [ecx+8]

; 240  : 		if( !element.ALLOC_GetDeleted() ){

	mov	edx, DWORD PTR [eax+edi+4]
	add	eax, edi
	shr	edx, 31					; 0000001fH
	not	dl
	test	dl, 1
	jne	SHORT $LN3@FreeIfDele
	pop	edi

; 241  : 			return false;

	xor	al, al
	pop	esi

; 256  : 	};

	ret	4
$LN3@FreeIfDele:

; 242  : 		}
; 243  : 
; 244  : 		if( uiIndex < m_uiFirstEmpty){

	mov	edx, DWORD PTR [ecx]
	cmp	esi, edx
	jae	SHORT $LN2@FreeIfDele

; 245  : 			element.ALLOC_SetNext(m_uiFirstEmpty);

	mov	DWORD PTR [eax], edx

; 252  : 		}
; 253  : 		m_uiSize--;

	dec	DWORD PTR [ecx+4]
	pop	edi
	mov	DWORD PTR [ecx], esi

; 254  : 
; 255  : 		return true;

	mov	al, 1
	pop	esi

; 256  : 	};

	ret	4
$LN2@FreeIfDele:

; 246  : 
; 247  : 			m_uiFirstEmpty = uiIndex;
; 248  : 		}else{
; 249  : 			T* pRoot = &m_vec[m_uiFirstEmpty];

	imul	edx, 44					; 0000002cH
	add	edx, edi

; 250  : 			element.ALLOC_SetNext( pRoot->ALLOC_GetNext() );

	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [eax], edi

; 251  : 			pRoot->ALLOC_SetNext(uiIndex);

	mov	DWORD PTR [edx], esi

; 252  : 		}
; 253  : 		m_uiSize--;

	dec	DWORD PTR [ecx+4]
	pop	edi

; 254  : 
; 255  : 		return true;

	mov	al, 1
	pop	esi

; 256  : 	};

	ret	4
?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int,CvDeal *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::max_size
_TEXT	ENDS
PUBLIC	??0base_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PBV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const::base_iterator_tail_const
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0base_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PBV1@@Z
_TEXT	SEGMENT
_pFastList$ = 8						; size = 4
??0base_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PBV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const::base_iterator_tail_const, COMDAT
; _this$ = ecx

; 273  : 		base_iterator_tail_const( const TYPE* pFastList ) : m_pFastList( pFastList ) {};

	mov	eax, ecx
	mov	ecx, DWORD PTR _pFastList$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0base_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PBV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const::base_iterator_tail_const
_TEXT	ENDS
PUBLIC	??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail::base_iterator_tail
; Function compile flags: /Ogtpy
;	COMDAT ??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z
_TEXT	SEGMENT
_pFastList$ = 8						; size = 4
??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail::base_iterator_tail, COMDAT
; _this$ = ecx

; 278  : 		base_iterator_tail( TYPE* pFastList ) : m_pFastList( pFastList ) {};

	mov	eax, ecx
	mov	ecx, DWORD PTR _pFastList$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail::base_iterator_tail
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+=
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAXPAX@Z ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAXPAX@Z PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAXPAX@Z ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	??0?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAE@XZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::BaseVector<MultiListNodePolicy<CvTradedItem>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAE@XZ PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::BaseVector<MultiListNodePolicy<CvTradedItem>,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@IAE@XZ ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::BaseVector<MultiListNodePolicy<CvTradedItem>,0>
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAPAXIIII@Z ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z
_TEXT	SEGMENT
$T225630 = -12						; size = 12
$T225634 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,CvDeal *> >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T225634[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T225630[esp+16]
	mov	DWORD PTR $T225634[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T225630[esp+16]
	push	ecx
	mov	DWORD PTR $T225630[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@0@Z ; std::_Iter_random<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@0@Z PROC ; std::_Iter_random<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@0@Z ENDP ; std::_Iter_random<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@IPAVCvDeal@@@0@0@Z ; std::_Ptr_cat<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@IPAVCvDeal@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@IPAVCvDeal@@@0@0@Z PROC ; std::_Ptr_cat<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@IPAVCvDeal@@@0@0@Z ENDP ; std::_Ptr_cat<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z ; std::_Fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z PROC ; std::_Fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z ENDP ; std::_Fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAU?$pair@IPAVCvDeal@@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@@Z ; std::_Move_cat<std::pair<unsigned int,CvDeal *> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAU?$pair@IPAVCvDeal@@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAU?$pair@IPAVCvDeal@@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@@Z PROC ; std::_Move_cat<std::pair<unsigned int,CvDeal *> *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAU?$pair@IPAVCvDeal@@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@IPAVCvDeal@@@0@@Z ENDP ; std::_Move_cat<std::pair<unsigned int,CvDeal *> *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@U?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int,CvDeal *>,std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@U?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@ABU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int,CvDeal *>,std::pair<unsigned int,CvDeal *> >, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int,CvDeal *>,std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@IPAVCvDeal@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@@Z ; std::_Destroy<std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U?$pair@IPAVCvDeal@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@IPAVCvDeal@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned int,CvDeal *> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U?$pair@IPAVCvDeal@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescriptionKey
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescriptionKey, COMDAT
; _this$ = ecx

; 69   : 		return m_strDescriptionKey.c_str();

	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescriptionKey
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getCOOP_WAR_LOCKED_LENGTH@CvGlobals@@QAEHXZ	; CvGlobals::getCOOP_WAR_LOCKED_LENGTH
; Function compile flags: /Ogtpy
;	COMDAT ?getCOOP_WAR_LOCKED_LENGTH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCOOP_WAR_LOCKED_LENGTH@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCOOP_WAR_LOCKED_LENGTH, COMDAT
; _this$ = ecx

; 5768 : 		return m_iCOOP_WAR_LOCKED_LENGTH;

	mov	eax, DWORD PTR [ecx+6692]

; 5769 : 	}

	ret	0
?getCOOP_WAR_LOCKED_LENGTH@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCOOP_WAR_LOCKED_LENGTH
_TEXT	ENDS
PUBLIC	?getRESEARCH_AGREEMENT_BOOST_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getRESEARCH_AGREEMENT_BOOST_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getRESEARCH_AGREEMENT_BOOST_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getRESEARCH_AGREEMENT_BOOST_DIVISOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getRESEARCH_AGREEMENT_BOOST_DIVISOR, COMDAT
; _this$ = ecx

; 5900 : 		return m_iRESEARCH_AGREEMENT_BOOST_DIVISOR;

	mov	eax, DWORD PTR [ecx+6824]

; 5901 : 	}

	ret	0
?getRESEARCH_AGREEMENT_BOOST_DIVISOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getRESEARCH_AGREEMENT_BOOST_DIVISOR
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?isAlive@CvTeam@@QBE_NXZ			; CvTeam::isAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isAlive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvTeam@@QBE_NXZ PROC				; CvTeam::isAlive, COMDAT
; _this$ = ecx

; 131  : 		return m_iAliveCount > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	setg	al

; 132  : 	}

	ret	0
?isAlive@CvTeam@@QBE_NXZ ENDP				; CvTeam::isAlive
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225859 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225859[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225859[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T225859[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T225859[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z PROC	; operator>>, COMDAT

; 24   : {

	push	esi

; 25   : 	int v;
; 26   : 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 27   : 	writeTo = static_cast<TradeableItems>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 28   : 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 29   : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T225880 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z PROC	; operator<<, COMDAT

; 34   : 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T225880[esp]
	mov	DWORD PTR $T225880[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 35   : 	return saveTo;

	mov	eax, esi
	pop	esi

; 36   : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z ; OldLoad
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z
_TEXT	SEGMENT
_v$225895 = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z PROC ; OldLoad, COMDAT

; 79   : {

	push	esi
	push	edi

; 80   : 	loadFrom >> writeTo.m_eItemType;

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	lea	eax, DWORD PTR _v$225895[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	esi, DWORD PTR _writeTo$[esp+4]
	mov	ecx, DWORD PTR _v$225895[esp+4]

; 81   : 	loadFrom >> writeTo.m_iDuration;

	lea	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], ecx
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 82   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 83   : 	loadFrom >> writeTo.m_iTurnsRemaining;
; 84   : #else
; 85   : 	loadFrom >> writeTo.m_iFinalTurn;

	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 86   : #endif
; 87   : 	loadFrom >> writeTo.m_iData1;

	lea	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 88   : 	loadFrom >> writeTo.m_iData2;

	lea	edx, DWORD PTR [esi+16]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 89   : 	loadFrom >> writeTo.m_eFromPlayer;

	lea	eax, DWORD PTR [esi+28]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 90   : 	writeTo.m_bFromRenewed = false;

	xor	al, al
	add	esp, 8
	mov	BYTE PTR [esi+32], al

; 91   : 	writeTo.m_bToRenewed = false;

	mov	BYTE PTR [esi+33], al

; 92   : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi

; 93   : }

	ret	0
?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z ENDP ; OldLoad
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_v$225922 = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z PROC	; operator>>, COMDAT

; 97   : {

	push	ecx
	push	esi
	push	edi

; 98   : 	uint uiVersion;
; 99   : 	loadFrom >> uiVersion;

	mov	edi, DWORD PTR _loadFrom$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 100  : 	loadFrom >> writeTo.m_eItemType;

	lea	ecx, DWORD PTR _v$225922[esp+8]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	esi, DWORD PTR _writeTo$[esp+8]
	mov	edx, DWORD PTR _v$225922[esp+8]

; 101  : 	loadFrom >> writeTo.m_iDuration;

	lea	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 102  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 103  : 	loadFrom >> writeTo.m_iTurnsRemaining;
; 104  : #else
; 105  : 	loadFrom >> writeTo.m_iFinalTurn;

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 106  : #endif
; 107  : 	loadFrom >> writeTo.m_iData1;

	lea	edx, DWORD PTR [esi+12]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 108  : 	loadFrom >> writeTo.m_iData2;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 109  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+12], 2
	jb	SHORT $LN2@operator@3

; 110  : 	{
; 111  : 		loadFrom >> writeTo.m_iData3;

	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 112  : 		loadFrom >> writeTo.m_bFlag1;

	lea	edx, DWORD PTR [esi+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN1@operator@3
$LN2@operator@3:

; 115  : 	{
; 116  : 		writeTo.m_iData3 = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+20], eax

; 117  : 		writeTo.m_bFlag1 = false;

	mov	BYTE PTR [esi+24], al
$LN1@operator@3:

; 118  : 	}
; 119  : 	loadFrom >> writeTo.m_eFromPlayer;

	lea	eax, DWORD PTR [esi+28]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 120  : 	loadFrom >> writeTo.m_bFromRenewed;

	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 121  : 	loadFrom >> writeTo.m_bToRenewed;

	add	esi, 33					; 00000021H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 122  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi

; 123  : }

	pop	ecx
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z	; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T225959 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z PROC	; operator<<, COMDAT

; 127  : {

	push	ecx
	push	esi

; 128  : 	uint uiVersion = 2;
; 129  : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 130  : 	saveTo << readFrom.m_eItemType;

	mov	edi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR $T225959[esp+8]
	mov	DWORD PTR $T225959[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 131  : 	saveTo << readFrom.m_iDuration;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 132  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 133  : 	saveTo << readFrom.m_iTurnsRemaining;
; 134  : #else
; 135  : 	saveTo << readFrom.m_iFinalTurn;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 136  : #endif
; 137  : 	saveTo << readFrom.m_iData1;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 138  : 	saveTo << readFrom.m_iData2;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 139  : 	saveTo << readFrom.m_iData3;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 140  : 	saveTo << readFrom.m_bFlag1;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 141  : 	saveTo << readFrom.m_eFromPlayer;

	lea	eax, DWORD PTR [edi+28]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 142  : 	saveTo << readFrom.m_bFromRenewed;

	lea	ecx, DWORD PTR [edi+32]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 143  : 	saveTo << readFrom.m_bToRenewed;

	add	edi, 33					; 00000021H
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi

; 144  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 145  : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z ; CvGameDeals::HasMadeProposal
; Function compile flags: /Ogtpy
;	COMDAT ?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z PROC ; CvGameDeals::HasMadeProposal, COMDAT
; _this$ = ecx

; 2924 : 	if(m_ProposedDeals.size() > 0)

	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN2@HasMadePro

; 2925 : 	{
; 2926 : 		DealList::iterator iter;
; 2927 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	add	edx, eax
	cmp	eax, edx
	je	SHORT $LN2@HasMadePro
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 76					; 0000004cH

; 2928 : 			if(iter->m_eFromPlayer == ePlayer)

	mov	ecx, eax
	add	ecx, edx
	mov	edx, DWORD PTR _ePlayer$[esp-4]
$LL4@HasMadePro:
	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN15@HasMadePro
	add	eax, 76					; 0000004cH
	cmp	eax, ecx
	jne	SHORT $LL4@HasMadePro
$LN2@HasMadePro:

; 2930 : 	}
; 2931 : 
; 2932 : 	return NO_PLAYER;

	or	eax, -1

; 2933 : }

	ret	4
$LN15@HasMadePro:

; 2929 : 				return iter->m_eToPlayer;

	mov	eax, DWORD PTR [eax+8]

; 2933 : }

	ret	4
?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z ENDP ; CvGameDeals::HasMadeProposal
_TEXT	ENDS
PUBLIC	?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z ; CvGameDeals::ProposedDealExists
; Function compile flags: /Ogtpy
;	COMDAT ?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z PROC ; CvGameDeals::ProposedDealExists, COMDAT
; _this$ = ecx

; 2937 : 	if(m_ProposedDeals.size() > 0)

	cmp	DWORD PTR [ecx+8], 0
	push	esi
	jbe	SHORT $LN2@ProposedDe

; 2938 : 	{
; 2939 : 		DealList::iterator iter;
; 2940 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	add	edx, eax
	cmp	eax, edx
	je	SHORT $LN2@ProposedDe
	mov	edx, DWORD PTR [ecx+8]

; 2941 : 		{
; 2942 : 			if(iter->m_eFromPlayer == eFromPlayer && iter->m_eToPlayer == eToPlayer)

	mov	esi, DWORD PTR _eFromPlayer$[esp]
	imul	edx, 76					; 0000004cH
	mov	ecx, eax
	add	ecx, edx
	mov	edx, DWORD PTR _eToPlayer$[esp]
$LL4@ProposedDe:
	cmp	DWORD PTR [eax+4], esi
	jne	SHORT $LN3@ProposedDe
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN15@ProposedDe
$LN3@ProposedDe:

; 2938 : 	{
; 2939 : 		DealList::iterator iter;
; 2940 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	add	eax, 76					; 0000004cH
	cmp	eax, ecx
	jne	SHORT $LL4@ProposedDe
$LN2@ProposedDe:

; 2944 : 		}
; 2945 : 	}
; 2946 : 
; 2947 : 	return false;

	xor	al, al
	pop	esi

; 2948 : }

	ret	8
$LN15@ProposedDe:

; 2943 : 				return true;

	mov	al, 1
	pop	esi

; 2948 : }

	ret	8
?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z ENDP ; CvGameDeals::ProposedDealExists
_TEXT	ENDS
PUBLIC	?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z ; CvGameDeals::GetProposedDeal
; Function compile flags: /Ogtpy
;	COMDAT ?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z PROC ; CvGameDeals::GetProposedDeal, COMDAT
; _this$ = ecx

; 2952 : 	if(m_ProposedDeals.size() > 0)

	cmp	DWORD PTR [ecx+8], 0
	push	esi
	jbe	SHORT $LN2@GetPropose

; 2953 : 	{
; 2954 : 		DealList::iterator iter;
; 2955 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	add	edx, eax
	cmp	eax, edx
	je	SHORT $LN2@GetPropose
	mov	edx, DWORD PTR [ecx+8]

; 2956 : 			if(iter->m_eFromPlayer == eFromPlayer && iter->m_eToPlayer == eToPlayer)

	mov	esi, DWORD PTR _eFromPlayer$[esp]
	imul	edx, 76					; 0000004cH
	mov	ecx, eax
	add	ecx, edx
	mov	edx, DWORD PTR _eToPlayer$[esp]
$LL4@GetPropose:
	cmp	DWORD PTR [eax+4], esi
	jne	SHORT $LN3@GetPropose
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN6@GetPropose
$LN3@GetPropose:

; 2953 : 	{
; 2954 : 		DealList::iterator iter;
; 2955 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	add	eax, 76					; 0000004cH
	cmp	eax, ecx
	jne	SHORT $LL4@GetPropose
$LN2@GetPropose:

; 2957 : 				return &(*iter);
; 2958 : 	}
; 2959 : 
; 2960 : 	return NULL;

	xor	eax, eax
$LN6@GetPropose:
	pop	esi

; 2961 : }

	ret	8
?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z ENDP ; CvGameDeals::GetProposedDeal
_TEXT	ENDS
PUBLIC	?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ; CvGameDeals::GetTradeItemGoldCost
EXTRN	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z:PROC ; CvGame::GetResearchAgreementCost
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z
_TEXT	SEGMENT
_eItem$ = 8						; size = 4
_ePlayer1$ = 12						; size = 4
_ePlayer2$ = 16						; size = 4
?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z PROC ; CvGameDeals::GetTradeItemGoldCost, COMDAT
; _this$ = ecx

; 3447 : 	int iGoldCost = 0;
; 3448 : 
; 3449 : 	switch(eItem)

	mov	ecx, DWORD PTR _eItem$[esp-4]
	xor	eax, eax
	sub	ecx, 8
	je	SHORT $LN2@GetTradeIt
	sub	ecx, 1
	jne	SHORT $LN3@GetTradeIt

; 3454 : 		break;
; 3455 : 	}
; 3456 : 	case TRADE_ITEM_TRADE_AGREEMENT:
; 3457 : 		iGoldCost = 250;

	mov	eax, 250				; 000000faH

; 3458 : 		break;
; 3459 : 	}
; 3460 : 
; 3461 : 	return iGoldCost;
; 3462 : }

	ret	12					; 0000000cH
$LN2@GetTradeIt:

; 3450 : 	{
; 3451 : 	case TRADE_ITEM_RESEARCH_AGREEMENT:
; 3452 : 	{
; 3453 : 		iGoldCost = GC.getGame().GetResearchAgreementCost(ePlayer1, ePlayer2);

	mov	eax, DWORD PTR _ePlayer2$[esp-4]
	mov	ecx, DWORD PTR _ePlayer1$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z ; CvGame::GetResearchAgreementCost
$LN3@GetTradeIt:

; 3458 : 		break;
; 3459 : 	}
; 3460 : 
; 3461 : 	return iGoldCost;
; 3462 : }

	ret	12					; 0000000cH
?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ENDP ; CvGameDeals::GetTradeItemGoldCost
_TEXT	ENDS
PUBLIC	?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ; CvGameDeals::GetCurrentDeal
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_index$ = 12						; size = 4
?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z PROC ; CvGameDeals::GetCurrentDeal, COMDAT
; _this$ = ecx

; 3742 : 	DealList::iterator iter;
; 3743 : 	DealList::iterator end = m_CurrentDeals.end();

	mov	edx, DWORD PTR [ecx+1544]

; 3744 : 
; 3745 : 	uint iCount = 0;
; 3746 : 	for(iter = m_CurrentDeals.begin(); iter != end; ++iter)

	mov	eax, DWORD PTR [ecx+1540]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [ecx+1540]
	push	ebx
	push	esi
	xor	esi, esi
	push	edi
	cmp	eax, edx
	je	SHORT $LN3@GetCurrent
	mov	edi, DWORD PTR _index$[esp+8]
	mov	ecx, DWORD PTR _ePlayer$[esp+8]
$LL5@GetCurrent:

; 3747 : 	{
; 3748 : 		if((iter->m_eToPlayer == ePlayer ||
; 3749 : 		        iter->m_eFromPlayer == ePlayer) &&
; 3750 : 		        (iCount++ == index))

	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN1@GetCurrent
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN4@GetCurrent
$LN1@GetCurrent:
	mov	ebx, esi
	inc	esi
	cmp	ebx, edi
	je	SHORT $LN6@GetCurrent
$LN4@GetCurrent:

; 3744 : 
; 3745 : 	uint iCount = 0;
; 3746 : 	for(iter = m_CurrentDeals.begin(); iter != end; ++iter)

	add	eax, 76					; 0000004cH
	cmp	eax, edx
	jne	SHORT $LL5@GetCurrent
$LN3@GetCurrent:

; 3751 : 		{
; 3752 : 			return &(*iter);
; 3753 : 		}
; 3754 : 	}
; 3755 : 
; 3756 : 	return NULL;

	xor	eax, eax
$LN6@GetCurrent:
	pop	edi
	pop	esi
	pop	ebx

; 3757 : }

	ret	8
?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ENDP ; CvGameDeals::GetCurrentDeal
_TEXT	ENDS
PUBLIC	?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ; CvGameDeals::GetHistoricDeal
; Function compile flags: /Ogtpy
;	COMDAT ?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_index$ = 12						; size = 4
?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z PROC ; CvGameDeals::GetHistoricDeal, COMDAT
; _this$ = ecx

; 3764 : 	DealList::iterator iter;
; 3765 : 	DealList::iterator end = m_HistoricalDeals.end();

	mov	edx, DWORD PTR [ecx+3080]

; 3766 : 
; 3767 : 	uint iCount = 0;
; 3768 : 	for(iter = m_HistoricalDeals.begin(); iter != end; ++iter)

	mov	eax, DWORD PTR [ecx+3076]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [ecx+3076]
	push	ebx
	push	esi
	xor	esi, esi
	push	edi
	cmp	eax, edx
	je	SHORT $LN3@GetHistori
	mov	edi, DWORD PTR _index$[esp+8]
	mov	ecx, DWORD PTR _ePlayer$[esp+8]
$LL5@GetHistori:

; 3769 : 	{
; 3770 : 		if((iter->m_eToPlayer == ePlayer ||
; 3771 : 		        iter->m_eFromPlayer == ePlayer) &&
; 3772 : 		        (iCount++ == index))

	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN1@GetHistori
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN4@GetHistori
$LN1@GetHistori:
	mov	ebx, esi
	inc	esi
	cmp	ebx, edi
	je	SHORT $LN6@GetHistori
$LN4@GetHistori:

; 3766 : 
; 3767 : 	uint iCount = 0;
; 3768 : 	for(iter = m_HistoricalDeals.begin(); iter != end; ++iter)

	add	eax, 76					; 0000004cH
	cmp	eax, edx
	jne	SHORT $LL5@GetHistori
$LN3@GetHistori:

; 3773 : 		{
; 3774 : 			return &(*iter);
; 3775 : 		}
; 3776 : 	}
; 3777 : 
; 3778 : 	return NULL;

	xor	eax, eax
$LN6@GetHistori:
	pop	edi
	pop	esi
	pop	ebx

; 3779 : }

	ret	8
?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ENDP ; CvGameDeals::GetHistoricDeal
_TEXT	ENDS
PUBLIC	?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ; CvGameDeals::GetNumCurrentDeals
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z PROC ; CvGameDeals::GetNumCurrentDeals, COMDAT
; _this$ = ecx

; 3786 : 	DealList::iterator iter;
; 3787 : 	DealList::iterator end = m_CurrentDeals.end();

	mov	edx, DWORD PTR [ecx+1544]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [ecx+1540]

; 3788 : 
; 3789 : 	uint iCount = 0;
; 3790 : 	for(iter = m_CurrentDeals.begin(); iter != end; ++iter)

	mov	ecx, DWORD PTR [ecx+1540]
	xor	eax, eax
	cmp	ecx, edx
	je	SHORT $LN3@GetNumCurr
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp]
$LL5@GetNumCurr:

; 3791 : 	{
; 3792 : 		if(iter->m_eToPlayer == ePlayer ||
; 3793 : 		        iter->m_eFromPlayer == ePlayer)

	cmp	DWORD PTR [ecx+8], esi
	je	SHORT $LN1@GetNumCurr
	cmp	DWORD PTR [ecx+4], esi
	jne	SHORT $LN4@GetNumCurr
$LN1@GetNumCurr:

; 3794 : 		{
; 3795 : 			++iCount;

	inc	eax
$LN4@GetNumCurr:

; 3788 : 
; 3789 : 	uint iCount = 0;
; 3790 : 	for(iter = m_CurrentDeals.begin(); iter != end; ++iter)

	add	ecx, 76					; 0000004cH
	cmp	ecx, edx
	jne	SHORT $LL5@GetNumCurr
	pop	esi
$LN3@GetNumCurr:

; 3796 : 		}
; 3797 : 	}
; 3798 : 
; 3799 : 	return iCount;
; 3800 : }

	ret	4
?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ENDP ; CvGameDeals::GetNumCurrentDeals
_TEXT	ENDS
PUBLIC	?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ; CvGameDeals::GetNumHistoricDeals
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z PROC ; CvGameDeals::GetNumHistoricDeals, COMDAT
; _this$ = ecx

; 3808 : 	DealList::iterator iter;
; 3809 : 	DealList::iterator end = m_HistoricalDeals.end();

	mov	edx, DWORD PTR [ecx+3080]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [ecx+3076]

; 3810 : 
; 3811 : 	uint iCount = 0;
; 3812 : 	for(iter = m_HistoricalDeals.begin(); iter != end; ++iter)

	mov	ecx, DWORD PTR [ecx+3076]
	xor	eax, eax
	cmp	ecx, edx
	je	SHORT $LN3@GetNumHist
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp]
$LL5@GetNumHist:

; 3813 : 	{
; 3814 : 		if(iter->m_eToPlayer == ePlayer ||
; 3815 : 		        iter->m_eFromPlayer == ePlayer)

	cmp	DWORD PTR [ecx+8], esi
	je	SHORT $LN1@GetNumHist
	cmp	DWORD PTR [ecx+4], esi
	jne	SHORT $LN4@GetNumHist
$LN1@GetNumHist:

; 3816 : 		{
; 3817 : 			++iCount;

	inc	eax
$LN4@GetNumHist:

; 3810 : 
; 3811 : 	uint iCount = 0;
; 3812 : 	for(iter = m_HistoricalDeals.begin(); iter != end; ++iter)

	add	ecx, 76					; 0000004cH
	cmp	ecx, edx
	jne	SHORT $LL5@GetNumHist
	pop	esi
$LN3@GetNumHist:

; 3818 : 		}
; 3819 : 	}
; 3820 : 
; 3821 : 	return iCount;
; 3822 : }

	ret	4
?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ENDP ; CvGameDeals::GetNumHistoricDeals
_TEXT	ENDS
PUBLIC	?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ ; FFastList<CvTradedItem,21,0>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ PROC	; FFastList<CvTradedItem,21,0>::size, COMDAT
; _this$ = ecx

; 189  : 	unsigned int size() const{ return BASE_TYPE::size(); };

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ ENDP	; FFastList<CvTradedItem,21,0>::size
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 20			; 00000014H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ	; BaseVector<CvDeal,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ PROC		; BaseVector<CvDeal,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	ebx
	push	esi
	mov	ebx, ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	esi, DWORD PTR [ebx]
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	jbe	SHORT $LN11@clear
	npad	2
$LL5@clear:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL5@clear
$LN11@clear:
	pop	edi
	pop	esi

; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ebx+4], 0
	pop	ebx

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ENDP		; BaseVector<CvDeal,0>::clear
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEAAU?$pair@IPAVCvDeal@@@1@XZ ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEAAU?$pair@IPAVCvDeal@@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEAAU?$pair@IPAVCvDeal@@@1@XZ PROC ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEAAU?$pair@IPAVCvDeal@@@1@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEPAU?$pair@IPAVCvDeal@@@1@XZ ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEPAU?$pair@IPAVCvDeal@@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEPAU?$pair@IPAVCvDeal@@@1@XZ PROC ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator->, COMDAT
; _this$ = ecx

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 345  : 		}

	ret	0
??C?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEPAU?$pair@IPAVCvDeal@@@1@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 8

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator!=
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEABW4TeamTypes@@I@Z ; CvWeightedVector<enum TeamTypes,63,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEABW4TeamTypes@@I@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEABW4TeamTypes@@I@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z ; CvWeightedVector<enum TeamTypes,63,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::GetWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ ; CvWeightedVector<enum TeamTypes,63,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[], COMDAT
; _this$ = ecx

; 269  : 		return m_vec[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+8]

; 270  : 	}

	ret	4
??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[]
_TEXT	ENDS
PUBLIC	??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[], COMDAT
; _this$ = ecx

; 274  : 		return m_vec[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+8]

; 275  : 
; 276  : 	}

	ret	4
??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[]
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	ebx, DWORD PTR _pVal$[esp]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _uiNumElements$[esp+8]
	mov	ebp, ecx
	test	edi, edi
	jbe	SHORT $LN5@Free
	push	esi
	mov	esi, ebx
$LL13@Free:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL13@Free
	pop	esi
$LN5@Free:

; 811  : 		if( pVal != (T*)m_aData )

	add	ebp, 12					; 0000000cH
	cmp	ebx, ebp
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free:
	pop	edi
	pop	ebp
	pop	ebx

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z PROC ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??1const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::~const_iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??1const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::~const_iterator, COMDAT
; _this$ = ecx

; 401  : 		~const_iterator(){};

	ret	0
??1const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::~const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 404  : 			return m_pFastList->get_allocator()[ m_uiCurrPos ];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+8]

; 405  : 		};

	ret	0
??Dconst_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEABU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
; Function compile flags: /Ogtpy
;	COMDAT ??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator, COMDAT
; _this$ = ecx

; 381  : 		~iterator(){};

	ret	0
??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ
_TEXT	SEGMENT
??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*, COMDAT
; _this$ = ecx

; 384  : 			return m_pFastList->get_allocator()[ m_uiCurrPos ];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+8]

; 385  : 		};

	ret	0
??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z PROC ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@PAU?$pair@IPAVCvDeal@@@1@@Z ENDP ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 63			; 0000003fH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEXXZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEXXZ PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEXXZ ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::clear
_TEXT	ENDS
PUBLIC	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z
_TEXT	SEGMENT
_uiStart$ = 8						; size = 4
tv379 = 12						; size = 4
_uiEnd$ = 12						; size = 4
?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink, COMDAT
; _this$ = ecx

; 657  : 		if( uiStart == ANCHOR_NODE_INDEX ){ return; }

	mov	eax, DWORD PTR _uiStart$[esp-4]
	cmp	eax, 268435455				; 0fffffffH
	je	$LN3@UnLink

; 658  : 		assert( get_allocator().is_element_valid(uiStart) );
; 659  : 
; 660  : 		if( uiStart == m_uiFirst){ m_uiFirst = uiEnd; }

	mov	edx, DWORD PTR _uiEnd$[esp-4]
	cmp	eax, DWORD PTR [ecx+24]
	jne	SHORT $LN7@UnLink
	mov	DWORD PTR [ecx+24], edx
$LN7@UnLink:

; 661  : 		uiStart = get_allocator()[uiStart].LIST_GetPrev();

	imul	eax, 44					; 0000002cH
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi+4]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _uiStart$[esp+4], eax

; 662  : 		if( uiEnd == ANCHOR_NODE_INDEX ){

	cmp	edx, 268435455				; 0fffffffH
	jne	SHORT $LN6@UnLink

; 663  : 			uiEnd = m_uiLast;

	mov	ebp, DWORD PTR [ecx+28]

; 664  : 			m_uiLast = uiStart;

	mov	DWORD PTR [ecx+28], eax

; 665  : 		}else{

	jmp	SHORT $LN78@UnLink
$LN6@UnLink:

; 666  : 			assert( get_allocator().is_element_valid(uiEnd) );
; 667  : 			uiEnd = get_allocator()[uiEnd].LIST_GetPrev();

	imul	edx, 44					; 0000002cH
	mov	ebp, DWORD PTR [edx+esi+4]
	and	ebp, 2147483647				; 7fffffffH
$LN78@UnLink:

; 668  : 		}
; 669  : 
; 670  : 		while( uiStart != uiEnd ){

	cmp	eax, ebp
	je	$LN81@UnLink
	push	ebx
	push	edi
$LL4@UnLink:

; 671  : 			T& kEnd = get_allocator()[uiEnd];

	mov	edi, DWORD PTR [ecx+8]
	mov	eax, ebp
	imul	eax, 44					; 0000002cH

; 672  : 			unsigned int uiNext = kEnd.LIST_GetNext();
; 673  : 			unsigned int uiPrev = kEnd.LIST_GetPrev();

	mov	esi, DWORD PTR [eax+edi+4]
	mov	ebx, DWORD PTR [eax+edi]
	lea	edx, DWORD PTR [eax+edi+4]
	and	esi, 2147483647				; 7fffffffH
	mov	DWORD PTR tv379[esp+12], edx

; 674  : 			if( uiNext != ANCHOR_NODE_INDEX ) get_allocator()[uiNext].LIST_SetPrev( uiPrev );

	cmp	ebx, 268435455				; 0fffffffH
	je	SHORT $LN43@UnLink
	mov	edx, ebx
	imul	edx, 44					; 0000002cH
	add	edx, edi
	mov	edi, DWORD PTR [edx+4]
	xor	edi, esi
	and	edi, 2147483647				; 7fffffffH
	xor	DWORD PTR [edx+4], edi
	mov	edx, DWORD PTR tv379[esp+12]
$LN43@UnLink:

; 675  : 			if( uiPrev != ANCHOR_NODE_INDEX ) get_allocator()[uiPrev].LIST_SetNext( uiNext );

	cmp	esi, 268435455				; 0fffffffH
	je	SHORT $LN51@UnLink
	mov	edi, DWORD PTR [ecx+8]
	mov	edx, esi
	imul	edx, 44					; 0000002cH
	mov	DWORD PTR [edx+edi], ebx
	mov	edx, DWORD PTR tv379[esp+12]
$LN51@UnLink:

; 676  : 			kEnd.LIST_SetDeleted(true);

	and	DWORD PTR [edx], 2147483647		; 7fffffffH

; 677  : 			get_allocator().FreeIfDeleted(uiEnd);

	mov	edi, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [eax+edi+4]
	shr	edx, 31					; 0000001fH
	not	dl
	test	dl, 1
	je	SHORT $LN80@UnLink
	mov	edx, DWORD PTR [ecx]
	cmp	ebp, edx
	jae	SHORT $LN58@UnLink
	mov	DWORD PTR [eax+edi], edx
	mov	DWORD PTR [ecx], ebp
	jmp	SHORT $LN76@UnLink
$LN58@UnLink:
	imul	edx, 44					; 0000002cH
	mov	ebx, DWORD PTR [edx+edi]
	add	edx, edi
	mov	DWORD PTR [eax+edi], ebx
	mov	DWORD PTR [edx], ebp
$LN76@UnLink:
	dec	DWORD PTR [ecx+4]
$LN80@UnLink:

; 678  : 
; 679  : 			m_uiSize--;

	dec	DWORD PTR [ecx+20]

; 680  : 
; 681  : 			uiEnd = uiPrev;

	mov	ebp, esi
	cmp	DWORD PTR _uiStart$[esp+12], esi
	jne	$LL4@UnLink
	pop	edi
	pop	ebx
$LN81@UnLink:
	pop	esi
	pop	ebp
$LN3@UnLink:

; 682  : 		}
; 683  : 	};

	ret	8
?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEPAU?$pair@IPAVCvDeal@@@2@I@Z ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEPAU?$pair@IPAVCvDeal@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEPAU?$pair@IPAVCvDeal@@@2@I@Z PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEPAU?$pair@IPAVCvDeal@@@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::allocate
_TEXT	ENDS
PUBLIC	??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>, COMDAT
; _this$ = ecx

; 293  : 		explicit base_iterator() : m_uiCurrPos( ANCHOR_NODE_INDEX ), TAIL(NULL) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>
_TEXT	ENDS
PUBLIC	??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>, COMDAT
; _this$ = ecx

; 293  : 		explicit base_iterator() : m_uiCurrPos( ANCHOR_NODE_INDEX ), TAIL(NULL) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter, COMDAT
; _this$ = ecx

; 634  : 		assert( get_allocator().is_element_valid(i) );
; 635  : 
; 636  : 		T* a = &get_allocator()[i];

	mov	edx, DWORD PTR [ecx+8]
	push	ebx
	mov	ebx, DWORD PTR _i$[esp]
	mov	eax, ebx
	imul	eax, 44					; 0000002cH
	push	edi

; 637  : 		if( j == ANCHOR_NODE_INDEX ){

	mov	edi, DWORD PTR _j$[esp+4]
	add	eax, edx
	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN3@InsertAfte

; 638  : 			a->LIST_SetNext(ANCHOR_NODE_INDEX);
; 639  : 			a->LIST_SetPrev(ANCHOR_NODE_INDEX);

	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -1879048193			; 8fffffffH
	or	ecx, edi
	mov	DWORD PTR [eax], edi
	pop	edi
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 652  : 		}
; 653  : 	};

	ret	8
$LN3@InsertAfte:
	push	ebp

; 640  : 		}else{
; 641  : 			T* b = &get_allocator()[j];
; 642  : 
; 643  : 			//Set the links for the new node
; 644  : 			unsigned int uiBNext = b->LIST_GetNext();
; 645  : 			a->LIST_SetPrev(j);

	mov	ebp, DWORD PTR [eax+4]
	push	esi
	mov	esi, edi
	imul	esi, 44					; 0000002cH
	xor	ebp, edi
	add	esi, edx
	mov	edx, DWORD PTR [esi]
	and	ebp, 2147483647				; 7fffffffH
	xor	DWORD PTR [eax+4], ebp

; 646  : 			a->LIST_SetNext(uiBNext);

	mov	DWORD PTR [eax], edx

; 647  : 
; 648  : 			//Fix the links for the next and previous nodes
; 649  : 			if( uiBNext != ANCHOR_NODE_INDEX )

	cmp	edx, 268435455				; 0fffffffH
	je	SHORT $LN34@InsertAfte

; 650  : 				get_allocator()[uiBNext].LIST_SetPrev(i);

	imul	edx, 44					; 0000002cH
	add	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+4]
	xor	eax, ebx
	and	eax, 2147483647				; 7fffffffH
	xor	DWORD PTR [edx+4], eax
$LN34@InsertAfte:

; 651  : 			b->LIST_SetNext(i);

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx

; 652  : 		}
; 653  : 	};

	ret	8
?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>, COMDAT
; _this$ = ecx

; 297  : 			: m_uiCurrPos( uiPos ), TAIL( pVec ) {};

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>
_TEXT	ENDS
PUBLIC	??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>, COMDAT
; _this$ = ecx

; 295  : 			: m_uiCurrPos( uiPos ), TAIL( pVec ) {};

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+=
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@3

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, esi
	imul	eax, 44					; 0000002cH
	push	85					; 00000055H
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@3:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEPAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T226590 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T226590[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 503  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 504  : 
; 505  : 	size_t bytes = 0;
; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 507  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 508  : 	str.assign(szComposedString, bytes);
; 509  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T226590[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	mov	eax, DWORD PTR $T226590[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T226590[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T226610 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T226610[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 517  : 
; 518  : 	size_t bytes = 0;
; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 520  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 521  : 	str.assign(szComposedString, bytes);
; 522  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T226610[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	mov	eax, DWORD PTR $T226610[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T226610[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	??$unchecked_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z PROC ; stdext::unchecked_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z ENDP ; stdext::unchecked_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
_TEXT	ENDS
PUBLIC	??$fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z ; std::fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z PROC ; std::fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z ENDP ; std::fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAU?$pair@IPAVCvDeal@@@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@ABU32@@Z ; std::allocator<std::pair<unsigned int,CvDeal *> >::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@ABU32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@@Z ; std::allocator<std::pair<unsigned int,CvDeal *> >::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::allocator<std::pair<unsigned int,CvDeal *> >::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@QAEXPAU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::allocator<std::pair<unsigned int,CvDeal *> >::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4PeaceTreatyTypes@@@Z ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdiplomacyaienums.h
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4PeaceTreatyTypes@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T226760 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4PeaceTreatyTypes@@@Z PROC ; operator<<, COMDAT

; 269  : 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T226760[esp]
	mov	DWORD PTR $T226760[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 270  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 271  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4PeaceTreatyTypes@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4PeaceTreatyTypes@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4PeaceTreatyTypes@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4PeaceTreatyTypes@@@Z PROC ; operator>>, COMDAT

; 273  : {

	push	esi

; 274  : 	int v;
; 275  : 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 276  : 	writeTo = static_cast<PeaceTreatyTypes>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 277  : 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 278  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4PeaceTreatyTypes@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?isEverAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isEverAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isEverAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isEverAlive@CvPlayer@@QBE_NXZ PROC			; CvPlayer::isEverAlive, COMDAT
; _this$ = ecx

; 1097 : 		return m_bEverAlive;

	mov	al, BYTE PTR [ecx+2268]

; 1098 : 	}

	ret	0
?isEverAlive@CvPlayer@@QBE_NXZ ENDP			; CvPlayer::isEverAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?GetNumItems@CvDeal@@QAEHXZ			; CvDeal::GetNumItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?GetNumItems@CvDeal@@QAEHXZ
_TEXT	SEGMENT
?GetNumItems@CvDeal@@QAEHXZ PROC			; CvDeal::GetNumItems, COMDAT
; _this$ = ecx

; 259  : 	return m_TradedItems.size();

	mov	eax, DWORD PTR [ecx+64]

; 260  : }

	ret	0
?GetNumItems@CvDeal@@QAEHXZ ENDP			; CvDeal::GetNumItems
_TEXT	ENDS
PUBLIC	?Init@CvGameDeals@@QAEXXZ			; CvGameDeals::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvGameDeals@@QAEXXZ
_TEXT	SEGMENT
?Init@CvGameDeals@@QAEXXZ PROC				; CvGameDeals::Init, COMDAT
; _this$ = ecx

; 2273 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2274 : 	m_ProposedDeals.clear();

	mov	eax, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	xor	ebp, ebp
	cmp	eax, ebp
	jbe	SHORT $LN5@Init
	mov	ebx, eax
$LL7@Init:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ebp
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	ebx, 1
	jne	SHORT $LL7@Init
$LN5@Init:
	mov	DWORD PTR [edi+8], ebp

; 2275 : 	m_CurrentDeals.clear();

	mov	ebx, DWORD PTR [edi+1544]
	mov	esi, DWORD PTR [edi+1540]
	cmp	ebx, ebp
	jbe	SHORT $LN13@Init
$LL15@Init:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ebp
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	ebx, 1
	jne	SHORT $LL15@Init
$LN13@Init:
	mov	DWORD PTR [edi+1544], ebp

; 2276 : 	m_HistoricalDeals.clear();

	mov	ebx, DWORD PTR [edi+3080]
	mov	esi, DWORD PTR [edi+3076]
	cmp	ebx, ebp
	jbe	SHORT $LN33@Init
	npad	1
$LL23@Init:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ebp
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	ebx, 1
	jne	SHORT $LL23@Init
$LN33@Init:
	mov	DWORD PTR [edi+3080], ebp
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2277 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2278 : 	m_CurrentlyEndingDeals.clear();
; 2279 : #endif
; 2280 : }

	ret	0
?Init@CvGameDeals@@QAEXXZ ENDP				; CvGameDeals::Init
_TEXT	ENDS
PUBLIC	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem
EXTRN	?CancelVoteCommitmentsToPlayer@CvLeagueAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvLeagueAI::CancelVoteCommitmentsToPlayer
EXTRN	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ:PROC ; CvPlayer::GetLeagueAI
EXTRN	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ:PROC ; CvTeam::getLeaderID
EXTRN	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::setForcePeace
EXTRN	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasTradeAgreement
EXTRN	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z:PROC ; CvTeamTechs::ChangeResearchProgress
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?changeOverflowResearch@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeOverflowResearch
EXTRN	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTechs::GetCurrentResearch
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?GetMedianTechPercentage@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetMedianTechPercentage
EXTRN	?GetResearchAgreementCounter@CvPlayer@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayer::GetResearchAgreementCounter
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasResearchAgreement
EXTRN	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasDefensivePact
EXTRN	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetAllowsOpenBordersToTeam
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeResourceImport
EXTRN	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeResourceExport
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z DD 019930522H
	DD	022H
	DD	FLAT:__unwindtable$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$14
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$16
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$17
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$18
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$19
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$22
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$23
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$24
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$25
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$26
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$27
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$28
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$29
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$30
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$31
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$32
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$33
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
_TEXT	SEGMENT
$T227120 = -140						; size = 4
_iToPlayerBeakers$223197 = -140				; size = 4
_szResourceDescription$223146 = -140			; size = 4
$T227351 = -136						; size = 4
$T227096 = -136						; size = 4
tv1934 = -132						; size = 4
_iFromPlayerBeakers$223198 = -132			; size = 4
$T227008 = -132						; size = 4
$T227006 = -132						; size = 4
$T227004 = -132						; size = 4
$T227002 = -132						; size = 4
_iGoldPerTurn$223124 = -132				; size = 4
_eFromPlayer$ = -132					; size = 4
_kTeam$223196 = -128					; size = 4
_strSummary$ = -124					; size = 28
_strBuffer$ = -96					; size = 28
$T227033 = -68						; size = 28
$T227031 = -68						; size = 28
$T227028 = -68						; size = 28
$T227027 = -68						; size = 28
$T227026 = -68						; size = 28
$T227025 = -68						; size = 28
$T227024 = -68						; size = 28
$T227023 = -68						; size = 28
$T227022 = -68						; size = 28
$T227021 = -68						; size = 28
$T227020 = -68						; size = 28
$T227019 = -68						; size = 28
$T227018 = -68						; size = 28
$T227017 = -68						; size = 28
$T227016 = -68						; size = 28
$T227015 = -68						; size = 28
$T227014 = -68						; size = 28
$T227013 = -68						; size = 28
$T227012 = -68						; size = 28
$T227011 = -68						; size = 28
$T227010 = -68						; size = 28
$T227009 = -68						; size = 28
$T227007 = -68						; size = 28
$T227005 = -68						; size = 28
$T227003 = -68						; size = 28
$T226999 = -68						; size = 28
$T226998 = -68						; size = 28
$T226997 = -68						; size = 28
$T226996 = -68						; size = 28
$T227032 = -40						; size = 28
$T227030 = -40						; size = 28
$T227029 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pItem$ = 8						; size = 4
_eToPlayer$ = 12					; size = 4
_bCancelled$ = 16					; size = 1
?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z PROC ; CvGameDeals::DoEndTradedItem, COMDAT
; _this$ = ecx

; 3192 : {

	push	-1
	push	__ehhandler$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3193 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3194 : 	CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3195 : 
; 3196 : 	PlayerTypes eFromPlayer = pItem->m_eFromPlayer;

	mov	eax, DWORD PTR _pItem$[esp+152]
	mov	ebp, DWORD PTR [eax+28]

; 3197 : 
; 3198 : 	CvPlayerAI& fromPlayer = GET_PLAYER(eFromPlayer);
; 3199 : 	CvPlayerAI& toPlayer = GET_PLAYER(eToPlayer);

	mov	esi, DWORD PTR _eToPlayer$[esp+152]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	mov	DWORD PTR _eFromPlayer$[esp+156], ebp
	imul	ebp, 63236				; 0000f704H
	lea	edi, DWORD PTR [ecx+ebp]
	add	esi, ecx

; 3200 : 
; 3201 : 	TeamTypes eFromTeam = fromPlayer.getTeam();

	mov	ecx, DWORD PTR [edi+44]
	mov	ebx, 1
	mov	BYTE PTR __$EHRec$[esp+164], bl
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN93@DoEndTrade
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T227096[esp+156], ecx
	jmp	SHORT $LN94@DoEndTrade
$LN93@DoEndTrade:
	mov	DWORD PTR $T227096[esp+156], -1
	mov	ecx, DWORD PTR $T227096[esp+156]
$LN94@DoEndTrade:

; 3202 : 	TeamTypes eToTeam = toPlayer.getTeam();

	mov	edx, DWORD PTR [esi+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN102@DoEndTrade
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR $T227096[esp+156]
	mov	DWORD PTR $T227120[esp+156], edx
	jmp	SHORT $LN103@DoEndTrade
$LN102@DoEndTrade:
	mov	DWORD PTR $T227120[esp+156], -1
$LN103@DoEndTrade:

; 3203 : 
; 3204 : 	CvNotifications* pNotifications = NULL;
; 3205 : 
; 3206 : 	pItem->m_bToRenewed = false; // if this item is properly ended, then don't have it marked with "to renew"
; 3207 : 
; 3208 : 	if(pItem->m_bFromRenewed)

	cmp	BYTE PTR [eax+32], 0
	mov	BYTE PTR [eax+33], 0

; 3209 : 	{
; 3210 : 		return;

	jne	$LN1@DoEndTrade

; 3211 : 	}
; 3212 : 
; 3213 : 	// Gold Per Turn
; 3214 : 	if(pItem->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	mov	edx, DWORD PTR [eax]
	cmp	edx, ebx
	jne	$LN39@DoEndTrade

; 3215 : 	{
; 3216 : 		int iGoldPerTurn = pItem->m_iData1;

	mov	eax, DWORD PTR [eax+12]

; 3217 : 		fromPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurn);

	push	eax
	mov	ecx, edi
	mov	DWORD PTR _iGoldPerTurn$223124[esp+160], eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3218 : 		toPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurn);

	mov	eax, DWORD PTR _iGoldPerTurn$223124[esp+156]
	neg	eax
	push	eax
	mov	ecx, esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3219 : 
; 3220 : 		pNotifications = GET_PLAYER(eFromPlayer).GetNotifications();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 3221 : 		if(pNotifications)

	test	ebp, ebp
	je	$LN38@DoEndTrade

; 3222 : 		{
; 3223 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_GPT_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T226996[esp+160]
	push	OFFSET $SG223132
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T226996[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3224 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_GPT_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T226997[esp+160]
	push	OFFSET $SG223134
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T226997[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3225 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_GPT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-235108627				; f1fc86edH
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN38@DoEndTrade:

; 3226 : 		}
; 3227 : 
; 3228 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3229 : 		if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3230 : 		{
; 3231 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_GPT_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T226998[esp+160]
	push	OFFSET $SG223137
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T226998[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3232 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_GPT_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T226999[esp+160]
	push	OFFSET $SG223139
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T226999[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3233 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_GPT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-235108627				; f1fc86edH

; 3430 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3431 : 			}
; 3432 : 		}
; 3433 : 	}

	jmp	$LN1@DoEndTrade
$LN39@DoEndTrade:

; 3234 : 		}
; 3235 : 	}
; 3236 : 	// Resource
; 3237 : 	else if(pItem->m_eItemType == TRADE_ITEM_RESOURCES)

	cmp	edx, 3
	jne	$LN35@DoEndTrade

; 3238 : 	{
; 3239 : 		ResourceTypes eResource = (ResourceTypes) pItem->m_iData1;

	mov	ebp, DWORD PTR [eax+12]

; 3240 : 		int iResourceQuantity = pItem->m_iData2;

	mov	eax, DWORD PTR [eax+16]

; 3241 : 
; 3242 : 		fromPlayer.changeResourceExport(eResource, -iResourceQuantity);

	neg	eax
	push	eax
	push	ebp
	mov	ecx, edi
	mov	DWORD PTR tv1934[esp+164], eax
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 3243 : 		toPlayer.changeResourceImport(eResource, -iResourceQuantity);

	mov	edx, DWORD PTR tv1934[esp+156]
	push	edx
	push	ebp
	mov	ecx, esi
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport

; 3244 : 
; 3245 : 		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 3246 : 		const char* szResourceDescription = (pkResourceInfo)? pkResourceInfo->GetDescriptionKey() : "";

	test	eax, eax
	je	SHORT $LN43@DoEndTrade
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szResourceDescription$223146[esp+156], eax
	jmp	SHORT $LN44@DoEndTrade
$LN43@DoEndTrade:
	mov	DWORD PTR _szResourceDescription$223146[esp+156], OFFSET $SG223147
$LN44@DoEndTrade:

; 3247 : 
; 3248 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 3249 : 		if(pNotifications)

	test	ebp, ebp
	je	$LN34@DoEndTrade

; 3250 : 		{
; 3251 : 
; 3252 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_RESOURCE_FROM_US", toPlayer.getNameKey(), szResourceDescription);

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T227002[esp+156], eax
	lea	eax, DWORD PTR _szResourceDescription$223146[esp+156]
	push	eax
	lea	ecx, DWORD PTR $T227002[esp+160]
	push	ecx
	lea	edx, DWORD PTR $T227003[esp+164]
	push	OFFSET $SG223158
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227003[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3253 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_RESOURCE_FROM_US", toPlayer.getNameKey(), szResourceDescription);

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T227004[esp+156], eax
	lea	eax, DWORD PTR _szResourceDescription$223146[esp+156]
	push	eax
	lea	ecx, DWORD PTR $T227004[esp+160]
	push	ecx
	lea	edx, DWORD PTR $T227005[esp+164]
	push	OFFSET $SG223161
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 7
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227005[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3254 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESOURCE, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	555577168				; 211d6f50H
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN34@DoEndTrade:

; 3255 : 		}
; 3256 : 
; 3257 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3258 : 		if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3259 : 		{
; 3260 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_RESOURCE_TO_US", fromPlayer.getNameKey(), szResourceDescription);

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T227006[esp+156], eax
	lea	eax, DWORD PTR _szResourceDescription$223146[esp+156]
	push	eax
	lea	ecx, DWORD PTR $T227006[esp+160]
	push	ecx
	lea	edx, DWORD PTR $T227007[esp+164]
	push	OFFSET $SG223165
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227007[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3261 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_RESOURCE_TO_US", fromPlayer.getNameKey(), szResourceDescription);

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T227008[esp+156], eax
	lea	eax, DWORD PTR _szResourceDescription$223146[esp+156]
	push	eax
	lea	ecx, DWORD PTR $T227008[esp+160]
	push	ecx
	lea	edx, DWORD PTR $T227009[esp+164]
	push	OFFSET $SG223168
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 9
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227009[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3262 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESOURCE, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	555577168				; 211d6f50H

; 3430 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3431 : 			}
; 3432 : 		}
; 3433 : 	}

	jmp	$LN1@DoEndTrade
$LN35@DoEndTrade:

; 3263 : 		}
; 3264 : 	}
; 3265 : 	// Open Borders
; 3266 : 	else if(pItem->m_eItemType == TRADE_ITEM_OPEN_BORDERS)

	cmp	edx, 6
	jne	$LN31@DoEndTrade

; 3267 : 	{
; 3268 : 		GET_TEAM(eFromTeam).SetAllowsOpenBordersToTeam(eToTeam, false);

	mov	eax, DWORD PTR $T227120[esp+156]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	eax
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 3269 : 
; 3270 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 3271 : 		if(pNotifications)

	test	ebp, ebp
	je	$LN30@DoEndTrade

; 3272 : 		{
; 3273 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T227010[esp+160]
	push	OFFSET $SG223173
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 10		; 0000000aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227010[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3274 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T227011[esp+160]
	push	OFFSET $SG223175
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 11		; 0000000bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227011[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3275 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	9054908					; 008a2abcH
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN30@DoEndTrade:

; 3276 : 		}
; 3277 : 
; 3278 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3279 : 		if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3280 : 		{
; 3281 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227012[esp+160]
	push	OFFSET $SG223178
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 12		; 0000000cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227012[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3282 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T227013[esp+160]
	push	OFFSET $SG223180
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 13		; 0000000dH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227013[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3283 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	9054908					; 008a2abcH

; 3430 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3431 : 			}
; 3432 : 		}
; 3433 : 	}

	jmp	$LN1@DoEndTrade
$LN31@DoEndTrade:

; 3284 : 		}
; 3285 : 	}
; 3286 : 	// Defensive Pact
; 3287 : 	else if(pItem->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT)

	cmp	edx, 7
	jne	$LN27@DoEndTrade

; 3288 : 	{
; 3289 : 		GET_TEAM(eFromTeam).SetHasDefensivePact(eToTeam, false);

	mov	edx, DWORD PTR $T227120[esp+156]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	edx
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 3290 : 
; 3291 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 3292 : 		if(pNotifications)

	test	ebp, ebp
	je	$LN26@DoEndTrade

; 3293 : 		{
; 3294 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227014[esp+160]
	push	OFFSET $SG223185
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 14		; 0000000eH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227014[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3295 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T227015[esp+160]
	push	OFFSET $SG223187
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 15		; 0000000fH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227015[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3296 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2090424272				; 8366a830H
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN26@DoEndTrade:

; 3297 : 		}
; 3298 : 
; 3299 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3300 : 		if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3301 : 		{
; 3302 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T227016[esp+160]
	push	OFFSET $SG223190
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 16		; 00000010H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227016[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3303 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227017[esp+160]
	push	OFFSET $SG223192
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 17		; 00000011H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227017[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3304 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2090424272				; 8366a830H

; 3430 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3431 : 			}
; 3432 : 		}
; 3433 : 	}

	jmp	$LN1@DoEndTrade
$LN27@DoEndTrade:

; 3305 : 		}
; 3306 : 	}
; 3307 : 	// Research Agreement
; 3308 : 	else if(pItem->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT)

	cmp	edx, 8
	jne	$LN23@DoEndTrade

; 3309 : 	{
; 3310 : 		GET_TEAM(eFromTeam).SetHasResearchAgreement(eToTeam, false);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebp, ecx
	mov	ecx, DWORD PTR $T227120[esp+156]
	imul	ebp, 2980				; 00000ba4H
	push	0
	push	ecx
	lea	ecx, DWORD PTR [edx+ebp]
	call	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasResearchAgreement

; 3311 : 
; 3312 : 		if(!GET_TEAM(eFromTeam).isAtWar(eToTeam) && !bCancelled)

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR $T227120[esp+156]
	lea	ecx, DWORD PTR [eax+ebp]
	push	edx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN22@DoEndTrade
	cmp	BYTE PTR _bCancelled$[esp+152], al
	jne	$LN22@DoEndTrade

; 3313 : 		{
; 3314 : 			// Beaker boost = ((sum of both players' beakers over term of RA) / 2) / 3) * (median tech percentage rate)
; 3315 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3316 : 			CvTeam& kTeam = GET_TEAM(toPlayer.getTeam());

	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 3317 : #endif
; 3318 : 			int iToPlayerBeakers = toPlayer.GetResearchAgreementCounter(eFromPlayer);

	mov	ecx, esi
	mov	DWORD PTR _kTeam$223196[esp+156], eax
	mov	eax, DWORD PTR _eFromPlayer$[esp+156]
	push	eax
	call	?GetResearchAgreementCounter@CvPlayer@@QBEHW4PlayerTypes@@@Z ; CvPlayer::GetResearchAgreementCounter

; 3319 : 			int iFromPlayerBeakers = fromPlayer.GetResearchAgreementCounter(eToPlayer);

	mov	ecx, DWORD PTR _eToPlayer$[esp+152]
	mov	ebp, eax
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iToPlayerBeakers$223197[esp+160], ebp
	call	?GetResearchAgreementCounter@CvPlayer@@QBEHW4PlayerTypes@@@Z ; CvPlayer::GetResearchAgreementCounter

; 3320 : #ifdef AUI_DEAL_FIX_ACCURATE_EARLYGAME_RESEARCH_AGREEMENT_YIELDS
; 3321 : 			int iBeakersBonus = MIN(iToPlayerBeakers, iFromPlayerBeakers) * toPlayer.GetMedianTechPercentage();
; 3322 : 			iBeakersBonus /= 100 * GC.getRESEARCH_AGREEMENT_BOOST_DIVISOR();
; 3323 : #else
; 3324 : 			int iBeakersBonus = min(iToPlayerBeakers, iFromPlayerBeakers) / GC.getRESEARCH_AGREEMENT_BOOST_DIVISOR(); //one (third) of minimum contribution

	cmp	eax, ebp
	mov	DWORD PTR _iFromPlayerBeakers$223198[esp+156], eax
	jge	SHORT $LN241@DoEndTrade
	lea	edx, DWORD PTR _iFromPlayerBeakers$223198[esp+156]
	mov	DWORD PTR $T227351[esp+156], edx
	jmp	SHORT $LN242@DoEndTrade
$LN241@DoEndTrade:
	lea	eax, DWORD PTR _iToPlayerBeakers$223197[esp+156]
	mov	DWORD PTR $T227351[esp+156], eax
$LN242@DoEndTrade:
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6824

; 3325 : 			iBeakersBonus = (iBeakersBonus * toPlayer.GetMedianTechPercentage()) / 100;

	mov	ecx, esi
	call	?GetMedianTechPercentage@CvPlayer@@QBEHXZ ; CvPlayer::GetMedianTechPercentage
	mov	edx, DWORD PTR $T227351[esp+156]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	ebp
	imul	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH

; 3326 : #endif
; 3327 : 
; 3328 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3329 : 			toPlayer.changeOverflowResearch(iBeakersBonus);
; 3330 : #else
; 3331 : 			TechTypes eCurrentTech = toPlayer.GetPlayerTechs()->GetCurrentResearch();

	mov	ecx, esi
	add	ebp, edx
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch

; 3332 : 			if(eCurrentTech == NO_TECH)

	cmp	eax, -1
	jne	SHORT $LN21@DoEndTrade

; 3333 : 			{
; 3334 : 				toPlayer.changeOverflowResearch(iBeakersBonus);

	push	ebp
	mov	ecx, esi
	call	?changeOverflowResearch@CvPlayer@@QAEXH@Z ; CvPlayer::changeOverflowResearch

; 3335 : 			}
; 3336 : 			else

	jmp	SHORT $LN20@DoEndTrade
$LN21@DoEndTrade:

; 3337 : 			{
; 3338 : 				kTeam.GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iBeakersBonus, eToPlayer);

	mov	ecx, DWORD PTR _eToPlayer$[esp+152]
	push	ecx
	mov	ecx, DWORD PTR _kTeam$223196[esp+160]
	push	ebp
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgress
$LN20@DoEndTrade:

; 3339 : 			}
; 3340 : #endif
; 3341 : 
; 3342 : 			pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3343 : 			if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3344 : 			{
; 3345 : 				strBuffer = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T227018[esp+160]
	push	OFFSET $SG223210
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 18		; 00000012H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227018[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3346 : 				strSummary = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_S", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227019[esp+160]
	push	OFFSET $SG223212
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+164], 19		; 00000013H

; 3347 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESEARCH_AGREEMENT, strBuffer, strSummary, -1, -1, -1);
; 3348 : 			}
; 3349 : 		}
; 3350 : 		else

	jmp	$LN379@DoEndTrade
$LN22@DoEndTrade:

; 3351 : 		{
; 3352 : 			pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3353 : 			if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3354 : 			{
; 3355 : 				if(GET_TEAM(eFromTeam).isAtWar(eToTeam))

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR $T227120[esp+156]
	add	ecx, ebp
	push	edx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar

; 3356 : 				{
; 3357 : 					strBuffer = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_WAR_CANCEL", fromPlayer.getNameKey());

	mov	ecx, edi
	test	al, al
	je	SHORT $LN16@DoEndTrade
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227020[esp+160]
	push	OFFSET $SG223217
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 20		; 00000014H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227020[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3358 : 					strSummary = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_WAR_CANCEL_S");

	lea	ecx, DWORD PTR $T227021[esp+156]
	push	OFFSET $SG223219
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+164], 21		; 00000015H

; 3359 : 				}
; 3360 : 				else

	jmp	SHORT $LN379@DoEndTrade
$LN16@DoEndTrade:

; 3361 : 				{
; 3362 : 					strBuffer = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_CANCEL", fromPlayer.getNameKey());

	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T227022[esp+160]
	push	OFFSET $SG223222
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 22		; 00000016H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227022[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3363 : 					strSummary = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_CANCEL_S");

	lea	eax, DWORD PTR $T227023[esp+156]
	push	OFFSET $SG223224
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+164], 23		; 00000017H
$LN379@DoEndTrade:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227023[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3364 : 				}
; 3365 : 
; 3366 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESEARCH_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1550921687				; a38ed029H

; 3430 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3431 : 			}
; 3432 : 		}
; 3433 : 	}

	jmp	$LN1@DoEndTrade
$LN23@DoEndTrade:

; 3367 : 			}
; 3368 : 		}
; 3369 : 	}
; 3370 : 	// Trade Agreement
; 3371 : 	else if(pItem->m_eItemType == TRADE_ITEM_TRADE_AGREEMENT)

	cmp	edx, 9
	jne	$LN13@DoEndTrade

; 3372 : 	{
; 3373 : 		GET_TEAM(eFromTeam).SetHasTradeAgreement(eToTeam, false);

	mov	edx, DWORD PTR $T227120[esp+156]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	edx
	call	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasTradeAgreement

; 3374 : 
; 3375 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 3376 : 		if(pNotifications)

	test	ebp, ebp
	je	$LN12@DoEndTrade

; 3377 : 		{
; 3378 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227024[esp+160]
	push	OFFSET $SG223229
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 24		; 00000018H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227024[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3379 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_US", toPlayer.getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T227025[esp+160]
	push	OFFSET $SG223231
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 25		; 00000019H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227025[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3380 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN12@DoEndTrade:

; 3381 : 		}
; 3382 : 
; 3383 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3384 : 		if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3385 : 		{
; 3386 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T227026[esp+160]
	push	OFFSET $SG223234
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 26		; 0000001aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227026[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3387 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227027[esp+160]
	push	OFFSET $SG223236
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+164], 27		; 0000001bH

; 3388 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);
; 3389 : 		}
; 3390 : 	}

	jmp	$LN381@DoEndTrade
$LN13@DoEndTrade:

; 3391 : 	// Peace Treaty
; 3392 : 	else if(pItem->m_eItemType == TRADE_ITEM_PEACE_TREATY)

	cmp	edx, 13					; 0000000dH
	jne	$LN9@DoEndTrade

; 3393 : 	{
; 3394 : 		GET_TEAM(eFromTeam).setForcePeace(eToTeam, false);

	mov	edx, DWORD PTR $T227120[esp+156]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	edx
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 3395 : 
; 3396 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3397 : 		if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3398 : 		{
; 3399 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR $T227028[esp+160]
	push	OFFSET $SG223241
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 28		; 0000001cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227028[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3400 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE");

	lea	ecx, DWORD PTR $T227029[esp+156]
	push	OFFSET $SG223243
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 29		; 0000001dH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227029[esp+156]

; 3401 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);
; 3402 : 		}
; 3403 : 	}

	jmp	$LN383@DoEndTrade
$LN9@DoEndTrade:

; 3404 : 	// Third Party Peace Treaty
; 3405 : 	else if(pItem->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE)

	cmp	edx, 14					; 0000000eH
	jne	$LN6@DoEndTrade

; 3406 : 	{
; 3407 : 		TeamTypes eTargetTeam = (TeamTypes) pItem->m_iData1;

	mov	esi, DWORD PTR [eax+12]

; 3408 : 		GET_TEAM(eFromTeam).setForcePeace(eTargetTeam, false);

	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	esi
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 3409 : 		GET_TEAM(eTargetTeam).setForcePeace(eFromTeam, false);

	imul	esi, 2980				; 00000ba4H
	mov	edx, DWORD PTR $T227096[esp+156]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	edx
	lea	ecx, DWORD PTR [esi+eax]
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 3410 : 
; 3411 : 		CvPlayer* targetPlayer = &GET_PLAYER(GET_TEAM(eTargetTeam).getLeaderID());

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	esi, ecx
	mov	ecx, esi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax

; 3412 : 
; 3413 : 		if (targetPlayer->isAlive())

	cmp	BYTE PTR [esi+2256], 0
	je	$LN1@DoEndTrade

; 3414 : 		{
; 3415 : 			// Notification for FROM player
; 3416 : 			pNotifications = fromPlayer.GetNotifications();

	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 3417 : 			if(pNotifications)

	test	ebp, ebp
	je	$LN377@DoEndTrade

; 3418 : 			{
; 3419 : 				strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE", targetPlayer->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR $T227030[esp+160]
	push	OFFSET $SG223252
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 30		; 0000001eH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227030[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3420 : 				strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE");

	lea	eax, DWORD PTR $T227031[esp+156]
	push	OFFSET $SG223254
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 31		; 0000001fH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227031[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3421 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN377@DoEndTrade:

; 3422 : 			}
; 3423 : 
; 3424 : 			// Notification for TARGET player
; 3425 : 			pNotifications = targetPlayer->GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 3426 : 			if(pNotifications)

	test	esi, esi
	je	$LN1@DoEndTrade

; 3427 : 			{
; 3428 : 				strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE", fromPlayer.getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T227032[esp+160]
	push	OFFSET $SG223257
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 32		; 00000020H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227032[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3429 : 				strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE");

	lea	edx, DWORD PTR $T227033[esp+156]
	push	OFFSET $SG223259
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+164], 33		; 00000021H
$LN381@DoEndTrade:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+160]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227033[esp+156]
$LN383@DoEndTrade:
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3430 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3431 : 			}
; 3432 : 		}
; 3433 : 	}

	jmp	SHORT $LN1@DoEndTrade
$LN6@DoEndTrade:

; 3434 : 	// Vote Commitment
; 3435 : 	else if(pItem->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT)

	cmp	edx, 19					; 00000013H
	jne	SHORT $LN1@DoEndTrade

; 3436 : 	{
; 3437 : 		fromPlayer.GetLeagueAI()->CancelVoteCommitmentsToPlayer(eToPlayer);

	mov	eax, DWORD PTR _eToPlayer$[esp+152]
	push	eax
	mov	ecx, edi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?CancelVoteCommitmentsToPlayer@CvLeagueAI@@QAEXW4PlayerTypes@@@Z ; CvLeagueAI::CancelVoteCommitmentsToPlayer

; 3438 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3439 : 		toPlayer.GetLeagueAI()->CancelVoteCommitmentsToPlayer(eFromPlayer);

	mov	ecx, DWORD PTR _eFromPlayer$[esp+156]
	push	ecx
	mov	ecx, esi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?CancelVoteCommitmentsToPlayer@CvLeagueAI@@QAEXW4PlayerTypes@@@Z ; CvLeagueAI::CancelVoteCommitmentsToPlayer
$LN1@DoEndTrade:

; 3440 : #endif
; 3441 : 	}
; 3442 : }

	lea	ecx, DWORD PTR _strSummary$[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+156]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 140				; 0000008cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$2:
	lea	ecx, DWORD PTR $T226996[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$3:
	lea	ecx, DWORD PTR $T226997[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$4:
	lea	ecx, DWORD PTR $T226998[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T226999[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$6:
	lea	ecx, DWORD PTR $T227003[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T227005[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T227007[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$9:
	lea	ecx, DWORD PTR $T227009[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$10:
	lea	ecx, DWORD PTR $T227010[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$11:
	lea	ecx, DWORD PTR $T227011[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T227012[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T227013[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T227014[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T227015[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$16:
	lea	ecx, DWORD PTR $T227016[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$17:
	lea	ecx, DWORD PTR $T227017[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$18:
	lea	ecx, DWORD PTR $T227018[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$19:
	lea	ecx, DWORD PTR $T227019[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$20:
	lea	ecx, DWORD PTR $T227020[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$21:
	lea	ecx, DWORD PTR $T227021[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$22:
	lea	ecx, DWORD PTR $T227022[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$23:
	lea	ecx, DWORD PTR $T227023[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$24:
	lea	ecx, DWORD PTR $T227024[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$25:
	lea	ecx, DWORD PTR $T227025[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$26:
	lea	ecx, DWORD PTR $T227026[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$27:
	lea	ecx, DWORD PTR $T227027[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$28:
	lea	ecx, DWORD PTR $T227028[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$29:
	lea	ecx, DWORD PTR $T227029[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$30:
	lea	ecx, DWORD PTR $T227030[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$31:
	lea	ecx, DWORD PTR $T227031[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$32:
	lea	ecx, DWORD PTR $T227032[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$33:
	lea	ecx, DWORD PTR $T227033[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ENDP ; CvGameDeals::DoEndTradedItem
PUBLIC	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
_TEXT	ENDS
PUBLIC	?begin@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::end
_TEXT	ENDS
PUBLIC	??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator, COMDAT
; _this$ = ecx

; 148  : 		~const_iterator(){};

	ret	0
??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEABUCvTradedItem@@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEABUCvTradedItem@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEABUCvTradedItem@@XZ PROC ; FFastList<CvTradedItem,21,0>::const_iterator::operator*, COMDAT
; _this$ = ecx

; 150  : 		const T & operator*() const{  return BASE_TYPE::const_iterator::operator*().data;  };

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx+8]
	ret	0
??Dconst_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEABUCvTradedItem@@XZ ENDP ; FFastList<CvTradedItem,21,0>::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??E?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::operator++, COMDAT
; _this$ = ecx

; 310  : 		base_iterator& operator++(){

	mov	eax, ecx

; 311  : 			if( m_uiCurrPos == ANCHOR_NODE_INDEX ){

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 268435455				; 0fffffffH
	jne	SHORT $LN2@operator@4

; 312  : 				m_uiCurrPos = m_pFastList->m_uiFirst;

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], edx

; 315  : 			}
; 316  : 			return *this;
; 317  : 		};

	ret	0
$LN2@operator@4:

; 313  : 			}else{
; 314  : 				m_uiCurrPos = m_pFastList->get_allocator()[ m_uiCurrPos ].LIST_GetNext();

	mov	edx, DWORD PTR [eax]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+4], ecx

; 315  : 			}
; 316  : 			return *this;
; 317  : 		};

	ret	0
??E?$base_iterator@Vbase_iterator_tail_const@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail_const>::operator++
_TEXT	ENDS
PUBLIC	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
; Function compile flags: /Ogtpy
;	COMDAT ??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::~iterator, COMDAT
; _this$ = ecx

; 136  : 		~iterator(){};

	ret	0
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::~iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEAAUCvTradedItem@@XZ ; FFastList<CvTradedItem,21,0>::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEAAUCvTradedItem@@XZ
_TEXT	SEGMENT
??Diterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEAAUCvTradedItem@@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::operator*, COMDAT
; _this$ = ecx

; 138  : 		T& operator*(){  return BASE_TYPE::iterator::operator*().data; };

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx+8]
	ret	0
??Diterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEAAUCvTradedItem@@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::operator*
_TEXT	ENDS
PUBLIC	??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ ; FFastList<CvTradedItem,21,0>::iterator::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ
_TEXT	SEGMENT
??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::operator->, COMDAT
; _this$ = ecx

; 139  : 		T* operator->(){  return &( BASE_TYPE::iterator::operator*().data );  };

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx+8]
	ret	0
??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::operator->
_TEXT	ENDS
PUBLIC	??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++, COMDAT
; _this$ = ecx

; 310  : 		base_iterator& operator++(){

	mov	eax, ecx

; 311  : 			if( m_uiCurrPos == ANCHOR_NODE_INDEX ){

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 268435455				; 0fffffffH
	jne	SHORT $LN2@operator@5

; 312  : 				m_uiCurrPos = m_pFastList->m_uiFirst;

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], edx

; 315  : 			}
; 316  : 			return *this;
; 317  : 		};

	ret	0
$LN2@operator@5:

; 313  : 			}else{
; 314  : 				m_uiCurrPos = m_pFastList->get_allocator()[ m_uiCurrPos ].LIST_GetNext();

	mov	edx, DWORD PTR [eax]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+4], ecx

; 315  : 			}
; 316  : 			return *this;
; 317  : 		};

	ret	0
??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
_TEXT	ENDS
PUBLIC	?clear@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXXZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXXZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::clear, COMDAT
; _this$ = ecx

; 527  : 		UnLink( m_uiFirst, ANCHOR_NODE_INDEX );

	mov	eax, DWORD PTR [ecx+24]
	push	268435455				; 0fffffffH
	push	eax
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 528  : 	};

	ret	0
?clear@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXXZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::clear
_TEXT	ENDS
PUBLIC	?clear@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEXXZ ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ?clear@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEXXZ PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::clear, COMDAT
; _this$ = ecx

; 200  : 		m_uiFirstEmpty = ms_uiAnchorNodeIndex;
; 201  : 		m_vec.clear();

	xor	eax, eax
	mov	DWORD PTR [ecx], 268435455		; 0fffffffH
	mov	DWORD PTR [ecx+12], eax

; 202  : 		m_uiSize = 0;

	mov	DWORD PTR [ecx+4], eax

; 203  : 	};

	ret	0
?clear@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEXXZ ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::clear
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy
_TEXT	ENDS
PUBLIC	??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 398  : 		explicit const_iterator(){};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator, COMDAT
; _this$ = ecx

; 378  : 		explicit iterator(){};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
_TEXT	ENDS
PUBLIC	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewIndex$ = 8					; size = 4
?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing, COMDAT
; _this$ = ecx

; 495  : 		unsigned int uiOldLast = m_uiLast;
; 496  : 		m_uiLast = uiNewIndex;

	mov	eax, DWORD PTR _uiNewIndex$[esp-4]

; 497  : 		m_uiSize++;

	inc	DWORD PTR [ecx+20]

; 498  : 		if( m_uiFirst == ANCHOR_NODE_INDEX ) m_uiFirst = m_uiLast;

	cmp	DWORD PTR [ecx+24], 268435455		; 0fffffffH
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [ecx+28], eax
	jne	SHORT $LN1@push_back_
	mov	DWORD PTR [ecx+24], eax
$LN1@push_back_:

; 499  : 		InsertAfter(m_uiLast, uiOldLast);

	push	edx
	push	eax
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter

; 500  : 	};

	ret	4
?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
_TEXT	ENDS
PUBLIC	??1?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 399  : 		explicit const_iterator( unsigned int uiPos, const TYPE* pVec )

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0const_iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPBV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator, COMDAT
; _this$ = ecx

; 379  : 		explicit iterator( unsigned int uiPos, TYPE* pVec )

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::operator+
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN34@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 63					; 0000003fH
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 63			; 0000003fH
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+516], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_pRet$227980 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	mov	ebx, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [ebx+8]
	push	esi
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN41@GrowSize@2
	mov	DWORD PTR [ebx+8], 1
$LN41@GrowSize@2:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [ebx+8]
	jb	SHORT $LN9@GrowSize@2
	npad	1
$LL10@GrowSize@2:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize@2

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [ebx+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@2

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@2
$LN37@GrowSize@2:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [ebx+8], edx
$LN9@GrowSize@2:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	esi, DWORD PTR [ebx+8]
	test	esi, esi
	jbe	SHORT $LN7@GrowSize@2
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	push	85					; 00000055H
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227980[esp+12], edi
	mov	DWORD PTR [ebx+8], esi

; 441  : 		if (pTemp)

	test	edi, edi
	je	SHORT $LN7@GrowSize@2

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebp, ebp
	cmp	DWORD PTR [ebx+4], ebp
	jbe	SHORT $LN2@GrowSize@2
	xor	edx, edx
	npad	6
$LL42@GrowSize@2:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN3@GrowSize@2
	mov	esi, DWORD PTR [ebx]
	add	esi, edx
	mov	ecx, 11					; 0000000bH
	mov	edi, eax
	rep movsd
	mov	edi, DWORD PTR _pRet$227980[esp+12]
$LN3@GrowSize@2:
	inc	ebp
	add	edx, 44					; 0000002cH
	add	eax, 44					; 0000002cH
	cmp	ebp, DWORD PTR [ebx+4]
	jb	SHORT $LL42@GrowSize@2
$LN2@GrowSize@2:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebx]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@2:
	pop	edi
	pop	esi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [ebx+8], ebp
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto
	mov	eax, edi
	imul	eax, 44					; 0000002cH
	push	85					; 00000055H
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z ; stdext::_Unchecked_move_backward<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z PROC ; stdext::_Unchecked_move_backward<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z
_TEXT	SEGMENT
$T228131 = -4						; size = 1
__Cat$228135 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T228131[esp+4], 0
	mov	eax, DWORD PTR $T228131[esp+4]
	mov	ecx, DWORD PTR __Cat$228135[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z		; CvGameDeals::GetDeal
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z PROC		; CvGameDeals::GetDeal, COMDAT
; _this$ = ecx

; 3868 : 	for(std::vector<std::pair<uint, CvDeal*> >::iterator it = m_Deals.begin();

	mov	eax, DWORD PTR [ecx+4692]
	mov	ecx, DWORD PTR [ecx+4696]

; 3869 : 	        it != m_Deals.end(); ++it)

	cmp	eax, ecx
	je	SHORT $LN2@GetDeal
	mov	edx, DWORD PTR _index$[esp-4]
$LL15@GetDeal:

; 3870 : 	{
; 3871 : 		if((*it).first == index)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN36@GetDeal
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL15@GetDeal
$LN2@GetDeal:

; 3873 : 	}
; 3874 : 
; 3875 : 	return NULL;

	xor	eax, eax

; 3876 : }

	ret	4
$LN36@GetDeal:

; 3872 : 			return (*it).second;

	mov	eax, DWORD PTR [eax+4]

; 3876 : }

	ret	4
?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z ENDP		; CvGameDeals::GetDeal
_TEXT	ENDS
PUBLIC	?clear@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEXXZ ; FFastList<CvTradedItem,21,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?clear@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEXXZ PROC ; FFastList<CvTradedItem,21,0>::clear, COMDAT
; _this$ = ecx

; 194  : 	void clear(){ BASE_TYPE::clear(); };

	mov	eax, DWORD PTR [ecx+24]
	push	268435455				; 0fffffffH
	push	eax
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink
	ret	0
?clear@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEXXZ ENDP ; FFastList<CvTradedItem,21,0>::clear
_TEXT	ENDS
PUBLIC	??0?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 145  : 		explicit const_iterator(){};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::iterator, COMDAT
; _this$ = ecx

; 133  : 		explicit iterator(){};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::CvWeightedVector<enum TeamTypes,63,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::CvWeightedVector<enum TeamTypes,63,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 63			; 0000003fH
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::CvWeightedVector<enum TeamTypes,63,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
_TEXT	ENDS
PUBLIC	?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_it$ = 12						; size = 8
?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase, COMDAT
; _this$ = ecx

; 565  : 		const unsigned int uiNext = get_allocator()[it.get_index()].LIST_GetNext();

	mov	eax, DWORD PTR _it$[esp]
	push	esi
	mov	esi, ecx
	mov	edx, DWORD PTR [esi+8]
	mov	ecx, eax
	imul	ecx, 44					; 0000002cH
	push	edi
	mov	edi, DWORD PTR [ecx+edx]

; 566  : 		UnLink( it.get_index(), uiNext );

	push	edi
	push	eax
	mov	ecx, esi
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 567  : 		return iterator( uiNext, this );

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 568  : 	};

	ret	12					; 0000000cH
?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase
_TEXT	ENDS
PUBLIC	??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 76   : 	~FFastAllocator(){ assert( m_uiSize == 0); };

	mov	ecx, DWORD PTR [ecx+8]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPBV1@@Z ; FFastList<CvTradedItem,21,0>::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPBV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPBV1@@Z PROC ; FFastList<CvTradedItem,21,0>::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 146  : 		explicit const_iterator( unsigned int uiPos, const TYPE* pVec ) 

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPBV1@@Z ENDP ; FFastList<CvTradedItem,21,0>::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z ; FFastList<CvTradedItem,21,0>::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z PROC ; FFastList<CvTradedItem,21,0>::iterator::iterator, COMDAT
; _this$ = ecx

; 134  : 		explicit iterator( unsigned int uiPos, TYPE* pVec ) 

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z ENDP ; FFastList<CvTradedItem,21,0>::iterator::iterator
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+516], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebx
	mov	ebx, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back@2

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@2:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	edi, DWORD PTR [ebx+4]
	imul	edi, 44					; 0000002cH
	add	edi, DWORD PTR [ebx]
	je	SHORT $LN4@push_back@2
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 11					; 0000000bH
	rep movsd
	pop	esi
$LN4@push_back@2:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 381  : 	};

	ret	4
?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??0?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ??0?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 73   : 		: m_uiFirstEmpty(ms_uiAnchorNodeIndex), m_uiSize(0) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], 268435455		; 0fffffffH
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@std@@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAXPAU?$pair@IPAVCvDeal@@@std@@IABU12@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAXPAU?$pair@IPAVCvDeal@@@std@@IABU12@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z
_TEXT	SEGMENT
$T228615 = -4						; size = 1
__Cat$228619 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAXPAU?$pair@IPAVCvDeal@@@std@@IABU12@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T228615[esp+4], 0
	mov	eax, DWORD PTR $T228615[esp+4]
	mov	ecx, DWORD PTR __Cat$228619[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAXPAU?$pair@IPAVCvDeal@@@std@@IABU12@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> >,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T228632 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$228635 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> >,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$228635[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T228632[esp+4], 0
	mov	eax, DWORD PTR $T228632[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> >,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?ClearItems@CvDeal@@QAEXXZ			; CvDeal::ClearItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?ClearItems@CvDeal@@QAEXXZ
_TEXT	SEGMENT
?ClearItems@CvDeal@@QAEXXZ PROC				; CvDeal::ClearItems, COMDAT
; _this$ = ecx

; 240  : {

	push	esi
	mov	esi, ecx

; 241  : 	m_TradedItems.clear();

	mov	eax, DWORD PTR [esi+68]
	lea	ecx, DWORD PTR [esi+44]
	push	268435455				; 0fffffffH
	push	eax
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 242  : 
; 243  : 	m_iFinalTurn = -1;

	or	eax, -1

; 244  : 	m_iDuration = -1;
; 245  : 	m_iStartTurn = -1;
; 246  : 	m_bConsideringForRenewal = false;

	xor	cl, cl
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+12], eax
	mov	BYTE PTR [esi+40], cl

; 247  : 	m_bCheckedForRenewal = false;

	mov	BYTE PTR [esi+41], cl

; 248  : 	m_bDealCancelled = false;

	mov	BYTE PTR [esi+42], cl

; 249  : 
; 250  : 	SetPeaceTreatyType(NO_PEACE_TREATY_TYPE);

	mov	DWORD PTR [esi+24], eax

; 251  : 	SetSurrenderingPlayer(NO_PLAYER);

	mov	DWORD PTR [esi+28], eax

; 252  : 	SetDemandingPlayer(NO_PLAYER);

	mov	DWORD PTR [esi+32], eax

; 253  : 	SetRequestingPlayer(NO_PLAYER);

	mov	DWORD PTR [esi+36], eax
	pop	esi

; 254  : }

	ret	0
?ClearItems@CvDeal@@QAEXXZ ENDP				; CvDeal::ClearItems
_TEXT	ENDS
PUBLIC	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::begin, COMDAT
; _this$ = ecx

; 199  : 	iterator begin(){ return iterator( m_uiFirst, this ); };

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], ecx
	ret	4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::end, COMDAT
; _this$ = ecx

; 200  : 	iterator end(){ return iterator( ANCHOR_NODE_INDEX, this ); };

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::end
_TEXT	ENDS
PUBLIC	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::begin, COMDAT
; _this$ = ecx

; 201  : 	const_iterator begin() const{ return const_iterator( m_uiFirst, this ); };

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], ecx
	ret	4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::end, COMDAT
; _this$ = ecx

; 202  : 	const_iterator end() const{ return const_iterator( ANCHOR_NODE_INDEX, this ); };

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::end
_TEXT	ENDS
PUBLIC	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z
_TEXT	SEGMENT
$T228778 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_it$ = 12						; size = 8
?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z PROC ; FFastList<CvTradedItem,21,0>::erase, COMDAT
; _this$ = ecx

; 227  : 		return iterator( BASE_TYPE::erase( it ).get_index(), this );

	mov	eax, DWORD PTR _it$[esp]
	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _it$[esp+8]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T228778[esp+20]
	push	edx
	mov	ecx, esi
	call	?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase
	mov	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 228  : 	};

	add	esp, 8
	ret	12					; 0000000cH
?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ENDP ; FFastList<CvTradedItem,21,0>::erase
_TEXT	ENDS
PUBLIC	??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ
_TEXT	SEGMENT
??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ PROC ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >, COMDAT
; _this$ = ecx

; 700  : 	~FCustomList_Tail_Member(){ m_kAllocator.clear(); };

	xor	eax, eax
	mov	DWORD PTR [ecx], 268435455		; 0fffffffH
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ENDP ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z ; CvWeightedVector<enum TeamTypes,63,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+516], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@3
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
$LN5@push_back@3:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@3
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@3:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXPAU?$pair@IPAVCvDeal@@@2@0@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXPAU?$pair@IPAVCvDeal@@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXPAU?$pair@IPAVCvDeal@@@2@0@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXPAU?$pair@IPAVCvDeal@@@2@0@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@2@PAU32@IABU32@@Z
_TEXT	SEGMENT
$T228966 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$228969 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@2@PAU32@IABU32@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$228969[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T228966[esp+12], 0
	mov	eax, DWORD PTR $T228966[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@2@PAU32@IABU32@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Ufill
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z
_TEXT	SEGMENT
_uiPos$ = -4						; size = 4
_x$ = 8							; size = 4
?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 90   : 	{

	push	ecx
	push	ebp
	mov	ebp, ecx

; 91   : 		unsigned int uiPos;
; 92   : 
; 93   : 		//If there are no pre-allocated spots, get a new one
; 94   : 		if( m_uiFirstEmpty == ms_uiAnchorNodeIndex )

	mov	eax, DWORD PTR [ebp]
	push	esi
	push	edi
	cmp	eax, 268435455				; 0fffffffH
	jne	SHORT $LN2@Alloc@4

; 95   : 		{
; 96   : 			uiPos = m_vec.size();

	mov	eax, DWORD PTR [ebp+12]
	push	ebx

; 97   : 			unsigned int uiIndex = m_vec.push_back( x );

	lea	ebx, DWORD PTR [ebp+8]
	mov	DWORD PTR _uiPos$[esp+20], eax
	mov	eax, DWORD PTR [ebx+8]
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN9@Alloc@4
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize
$LN9@Alloc@4:
	mov	edi, DWORD PTR [ebx+4]
	imul	edi, 44					; 0000002cH
	add	edi, DWORD PTR [ebx]
	je	SHORT $LN12@Alloc@4
	mov	esi, DWORD PTR _x$[esp+16]
	mov	ecx, 11					; 0000000bH
	rep movsd
$LN12@Alloc@4:
	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]

; 98   : 			m_vec[uiIndex].ALLOC_SetDeleted(false);

	imul	eax, 44					; 0000002cH
	mov	DWORD PTR [ebx+4], ecx
	add	eax, DWORD PTR [ebx]
	pop	ebx

; 108  : 			pTemp->ALLOC_SetDeleted(false);

	or	DWORD PTR [eax+4], -2147483648		; 80000000H

; 109  : 		}
; 110  : 		m_uiSize++;

	inc	DWORD PTR [ebp+4]

; 111  : 		return uiPos;

	mov	eax, DWORD PTR _uiPos$[esp+16]
	pop	edi
	pop	esi
	pop	ebp

; 112  : 	};

	pop	ecx
	ret	4
$LN2@Alloc@4:

; 99   : 		}
; 100  : 
; 101  : 		//Otherwise reuse an old spot after deleting it's previous contents
; 102  : 		else{
; 103  : 			uiPos = m_uiFirstEmpty;
; 104  : 			T* pTemp = &m_vec[uiPos];
; 105  : 			m_uiFirstEmpty = pTemp->ALLOC_GetNext();
; 106  : 			pTemp->~T();
; 107  : 			new( (void*)pTemp )T( x );

	mov	esi, DWORD PTR _x$[esp+12]
	mov	DWORD PTR _uiPos$[esp+16], eax
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ebp+8]
	mov	ecx, 11					; 0000000bH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ebp], edx
	mov	edi, eax
	rep movsd

; 108  : 			pTemp->ALLOC_SetDeleted(false);

	or	DWORD PTR [eax+4], -2147483648		; 80000000H

; 109  : 		}
; 110  : 		m_uiSize++;

	inc	DWORD PTR [ebp+4]

; 111  : 		return uiPos;

	mov	eax, DWORD PTR _uiPos$[esp+16]
	pop	edi
	pop	esi
	pop	ebp

; 112  : 	};

	pop	ecx
	ret	4
?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	??0?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ
_TEXT	SEGMENT
??0?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ PROC ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >, COMDAT
; _this$ = ecx

; 697  : 	FCustomList_Tail_Member(){};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], 268435455		; 0fffffffH
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ENDP ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z
_TEXT	SEGMENT
$T229102 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$229105 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$229105[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T229102[esp+4], 0
	mov	eax, DWORD PTR $T229102[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	??1?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::~FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::~FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >, COMDAT
; _this$ = ecx
	xor	eax, eax
	mov	DWORD PTR [ecx], 268435455		; 0fffffffH
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::~FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
_TEXT	ENDS
PUBLIC	?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z ; CvDeal::GetNumResource
EXTRN	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z:PROC ; CvDiplomacyAI::GetDealToRenew
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
_iNumInRenewDeal$ = -28					; size = 4
_iNumInExistingDeal$ = -24				; size = 4
$T229256 = -20						; size = 8
$T229254 = -20						; size = 8
_this$ = -20						; size = 4
_iNumAvailable$ = -12					; size = 4
$T229253 = -8						; size = 8
$T229251 = -8						; size = 8
_it$221597 = -8						; size = 8
_ePlayer$ = 8						; size = 4
_eResource$ = 12					; size = 4
?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z PROC ; CvDeal::GetNumResource, COMDAT
; _this$ = ecx

; 981  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 982  : 	int iNumAvailable = GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, false);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR _eResource$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _ePlayer$[ebp]
	push	esi
	mov	esi, ebx
	imul	esi, 63236				; 0000f704H
	push	edi
	mov	edi, ecx
	push	0
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	mov	DWORD PTR _this$[esp+48], edi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable

; 983  : 	int iNumInRenewDeal = 0;
; 984  : 	int iNumInExistingDeal = 0;
; 985  : 
; 986  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 987  : 	PlayerTypes eOtherPlayer = GetOtherPlayer(ePlayer);
; 988  : 	CvGameDeals* pGameDeals = GC.getGame().GetGameDeals();
; 989  : 	uint uiCurrentlyEndingDeals = pGameDeals->GetNumCurrentlyEndingDeals(ePlayer, eOtherPlayer);
; 990  : #endif
; 991  : 	CvDeal* pRenewDeal = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetDealToRenew();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _iNumAvailable$[esp+40], eax
	xor	eax, eax
	add	ecx, esi
	push	eax
	mov	DWORD PTR _iNumInRenewDeal$[esp+44], eax
	mov	DWORD PTR _iNumInExistingDeal$[esp+44], eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew

; 992  : 	if (!pRenewDeal)

	test	eax, eax
	jne	SHORT $LN144@GetNumReso

; 993  : 	{
; 994  : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 995  : 		PlayerTypes eOtherPlayer = GetOtherPlayer(ePlayer);

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	jne	SHORT $LN18@GetNumReso
	mov	eax, DWORD PTR [edi+8]
$LN18@GetNumReso:

; 996  : #endif
; 997  : 		if (eOtherPlayer != NO_PLAYER)

	cmp	eax, -1
	je	$LN2@GetNumReso

; 998  : 		{
; 999  : 			pRenewDeal = GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetDealToRenew();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew

; 1000 : 		}
; 1001 : 	}
; 1002 : 
; 1003 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1004 : 	if (pRenewDeal || uiCurrentlyEndingDeals > 0)
; 1005 : #else
; 1006 : 	if (pRenewDeal)

	test	eax, eax
	je	$LN2@GetNumReso
$LN144@GetNumReso:

; 1007 : #endif
; 1008 : 	{
; 1009 : 		// count any that are in the renew deal
; 1010 : 		TradedItemList::iterator it;
; 1011 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1012 : 		if (pRenewDeal)
; 1013 : 		{
; 1014 : #endif
; 1015 : 		for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [eax+44]
	lea	edx, DWORD PTR $T229251[esp+40]
	push	edx
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T229253[esp+40]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN6@GetNumReso
$LL32@GetNumReso:

; 1016 : 		{
; 1017 : 			if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, esi
	imul	ecx, 44					; 0000002cH
	add	eax, ecx
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN7@GetNumReso
	mov	edx, DWORD PTR _ePlayer$[ebp]
	cmp	DWORD PTR [eax+36], edx
	jne	SHORT $LN7@GetNumReso
	mov	ecx, DWORD PTR _eResource$[ebp]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN7@GetNumReso

; 1018 : 			{
; 1019 : 				// credit the amount
; 1020 : 				iNumInRenewDeal += it->m_iData2;

	mov	edx, DWORD PTR [eax+24]
	add	DWORD PTR _iNumInRenewDeal$[esp+40], edx
$LN7@GetNumReso:

; 1007 : #endif
; 1008 : 	{
; 1009 : 		// count any that are in the renew deal
; 1010 : 		TradedItemList::iterator it;
; 1011 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1012 : 		if (pRenewDeal)
; 1013 : 		{
; 1014 : #endif
; 1015 : 		for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN33@GetNumReso
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN142@GetNumReso
$LN33@GetNumReso:
	mov	esi, DWORD PTR [eax]
$LN142@GetNumReso:
	lea	eax, DWORD PTR $T229253[esp+40]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL32@GetNumReso
$LN6@GetNumReso:

; 1021 : 			}
; 1022 : 		}
; 1023 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1024 : 		}
; 1025 : 
; 1026 : 		CvDeal* pLoopDeal = NULL;
; 1027 : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 1028 : 		{
; 1029 : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eOtherPlayer, uiI);
; 1030 : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 1031 : 			{
; 1032 : 				if (it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)
; 1033 : 				{
; 1034 : 					// credit the amount
; 1035 : 					iNumInRenewDeal += it->m_iData2;
; 1036 : 				}
; 1037 : 			}
; 1038 : 		}
; 1039 : #endif
; 1040 : 
; 1041 : 		// remove any that are in this deal
; 1042 : 		for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	mov	edi, DWORD PTR _this$[esp+40]
	lea	ecx, DWORD PTR $T229254[esp+40]
	add	edi, 44					; 0000002cH
	push	ecx
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T229256[esp+40]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR _it$221597[esp+44], ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@GetNumReso
	mov	ebx, DWORD PTR [ebx+8]
	npad	6
$LL86@GetNumReso:

; 1043 : 		{
; 1044 : 			if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	eax, esi
	imul	eax, 44					; 0000002cH
	add	eax, ebx
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN3@GetNumReso
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN3@GetNumReso
	mov	edx, DWORD PTR _eResource$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jne	SHORT $LN3@GetNumReso

; 1045 : 			{
; 1046 : 				iNumInExistingDeal += it->m_iData2;

	mov	ecx, DWORD PTR [eax+24]
	add	DWORD PTR _iNumInExistingDeal$[esp+40], ecx
$LN3@GetNumReso:

; 1021 : 			}
; 1022 : 		}
; 1023 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1024 : 		}
; 1025 : 
; 1026 : 		CvDeal* pLoopDeal = NULL;
; 1027 : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 1028 : 		{
; 1029 : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eOtherPlayer, uiI);
; 1030 : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 1031 : 			{
; 1032 : 				if (it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)
; 1033 : 				{
; 1034 : 					// credit the amount
; 1035 : 					iNumInRenewDeal += it->m_iData2;
; 1036 : 				}
; 1037 : 			}
; 1038 : 		}
; 1039 : #endif
; 1040 : 
; 1041 : 		// remove any that are in this deal
; 1042 : 		for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN87@GetNumReso
	mov	edx, DWORD PTR _it$221597[esp+40]
	mov	esi, DWORD PTR [edx+24]
	jmp	SHORT $LN143@GetNumReso
$LN87@GetNumReso:
	mov	esi, DWORD PTR [eax]
$LN143@GetNumReso:
	lea	eax, DWORD PTR $T229256[esp+40]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL86@GetNumReso
$LN2@GetNumReso:

; 1047 : 			}
; 1048 : 		}
; 1049 : 	}
; 1050 : 
; 1051 : 	return iNumAvailable + iNumInRenewDeal - iNumInExistingDeal;

	mov	eax, DWORD PTR _iNumInRenewDeal$[esp+40]
	sub	eax, DWORD PTR _iNumInExistingDeal$[esp+40]

; 1052 : }

	pop	edi
	add	eax, DWORD PTR _iNumAvailable$[esp+36]
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z ENDP ; CvDeal::GetNumResource
_TEXT	ENDS
PUBLIC	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z	; CvDeal::GetGoldTrade
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T229620 = -8						; size = 8
$T229618 = -8						; size = 8
_eFrom$ = 8						; size = 4
?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z PROC	; CvDeal::GetGoldTrade, COMDAT
; _this$ = ecx

; 1618 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1619 : 	TradedItemList::iterator it;
; 1620 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T229618[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T229620[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@GetGoldTra
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@GetGoldTra:

; 1621 : 	{
; 1622 : 		if(it->m_eItemType == TRADE_ITEM_GOLD && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 0
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@GetGoldTra
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN60@GetGoldTra
$LN3@GetGoldTra:

; 1619 : 	TradedItemList::iterator it;
; 1620 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@GetGoldTra
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN61@GetGoldTra
$LN16@GetGoldTra:
	mov	esi, DWORD PTR [eax]
$LN61@GetGoldTra:
	lea	edx, DWORD PTR $T229620[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@GetGoldTra
$LN2@GetGoldTra:
	pop	edi
	pop	esi
	pop	ebp

; 1625 : 		}
; 1626 : 	}
; 1627 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1628 : }

	add	esp, 8
	ret	4
$LN60@GetGoldTra:

; 1623 : 		{
; 1624 : 			return it->m_iData1;

	imul	esi, 44					; 0000002cH
	mov	eax, DWORD PTR [esi+ebx+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1628 : }

	add	esp, 8
	ret	4
?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ENDP	; CvDeal::GetGoldTrade
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T229780 = -8						; size = 8
$T229778 = -8						; size = 8
_eFrom$ = 8						; size = 4
?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z PROC	; CvDeal::GetGoldPerTurnTrade, COMDAT
; _this$ = ecx

; 1661 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1662 : 	TradedItemList::iterator it;
; 1663 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T229778[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T229780[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@GetGoldPer
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@GetGoldPer:

; 1664 : 	{
; 1665 : 		if(it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 1
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@GetGoldPer
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN60@GetGoldPer
$LN3@GetGoldPer:

; 1662 : 	TradedItemList::iterator it;
; 1663 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@GetGoldPer
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN61@GetGoldPer
$LN16@GetGoldPer:
	mov	esi, DWORD PTR [eax]
$LN61@GetGoldPer:
	lea	edx, DWORD PTR $T229780[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@GetGoldPer
$LN2@GetGoldPer:
	pop	edi
	pop	esi
	pop	ebp

; 1668 : 		}
; 1669 : 	}
; 1670 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1671 : }

	add	esp, 8
	ret	4
$LN60@GetGoldPer:

; 1666 : 		{
; 1667 : 			return it->m_iData1;

	imul	esi, 44					; 0000002cH
	mov	eax, DWORD PTR [esi+ebx+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1671 : }

	add	esp, 8
	ret	4
?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ENDP	; CvDeal::GetGoldPerTurnTrade
_TEXT	ENDS
PUBLIC	?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvDeal::IsResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
$T229940 = -8						; size = 8
$T229938 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eResource$ = 12					; size = 4
?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z PROC ; CvDeal::IsResourceTrade, COMDAT
; _this$ = ecx

; 1701 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1702 : 	TradedItemList::iterator it;
; 1703 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T229938[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T229940[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsResource
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsResource:

; 1704 : 	{
; 1705 : 		if(it->m_eItemType == TRADE_ITEM_RESOURCES &&
; 1706 : 		        it->m_eFromPlayer == eFrom &&
; 1707 : 		        (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 3
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsResource
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN3@IsResource
	mov	edx, DWORD PTR _eResource$[esp+20]
	cmp	DWORD PTR [eax+20], edx
	je	SHORT $LN60@IsResource
$LN3@IsResource:

; 1702 : 	TradedItemList::iterator it;
; 1703 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsResource
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN61@IsResource
$LN16@IsResource:
	mov	esi, DWORD PTR [eax]
$LN61@IsResource:
	lea	eax, DWORD PTR $T229940[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsResource
$LN2@IsResource:
	pop	edi
	pop	esi
	pop	ebp

; 1710 : 		}
; 1711 : 	}
; 1712 : 	return false;

	xor	al, al
	pop	ebx

; 1713 : }

	add	esp, 8
	ret	8
$LN60@IsResource:
	pop	edi
	pop	esi
	pop	ebp

; 1708 : 		{
; 1709 : 			return true;

	mov	al, 1
	pop	ebx

; 1713 : }

	add	esp, 8
	ret	8
?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ENDP ; CvDeal::IsResourceTrade
_TEXT	ENDS
PUBLIC	?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z	; CvDeal::IsCityTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
$T230100 = -8						; size = 8
$T230098 = -8						; size = 8
_eFrom$ = 8						; size = 4
_cityX$ = 12						; size = 4
_cityY$ = 16						; size = 4
?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z PROC	; CvDeal::IsCityTrade, COMDAT
; _this$ = ecx

; 1745 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1746 : 	TradedItemList::iterator it;
; 1747 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230098[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230100[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsCityTrad
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsCityTrad:

; 1748 : 	{
; 1749 : 		if(it->m_eItemType   == TRADE_ITEM_CITIES &&
; 1750 : 		        it->m_eFromPlayer == eFrom &&
; 1751 : 		        it->m_iData1 == cityX &&
; 1752 : 		        it->m_iData2 == cityY)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 4
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsCityTrad
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN3@IsCityTrad
	mov	edx, DWORD PTR _cityX$[esp+20]
	cmp	DWORD PTR [eax+20], edx
	jne	SHORT $LN3@IsCityTrad
	mov	ecx, DWORD PTR _cityY$[esp+20]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN70@IsCityTrad
$LN3@IsCityTrad:

; 1746 : 	TradedItemList::iterator it;
; 1747 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsCityTrad
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN71@IsCityTrad
$LN16@IsCityTrad:
	mov	esi, DWORD PTR [eax]
$LN71@IsCityTrad:
	lea	edx, DWORD PTR $T230100[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsCityTrad
$LN2@IsCityTrad:
	pop	edi
	pop	esi
	pop	ebp

; 1755 : 		}
; 1756 : 	}
; 1757 : 	return false;

	xor	al, al
	pop	ebx

; 1758 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN70@IsCityTrad:
	pop	edi
	pop	esi
	pop	ebp

; 1753 : 		{
; 1754 : 			return true;

	mov	al, 1
	pop	ebx

; 1758 : }

	add	esp, 8
	ret	12					; 0000000cH
?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ENDP	; CvDeal::IsCityTrade
_TEXT	ENDS
PUBLIC	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsAllowEmbassyTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T230291 = -8						; size = 8
$T230289 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsAllowEmbassyTrade, COMDAT
; _this$ = ecx

; 1761 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1762 : 	TradedItemList::iterator it;
; 1763 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230289[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230291[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsAllowEmb
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsAllowEmb:

; 1764 : 	{
; 1765 : 		if(it->m_eItemType == TRADE_ITEM_ALLOW_EMBASSY && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 17		; 00000011H
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsAllowEmb
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsAllowEmb
$LN3@IsAllowEmb:

; 1762 : 	TradedItemList::iterator it;
; 1763 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsAllowEmb
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsAllowEmb
$LN16@IsAllowEmb:
	mov	esi, DWORD PTR [eax]
$LN51@IsAllowEmb:
	lea	edx, DWORD PTR $T230291[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsAllowEmb
$LN2@IsAllowEmb:
	pop	edi
	pop	esi
	pop	ebp

; 1768 : 		}
; 1769 : 	}
; 1770 : 	return 0;

	xor	al, al
	pop	ebx

; 1771 : }

	add	esp, 8
	ret	4
$LN50@IsAllowEmb:
	pop	edi
	pop	esi
	pop	ebp

; 1766 : 		{
; 1767 : 			return true;

	mov	al, 1
	pop	ebx

; 1771 : }

	add	esp, 8
	ret	4
?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsAllowEmbassyTrade
_TEXT	ENDS
PUBLIC	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsOpenBordersTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T230420 = -8						; size = 8
$T230418 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC	; CvDeal::IsOpenBordersTrade, COMDAT
; _this$ = ecx

; 1774 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1775 : 	TradedItemList::iterator it;
; 1776 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230418[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230420[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsOpenBord
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsOpenBord:

; 1777 : 	{
; 1778 : 		if(it->m_eItemType == TRADE_ITEM_OPEN_BORDERS && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 6
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsOpenBord
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsOpenBord
$LN3@IsOpenBord:

; 1775 : 	TradedItemList::iterator it;
; 1776 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsOpenBord
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsOpenBord
$LN16@IsOpenBord:
	mov	esi, DWORD PTR [eax]
$LN51@IsOpenBord:
	lea	edx, DWORD PTR $T230420[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsOpenBord
$LN2@IsOpenBord:
	pop	edi
	pop	esi
	pop	ebp

; 1781 : 		}
; 1782 : 	}
; 1783 : 	return 0;

	xor	al, al
	pop	ebx

; 1784 : }

	add	esp, 8
	ret	4
$LN50@IsOpenBord:
	pop	edi
	pop	esi
	pop	ebp

; 1779 : 		{
; 1780 : 			return true;

	mov	al, 1
	pop	ebx

; 1784 : }

	add	esp, 8
	ret	4
?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP	; CvDeal::IsOpenBordersTrade
_TEXT	ENDS
PUBLIC	?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsDefensivePactTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T230549 = -8						; size = 8
$T230547 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsDefensivePactTrade, COMDAT
; _this$ = ecx

; 1787 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1788 : 	TradedItemList::iterator it;
; 1789 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230547[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230549[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsDefensiv
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsDefensiv:

; 1790 : 	{
; 1791 : 		if(it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 7
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsDefensiv
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsDefensiv
$LN3@IsDefensiv:

; 1788 : 	TradedItemList::iterator it;
; 1789 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsDefensiv
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsDefensiv
$LN16@IsDefensiv:
	mov	esi, DWORD PTR [eax]
$LN51@IsDefensiv:
	lea	edx, DWORD PTR $T230549[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsDefensiv
$LN2@IsDefensiv:
	pop	edi
	pop	esi
	pop	ebp

; 1794 : 		}
; 1795 : 	}
; 1796 : 	return 0;

	xor	al, al
	pop	ebx

; 1797 : }

	add	esp, 8
	ret	4
$LN50@IsDefensiv:
	pop	edi
	pop	esi
	pop	ebp

; 1792 : 		{
; 1793 : 			return true;

	mov	al, 1
	pop	ebx

; 1797 : }

	add	esp, 8
	ret	4
?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsDefensivePactTrade
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsResearchAgreementTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T230678 = -8						; size = 8
$T230676 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsResearchAgreementTrade, COMDAT
; _this$ = ecx

; 1800 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1801 : 	TradedItemList::iterator it;
; 1802 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230676[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230678[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsResearch
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsResearch:

; 1803 : 	{
; 1804 : 		if(it->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 8
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsResearch
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsResearch
$LN3@IsResearch:

; 1801 : 	TradedItemList::iterator it;
; 1802 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsResearch
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsResearch
$LN16@IsResearch:
	mov	esi, DWORD PTR [eax]
$LN51@IsResearch:
	lea	edx, DWORD PTR $T230678[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsResearch
$LN2@IsResearch:
	pop	edi
	pop	esi
	pop	ebp

; 1807 : 		}
; 1808 : 	}
; 1809 : 	return 0;

	xor	al, al
	pop	ebx

; 1810 : }

	add	esp, 8
	ret	4
$LN50@IsResearch:
	pop	edi
	pop	esi
	pop	ebp

; 1805 : 		{
; 1806 : 			return true;

	mov	al, 1
	pop	ebx

; 1810 : }

	add	esp, 8
	ret	4
?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsResearchAgreementTrade
_TEXT	ENDS
PUBLIC	?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsTradeAgreementTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T230807 = -8						; size = 8
$T230805 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsTradeAgreementTrade, COMDAT
; _this$ = ecx

; 1813 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1814 : 	TradedItemList::iterator it;
; 1815 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230805[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230807[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsTradeAgr
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsTradeAgr:

; 1816 : 	{
; 1817 : 		if(it->m_eItemType == TRADE_ITEM_TRADE_AGREEMENT && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 9
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsTradeAgr
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsTradeAgr
$LN3@IsTradeAgr:

; 1814 : 	TradedItemList::iterator it;
; 1815 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsTradeAgr
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsTradeAgr
$LN16@IsTradeAgr:
	mov	esi, DWORD PTR [eax]
$LN51@IsTradeAgr:
	lea	edx, DWORD PTR $T230807[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsTradeAgr
$LN2@IsTradeAgr:
	pop	edi
	pop	esi
	pop	ebp

; 1820 : 		}
; 1821 : 	}
; 1822 : 	return 0;

	xor	al, al
	pop	ebx

; 1823 : }

	add	esp, 8
	ret	4
$LN50@IsTradeAgr:
	pop	edi
	pop	esi
	pop	ebp

; 1818 : 		{
; 1819 : 			return true;

	mov	al, 1
	pop	ebx

; 1823 : }

	add	esp, 8
	ret	4
?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsTradeAgreementTrade
_TEXT	ENDS
PUBLIC	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T230936 = -8						; size = 8
$T230934 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC	; CvDeal::IsPeaceTreatyTrade, COMDAT
; _this$ = ecx

; 1826 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1827 : 	TradedItemList::iterator it;
; 1828 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T230934[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T230936[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsPeaceTre
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsPeaceTre:

; 1829 : 	{
; 1830 : 		if(it->m_eItemType == TRADE_ITEM_PEACE_TREATY && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 13		; 0000000dH
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsPeaceTre
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsPeaceTre
$LN3@IsPeaceTre:

; 1827 : 	TradedItemList::iterator it;
; 1828 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsPeaceTre
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsPeaceTre
$LN16@IsPeaceTre:
	mov	esi, DWORD PTR [eax]
$LN51@IsPeaceTre:
	lea	edx, DWORD PTR $T230936[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsPeaceTre
$LN2@IsPeaceTre:
	pop	edi
	pop	esi
	pop	ebp

; 1833 : 		}
; 1834 : 	}
; 1835 : 	return 0;

	xor	al, al
	pop	ebx

; 1836 : }

	add	esp, 8
	ret	4
$LN50@IsPeaceTre:
	pop	edi
	pop	esi
	pop	ebp

; 1831 : 		{
; 1832 : 			return true;

	mov	al, 1
	pop	ebx

; 1836 : }

	add	esp, 8
	ret	4
?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP	; CvDeal::IsPeaceTreatyTrade
_TEXT	ENDS
PUBLIC	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyPeaceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
$T231065 = -8						; size = 8
$T231063 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::IsThirdPartyPeaceTrade, COMDAT
; _this$ = ecx

; 1839 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1840 : 	TradedItemList::iterator it;
; 1841 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231063[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231065[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsThirdPar
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsThirdPar:

; 1842 : 	{
; 1843 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE && it->m_eFromPlayer == eFrom && it->m_iData1 == eThirdPartyTeam)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 14		; 0000000eH
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsThirdPar
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN3@IsThirdPar
	mov	edx, DWORD PTR _eThirdPartyTeam$[esp+20]
	cmp	DWORD PTR [eax+20], edx
	je	SHORT $LN60@IsThirdPar
$LN3@IsThirdPar:

; 1840 : 	TradedItemList::iterator it;
; 1841 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsThirdPar
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN61@IsThirdPar
$LN16@IsThirdPar:
	mov	esi, DWORD PTR [eax]
$LN61@IsThirdPar:
	lea	eax, DWORD PTR $T231065[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsThirdPar
$LN2@IsThirdPar:
	pop	edi
	pop	esi
	pop	ebp

; 1846 : 		}
; 1847 : 	}
; 1848 : 	return 0;

	xor	al, al
	pop	ebx

; 1849 : }

	add	esp, 8
	ret	8
$LN60@IsThirdPar:
	pop	edi
	pop	esi
	pop	ebp

; 1844 : 		{
; 1845 : 			return true;

	mov	al, 1
	pop	ebx

; 1849 : }

	add	esp, 8
	ret	8
?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::IsThirdPartyPeaceTrade
_TEXT	ENDS
PUBLIC	?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyWarTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
$T231225 = -8						; size = 8
$T231223 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::IsThirdPartyWarTrade, COMDAT
; _this$ = ecx

; 1852 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1853 : 	TradedItemList::iterator it;
; 1854 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231223[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231225[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsThirdPar@2
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsThirdPar@2:

; 1855 : 	{
; 1856 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR && it->m_eFromPlayer == eFrom && it->m_iData1 == eThirdPartyTeam)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 15		; 0000000fH
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsThirdPar@2
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN3@IsThirdPar@2
	mov	edx, DWORD PTR _eThirdPartyTeam$[esp+20]
	cmp	DWORD PTR [eax+20], edx
	je	SHORT $LN60@IsThirdPar@2
$LN3@IsThirdPar@2:

; 1853 : 	TradedItemList::iterator it;
; 1854 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsThirdPar@2
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN61@IsThirdPar@2
$LN16@IsThirdPar@2:
	mov	esi, DWORD PTR [eax]
$LN61@IsThirdPar@2:
	lea	eax, DWORD PTR $T231225[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsThirdPar@2
$LN2@IsThirdPar@2:
	pop	edi
	pop	esi
	pop	ebp

; 1859 : 		}
; 1860 : 	}
; 1861 : 	return 0;

	xor	al, al
	pop	ebx

; 1862 : }

	add	esp, 8
	ret	8
$LN60@IsThirdPar@2:
	pop	edi
	pop	esi
	pop	ebp

; 1857 : 		{
; 1858 : 			return true;

	mov	al, 1
	pop	ebx

; 1862 : }

	add	esp, 8
	ret	8
?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::IsThirdPartyWarTrade
_TEXT	ENDS
PUBLIC	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T231385 = -8						; size = 8
$T231383 = -8						; size = 8
_eFrom$ = 8						; size = 4
?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsVoteCommitmentTrade, COMDAT
; _this$ = ecx

; 1865 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1866 : 	TradedItemList::iterator it;
; 1867 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231383[esp+24]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231385[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@IsVoteComm
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@IsVoteComm:

; 1868 : 	{
; 1869 : 		if(it->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT && it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 19		; 00000013H
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@IsVoteComm
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	je	SHORT $LN50@IsVoteComm
$LN3@IsVoteComm:

; 1866 : 	TradedItemList::iterator it;
; 1867 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@IsVoteComm
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN51@IsVoteComm
$LN16@IsVoteComm:
	mov	esi, DWORD PTR [eax]
$LN51@IsVoteComm:
	lea	edx, DWORD PTR $T231385[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@IsVoteComm
$LN2@IsVoteComm:
	pop	edi
	pop	esi
	pop	ebp

; 1872 : 		}
; 1873 : 	}
; 1874 : 	return false;

	xor	al, al
	pop	ebx

; 1875 : }

	add	esp, 8
	ret	4
$LN50@IsVoteComm:
	pop	edi
	pop	esi
	pop	ebp

; 1870 : 		{
; 1871 : 			return true;

	mov	al, 1
	pop	ebx

; 1875 : }

	add	esp, 8
	ret	4
?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsVoteCommitmentTrade
_TEXT	ENDS
PUBLIC	?IsPotentiallyRenewable@CvDeal@@QAE_NXZ		; CvDeal::IsPotentiallyRenewable
; Function compile flags: /Ogtpy
;	COMDAT ?IsPotentiallyRenewable@CvDeal@@QAE_NXZ
_TEXT	SEGMENT
_bHasValidTradeItem$ = -9				; size = 1
$T231514 = -8						; size = 8
$T231512 = -8						; size = 8
?IsPotentiallyRenewable@CvDeal@@QAE_NXZ PROC		; CvDeal::IsPotentiallyRenewable, COMDAT
; _this$ = ecx

; 1918 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1919 : 	TradedItemList::iterator it;
; 1920 : 	bool bHasValidTradeItem = false;
; 1921 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231512[esp+28]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR _bHasValidTradeItem$[esp+32], 0
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231514[esp+28]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN6@IsPotentia
	mov	ebp, DWORD PTR [ebx+8]
$LL19@IsPotentia:

; 1922 : 	{
; 1923 : 		switch(GetItemTradeableState(it->m_eItemType))

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR [edx+ebp+8]
	lea	ecx, DWORD PTR [edx+ebp]
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN46@IsPotentia
	movzx	eax, BYTE PTR $LN52@IsPotentia[eax]
	jmp	DWORD PTR $LN53@IsPotentia[eax*4]
$LN44@IsPotentia:
	xor	eax, eax
	jmp	SHORT $LN48@IsPotentia
$LN43@IsPotentia:
	mov	eax, 2
	jmp	SHORT $LN48@IsPotentia
$LN46@IsPotentia:
	mov	eax, 1
$LN48@IsPotentia:
	sub	eax, 0
	je	SHORT $LN2@IsPotentia
	sub	eax, 1
	jne	SHORT $LN7@IsPotentia
	pop	edi
	pop	esi
	pop	ebp

; 1924 : 		{
; 1925 : 		case DEAL_NONRENEWABLE:
; 1926 : 			return false;

	xor	al, al
	pop	ebx

; 1935 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@IsPotentia:

; 1927 : 		case DEAL_RENEWABLE:
; 1928 : 			bHasValidTradeItem = true;

	mov	BYTE PTR _bHasValidTradeItem$[esp+28], 1
$LN7@IsPotentia:

; 1919 : 	TradedItemList::iterator it;
; 1920 : 	bool bHasValidTradeItem = false;
; 1921 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN20@IsPotentia
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN51@IsPotentia
$LN20@IsPotentia:
	mov	esi, DWORD PTR [ecx]
$LN51@IsPotentia:
	lea	ecx, DWORD PTR $T231514[esp+28]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL19@IsPotentia
$LN6@IsPotentia:

; 1929 : 			break;
; 1930 : 		case DEAL_SUPPLEMENTAL:
; 1931 : 			break;
; 1932 : 		}
; 1933 : 	}
; 1934 : 	return bHasValidTradeItem;

	mov	al, BYTE PTR _bHasValidTradeItem$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1935 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN53@IsPotentia:
	DD	$LN43@IsPotentia
	DD	$LN44@IsPotentia
	DD	$LN46@IsPotentia
	DD	$LN46@IsPotentia
$LN52@IsPotentia:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	2
	DB	2
	DB	1
	DB	1
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	3
	DB	2
?IsPotentiallyRenewable@CvDeal@@QAE_NXZ ENDP		; CvDeal::IsPotentiallyRenewable
_TEXT	ENDS
PUBLIC	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T231623 = -8						; size = 8
$T231622 = -8						; size = 8
$T231620 = -8						; size = 8
_eItemType$ = 8						; size = 4
_eFrom$ = 12						; size = 4
?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z PROC ; CvDeal::RemoveByType, COMDAT
; _this$ = ecx

; 1939 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1940 : 	TradedItemList::iterator it;
; 1941 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231620[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231622[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN3@RemoveByTy
	push	ebp
	mov	ebp, DWORD PTR _eFrom$[esp+20]
$LL16@RemoveByTy:

; 1942 : 	{
; 1943 : 		if(it->m_eItemType == eItemType &&
; 1944 : 		        (eFrom == NO_PLAYER || eFrom == it->m_eFromPlayer))

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _eItemType$[esp+20]
	mov	edx, esi
	imul	edx, 44					; 0000002cH
	add	eax, edx
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN4@RemoveByTy
	cmp	ebp, -1
	je	SHORT $LN1@RemoveByTy
	cmp	ebp, DWORD PTR [eax+36]
	je	SHORT $LN1@RemoveByTy
$LN4@RemoveByTy:

; 1940 : 	TradedItemList::iterator it;
; 1941 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN17@RemoveByTy
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN51@RemoveByTy
$LN17@RemoveByTy:
	mov	esi, DWORD PTR [eax]
$LN51@RemoveByTy:
	lea	edx, DWORD PTR $T231622[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL16@RemoveByTy
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 1947 : 			break;
; 1948 : 		}
; 1949 : 	}
; 1950 : }

	add	esp, 8
	ret	8
$LN1@RemoveByTy:

; 1945 : 		{
; 1946 : 			m_TradedItems.erase(it);

	push	esi
	push	ebx
	lea	eax, DWORD PTR $T231623[esp+32]
	push	eax
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebp
$LN3@RemoveByTy:
	pop	edi
	pop	esi
	pop	ebx

; 1947 : 			break;
; 1948 : 		}
; 1949 : 	}
; 1950 : }

	add	esp, 8
	ret	8
?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ENDP ; CvDeal::RemoveByType
_TEXT	ENDS
PUBLIC	?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z ; CvDeal::RemoveResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z
_TEXT	SEGMENT
$T231751 = -8						; size = 8
$T231750 = -8						; size = 8
$T231748 = -8						; size = 8
_eResource$ = 8						; size = 4
?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z PROC ; CvDeal::RemoveResourceTrade, COMDAT
; _this$ = ecx

; 1954 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1955 : 	TradedItemList::iterator it;
; 1956 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231748[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231750[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@RemoveReso
	push	ebp
	mov	ebp, DWORD PTR [ebx+8]
	npad	1
$LL15@RemoveReso:

; 1957 : 	{
; 1958 : 		if(it->m_eItemType == TRADE_ITEM_RESOURCES &&
; 1959 : 		        (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebp+8], 3
	lea	eax, DWORD PTR [edx+ebp]
	jne	SHORT $LN3@RemoveReso
	mov	ecx, DWORD PTR _eResource$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN50@RemoveReso
$LN3@RemoveReso:

; 1955 : 	TradedItemList::iterator it;
; 1956 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@RemoveReso
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN51@RemoveReso
$LN16@RemoveReso:
	mov	esi, DWORD PTR [eax]
$LN51@RemoveReso:
	lea	edx, DWORD PTR $T231750[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@RemoveReso
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 1962 : 			break;
; 1963 : 		}
; 1964 : 	}
; 1965 : }

	add	esp, 8
	ret	4
$LN50@RemoveReso:

; 1960 : 		{
; 1961 : 			m_TradedItems.erase(it);

	push	esi
	push	ebx
	lea	eax, DWORD PTR $T231751[esp+32]
	push	eax
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebp
$LN2@RemoveReso:
	pop	edi
	pop	esi
	pop	ebx

; 1962 : 			break;
; 1963 : 		}
; 1964 : 	}
; 1965 : }

	add	esp, 8
	ret	4
?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z ENDP ; CvDeal::RemoveResourceTrade
_TEXT	ENDS
PUBLIC	?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::RemoveCityTrade
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
tv384 = -12						; size = 4
$T231880 = -8						; size = 8
$T231879 = -8						; size = 8
$T231877 = -8						; size = 8
_eFrom$ = 8						; size = 4
_iCityID$ = 12						; size = 4
?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::RemoveCityTrade, COMDAT
; _this$ = ecx

; 1969 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 1970 : 	TradedItemList::iterator it;
; 1971 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	esi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T231877[esp+24]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR tv384[esp+28], esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T231879[esp+24]
	push	ecx
	mov	ecx, esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	je	$LN3@RemoveCity
	push	edi
	mov	edi, DWORD PTR [ebp+8]
	npad	9
$LL16@RemoveCity:

; 1972 : 	{
; 1973 : 		if(it->m_eItemType == TRADE_ITEM_CITIES &&
; 1974 : 		        it->m_eFromPlayer == eFrom)

	mov	esi, ebx
	imul	esi, 44					; 0000002cH
	cmp	DWORD PTR [edi+esi+8], 4
	jne	SHORT $LN4@RemoveCity
	mov	ecx, DWORD PTR _eFrom$[esp+24]
	cmp	DWORD PTR [edi+esi+36], ecx
	jne	SHORT $LN4@RemoveCity

; 1975 : 		{
; 1976 : 			CvCity* pCity = GET_PLAYER(eFrom).getCity(iCityID);

	mov	edx, DWORD PTR _iCityID$[esp+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1977 : 			if(it->m_iData1 == pCity->getX() &&
; 1978 : 			        it->m_iData2 == pCity->getY())

	mov	edi, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi+esi+20]
	cmp	ecx, DWORD PTR [eax+96]
	jne	SHORT $LN4@RemoveCity
	mov	edx, DWORD PTR [edi+esi+24]
	cmp	edx, DWORD PTR [eax+108]
	je	SHORT $LN81@RemoveCity
$LN4@RemoveCity:

; 1970 : 	TradedItemList::iterator it;
; 1971 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	ebx, 268435455				; 0fffffffH
	jne	SHORT $LN17@RemoveCity
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN82@RemoveCity
$LN17@RemoveCity:
	mov	ebx, DWORD PTR [edi+esi]
$LN82@RemoveCity:
	mov	ecx, DWORD PTR tv384[esp+28]
	lea	eax, DWORD PTR $T231879[esp+28]
	push	eax
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	jne	SHORT $LL16@RemoveCity
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1981 : 				return;
; 1982 : 			}
; 1983 : 		}
; 1984 : 	}
; 1985 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN81@RemoveCity:

; 1979 : 			{
; 1980 : 				m_TradedItems.erase(it);

	push	ebx
	push	ebp
	lea	ecx, DWORD PTR $T231880[esp+36]
	push	ecx
	mov	ecx, DWORD PTR tv384[esp+40]
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	edi
$LN3@RemoveCity:
	pop	esi
	pop	ebp
	pop	ebx

; 1981 : 				return;
; 1982 : 			}
; 1983 : 		}
; 1984 : 	}
; 1985 : }

	add	esp, 12					; 0000000cH
	ret	8
?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::RemoveCityTrade
_TEXT	ENDS
PUBLIC	?RemoveUnitTrade@CvDeal@@QAEXH@Z		; CvDeal::RemoveUnitTrade
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveUnitTrade@CvDeal@@QAEXH@Z
_TEXT	SEGMENT
$T232093 = -8						; size = 8
$T232092 = -8						; size = 8
$T232090 = -8						; size = 8
_iUnitID$ = 8						; size = 4
?RemoveUnitTrade@CvDeal@@QAEXH@Z PROC			; CvDeal::RemoveUnitTrade, COMDAT
; _this$ = ecx

; 1989 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1990 : 	TradedItemList::iterator it;
; 1991 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T232090[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T232092[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@RemoveUnit
	push	ebp
	mov	ebp, DWORD PTR [ebx+8]
	npad	1
$LL15@RemoveUnit:

; 1992 : 	{
; 1993 : 		if(it->m_eItemType == TRADE_ITEM_UNITS &&
; 1994 : 		        it->m_iData1 == iUnitID)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebp+8], 5
	lea	eax, DWORD PTR [edx+ebp]
	jne	SHORT $LN3@RemoveUnit
	mov	ecx, DWORD PTR _iUnitID$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN50@RemoveUnit
$LN3@RemoveUnit:

; 1990 : 	TradedItemList::iterator it;
; 1991 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@RemoveUnit
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN51@RemoveUnit
$LN16@RemoveUnit:
	mov	esi, DWORD PTR [eax]
$LN51@RemoveUnit:
	lea	edx, DWORD PTR $T232092[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@RemoveUnit
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 1997 : 			break;
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	add	esp, 8
	ret	4
$LN50@RemoveUnit:

; 1995 : 		{
; 1996 : 			m_TradedItems.erase(it);

	push	esi
	push	ebx
	lea	eax, DWORD PTR $T232093[esp+32]
	push	eax
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebp
$LN2@RemoveUnit:
	pop	edi
	pop	esi
	pop	ebx

; 1997 : 			break;
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	add	esp, 8
	ret	4
?RemoveUnitTrade@CvDeal@@QAEXH@Z ENDP			; CvDeal::RemoveUnitTrade
_TEXT	ENDS
PUBLIC	?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::RemoveThirdPartyPeace
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
$T232222 = -8						; size = 8
$T232221 = -8						; size = 8
$T232219 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::RemoveThirdPartyPeace, COMDAT
; _this$ = ecx

; 2004 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 2005 : 	TradedItemList::iterator it;
; 2006 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T232219[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T232221[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@RemoveThir
	push	ebp
	mov	ebp, DWORD PTR [ebx+8]
	npad	1
$LL15@RemoveThir:

; 2007 : 	{
; 2008 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE &&
; 2009 : 		        (TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2010 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebp+8], 14		; 0000000eH
	lea	eax, DWORD PTR [edx+ebp]
	jne	SHORT $LN3@RemoveThir
	mov	ecx, DWORD PTR _eThirdPartyTeam$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@RemoveThir
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	je	SHORT $LN60@RemoveThir
$LN3@RemoveThir:

; 2005 : 	TradedItemList::iterator it;
; 2006 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@RemoveThir
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN61@RemoveThir
$LN16@RemoveThir:
	mov	esi, DWORD PTR [eax]
$LN61@RemoveThir:
	lea	eax, DWORD PTR $T232221[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@RemoveThir
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 2013 : 			break;
; 2014 : 		}
; 2015 : 	}
; 2016 : }

	add	esp, 8
	ret	8
$LN60@RemoveThir:

; 2011 : 		{
; 2012 : 			m_TradedItems.erase(it);

	push	esi
	push	ebx
	lea	ecx, DWORD PTR $T232222[esp+32]
	push	ecx
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebp
$LN2@RemoveThir:
	pop	edi
	pop	esi
	pop	ebx

; 2013 : 			break;
; 2014 : 		}
; 2015 : 	}
; 2016 : }

	add	esp, 8
	ret	8
?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::RemoveThirdPartyPeace
_TEXT	ENDS
PUBLIC	?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::RemoveThirdPartyWar
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
$T232382 = -8						; size = 8
$T232381 = -8						; size = 8
$T232379 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::RemoveThirdPartyWar, COMDAT
; _this$ = ecx

; 2020 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 2021 : 	TradedItemList::iterator it;
; 2022 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T232379[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T232381[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@RemoveThir@2
	push	ebp
	mov	ebp, DWORD PTR [ebx+8]
	npad	1
$LL15@RemoveThir@2:

; 2023 : 	{
; 2024 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR &&
; 2025 : #ifdef AUI_WARNING_FIXES
; 2026 : 				(TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2027 : #else
; 2028 : 		        (PlayerTypes)it->m_iData1 == eThirdPartyTeam &&
; 2029 : #endif
; 2030 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebp+8], 15		; 0000000fH
	lea	eax, DWORD PTR [edx+ebp]
	jne	SHORT $LN3@RemoveThir@2
	mov	ecx, DWORD PTR _eThirdPartyTeam$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@RemoveThir@2
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	je	SHORT $LN60@RemoveThir@2
$LN3@RemoveThir@2:

; 2021 : 	TradedItemList::iterator it;
; 2022 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@RemoveThir@2
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN61@RemoveThir@2
$LN16@RemoveThir@2:
	mov	esi, DWORD PTR [eax]
$LN61@RemoveThir@2:
	lea	eax, DWORD PTR $T232381[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@RemoveThir@2
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 2033 : 			break;
; 2034 : 		}
; 2035 : 	}
; 2036 : }

	add	esp, 8
	ret	8
$LN60@RemoveThir@2:

; 2031 : 		{
; 2032 : 			m_TradedItems.erase(it);

	push	esi
	push	ebx
	lea	ecx, DWORD PTR $T232382[esp+32]
	push	ecx
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebp
$LN2@RemoveThir@2:
	pop	edi
	pop	esi
	pop	ebx

; 2033 : 			break;
; 2034 : 		}
; 2035 : 	}
; 2036 : }

	add	esp, 8
	ret	8
?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::RemoveThirdPartyWar
_TEXT	ENDS
PUBLIC	?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z ; CvDeal::RemoveThirdPartyEmbargo
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z
_TEXT	SEGMENT
$T232542 = -8						; size = 8
$T232541 = -8						; size = 8
$T232539 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdParty$ = 12					; size = 4
?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z PROC ; CvDeal::RemoveThirdPartyEmbargo, COMDAT
; _this$ = ecx

; 2040 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 2041 : 	TradedItemList::iterator it;
; 2042 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T232539[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T232541[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@RemoveThir@3
	push	ebp
	mov	ebp, DWORD PTR [ebx+8]
	npad	1
$LL15@RemoveThir@3:

; 2043 : 	{
; 2044 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_EMBARGO &&
; 2045 : 		        (PlayerTypes)it->m_iData1 == eThirdParty &&
; 2046 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebp+8], 16		; 00000010H
	lea	eax, DWORD PTR [edx+ebp]
	jne	SHORT $LN3@RemoveThir@3
	mov	ecx, DWORD PTR _eThirdParty$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@RemoveThir@3
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	je	SHORT $LN60@RemoveThir@3
$LN3@RemoveThir@3:

; 2041 : 	TradedItemList::iterator it;
; 2042 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@RemoveThir@3
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN61@RemoveThir@3
$LN16@RemoveThir@3:
	mov	esi, DWORD PTR [eax]
$LN61@RemoveThir@3:
	lea	eax, DWORD PTR $T232541[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@RemoveThir@3
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 2049 : 			break;
; 2050 : 		}
; 2051 : 	}
; 2052 : }

	add	esp, 8
	ret	8
$LN60@RemoveThir@3:

; 2047 : 		{
; 2048 : 			m_TradedItems.erase(it);

	push	esi
	push	ebx
	lea	ecx, DWORD PTR $T232542[esp+32]
	push	ecx
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebp
$LN2@RemoveThir@3:
	pop	edi
	pop	esi
	pop	ebx

; 2049 : 			break;
; 2050 : 		}
; 2051 : 	}
; 2052 : }

	add	esp, 8
	ret	8
?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z ENDP ; CvDeal::RemoveThirdPartyEmbargo
_TEXT	ENDS
PUBLIC	?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::RemoveVoteCommitment
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
_TEXT	SEGMENT
$T232702 = -8						; size = 8
$T232701 = -8						; size = 8
$T232699 = -8						; size = 8
_eFrom$ = 8						; size = 4
_iResolutionID$ = 12					; size = 4
_iVoteChoice$ = 16					; size = 4
_iNumVotes$ = 20					; size = 4
_bRepeal$ = 24						; size = 1
?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z PROC ; CvDeal::RemoveVoteCommitment, COMDAT
; _this$ = ecx

; 2056 : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 2057 : 	TradedItemList::iterator it;
; 2058 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T232699[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T232701[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@RemoveVote
	push	ebx
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@RemoveVote:

; 2059 : 	{
; 2060 : 		if(it->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT &&
; 2061 : 			it->m_eFromPlayer == eFrom &&
; 2062 : 			it->m_iData1 == iResolutionID &&
; 2063 : 			it->m_iData2 == iVoteChoice &&
; 2064 : 			it->m_iData3 == iNumVotes &&
; 2065 : 			it->m_bFlag1 == bRepeal)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 19		; 00000013H
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@RemoveVote
	mov	ecx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN3@RemoveVote
	mov	edx, DWORD PTR _iResolutionID$[esp+20]
	cmp	DWORD PTR [eax+20], edx
	jne	SHORT $LN3@RemoveVote
	mov	ecx, DWORD PTR _iVoteChoice$[esp+20]
	cmp	DWORD PTR [eax+24], ecx
	jne	SHORT $LN3@RemoveVote
	mov	edx, DWORD PTR _iNumVotes$[esp+20]
	cmp	DWORD PTR [eax+28], edx
	jne	SHORT $LN3@RemoveVote
	mov	cl, BYTE PTR _bRepeal$[esp+20]
	cmp	BYTE PTR [eax+32], cl
	je	SHORT $LN90@RemoveVote
$LN3@RemoveVote:

; 2057 : 	TradedItemList::iterator it;
; 2058 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@RemoveVote
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN91@RemoveVote
$LN16@RemoveVote:
	mov	esi, DWORD PTR [eax]
$LN91@RemoveVote:
	lea	edx, DWORD PTR $T232701[esp+24]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@RemoveVote
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2068 : 			break;
; 2069 : 		}
; 2070 : 	}
; 2071 : }

	add	esp, 8
	ret	20					; 00000014H
$LN90@RemoveVote:

; 2066 : 		{
; 2067 : 			m_TradedItems.erase(it);

	push	esi
	push	ebp
	lea	eax, DWORD PTR $T232702[esp+32]
	push	eax
	mov	ecx, edi
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
	pop	ebx
$LN2@RemoveVote:
	pop	edi
	pop	esi
	pop	ebp

; 2068 : 			break;
; 2069 : 		}
; 2070 : 	}
; 2071 : }

	add	esp, 8
	ret	20					; 00000014H
?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ENDP ; CvDeal::RemoveVoteCommitment
_TEXT	ENDS
PUBLIC	?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::ChangeThirdPartyWarDuration
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
$T232954 = -8						; size = 8
$T232952 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
_iNewDuration$ = 16					; size = 4
?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z PROC ; CvDeal::ChangeThirdPartyWarDuration, COMDAT
; _this$ = ecx

; 2074 : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 2075 : 	TradedItemList::iterator it;
; 2076 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T232952[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T232954[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@ChangeThir
	push	ebx
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@ChangeThir:

; 2077 : 	{
; 2078 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR &&
; 2079 : #ifdef AUI_WARNING_FIXES
; 2080 : 				(TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2081 : #else
; 2082 : 		        (PlayerTypes)it->m_iData1 == eThirdPartyTeam &&
; 2083 : #endif
; 2084 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 15		; 0000000fH
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@ChangeThir
	mov	ecx, DWORD PTR _eThirdPartyTeam$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@ChangeThir
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	je	SHORT $LN70@ChangeThir
$LN3@ChangeThir:

; 2075 : 	TradedItemList::iterator it;
; 2076 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@ChangeThir
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN71@ChangeThir
$LN16@ChangeThir:
	mov	esi, DWORD PTR [eax]
$LN71@ChangeThir:
	lea	eax, DWORD PTR $T232954[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@ChangeThir
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2087 : 			break;
; 2088 : 		}
; 2089 : 	}
; 2090 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN70@ChangeThir:

; 2085 : 		{
; 2086 : 			it->m_iDuration = iNewDuration;

	mov	ecx, DWORD PTR _iNewDuration$[esp+20]
	imul	esi, 44					; 0000002cH
	mov	DWORD PTR [esi+ebx+12], ecx
	pop	ebx
$LN2@ChangeThir:
	pop	edi
	pop	esi
	pop	ebp

; 2087 : 			break;
; 2088 : 		}
; 2089 : 	}
; 2090 : }

	add	esp, 8
	ret	12					; 0000000cH
?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ENDP ; CvDeal::ChangeThirdPartyWarDuration
_TEXT	ENDS
PUBLIC	?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::ChangeThirdPartyPeaceDuration
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
$T233144 = -8						; size = 8
$T233142 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
_iNewDuration$ = 16					; size = 4
?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z PROC ; CvDeal::ChangeThirdPartyPeaceDuration, COMDAT
; _this$ = ecx

; 2094 : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 2095 : 	CvAssertMsg(iNewDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2096 : 	CvAssertMsg(iNewDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2097 : 
; 2098 : 	TradedItemList::iterator it;
; 2099 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T233142[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T233144[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@ChangeThir@2
	push	ebx
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@ChangeThir@2:

; 2100 : 	{
; 2101 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE &&
; 2102 : 		        (TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2103 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 14		; 0000000eH
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@ChangeThir@2
	mov	ecx, DWORD PTR _eThirdPartyTeam$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@ChangeThir@2
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	je	SHORT $LN70@ChangeThir@2
$LN3@ChangeThir@2:

; 2095 : 	CvAssertMsg(iNewDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2096 : 	CvAssertMsg(iNewDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2097 : 
; 2098 : 	TradedItemList::iterator it;
; 2099 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@ChangeThir@2
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN71@ChangeThir@2
$LN16@ChangeThir@2:
	mov	esi, DWORD PTR [eax]
$LN71@ChangeThir@2:
	lea	eax, DWORD PTR $T233144[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@ChangeThir@2
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2106 : 			break;
; 2107 : 		}
; 2108 : 	}
; 2109 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN70@ChangeThir@2:

; 2104 : 		{
; 2105 : 			it->m_iDuration = iNewDuration;

	mov	ecx, DWORD PTR _iNewDuration$[esp+20]
	imul	esi, 44					; 0000002cH
	mov	DWORD PTR [esi+ebx+12], ecx
	pop	ebx
$LN2@ChangeThir@2:
	pop	edi
	pop	esi
	pop	ebp

; 2106 : 			break;
; 2107 : 		}
; 2108 : 	}
; 2109 : }

	add	esp, 8
	ret	12					; 0000000cH
?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ENDP ; CvDeal::ChangeThirdPartyPeaceDuration
_TEXT	ENDS
PUBLIC	?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z ; CvDeal::ChangeThirdPartyEmbargoDuration
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z
_TEXT	SEGMENT
$T233334 = -8						; size = 8
$T233332 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eThirdParty$ = 12					; size = 4
_iNewDuration$ = 16					; size = 4
?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z PROC ; CvDeal::ChangeThirdPartyEmbargoDuration, COMDAT
; _this$ = ecx

; 2112 : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 2113 : 	CvAssertMsg(iNewDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2114 : 	CvAssertMsg(iNewDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2115 : 
; 2116 : 	TradedItemList::iterator it;
; 2117 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T233332[esp+20]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T233334[esp+20]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN2@ChangeThir@3
	push	ebx
	mov	ebx, DWORD PTR [ebp+8]
	npad	1
$LL15@ChangeThir@3:

; 2118 : 	{
; 2119 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_EMBARGO &&
; 2120 : 		        (PlayerTypes)it->m_iData1 == eThirdParty &&
; 2121 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	cmp	DWORD PTR [edx+ebx+8], 16		; 00000010H
	lea	eax, DWORD PTR [edx+ebx]
	jne	SHORT $LN3@ChangeThir@3
	mov	ecx, DWORD PTR _eThirdParty$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@ChangeThir@3
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	je	SHORT $LN70@ChangeThir@3
$LN3@ChangeThir@3:

; 2113 : 	CvAssertMsg(iNewDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2114 : 	CvAssertMsg(iNewDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2115 : 
; 2116 : 	TradedItemList::iterator it;
; 2117 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN16@ChangeThir@3
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN71@ChangeThir@3
$LN16@ChangeThir@3:
	mov	esi, DWORD PTR [eax]
$LN71@ChangeThir@3:
	lea	eax, DWORD PTR $T233334[esp+24]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL15@ChangeThir@3
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2124 : 			break;
; 2125 : 		}
; 2126 : 	}
; 2127 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN70@ChangeThir@3:

; 2122 : 		{
; 2123 : 			it->m_iDuration = iNewDuration;

	mov	ecx, DWORD PTR _iNewDuration$[esp+20]
	imul	esi, 44					; 0000002cH
	mov	DWORD PTR [esi+ebx+12], ecx
	pop	ebx
$LN2@ChangeThir@3:
	pop	edi
	pop	esi
	pop	ebp

; 2124 : 			break;
; 2125 : 		}
; 2126 : 	}
; 2127 : }

	add	esp, 8
	ret	12					; 0000000cH
?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z ENDP ; CvDeal::ChangeThirdPartyEmbargoDuration
_TEXT	ENDS
PUBLIC	?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::ContainsItemType
; Function compile flags: /Ogtpy
;	COMDAT ?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv297 = -20						; size = 4
_it$ = -16						; size = 8
$T233524 = -8						; size = 8
$T233522 = -8						; size = 8
_eItemType$ = 8						; size = 4
_eFrom$ = 12						; size = 4
?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z PROC ; CvDeal::ContainsItemType, COMDAT
; _this$ = ecx

; 2130 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2131 : 	TradedItemList::iterator it;
; 2132 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	edi, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR $T233522[esp+36]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T233524[esp+36]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _it$[esp+40], ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN3@ContainsIt

; 2133 : 	{
; 2134 : 		if(it->m_eItemType == eItemType && (eFrom == NO_PLAYER || it->m_eFromPlayer == eFrom))

	mov	edx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR _eFrom$[esp+32]
	mov	ebp, DWORD PTR _eItemType$[esp+32]
	mov	DWORD PTR tv297[esp+36], edx
	npad	1
$LL52@ContainsIt:
	mov	ecx, DWORD PTR tv297[esp+36]
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	add	eax, ecx
	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN4@ContainsIt
	cmp	ebx, -1
	je	SHORT $LN1@ContainsIt
	cmp	DWORD PTR [eax+36], ebx
	je	SHORT $LN1@ContainsIt
$LN4@ContainsIt:

; 2131 : 	TradedItemList::iterator it;
; 2132 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN17@ContainsIt
	mov	edx, DWORD PTR _it$[esp+36]
	mov	esi, DWORD PTR [edx+24]
	jmp	SHORT $LN51@ContainsIt
$LN17@ContainsIt:
	mov	esi, DWORD PTR [eax]
$LN51@ContainsIt:
	lea	eax, DWORD PTR $T233524[esp+36]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL52@ContainsIt
$LN3@ContainsIt:
	pop	edi
	pop	esi
	pop	ebp

; 2137 : 		}
; 2138 : 	}
; 2139 : 	return false;

	xor	al, al
	pop	ebx

; 2140 : }

	add	esp, 20					; 00000014H
	ret	8
$LN1@ContainsIt:
	pop	edi
	pop	esi
	pop	ebp

; 2135 : 		{
; 2136 : 			return true;

	mov	al, 1
	pop	ebx

; 2140 : }

	add	esp, 20					; 00000014H
	ret	8
?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z ENDP ; CvDeal::ContainsItemType
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z
_TEXT	SEGMENT
_uiVersion$ = -12					; size = 4
$T233654 = -8						; size = 8
$T233652 = -8						; size = 8
tv337 = 8						; size = 4
$T233684 = 8						; size = 4
$T233651 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z PROC		; operator<<, COMDAT

; 2218 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 2219 : 	// Current version number
; 2220 : 	uint uiVersion = 3;
; 2221 : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+20]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+32], 3
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2222 : 	saveTo << readFrom.m_eFromPlayer;

	mov	edi, DWORD PTR _readFrom$[esp+24]
	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 2223 : 	saveTo << readFrom.m_eToPlayer;

	lea	edx, DWORD PTR [edi+8]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 16					; 00000010H

; 2224 : 	saveTo << readFrom.m_iFinalTurn;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2225 : 	saveTo << readFrom.m_iDuration;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2226 : 	saveTo << readFrom.m_iStartTurn;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2227 : 	saveTo << readFrom.m_bConsideringForRenewal;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2228 : 	saveTo << readFrom.m_bCheckedForRenewal;

	lea	ecx, DWORD PTR [edi+41]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2229 : 	saveTo << readFrom.m_bDealCancelled;

	lea	edx, DWORD PTR [edi+42]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2230 : 	saveTo << readFrom.m_ePeaceTreatyType;

	mov	eax, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR $T233684[esp+24]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T233684[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2231 : 	saveTo << readFrom.m_eSurrenderingPlayer;

	lea	edx, DWORD PTR [edi+28]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 2232 : 	saveTo << readFrom.m_eDemandingPlayer;

	lea	eax, DWORD PTR [edi+32]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 2233 : 	saveTo << readFrom.m_eRequestingPlayer;

	lea	ecx, DWORD PTR [edi+36]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 2234 : 	saveTo << readFrom.m_TradedItems.size();

	mov	edx, DWORD PTR [edi+64]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR $T233651[esp+24]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T233651[esp+28], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2235 : 	TradedItemList::const_iterator it;
; 2236 : 	for(it = readFrom.m_TradedItems.begin(); it != readFrom.m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR $T233652[esp+28]
	lea	ebx, DWORD PTR [edi+44]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR tv337[esp+28], ebx
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T233654[esp+28]
	push	edx
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	SHORT $LN64@operator@6
	npad	4
$LL38@operator@6:

; 2237 : 	{
; 2238 : 		saveTo << *it;

	mov	eax, DWORD PTR [ebp+8]
	mov	ebx, edi
	imul	ebx, 44					; 0000002cH
	lea	ecx, DWORD PTR [eax+ebx+8]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z ; operator<<
	add	esp, 8
	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN39@operator@6

; 2235 : 	TradedItemList::const_iterator it;
; 2236 : 	for(it = readFrom.m_TradedItems.begin(); it != readFrom.m_TradedItems.end(); ++it)

	mov	edi, DWORD PTR [ebp+24]
	jmp	SHORT $LN63@operator@6
$LN39@operator@6:
	mov	edx, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [ebx+edx]
$LN63@operator@6:
	mov	ecx, DWORD PTR tv337[esp+24]
	lea	eax, DWORD PTR $T233654[esp+28]
	push	eax
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	jne	SHORT $LL38@operator@6
$LN64@operator@6:
	pop	edi

; 2239 : 	}
; 2240 : 
; 2241 : 	return saveTo;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2242 : }

	add	esp, 12					; 0000000cH
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z ; CvGameDeals::PrepareRenewDeal
; Function compile flags: /Ogtpy
;	COMDAT ?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z
_TEXT	SEGMENT
_toPlayer$ = -64					; size = 4
_fromPlayer$ = -60					; size = 4
tv1236 = -56						; size = 4
tv1232 = -52						; size = 4
tv1251 = -48						; size = 4
tv1239 = -44						; size = 4
_oldDealItemIter$ = -40					; size = 8
_newDealItemIter$223291 = -32				; size = 8
$T233797 = -24						; size = 8
$T233794 = -16						; size = 8
$T233792 = -16						; size = 8
$T233795 = -8						; size = 8
_pOldDeal$ = 8						; size = 4
_pNewDeal$ = 12						; size = 4
?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z PROC ; CvGameDeals::PrepareRenewDeal, COMDAT

; 3466 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 68					; 00000044H

; 3467 : 	// Cancel individual items
; 3468 : 	// HACK HACK HACK
; 3469 : 	// bad slewis! bad! bad!!
; 3470 : 	CvDeal* pNonConstNewDeal = (CvDeal*)pNewDeal;
; 3471 : 	// end HACK HACK HACK
; 3472 : 
; 3473 : 	CvAssertMsg(pOldDeal->m_eFromPlayer == pNewDeal->m_eFromPlayer, "Deal is not to the same from players");
; 3474 : 	CvAssertMsg(pOldDeal->m_eToPlayer == pNewDeal->m_eToPlayer, "Deal is not to the same to players");
; 3475 : 
; 3476 : 	CvPlayerAI& fromPlayer = GET_PLAYER(pOldDeal->m_eFromPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	esi
	mov	esi, DWORD PTR _pOldDeal$[ebp]
	mov	eax, DWORD PTR [esi+4]
	imul	eax, 63236				; 0000f704H
	add	eax, ecx
	mov	DWORD PTR _fromPlayer$[esp+76], eax

; 3477 : 	CvPlayerAI& toPlayer = GET_PLAYER(pOldDeal->m_eToPlayer);

	mov	eax, DWORD PTR [esi+8]
	imul	eax, 63236				; 0000f704H
	add	eax, ecx
	mov	DWORD PTR _toPlayer$[esp+76], eax
	push	edi

; 3478 : 
; 3479 : 	TradedItemList::iterator oldDealItemIter;
; 3480 : 	for(oldDealItemIter = pOldDeal->m_TradedItems.begin(); oldDealItemIter != pOldDeal->m_TradedItems.end(); ++oldDealItemIter)

	lea	eax, DWORD PTR $T233792[esp+80]
	add	esi, 44					; 0000002cH
	push	eax
	mov	ecx, esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T233794[esp+80]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _oldDealItemIter$[esp+84], ebx
	mov	DWORD PTR _oldDealItemIter$[esp+88], edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	$LN17@PrepareRen
$LN34@PrepareRen:

; 3481 : 	{
; 3482 : 		// if this is not a renewable item, ignore
; 3483 : 		if(CvDeal::GetItemTradeableState(oldDealItemIter->m_eItemType) != CvDeal::DEAL_RENEWABLE)

	mov	edi, DWORD PTR _oldDealItemIter$[esp+84]
	mov	edx, DWORD PTR [ebx+8]
	imul	edi, 44					; 0000002cH
	lea	eax, DWORD PTR [edx+edi]
	mov	DWORD PTR tv1236[esp+80], eax
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR tv1232[esp+80], edi
	mov	DWORD PTR tv1239[esp+80], eax
	cmp	eax, 19					; 00000013H
	ja	$LN18@PrepareRen
	movzx	eax, BYTE PTR $LN300@PrepareRen[eax]
	jmp	DWORD PTR $LN310@PrepareRen[eax*4]
$LN298@PrepareRen:

; 3484 : 		{
; 3485 : 			continue;
; 3486 : 		}
; 3487 : 
; 3488 : 		TradedItemList::iterator newDealItemIter;
; 3489 : 		for(newDealItemIter = pNonConstNewDeal->m_TradedItems.begin(); newDealItemIter != pNonConstNewDeal->m_TradedItems.end(); ++newDealItemIter)

	mov	ebx, DWORD PTR _pNewDeal$[ebp]
	lea	ecx, DWORD PTR $T233795[esp+80]
	add	ebx, 44					; 0000002cH
	push	ecx
	mov	ecx, ebx
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T233797[esp+80]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _newDealItemIter$223291[esp+84], edx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	$LN18@PrepareRen

; 3534 : 					}
; 3535 : 				}
; 3536 : 			}
; 3537 : 
; 3538 : 			if(oldDealItemIter->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	mov	ecx, DWORD PTR _newDealItemIter$223291[esp+80]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv1251[esp+80], edx
$LN73@PrepareRen:
	mov	ecx, DWORD PTR tv1251[esp+80]
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, 19					; 00000013H
	ja	SHORT $LN14@PrepareRen

; 3490 : 		{
; 3491 : 			// if this is not a renewable item, ignore
; 3492 : 			if(CvDeal::GetItemTradeableState(newDealItemIter->m_eItemType) != CvDeal::DEAL_RENEWABLE)

	movzx	edx, BYTE PTR $LN301@PrepareRen[ecx]
	jmp	DWORD PTR $LN311@PrepareRen[edx*4]
$LN299@PrepareRen:

; 3493 : 			{
; 3494 : 				continue;
; 3495 : 			}
; 3496 : 
; 3497 : 			// if the from player doesn't match, ignore
; 3498 : 			if(oldDealItemIter->m_eFromPlayer != newDealItemIter->m_eFromPlayer)

	mov	edx, DWORD PTR tv1236[esp+80]
	mov	edx, DWORD PTR [edx+36]
	cmp	edx, DWORD PTR [eax+36]
	jne	SHORT $LN14@PrepareRen

; 3499 : 			{
; 3500 : 				continue;
; 3501 : 			}
; 3502 : 
; 3503 : 			// if the item types don't match, ignore
; 3504 : 			if(oldDealItemIter->m_eItemType != newDealItemIter->m_eItemType)

	mov	edx, DWORD PTR tv1239[esp+80]
	cmp	edx, ecx
	jne	SHORT $LN14@PrepareRen

; 3505 : 			{
; 3506 : 				continue;
; 3507 : 			}
; 3508 : 
; 3509 : 			TradeableItems eItemType = oldDealItemIter->m_eItemType;
; 3510 : 
; 3511 : 			if(eItemType == TRADE_ITEM_RESOURCES)

	cmp	edx, 3
	jne	$LN5@PrepareRen

; 3512 : 			{
; 3513 : 				// resource type
; 3514 : 				if(oldDealItemIter->m_iData1 != newDealItemIter->m_iData1)

	mov	ecx, DWORD PTR tv1236[esp+80]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	je	SHORT $LN8@PrepareRen
$LN14@PrepareRen:

; 3484 : 		{
; 3485 : 			continue;
; 3486 : 		}
; 3487 : 
; 3488 : 		TradedItemList::iterator newDealItemIter;
; 3489 : 		for(newDealItemIter = pNonConstNewDeal->m_TradedItems.begin(); newDealItemIter != pNonConstNewDeal->m_TradedItems.end(); ++newDealItemIter)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN74@PrepareRen
	mov	eax, DWORD PTR _newDealItemIter$223291[esp+80]
	mov	esi, DWORD PTR [eax+24]
	jmp	SHORT $LN296@PrepareRen
$LN74@PrepareRen:
	mov	esi, DWORD PTR [eax]
$LN296@PrepareRen:
	lea	ecx, DWORD PTR $T233797[esp+80]
	push	ecx
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LN73@PrepareRen
	jmp	$LN18@PrepareRen
$LN8@PrepareRen:

; 3515 : 				{
; 3516 : 					continue;
; 3517 : 				}
; 3518 : 
; 3519 : 				ResourceTypes eResource = (ResourceTypes)oldDealItemIter->m_iData1;

	mov	edx, DWORD PTR _oldDealItemIter$[esp+80]
	mov	eax, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [eax+edi+20]

; 3520 : 
; 3521 : 				// quantity
; 3522 : 				if(oldDealItemIter->m_iData2 != newDealItemIter->m_iData2)

	mov	edx, esi
	imul	edx, 44					; 0000002cH
	lea	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR _newDealItemIter$223291[esp+80]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx+eax+24]
	cmp	DWORD PTR [ecx+24], eax
	je	SHORT $LN5@PrepareRen

; 3523 : 				{
; 3524 : 					int iResourceDelta = newDealItemIter->m_iData2 - oldDealItemIter->m_iData2;

	mov	ecx, DWORD PTR _oldDealItemIter$[esp+80]
	mov	edx, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+edi+24]
	lea	ecx, DWORD PTR [edx+edi]
	mov	edi, eax

; 3525 : 					if(oldDealItemIter->m_eFromPlayer == pOldDeal->m_eFromPlayer)

	mov	eax, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _pOldDeal$[ebp]

; 3526 : 					{
; 3527 : 						fromPlayer.changeResourceExport(eResource, iResourceDelta);

	push	edi
	push	ebx
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN6@PrepareRen
	mov	ecx, DWORD PTR _fromPlayer$[esp+88]
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 3528 : 						toPlayer.changeResourceImport(eResource, iResourceDelta);

	mov	ecx, DWORD PTR _toPlayer$[esp+80]

; 3529 : 					}
; 3530 : 					else

	jmp	SHORT $LN308@PrepareRen
$LN6@PrepareRen:

; 3531 : 					{
; 3532 : 						toPlayer.changeResourceExport(eResource, iResourceDelta);

	mov	ecx, DWORD PTR _toPlayer$[esp+88]
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 3533 : 						fromPlayer.changeResourceImport(eResource, iResourceDelta);

	mov	ecx, DWORD PTR _fromPlayer$[esp+80]
$LN308@PrepareRen:
	push	edi
	push	ebx
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport
	mov	edi, DWORD PTR tv1232[esp+80]
$LN5@PrepareRen:

; 3534 : 					}
; 3535 : 				}
; 3536 : 			}
; 3537 : 
; 3538 : 			if(oldDealItemIter->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	mov	edx, DWORD PTR _oldDealItemIter$[esp+80]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+edi+8], 1
	lea	ecx, DWORD PTR [eax+edi]
	jne	SHORT $LN1@PrepareRen

; 3539 : 			{
; 3540 : 				int iOldGPTAmount = oldDealItemIter->m_iData1;
; 3541 : 				int iNewGPTAmount = newDealItemIter->m_iData1;

	mov	ebx, DWORD PTR _newDealItemIter$223291[esp+80]
	mov	ebx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	mov	eax, DWORD PTR [eax+ebx+20]

; 3542 : 
; 3543 : 				// has the amount of gold amount changed?
; 3544 : 				if(iOldGPTAmount != iNewGPTAmount)

	cmp	edx, eax
	je	SHORT $LN1@PrepareRen

; 3545 : 				{
; 3546 : 					int iGoldPerTurnDelta = iNewGPTAmount - iOldGPTAmount;
; 3547 : 					if(oldDealItemIter->m_eFromPlayer == pOldDeal->m_eFromPlayer)

	mov	ecx, DWORD PTR [ecx+36]
	sub	eax, edx
	mov	edx, DWORD PTR _pOldDeal$[ebp]
	mov	ebx, eax
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN2@PrepareRen

; 3548 : 					{
; 3549 : 						fromPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurnDelta);

	mov	ecx, DWORD PTR _fromPlayer$[esp+80]
	neg	eax
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3550 : 						toPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurnDelta);

	mov	ecx, DWORD PTR _toPlayer$[esp+80]

; 3551 : 					}
; 3552 : 					else

	jmp	SHORT $LN309@PrepareRen
$LN2@PrepareRen:

; 3553 : 					{
; 3554 : 						toPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurnDelta);

	mov	ecx, ebx
	neg	ecx
	push	ecx
	mov	ecx, DWORD PTR _toPlayer$[esp+84]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3555 : 						fromPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurnDelta);

	mov	ecx, DWORD PTR _fromPlayer$[esp+80]
$LN309@PrepareRen:
	push	ebx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
$LN1@PrepareRen:

; 3556 : 					}
; 3557 : 				}
; 3558 : 			}
; 3559 : 
; 3560 : 			// mark the deals as appropriately renewed
; 3561 : 			newDealItemIter->m_bToRenewed = true;

	mov	edx, DWORD PTR _newDealItemIter$223291[esp+80]
	imul	esi, 44					; 0000002cH
	mov	eax, DWORD PTR [edx+8]

; 3562 : 			oldDealItemIter->m_bFromRenewed = true;

	mov	ecx, DWORD PTR _oldDealItemIter$[esp+80]
	mov	BYTE PTR [esi+eax+41], 1
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+edi+40], 1
$LN18@PrepareRen:
	cmp	DWORD PTR _oldDealItemIter$[esp+84], 268435455 ; 0fffffffH
	mov	ebx, DWORD PTR _oldDealItemIter$[esp+80]
	jne	SHORT $LN35@PrepareRen
	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR _oldDealItemIter$[esp+84], eax
	jmp	SHORT $LN297@PrepareRen

; 3478 : 
; 3479 : 	TradedItemList::iterator oldDealItemIter;
; 3480 : 	for(oldDealItemIter = pOldDeal->m_TradedItems.begin(); oldDealItemIter != pOldDeal->m_TradedItems.end(); ++oldDealItemIter)

$LN35@PrepareRen:
	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [edi+ecx]
	mov	DWORD PTR _oldDealItemIter$[esp+84], edx
$LN297@PrepareRen:
	mov	ecx, DWORD PTR _pOldDeal$[ebp]
	lea	eax, DWORD PTR $T233794[esp+80]
	push	eax
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	ecx, DWORD PTR _oldDealItemIter$[esp+84]
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LN34@PrepareRen
$LN17@PrepareRen:

; 3563 : 
; 3564 : 			// break because we found the match and can continue on
; 3565 : 			break;
; 3566 : 		}
; 3567 : 	}
; 3568 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN310@PrepareRen:
	DD	$LN18@PrepareRen
	DD	$LN298@PrepareRen
	DD	$LN18@PrepareRen
$LN300@PrepareRen:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	2
	DB	0
$LN311@PrepareRen:
	DD	$LN14@PrepareRen
	DD	$LN299@PrepareRen
	DD	$LN14@PrepareRen
$LN301@PrepareRen:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	2
	DB	0
?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z ENDP ; CvGameDeals::PrepareRenewDeal
_TEXT	ENDS
PUBLIC	?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z	; CvGameDeals::LogDealComplete
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$9
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$12
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$14
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$16
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$17
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
_TEXT	SEGMENT
_itemIter$223338 = -256					; size = 8
_strTemp$223327 = -248					; size = 28
$T234621 = -220						; size = 28
$T234620 = -220						; size = 28
$T234618 = -220						; size = 28
$T234616 = -220						; size = 28
$T234614 = -220						; size = 28
$T234613 = -220						; size = 28
$T234612 = -220						; size = 28
$T234605 = -220						; size = 28
_playerName$223325 = -192				; size = 28
_pLog$223335 = -164					; size = 4
$T234609 = -160						; size = 8
$T234607 = -160						; size = 8
_strOutBuf$223323 = -152				; size = 28
$T234619 = -124						; size = 28
$T234617 = -124						; size = 28
$T234615 = -124						; size = 28
$T234606 = -124						; size = 28
_strBaseString$223324 = -96				; size = 28
_strLogName$223322 = -68				; size = 28
_otherPlayerName$223326 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z PROC	; CvGameDeals::LogDealComplete, COMDAT
; _this$ = ecx

; 3572 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 244				; 000000f4H

; 3573 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN38@LogDealCom
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN38@LogDealCom
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3574 : 	{
; 3575 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$223322[esp+272]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3576 : 
; 3577 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$223323[esp+272]
	mov	DWORD PTR __$EHRec$[esp+280], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3578 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$223324[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3579 : 
; 3580 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$223325[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3581 : 		CvString otherPlayerName;

	lea	ecx, DWORD PTR _otherPlayerName$223326[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3582 : 
; 3583 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223327[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3584 : 
; 3585 : 		// Open the log file
; 3586 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	test	al, al
	je	SHORT $LN37@LogDealCom

; 3587 : 		{
; 3588 : 			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$223325[esp+272]
	push	eax
	lea	ecx, DWORD PTR $T234605[esp+276]
	push	OFFSET $SG223332
	push	ecx
	call	edi
	push	OFFSET $SG223331
	push	eax
	lea	edx, DWORD PTR $T234606[esp+292]
	mov	bl, 6
	push	edx
	mov	BYTE PTR __$EHRec$[esp+304], bl
	call	ebp
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+280], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$223322[esp+276]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234606[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234605[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3589 : 		}
; 3590 : 		else

	jmp	SHORT $LN81@LogDealCom
$LN37@LogDealCom:

; 3591 : 		{
; 3592 : 			strLogName = "DiplomacyAI_Messages_Log.csv";

	push	OFFSET $SG223334
	lea	ecx, DWORD PTR _strLogName$223322[esp+276]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN81@LogDealCom:

; 3593 : 		}
; 3594 : 
; 3595 : 		FILogFile* pLog;
; 3596 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$223322[esp+272]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 3597 : 
; 3598 : 		PlayerTypes eFromPlayer;
; 3599 : 		PlayerTypes eToPlayer;
; 3600 : 
; 3601 : 		TradedItemList::iterator itemIter;
; 3602 : 		for(itemIter = pDeal->m_TradedItems.begin(); itemIter != pDeal->m_TradedItems.end(); ++itemIter)

	mov	esi, DWORD PTR _pDeal$[esp+268]
	lea	ecx, DWORD PTR $T234607[esp+272]
	add	esi, 44					; 0000002cH
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _pLog$223335[esp+276], eax
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T234609[esp+272]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _itemIter$223338[esp+276], edx
	mov	DWORD PTR _itemIter$223338[esp+280], ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	setne	al
	test	al, al
	je	$LN33@LogDealCom
	jmp	SHORT $LN95@LogDealCom
	npad	1
$LL274@LogDealCom:
	mov	ebx, DWORD PTR _itemIter$223338[esp+276]
$LN95@LogDealCom:

; 3603 : 		{
; 3604 : 			// Turn number
; 3605 : 			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223324[esp+276]
	push	OFFSET $SG223345
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3606 : 
; 3607 : 			eFromPlayer = itemIter->m_eFromPlayer;

	imul	ebx, 44					; 0000002cH
	mov	edx, DWORD PTR _itemIter$223338[esp+284]
	mov	eax, DWORD PTR [edx+8]

; 3608 : 			eToPlayer = eFromPlayer == pDeal->m_eFromPlayer ? pDeal->m_eToPlayer : pDeal->m_eFromPlayer;

	mov	ecx, DWORD PTR _pDeal$[esp+280]
	mov	eax, DWORD PTR [ebx+eax+36]
	mov	esi, DWORD PTR [ecx+4]
	add	esp, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LN41@LogDealCom
	mov	edx, ecx
	mov	esi, DWORD PTR [edx+8]
$LN41@LogDealCom:

; 3609 : 
; 3610 : 			playerName = GET_PLAYER(eFromPlayer).getCivilizationShortDescription();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$223325[esp+272]
	test	eax, eax
	je	SHORT $LN124@LogDealCom
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN123@LogDealCom
$LN124@LogDealCom:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN123@LogDealCom:

; 3611 : 
; 3612 : 			// Our Name
; 3613 : 			strBaseString += playerName;

	lea	eax, DWORD PTR _playerName$223325[esp+272]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223324[esp+276]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3614 : 
; 3615 : 			// Their Name
; 3616 : 			otherPlayerName = GET_PLAYER(eToPlayer).getCivilizationShortDescription();

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, esi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _otherPlayerName$223326[esp+272]
	test	eax, eax
	je	SHORT $LN130@LogDealCom
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN129@LogDealCom
$LN130@LogDealCom:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN129@LogDealCom:

; 3617 : 			strBaseString += ", " + otherPlayerName;

	lea	ecx, DWORD PTR _otherPlayerName$223326[esp+272]
	push	ecx
	lea	edx, DWORD PTR $T234612[esp+276]
	push	OFFSET $SG223347
	push	edx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223324[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234612[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3618 : 
; 3619 : 			strOutBuf = strBaseString + ", , ";

	push	OFFSET $SG223349
	lea	eax, DWORD PTR _strBaseString$223324[esp+276]
	push	eax
	lea	ecx, DWORD PTR $T234613[esp+280]
	push	ecx
	call	ebp
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+280], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234613[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3620 : 
; 3621 : 			// Peace Treaty deal?
; 3622 : 			if(pDeal->GetPeaceTreatyType() != NO_PEACE_TREATY_TYPE)

	mov	esi, DWORD PTR _pDeal$[esp+268]
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, -1
	je	$LN32@LogDealCom

; 3623 : 			{
; 3624 : 				switch(pDeal->GetPeaceTreatyType())

	cmp	eax, 8
	ja	SHORT $LN20@LogDealCom
	jmp	DWORD PTR $LN280@LogDealCom[eax*4]
$LN29@LogDealCom:

; 3625 : 				{
; 3626 : 				case PEACE_TREATY_WHITE_PEACE:
; 3627 : 					strTemp.Format("***** WHITE PEACE *****");

	push	OFFSET $SG223356

; 3628 : 					break;

	jmp	SHORT $LN276@LogDealCom
$LN28@LogDealCom:

; 3629 : 				case PEACE_TREATY_ARMISTICE:
; 3630 : 					strTemp.Format("***** ARMISTICE *****");

	push	OFFSET $SG223358
	lea	eax, DWORD PTR _strTemp$223327[esp+276]
	push	eax

; 3631 : 					break;

	jmp	SHORT $LN277@LogDealCom
$LN27@LogDealCom:

; 3632 : 				case PEACE_TREATY_SETTLEMENT:
; 3633 : 					strTemp.Format("***** SETTLEMENT *****");

	push	OFFSET $SG223360
	lea	ecx, DWORD PTR _strTemp$223327[esp+276]
	push	ecx

; 3634 : 					break;

	jmp	SHORT $LN277@LogDealCom
$LN26@LogDealCom:

; 3635 : 				case PEACE_TREATY_BACKDOWN:
; 3636 : 					strTemp.Format("***** BACKDOWN *****");

	push	OFFSET $SG223362

; 3637 : 					break;

	jmp	SHORT $LN276@LogDealCom
$LN25@LogDealCom:

; 3638 : 				case PEACE_TREATY_SUBMISSION:
; 3639 : 					strTemp.Format("***** SUBMISSION *****");

	push	OFFSET $SG223364
	lea	eax, DWORD PTR _strTemp$223327[esp+276]
	push	eax

; 3640 : 					break;

	jmp	SHORT $LN277@LogDealCom
$LN24@LogDealCom:

; 3641 : 				case PEACE_TREATY_SURRENDER:
; 3642 : 					strTemp.Format("***** SURRENDER *****");

	push	OFFSET $SG223366
	lea	ecx, DWORD PTR _strTemp$223327[esp+276]
	push	ecx

; 3643 : 					break;

	jmp	SHORT $LN277@LogDealCom
$LN23@LogDealCom:

; 3644 : 				case PEACE_TREATY_CESSION:
; 3645 : 					strTemp.Format("***** CESSION *****");

	push	OFFSET $SG223368

; 3646 : 					break;

	jmp	SHORT $LN276@LogDealCom
$LN22@LogDealCom:

; 3647 : 				case PEACE_TREATY_CAPITULATION:
; 3648 : 					strTemp.Format("***** CAPITULATION *****");

	push	OFFSET $SG223370
	lea	eax, DWORD PTR _strTemp$223327[esp+276]
	push	eax

; 3649 : 					break;

	jmp	SHORT $LN277@LogDealCom
$LN21@LogDealCom:

; 3650 : 				case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
; 3651 : 					strTemp.Format("***** UNCONDITIONAL SURRENDER *****");

	push	OFFSET $SG223372
	lea	ecx, DWORD PTR _strTemp$223327[esp+276]
	push	ecx

; 3652 : 					break;

	jmp	SHORT $LN277@LogDealCom
$LN20@LogDealCom:

; 3653 : 				default:
; 3654 : 					strTemp.Format("XXX NO VALID PEACE TREATY!!!");

	push	OFFSET $SG223374
$LN276@LogDealCom:
	lea	edx, DWORD PTR _strTemp$223327[esp+276]
	push	edx
$LN277@LogDealCom:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3655 : 					break;
; 3656 : 				}
; 3657 : 				strOutBuf += ", " + strTemp;

	lea	eax, DWORD PTR _strTemp$223327[esp+272]
	push	eax
	lea	ecx, DWORD PTR $T234614[esp+276]
	push	OFFSET $SG223376
	push	ecx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234614[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN32@LogDealCom:

; 3658 : 			}
; 3659 : 
; 3660 : 			// Is someone surrendering?
; 3661 : 			if(pDeal->GetSurrenderingPlayer() != NO_PLAYER)

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, -1
	je	$LN19@LogDealCom

; 3662 : 			{
; 3663 : 				playerName = GET_PLAYER(pDeal->GetSurrenderingPlayer()).getCivilizationShortDescription();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$223325[esp+272]
	test	eax, eax
	je	SHORT $LN146@LogDealCom
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN145@LogDealCom
$LN146@LogDealCom:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN145@LogDealCom:

; 3664 : 				strOutBuf += ", " + playerName + " is giving up!";

	lea	edx, DWORD PTR _playerName$223325[esp+272]
	push	edx
	lea	eax, DWORD PTR $T234615[esp+276]
	push	OFFSET $SG223381
	push	eax
	call	edi
	push	OFFSET $SG223380
	push	eax
	lea	ecx, DWORD PTR $T234616[esp+292]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+304], 11		; 0000000bH
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], 12		; 0000000cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234616[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234615[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN17@LogDealCom
$LN19@LogDealCom:

; 3665 : 			}
; 3666 : 			// White Peace
; 3667 : 			else if(pDeal->GetPeaceTreatyType() == PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN17@LogDealCom

; 3668 : 			{
; 3669 : 				strOutBuf += ", White Peace!";

	push	OFFSET $SG223384
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN17@LogDealCom:

; 3670 : 			}
; 3671 : 
; 3672 : 			// Is this a demand?
; 3673 : 			if(pDeal->GetDemandingPlayer() != NO_PLAYER)

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, -1
	je	$LN16@LogDealCom

; 3674 : 			{
; 3675 : 				playerName = GET_PLAYER(pDeal->GetDemandingPlayer()).getCivilizationShortDescription();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$223325[esp+272]
	test	eax, eax
	je	SHORT $LN158@LogDealCom
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN157@LogDealCom
$LN158@LogDealCom:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN157@LogDealCom:

; 3676 : 				strOutBuf += ", " + playerName + " has made a demand!";

	lea	edx, DWORD PTR _playerName$223325[esp+272]
	push	edx
	lea	eax, DWORD PTR $T234617[esp+276]
	push	OFFSET $SG223389
	push	eax
	call	edi
	push	OFFSET $SG223388
	push	eax
	lea	ecx, DWORD PTR $T234618[esp+292]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+304], 13		; 0000000dH
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], 14		; 0000000eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234618[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234617[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@LogDealCom:

; 3677 : 			}
; 3678 : 
; 3679 : 			// Is this a request?
; 3680 : 			if(pDeal->GetRequestingPlayer() != NO_PLAYER)

	mov	eax, DWORD PTR [esi+36]
	cmp	eax, -1
	je	$LN15@LogDealCom

; 3681 : 			{
; 3682 : 				playerName = GET_PLAYER(pDeal->GetRequestingPlayer()).getCivilizationShortDescription();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$223325[esp+272]
	test	eax, eax
	je	SHORT $LN168@LogDealCom
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN167@LogDealCom
$LN168@LogDealCom:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN167@LogDealCom:

; 3683 : 				strOutBuf += ", " + playerName + " has made a request!";

	lea	edx, DWORD PTR _playerName$223325[esp+272]
	push	edx
	lea	eax, DWORD PTR $T234619[esp+276]
	push	OFFSET $SG223394
	push	eax
	call	edi
	push	OFFSET $SG223393
	push	eax
	lea	ecx, DWORD PTR $T234620[esp+292]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+304], 15		; 0000000fH
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], 16		; 00000010H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234620[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234619[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN15@LogDealCom:

; 3684 : 			}
; 3685 : 
; 3686 : 			// What is this particular Trade item?
; 3687 : 			switch(itemIter->m_eItemType)

	mov	esi, DWORD PTR _itemIter$223338[esp+272]
	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ebx+edx+8]
	lea	eax, DWORD PTR [ebx+edx]
	cmp	ecx, 19					; 00000013H
	ja	$LN1@LogDealCom
	movzx	ecx, BYTE PTR $LN273@LogDealCom[ecx]
	jmp	DWORD PTR $LN281@LogDealCom[ecx*4]
$LN12@LogDealCom:

; 3688 : 			{
; 3689 : 			case TRADE_ITEM_GOLD:
; 3690 : 				strTemp.Format("***** Gold Trade: %d *****", itemIter->m_iData1);

	mov	edx, DWORD PTR [eax+20]
	push	edx
	lea	eax, DWORD PTR _strTemp$223327[esp+276]
	push	OFFSET $SG223400
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3691 : 				break;

	jmp	$LN13@LogDealCom
$LN11@LogDealCom:

; 3692 : 			case TRADE_ITEM_GOLD_PER_TURN:
; 3693 : 				strTemp.Format("***** GPT Trade: %d *****", itemIter->m_iData1);

	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	lea	edx, DWORD PTR _strTemp$223327[esp+276]
	push	OFFSET $SG223402
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3694 : 				break;

	jmp	$LN13@LogDealCom
$LN10@LogDealCom:

; 3695 : 			case TRADE_ITEM_RESOURCES:
; 3696 : 				strTemp.Format("***** Resource Trade: ID %d *****", itemIter->m_iData1);

	mov	eax, DWORD PTR [eax+20]
	push	eax
	lea	ecx, DWORD PTR _strTemp$223327[esp+276]
	push	OFFSET $SG223404
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3697 : 				break;

	jmp	$LN13@LogDealCom
$LN9@LogDealCom:

; 3698 : 			case TRADE_ITEM_CITIES:
; 3699 : 				strTemp.Format("***** City Trade: ID %d %d *****", itemIter->m_iData1, itemIter->m_iData2);

	mov	ecx, DWORD PTR [ebx+edx+24]
	lea	eax, DWORD PTR [ebx+edx]
	mov	edx, DWORD PTR [eax+20]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$223327[esp+280]
	push	OFFSET $SG223406
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3700 : 				break;

	jmp	SHORT $LN13@LogDealCom
$LN8@LogDealCom:

; 3701 : 			case TRADE_ITEM_OPEN_BORDERS:
; 3702 : 				strTemp.Format("Open Borders Trade");

	push	OFFSET $SG223408
	lea	ecx, DWORD PTR _strTemp$223327[esp+276]
	push	ecx

; 3703 : 				break;

	jmp	SHORT $LN278@LogDealCom
$LN7@LogDealCom:

; 3704 : 			case TRADE_ITEM_DEFENSIVE_PACT:
; 3705 : 				strTemp.Format("***** Defensive Pact Trade *****");

	push	OFFSET $SG223410

; 3706 : 				break;

	jmp	SHORT $LN279@LogDealCom
$LN6@LogDealCom:

; 3707 : 			case TRADE_ITEM_RESEARCH_AGREEMENT:
; 3708 : 				strTemp.Format("Research Agreement Trade");

	push	OFFSET $SG223412
	lea	eax, DWORD PTR _strTemp$223327[esp+276]
	push	eax

; 3709 : 				break;

	jmp	SHORT $LN278@LogDealCom
$LN5@LogDealCom:

; 3710 : 			case TRADE_ITEM_PEACE_TREATY:
; 3711 : 				strTemp.Format("***** Peace Treaty Trade *****");

	push	OFFSET $SG223414
	lea	ecx, DWORD PTR _strTemp$223327[esp+276]
	push	ecx

; 3712 : 				break;

	jmp	SHORT $LN278@LogDealCom
$LN4@LogDealCom:

; 3713 : 			case TRADE_ITEM_THIRD_PARTY_PEACE:
; 3714 : 				strTemp.Format("***** Third Party Peace Trade *****");

	push	OFFSET $SG223416

; 3715 : 				break;

	jmp	SHORT $LN279@LogDealCom
$LN3@LogDealCom:

; 3716 : 			case TRADE_ITEM_THIRD_PARTY_WAR:
; 3717 : 				strTemp.Format("***** Third Party War Trade *****");

	push	OFFSET $SG223418
	lea	eax, DWORD PTR _strTemp$223327[esp+276]
	push	eax

; 3718 : 				break;

	jmp	SHORT $LN278@LogDealCom
$LN2@LogDealCom:

; 3719 : 			case TRADE_ITEM_VOTE_COMMITMENT:
; 3720 : 				strTemp.Format("***** Vote Commitment: ID %d, Choice %d *****", itemIter->m_iData1, itemIter->m_iData2);

	mov	ecx, edx
	mov	edx, DWORD PTR [ebx+ecx+24]
	lea	eax, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [eax+20]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strTemp$223327[esp+280]
	push	OFFSET $SG223420
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3721 : 				break;

	jmp	SHORT $LN13@LogDealCom
$LN1@LogDealCom:

; 3722 : 			default:
; 3723 : 				strTemp.Format("***** UNKNOWN TRADE!!! *****");

	push	OFFSET $SG223422
$LN279@LogDealCom:
	lea	edx, DWORD PTR _strTemp$223327[esp+276]
	push	edx
$LN278@LogDealCom:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8
$LN13@LogDealCom:

; 3724 : 				break;
; 3725 : 			}
; 3726 : 			strOutBuf += ", " + strTemp;

	lea	eax, DWORD PTR _strTemp$223327[esp+272]
	push	eax
	lea	ecx, DWORD PTR $T234621[esp+276]
	push	OFFSET $SG223424
	push	ecx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], 17		; 00000011H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234621[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3727 : 
; 3728 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$223323[esp+272]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$223335[esp+272]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	add	esp, 8
	cmp	DWORD PTR _itemIter$223338[esp+276], 268435455 ; 0fffffffH
	jne	SHORT $LN96@LogDealCom
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR _itemIter$223338[esp+276], ecx
	jmp	SHORT $LN272@LogDealCom

; 3597 : 
; 3598 : 		PlayerTypes eFromPlayer;
; 3599 : 		PlayerTypes eToPlayer;
; 3600 : 
; 3601 : 		TradedItemList::iterator itemIter;
; 3602 : 		for(itemIter = pDeal->m_TradedItems.begin(); itemIter != pDeal->m_TradedItems.end(); ++itemIter)

$LN96@LogDealCom:
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ebx+edx]
	mov	DWORD PTR _itemIter$223338[esp+276], eax
$LN272@LogDealCom:
	lea	ecx, DWORD PTR $T234609[esp+272]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[esp+272]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	edx, DWORD PTR _itemIter$223338[esp+276]
	cmp	edx, DWORD PTR [eax+4]
	setne	al
	test	al, al
	jne	$LL274@LogDealCom
$LN33@LogDealCom:

; 3729 : 
; 3730 : 			OutputDebugString("\n");
; 3731 : 			OutputDebugString(strOutBuf);
; 3732 : 			OutputDebugString("\n");
; 3733 : 		}
; 3734 : 	}

	lea	ecx, DWORD PTR _strTemp$223327[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _otherPlayerName$223326[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$223325[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$223324[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$223323[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogName$223322[esp+272]
	mov	DWORD PTR __$EHRec$[esp+280], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN38@LogDealCom:

; 3735 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+256]
	mov	DWORD PTR fs:0, ecx
	add	esp, 256				; 00000100H
	ret	4
$LN280@LogDealCom:
	DD	$LN29@LogDealCom
	DD	$LN28@LogDealCom
	DD	$LN27@LogDealCom
	DD	$LN26@LogDealCom
	DD	$LN25@LogDealCom
	DD	$LN24@LogDealCom
	DD	$LN23@LogDealCom
	DD	$LN22@LogDealCom
	DD	$LN21@LogDealCom
$LN281@LogDealCom:
	DD	$LN12@LogDealCom
	DD	$LN11@LogDealCom
	DD	$LN10@LogDealCom
	DD	$LN9@LogDealCom
	DD	$LN8@LogDealCom
	DD	$LN7@LogDealCom
	DD	$LN6@LogDealCom
	DD	$LN5@LogDealCom
	DD	$LN4@LogDealCom
	DD	$LN3@LogDealCom
	DD	$LN2@LogDealCom
	DD	$LN1@LogDealCom
$LN273@LogDealCom:
	DB	0
	DB	1
	DB	11					; 0000000bH
	DB	2
	DB	3
	DB	11					; 0000000bH
	DB	4
	DB	5
	DB	6
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	7
	DB	8
	DB	9
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _strLogName$223322[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$223323[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$2:
	lea	ecx, DWORD PTR _strBaseString$223324[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$3:
	lea	ecx, DWORD PTR _playerName$223325[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$4:
	lea	ecx, DWORD PTR _otherPlayerName$223326[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$5:
	lea	ecx, DWORD PTR _strTemp$223327[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$6:
	lea	ecx, DWORD PTR $T234605[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$7:
	lea	ecx, DWORD PTR $T234606[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$8:
	lea	ecx, DWORD PTR $T234612[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$9:
	lea	ecx, DWORD PTR $T234613[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$10:
	lea	ecx, DWORD PTR $T234614[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$11:
	lea	ecx, DWORD PTR $T234615[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$12:
	lea	ecx, DWORD PTR $T234616[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$13:
	lea	ecx, DWORD PTR $T234617[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$14:
	lea	ecx, DWORD PTR $T234618[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$15:
	lea	ecx, DWORD PTR $T234619[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$16:
	lea	ecx, DWORD PTR $T234620[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$17:
	lea	ecx, DWORD PTR $T234621[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z ENDP	; CvGameDeals::LogDealComplete
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T235155 = 8						; size = 4
$T235154 = 8						; size = 4
$T235153 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z PROC	; operator<<, COMDAT

; 3985 : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 3986 : 	uint uiVersion = 1;
; 3987 : 	DealList::const_iterator it;
; 3988 : 	saveTo << uiVersion;

	mov	edi, DWORD PTR _saveTo$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3989 : 
; 3990 : 	saveTo << readFrom.m_ProposedDeals.size();

	mov	esi, DWORD PTR _readFrom$[esp+12]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T235153[esp+12]
	mov	DWORD PTR $T235153[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3991 : 	for(it = readFrom.m_ProposedDeals.begin(); it != readFrom.m_ProposedDeals.end(); ++it)

	mov	eax, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+4]
	imul	eax, 76					; 0000004cH
	add	eax, ebx
	cmp	ebx, eax
	je	SHORT $LN7@operator@7
$LL9@operator@7:

; 3992 : 	{
; 3993 : 		saveTo << *it;

	push	ebx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ; operator<<
	mov	ecx, DWORD PTR [esi+8]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi+4]
	add	ebx, 76					; 0000004cH
	add	esp, 8
	cmp	ebx, ecx
	jne	SHORT $LL9@operator@7
$LN7@operator@7:

; 3994 : 	}
; 3995 : 	saveTo << readFrom.m_CurrentDeals.size();

	mov	edx, DWORD PTR [esi+1544]
	lea	eax, DWORD PTR $T235154[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T235154[esp+16], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3996 : 	for(it = readFrom.m_CurrentDeals.begin(); it != readFrom.m_CurrentDeals.end(); ++it)

	mov	ecx, DWORD PTR [esi+1544]
	mov	ebx, DWORD PTR [esi+1540]
	imul	ecx, 76					; 0000004cH
	add	ecx, ebx
	cmp	ebx, ecx
	je	SHORT $LN4@operator@7
$LL6@operator@7:

; 3997 : 	{
; 3998 : 		saveTo << *it;

	push	ebx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ; operator<<
	mov	edx, DWORD PTR [esi+1544]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [esi+1540]
	add	ebx, 76					; 0000004cH
	add	esp, 8
	cmp	ebx, edx
	jne	SHORT $LL6@operator@7
$LN4@operator@7:

; 3999 : 	}
; 4000 : 	saveTo << readFrom.m_HistoricalDeals.size();

	mov	eax, DWORD PTR [esi+3080]
	lea	ecx, DWORD PTR $T235155[esp+12]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T235155[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4001 : 	for(it = readFrom.m_HistoricalDeals.begin(); it != readFrom.m_HistoricalDeals.end(); ++it)

	mov	edx, DWORD PTR [esi+3080]
	mov	ebx, DWORD PTR [esi+3076]
	imul	edx, 76					; 0000004cH
	add	edx, ebx
	cmp	ebx, edx
	je	SHORT $LN44@operator@7
$LL3@operator@7:

; 4002 : 	{
; 4003 : 		saveTo << *it;

	push	ebx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ; operator<<
	mov	eax, DWORD PTR [esi+3080]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [esi+3076]
	add	ebx, 76					; 0000004cH
	add	esp, 8
	cmp	ebx, eax
	jne	SHORT $LL3@operator@7
$LN44@operator@7:

; 4004 : 	}
; 4005 : 
; 4006 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 4007 : 	saveTo << readFrom.m_CurrentlyEndingDeals.size();
; 4008 : 	for (it = readFrom.m_CurrentlyEndingDeals.begin(); it != readFrom.m_CurrentlyEndingDeals.end(); ++it)
; 4009 : 	{
; 4010 : 		saveTo << *it;
; 4011 : 	}
; 4012 : #endif
; 4013 : 
; 4014 : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4015 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+8]
	cmp	eax, esi
	je	SHORT $LN9@erase
	push	edi
$LL11@erase:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL11@erase
	mov	edx, DWORD PTR __Where$[esp+4]
	pop	edi
$LN9@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [ecx+8], -8			; fffffff8H
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
_TEXT	ENDS
PUBLIC	?push_back@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?push_back@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?push_back@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back, COMDAT
; _this$ = ecx

; 489  : 		unsigned int uiNewIndex = get_allocator().Alloc( x );

	mov	eax, DWORD PTR _x$[esp-4]
	push	esi
	push	edi
	push	eax
	mov	esi, ecx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc

; 490  : 		push_back_existing( uiNewIndex );

	inc	DWORD PTR [esi+20]
	cmp	DWORD PTR [esi+24], 268435455		; 0fffffffH
	mov	edi, eax
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+28], edi
	jne	SHORT $LN5@push_back@4
	mov	DWORD PTR [esi+24], edi
$LN5@push_back@4:
	push	eax
	push	edi
	mov	ecx, esi
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter

; 491  : 		return uiNewIndex;

	mov	eax, edi
	pop	edi
	pop	esi

; 492  : 	};

	ret	4
?push_back@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@2
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@2
	push	ebx
	npad	4
$LL28@erase@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	add	edx, 8
	add	esi, 8
	cmp	edx, edi
	jne	SHORT $LL28@erase@2
	pop	ebx
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@2:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
_TEXT	ENDS
PUBLIC	??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ
_TEXT	SEGMENT
??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >, COMDAT
; _this$ = ecx

; 416  : 		: TAIL(), m_uiFirst( ANCHOR_NODE_INDEX ), m_uiLast( ANCHOR_NODE_INDEX ), m_uiSize(0) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	edx, 268435455				; 0fffffffH
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], edx
	mov	DWORD PTR [eax+28], edx
	ret	0
??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAU?$pair@IPAVCvDeal@@@std@@@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@1@PAU21@00@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Umove<std::pair<unsigned int,CvDeal *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAU?$pair@IPAVCvDeal@@@std@@@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@1@PAU21@00@Z
_TEXT	SEGMENT
$T235488 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$235491 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAU?$pair@IPAVCvDeal@@@std@@@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@1@PAU21@00@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Umove<std::pair<unsigned int,CvDeal *> *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$235491[esp]
	mov	BYTE PTR $T235488[esp+4], 0
	mov	eax, DWORD PTR $T235488[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAU?$pair@IPAVCvDeal@@@std@@@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@1@PAU21@00@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Umove<std::pair<unsigned int,CvDeal *> *>
_TEXT	ENDS
PUBLIC	??1?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ ; FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>::~FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ PROC ; FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>::~FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>, COMDAT
; _this$ = ecx
	xor	eax, eax
	mov	DWORD PTR [ecx], 268435455		; 0fffffffH
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ ENDP ; FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>::~FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>
_TEXT	ENDS
PUBLIC	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
EXTRN	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ:PROC ; CvGame::GetGameDeals
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z
_TEXT	SEGMENT
_iGoldAvailable$ = -28					; size = 4
_this$ = -24						; size = 4
$T235849 = -20						; size = 4
_it$ = -16						; size = 8
$T235673 = -8						; size = 8
$T235671 = -8						; size = 8
_ePlayer$ = 8						; size = 4
_eItemToBeChanged$ = 12					; size = 4
?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z PROC ; CvDeal::GetGoldAvailable, COMDAT
; _this$ = ecx

; 298  : {

	sub	esp, 28					; 0000001cH
	push	ebx

; 299  : 	int iGoldAvailable = GET_PLAYER(ePlayer).GetTreasury()->GetGold();

	mov	ebx, DWORD PTR _ePlayer$[esp+28]
	push	ebp
	push	esi
	mov	esi, ecx
	mov	ecx, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	DWORD PTR _this$[esp+44], esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold

; 300  : 
; 301  : 	// Remove Gold we're sending to the other player in this deal (unless we're changing it)
; 302  : 	if(eItemToBeChanged != TRADE_ITEM_GOLD)

	cmp	DWORD PTR _eItemToBeChanged$[esp+40], 0
	mov	edi, eax
	mov	DWORD PTR _iGoldAvailable$[esp+44], eax
	je	SHORT $LN7@GetGoldAva

; 303  : 	{
; 304  : 		iGoldAvailable -= GetGoldTrade(ePlayer);

	push	ebx
	mov	ecx, esi
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	sub	edi, eax
	mov	DWORD PTR _iGoldAvailable$[esp+44], edi
$LN7@GetGoldAva:

; 305  : 	}
; 306  : 
; 307  : 	int iGoldCost;
; 308  : 
; 309  : 	// Loop through all trade items to see if they have a cost
; 310  : 	TradedItemList::iterator it;
; 311  : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T235671[esp+44]
	add	esi, 44					; 0000002cH
	push	eax
	mov	ecx, esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T235673[esp+44]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _it$[esp+48], ebp
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	je	$LN77@GetGoldAva
$LL20@GetGoldAva:

; 312  : 	{
; 313  : 		// Don't count something against itself when trying to add it
; 314  : 		if(it->m_eItemType != eItemToBeChanged)

	mov	edx, DWORD PTR [ebp+8]
	mov	esi, ebx
	imul	esi, 44					; 0000002cH
	mov	edi, DWORD PTR [edx+esi+8]
	lea	eax, DWORD PTR [edx+esi]
	cmp	edi, DWORD PTR _eItemToBeChanged$[esp+40]
	je	SHORT $LN5@GetGoldAva

; 315  : 		{
; 316  : 			if(it->m_eFromPlayer == ePlayer)

	mov	ecx, DWORD PTR _ePlayer$[esp+40]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN5@GetGoldAva

; 317  : 			{
; 318  : 				iGoldCost = GC.getGame().GetGameDeals()->GetTradeItemGoldCost(it->m_eItemType, m_eFromPlayer, m_eToPlayer);

	mov	edx, DWORD PTR _this$[esp+44]
	mov	ebp, DWORD PTR [edx+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235849[esp+44], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	sub	edi, 8
	je	SHORT $LN67@GetGoldAva
	sub	edi, 1
	jne	SHORT $LN78@GetGoldAva
	mov	eax, 250				; 000000faH
	jmp	SHORT $LN76@GetGoldAva
$LN67@GetGoldAva:
	mov	edx, DWORD PTR $T235849[esp+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	push	edx
	call	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z ; CvGame::GetResearchAgreementCost

; 319  : 
; 320  : 				if(iGoldCost != 0)		// Negative cost valid?  Maybe ;-O

	test	eax, eax
	je	SHORT $LN78@GetGoldAva
$LN76@GetGoldAva:

; 321  : 				{
; 322  : 					iGoldAvailable -= iGoldCost;

	sub	DWORD PTR _iGoldAvailable$[esp+44], eax
$LN78@GetGoldAva:
	mov	ebp, DWORD PTR _it$[esp+44]
$LN5@GetGoldAva:

; 305  : 	}
; 306  : 
; 307  : 	int iGoldCost;
; 308  : 
; 309  : 	// Loop through all trade items to see if they have a cost
; 310  : 	TradedItemList::iterator it;
; 311  : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	ebx, 268435455				; 0fffffffH
	jne	SHORT $LN21@GetGoldAva
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN75@GetGoldAva
$LN21@GetGoldAva:
	mov	eax, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [esi+eax]
$LN75@GetGoldAva:
	lea	ecx, DWORD PTR $T235673[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+48]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	jne	$LL20@GetGoldAva

; 323  : 				}
; 324  : 			}
; 325  : 		}
; 326  : 	}
; 327  : 
; 328  : 	return iGoldAvailable;

	mov	eax, DWORD PTR _iGoldAvailable$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 329  : }

	add	esp, 28					; 0000001cH
	ret	8
$LN77@GetGoldAva:

; 323  : 				}
; 324  : 			}
; 325  : 		}
; 326  : 	}
; 327  : 
; 328  : 	return iGoldAvailable;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 329  : }

	add	esp, 28					; 0000001cH
	ret	8
?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ENDP ; CvDeal::GetGoldAvailable
_TEXT	ENDS
PUBLIC	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
EXTRN	?CanCommitVote@CvLeagueAI@@QAE_NW4PlayerTypes@@PAVCvString@@@Z:PROC ; CvLeagueAI::CanCommitVote
EXTRN	?IsProposed@CvLeague@@QAE_NH_N0@Z:PROC		; CvLeague::IsProposed
EXTRN	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ:PROC ; CvGameLeagues::GetActiveLeague
EXTRN	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ:PROC	; CvGameLeagues::GetNumActiveLeagues
EXTRN	?isMinorCiv@CvTeam@@QBE_NXZ:PROC		; CvTeam::isMinorCiv
EXTRN	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::canDeclareWar
EXTRN	?IsWantsPeaceWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantsPeaceWithPlayer
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPeaceBlocked
EXTRN	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPermanentWar
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasTradeAgreement
EXTRN	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::IsTradeAgreementTradingAllowed
EXTRN	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ:PROC ; CvTeamTechs::HasResearchedAllTechs
EXTRN	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasResearchAgreement
EXTRN	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::IsResearchAgreementTradingAllowed
EXTRN	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasDefensivePact
EXTRN	?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::isDefensivePactTradingAllowed
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::isOpenBordersTradingAllowed
EXTRN	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::HasEmbassyAtTeam
EXTRN	?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::isAllowEmbassyTradingAllowed
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z:PROC ; CvTeam::IsResourceObsolete
EXTRN	?isHuman@CvTeam@@QBE_NXZ:PROC			; CvTeam::isHuman
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z:PROC ; CvGameLeagues::IsLuxuryHappinessBanned
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
EXTRN	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDoFAccepted
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$0
__ehfuncinfo$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
_TEXT	SEGMENT
$T235916 = -48						; size = 4
_pFromTeam$ = -44					; size = 4
$T235892 = -40						; size = 4
$T235864 = -40						; size = 8
$T235862 = -40						; size = 8
$T235861 = -40						; size = 8
$T235859 = -40						; size = 8
_this$ = -32						; size = 4
$T235869 = -28						; size = 8
$T235867 = -28						; size = 8
_pToPlayer$ = -28					; size = 4
tv1602 = -20						; size = 4
_it$221473 = -20					; size = 8
_it$221421 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eToPlayer$ = 12					; size = 4
_iGoldAvailable$ = 16					; size = 4
_eItem$ = 16						; size = 4
_iNumAvailable$221417 = 20				; size = 4
_iData1$ = 20						; size = 4
_iData2$ = 24						; size = 4
_iData3$ = 28						; size = 4
_bFlag1$ = 32						; size = 1
_bResult$221528 = 36					; size = 1
_bIgnoreExistingOP$221470 = 36				; size = 1
$T235865 = 36						; size = 4
_iNumInRenewDeal$221418 = 36				; size = 4
_bCheckOtherPlayerValidity$ = 36			; size = 1
_args$221527 = 40					; size = 4
$T235866 = 40						; size = 4
_iNumInExistingDeal$221419 = 40				; size = 4
_bFinalizing$ = 40					; size = 1
?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z PROC ; CvDeal::IsPossibleToTradeItem, COMDAT
; _this$ = ecx

; 333  : {

	push	-1
	push	__ehhandler$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H

; 334  : 	// The Data parameters can be -1, which means we don't care about whatever data is stored there (e.g. -1 for Gold means can we trade ANY amount of Gold?)
; 335  : 	CvPlayer* pFromPlayer = &GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+60]
	mov	DWORD PTR _this$[esp+64], ecx
	imul	edi, 63236				; 0000f704H

; 336  : 	CvPlayer* pToPlayer = &GET_PLAYER(eToPlayer);

	mov	ecx, DWORD PTR _eToPlayer$[esp+60]
	imul	ecx, 63236				; 0000f704H
	add	edi, eax
	lea	esi, DWORD PTR [ecx+eax]

; 337  : 
; 338  : 	TeamTypes eFromTeam = pFromPlayer->getTeam();

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR tv1602[esp+64], ecx
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	DWORD PTR _pToPlayer$[esp+64], esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN161@IsPossible
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN462@IsPossible
$LN161@IsPossible:
	or	eax, -1
$LN462@IsPossible:

; 339  : 	TeamTypes eToTeam = pToPlayer->getTeam();

	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR $T235892[esp+64], eax
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN170@IsPossible
	mov	ecx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN463@IsPossible
$LN170@IsPossible:
	or	ebx, -1
$LN463@IsPossible:

; 340  : 
; 341  : 	CvTeam* pFromTeam = &GET_TEAM(eFromTeam);

	mov	ecx, eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	ecx, 2980				; 00000ba4H
	mov	DWORD PTR $T235916[esp+64], ebx

; 342  : 	CvTeam* pToTeam = &GET_TEAM(eToTeam);

	imul	ebx, 2980				; 00000ba4H
	add	ecx, eax
	mov	DWORD PTR _pFromTeam$[esp+64], ecx

; 343  : 
; 344  : 	CvDeal* pRenewDeal = pFromPlayer->GetDiplomacyAI()->GetDealToRenew();

	push	0
	mov	ecx, edi
	add	ebx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	mov	ebp, eax

; 345  : 	if (!pRenewDeal)

	test	ebp, ebp
	jne	SHORT $LN149@IsPossible

; 346  : 	{
; 347  : 		pRenewDeal = pToPlayer->GetDiplomacyAI()->GetDealToRenew();

	push	eax
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	mov	ebp, eax
$LN149@IsPossible:

; 348  : 	}
; 349  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 350  : 	CvGameDeals* pGameDeals = GC.getGame().GetGameDeals();
; 351  : 	uint uiCurrentlyEndingDeals = pGameDeals->GetNumCurrentlyEndingDeals(ePlayer, eToPlayer);
; 352  : #endif
; 353  : 
; 354  : 	int iGoldAvailable = GetGoldAvailable(ePlayer, eItem);

	mov	esi, DWORD PTR _eItem$[esp+60]
	mov	edx, DWORD PTR _ePlayer$[esp+60]
	mov	ecx, DWORD PTR _this$[esp+64]
	push	esi
	push	edx
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable

; 355  : 
; 356  : 	// Some items require gold be spent (e.g. Research and Trade Agreements)
; 357  : 	int iCost = GC.getGame().GetGameDeals()->GetTradeItemGoldCost(eItem, ePlayer, eToPlayer);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _iGoldAvailable$[esp+60], eax
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, esi
	xor	eax, eax
	sub	ecx, 8
	je	SHORT $LN182@IsPossible
	sub	ecx, 1
	jne	SHORT $LN455@IsPossible
	mov	eax, 250				; 000000faH
	jmp	SHORT $LN451@IsPossible
$LN182@IsPossible:
	mov	eax, DWORD PTR _eToPlayer$[esp+60]
	mov	ecx, DWORD PTR _ePlayer$[esp+60]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z ; CvGame::GetResearchAgreementCost

; 358  : 	if(iCost > 0 && iGoldAvailable < iCost)

	test	eax, eax
	jle	SHORT $LN455@IsPossible
$LN451@IsPossible:
	cmp	DWORD PTR _iGoldAvailable$[esp+60], eax

; 359  : 		return false;

	jl	$LN144@IsPossible
$LN455@IsPossible:

; 360  : 
; 361  : 	iGoldAvailable -= iCost;

	sub	DWORD PTR _iGoldAvailable$[esp+60], eax

; 362  : 
; 363  : 	////////////////////////////////////////////////////
; 364  : 
; 365  : 	// Gold
; 366  : 	if(eItem == TRADE_ITEM_GOLD)

	test	esi, esi
	jne	$LN147@IsPossible

; 367  : 	{
; 368  : 		// DoF has not been made with this player
; 369  : 		if (!this->IsPeaceTreatyTrade(eToPlayer) && !this->IsPeaceTreatyTrade(ePlayer))

	mov	ebp, DWORD PTR _eToPlayer$[esp+60]
	mov	esi, DWORD PTR _this$[esp+64]
	push	ebp
	mov	ecx, esi
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	test	al, al
	jne	SHORT $LN457@IsPossible
	mov	ebx, DWORD PTR _ePlayer$[esp+60]
	push	ebx
	mov	ecx, esi
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	test	al, al
	jne	SHORT $LN457@IsPossible

; 370  : 		{
; 371  : 			if (pFromPlayer->getTeam() != pToPlayer->getTeam() && (!pFromPlayer->GetDiplomacyAI()->IsDoFAccepted(eToPlayer) || !pToPlayer->GetDiplomacyAI()->IsDoFAccepted(ePlayer)))

	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN193@IsPossible
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN194@IsPossible
$LN193@IsPossible:
	or	eax, -1
$LN194@IsPossible:
	mov	esi, DWORD PTR _pToPlayer$[esp+64]
	mov	ecx, DWORD PTR [esi+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN202@IsPossible
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN203@IsPossible
$LN202@IsPossible:
	or	ecx, -1
$LN203@IsPossible:
	cmp	eax, ecx
	je	SHORT $LN457@IsPossible
	push	ebp
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	SHORT $LN144@IsPossible
	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al

; 372  : 				return false;

	je	SHORT $LN144@IsPossible
$LN457@IsPossible:

; 373  : 		}
; 374  : 
; 375  : 		// Can't trade more Gold than you have
; 376  : 		int iGold = iData1;
; 377  : 		if(iGold != -1 && iGoldAvailable < iGold)

	mov	eax, DWORD PTR _iData1$[esp+60]
	cmp	eax, -1
	je	$LN1@IsPossible
	cmp	DWORD PTR _iGoldAvailable$[esp+60], eax
	jge	$LN1@IsPossible
$LN144@IsPossible:
	pop	edi
	pop	esi
	pop	ebp

; 378  : 			return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN147@IsPossible:

; 379  : 	}
; 380  : 	// Gold per Turn
; 381  : 	else if(eItem == TRADE_ITEM_GOLD_PER_TURN)

	cmp	esi, 1
	jne	SHORT $LN141@IsPossible

; 382  : 	{
; 383  : 		// Can't trade more GPT than you're making
; 384  : 		int iGoldPerTurn = iData1;
; 385  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 386  : 		if (pRenewDeal || uiCurrentlyEndingDeals > 0)
; 387  : 		{
; 388  : 			CvDeal* pLoopDeal = NULL;
; 389  : 			TradedItemList::iterator it;
; 390  : 			if (pRenewDeal)
; 391  : 			{
; 392  : 				for (it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)
; 393  : 				{
; 394  : 					if (it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == ePlayer)
; 395  : 					{
; 396  : 						// credit the amount
; 397  : 						iGoldPerTurn += it->m_iData1;
; 398  : 					}
; 399  : 				}
; 400  : 			}
; 401  : 			for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 402  : 			{
; 403  : 				pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 404  : 				for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 405  : 				{
; 406  : 					if (it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == ePlayer)
; 407  : 					{
; 408  : 						iGoldPerTurn += it->m_iData1;
; 409  : 					}
; 410  : 				}
; 411  : 			}
; 412  : 			// remove any that are in this deal
; 413  : 			for (it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)
; 414  : 			{
; 415  : 				if (it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == ePlayer)
; 416  : 				{
; 417  : 					iGoldPerTurn -= it->m_iData1;
; 418  : 				}
; 419  : 			}
; 420  : 		}
; 421  : #endif
; 422  : 		if(iGoldPerTurn != -1 && pFromPlayer->calculateGoldRate() < iGoldPerTurn)

	mov	esi, DWORD PTR _iData1$[esp+60]
	cmp	esi, -1
	je	$LN1@IsPossible
	mov	ecx, edi
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	cmp	eax, esi
	jge	$LN1@IsPossible
	pop	edi
	pop	esi
	pop	ebp

; 423  : 			return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN141@IsPossible:

; 424  : 
; 425  : 		//int iDuration = iData2;
; 426  : 		//if (iDuration != GC.getGame().GetDealDuration())
; 427  : 		//	return false;
; 428  : 	}
; 429  : 	// Map
; 430  : 	else if(eItem == TRADE_ITEM_MAPS)

	cmp	esi, 2

; 431  : 	{
; 432  : 		return false;

	je	SHORT $LN144@IsPossible

; 433  : 	}
; 434  : 	// Resource
; 435  : 	else if(eItem == TRADE_ITEM_RESOURCES)

	cmp	esi, 3
	jne	$LN136@IsPossible

; 436  : 	{
; 437  : 		ResourceTypes eResource = (ResourceTypes) iData1;
; 438  : 		if(eResource != NO_RESOURCE)

	mov	ebx, DWORD PTR _iData1$[esp+60]
	cmp	ebx, -1
	je	$LN1@IsPossible

; 439  : 		{
; 440  : 			int iResourceQuantity = iData2;
; 441  : 
; 442  : 			// Can't trade a negative amount of something!
; 443  : 			if(iResourceQuantity < 0)

	cmp	DWORD PTR _iData2$[esp+60], 0

; 444  : 				return false;

	jl	SHORT $LN144@IsPossible

; 445  : 
; 446  : 			if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(ePlayer, eResource) || GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(eToPlayer, eResource))

	mov	eax, DWORD PTR _ePlayer$[esp+60]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	test	al, al
	jne	$LN144@IsPossible
	mov	ecx, DWORD PTR _eToPlayer$[esp+60]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	test	al, al
	jne	$LN144@IsPossible

; 447  : 			{
; 448  : 				return false;
; 449  : 			}
; 450  : 
; 451  : 			//int iNumAvailable = GetNumResource(ePlayer, eResource, true);
; 452  : 
; 453  : 			int iNumAvailable = pFromPlayer->getNumResourceAvailable(eResource, false);

	xor	esi, esi
	push	esi
	push	ebx
	mov	ecx, edi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iNumAvailable$221417[esp+60], eax

; 454  : 			int iNumInRenewDeal = 0;

	mov	DWORD PTR _iNumInRenewDeal$221418[esp+60], esi

; 455  : 			int iNumInExistingDeal = 0;

	mov	DWORD PTR _iNumInExistingDeal$221419[esp+60], esi

; 456  : 
; 457  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 458  : 			if (pRenewDeal || uiCurrentlyEndingDeals > 0)
; 459  : #else
; 460  : 			if (pRenewDeal)

	cmp	ebp, esi
	je	$LN124@IsPossible

; 461  : #endif
; 462  : 			{
; 463  : 				// count any that are in the renew deal
; 464  : 				TradedItemList::iterator it;
; 465  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 466  : 				if (pRenewDeal)
; 467  : 				{
; 468  : #endif
; 469  : 				for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	edx, DWORD PTR $T235859[esp+64]
	lea	edi, DWORD PTR [ebp+44]
	push	edx
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T235861[esp+64]
	mov	DWORD PTR _it$221421[esp+64], ecx
	push	edx
	mov	ecx, edi
	mov	DWORD PTR _it$221421[esp+72], esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN128@IsPossible
	mov	ebp, DWORD PTR _iNumInRenewDeal$221418[esp+60]
	npad	8
$LL452@IsPossible:

; 470  : 				{
; 471  : 					if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	eax, DWORD PTR _it$221421[esp+64]
	imul	esi, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [esi+ecx+8], 3
	lea	eax, DWORD PTR [esi+ecx]
	jne	SHORT $LN129@IsPossible
	mov	edx, DWORD PTR _ePlayer$[esp+60]
	cmp	DWORD PTR [eax+36], edx
	jne	SHORT $LN129@IsPossible
	cmp	DWORD PTR [eax+20], ebx
	jne	SHORT $LN129@IsPossible

; 472  : 					{
; 473  : 						// credit the amount
; 474  : 						iNumInRenewDeal += it->m_iData2;

	add	ebp, DWORD PTR [eax+24]
$LN129@IsPossible:

; 461  : #endif
; 462  : 			{
; 463  : 				// count any that are in the renew deal
; 464  : 				TradedItemList::iterator it;
; 465  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 466  : 				if (pRenewDeal)
; 467  : 				{
; 468  : #endif
; 469  : 				for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR _it$221421[esp+64]
	call	??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
	lea	eax, DWORD PTR $T235861[esp+64]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	esi, DWORD PTR _it$221421[esp+68]
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL452@IsPossible

; 472  : 					{
; 473  : 						// credit the amount
; 474  : 						iNumInRenewDeal += it->m_iData2;

	mov	DWORD PTR _iNumInRenewDeal$221418[esp+60], ebp
$LN128@IsPossible:

; 475  : 					}
; 476  : 				}
; 477  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 478  : 				}
; 479  : 
; 480  : 				CvDeal* pLoopDeal = NULL;
; 481  : 				for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 482  : 				{
; 483  : 					pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 484  : 					for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 485  : 					{
; 486  : 						if (it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)
; 487  : 						{
; 488  : 							// credit the amount
; 489  : 							iNumInRenewDeal += it->m_iData2;
; 490  : 						}
; 491  : 					}
; 492  : 				}
; 493  : #endif
; 494  : 
; 495  : 				// remove any that are in this deal
; 496  : 				for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	mov	edi, DWORD PTR _this$[esp+64]
	lea	ecx, DWORD PTR $T235862[esp+64]
	add	edi, 44					; 0000002cH
	push	ecx
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T235864[esp+64]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _it$221421[esp+68], edx
	mov	DWORD PTR _it$221421[esp+72], esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN124@IsPossible
	mov	ebp, DWORD PTR _iNumInExistingDeal$221419[esp+60]
	npad	4
$LL453@IsPossible:

; 497  : 				{
; 498  : 					if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	ecx, DWORD PTR _it$221421[esp+64]
	imul	esi, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [esi+edx+8], 3
	lea	eax, DWORD PTR [esi+edx]
	jne	SHORT $LN125@IsPossible
	mov	ecx, DWORD PTR _ePlayer$[esp+60]
	cmp	DWORD PTR [eax+36], ecx
	jne	SHORT $LN125@IsPossible
	cmp	DWORD PTR [eax+20], ebx
	jne	SHORT $LN125@IsPossible

; 499  : 					{
; 500  : 						iNumInExistingDeal += it->m_iData2;

	add	ebp, DWORD PTR [eax+24]
$LN125@IsPossible:

; 475  : 					}
; 476  : 				}
; 477  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 478  : 				}
; 479  : 
; 480  : 				CvDeal* pLoopDeal = NULL;
; 481  : 				for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 482  : 				{
; 483  : 					pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 484  : 					for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 485  : 					{
; 486  : 						if (it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)
; 487  : 						{
; 488  : 							// credit the amount
; 489  : 							iNumInRenewDeal += it->m_iData2;
; 490  : 						}
; 491  : 					}
; 492  : 				}
; 493  : #endif
; 494  : 
; 495  : 				// remove any that are in this deal
; 496  : 				for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR _it$221421[esp+64]
	call	??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
	lea	edx, DWORD PTR $T235864[esp+64]
	push	edx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	esi, DWORD PTR _it$221421[esp+68]
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL453@IsPossible

; 499  : 					{
; 500  : 						iNumInExistingDeal += it->m_iData2;

	mov	DWORD PTR _iNumInExistingDeal$221419[esp+60], ebp
$LN124@IsPossible:

; 501  : 					}
; 502  : 				}
; 503  : 			}
; 504  : 
; 505  : 			// Offering up more of a Resource than we have available
; 506  : 			if(iNumAvailable + iNumInRenewDeal - iNumInExistingDeal < iResourceQuantity)

	mov	esi, DWORD PTR _iNumInRenewDeal$221418[esp+60]
	sub	esi, DWORD PTR _iNumInExistingDeal$221419[esp+60]
	mov	eax, DWORD PTR _iNumAvailable$221417[esp+60]
	lea	ecx, DWORD PTR [esi+eax]
	cmp	ecx, DWORD PTR _iData2$[esp+60]

; 507  : 				return false;

	jl	$LN144@IsPossible

; 508  : 
; 509  : 			// Must be a Luxury or a Strategic Resource
; 510  : 			ResourceUsageTypes eUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 511  : 			if(eUsage != RESOURCEUSAGE_LUXURY && eUsage != RESOURCEUSAGE_STRATEGIC)

	cmp	eax, 2
	je	SHORT $LN449@IsPossible
	cmp	eax, 1
	je	SHORT $LN119@IsPossible
	pop	edi
	pop	esi
	pop	ebp

; 512  : 				return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN449@IsPossible:

; 513  : 
; 514  : 			if(eUsage == RESOURCEUSAGE_LUXURY)
; 515  : 			{
; 516  : 				// Can't trade Luxury if the other player already has one
; 517  : 				if(pToPlayer->getNumResourceAvailable(eResource) > MAX(iNumInRenewDeal - iNumInExistingDeal, 0))

	mov	DWORD PTR $T235866[esp+60], esi
	test	esi, esi
	mov	DWORD PTR $T235865[esp+60], 0
	lea	esi, DWORD PTR $T235865[esp+60]
	jl	SHORT $LN306@IsPossible
	lea	esi, DWORD PTR $T235866[esp+60]
$LN306@IsPossible:
	mov	ecx, DWORD PTR _pToPlayer$[esp+64]
	push	1
	push	ebx
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, DWORD PTR [esi]

; 518  : 				{
; 519  : 					return false;

	jg	$LN144@IsPossible
$LN119@IsPossible:

; 520  : 				}
; 521  : 			}
; 522  : 
; 523  : 			// Can't trade them something they're already giving us in the deal
; 524  : 			if(IsResourceTrade(eToPlayer, eResource))

	mov	edx, DWORD PTR _eToPlayer$[esp+60]
	mov	ecx, DWORD PTR _this$[esp+64]
	push	ebx
	push	edx
	call	?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvDeal::IsResourceTrade
	test	al, al

; 525  : 				return false;

	jne	$LN144@IsPossible

; 526  : 
; 527  : 			// AI can't trade an obsolete resource
; 528  : 			if (!pFromTeam->isHuman() && pFromTeam->IsResourceObsolete(eResource))

	mov	ecx, DWORD PTR _pFromTeam$[esp+64]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	jne	$LN1@IsPossible
	mov	ecx, DWORD PTR _pFromTeam$[esp+64]
	push	ebx
	call	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ; CvTeam::IsResourceObsolete
	test	al, al
	je	$LN1@IsPossible
	pop	edi
	pop	esi
	pop	ebp

; 529  : 			{
; 530  : 				return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN136@IsPossible:

; 531  : 			}
; 532  : 		}
; 533  : 	}
; 534  : 	// City
; 535  : 	else if(eItem == TRADE_ITEM_CITIES)

	cmp	esi, 4
	jne	$LN115@IsPossible

; 536  : 	{
; 537  : 		CvCity* pCity = NULL;
; 538  : 		CvPlot* pPlot = GC.getMap().plot(iData1, iData2);

	mov	eax, DWORD PTR _iData1$[esp+60]
	cmp	eax, -2147483647			; 80000001H
	je	$LN144@IsPossible
	mov	ebp, DWORD PTR _iData2$[esp+60]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN144@IsPossible
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edi, DWORD PTR [ebx+4020]
	je	SHORT $LN319@IsPossible
	test	eax, eax
	jge	SHORT $LN321@IsPossible
	cdq
	idiv	edi
	mov	ecx, edx
	add	ecx, edi
	jmp	SHORT $LN323@IsPossible
$LN321@IsPossible:
	cmp	eax, edi
	jl	SHORT $LN319@IsPossible
	cdq
	idiv	edi
	mov	ecx, edx
	jmp	SHORT $LN323@IsPossible
$LN319@IsPossible:
	mov	ecx, eax
$LN323@IsPossible:
	cmp	BYTE PTR [ebx+4057], 0
	mov	esi, DWORD PTR [ebx+4024]
	je	SHORT $LN458@IsPossible
	test	ebp, ebp
	jge	SHORT $LN331@IsPossible
	mov	eax, ebp
	cdq
	idiv	esi
	add	edx, esi
	jmp	SHORT $LN333@IsPossible
$LN331@IsPossible:
	cmp	ebp, esi
	jl	SHORT $LN458@IsPossible
	mov	eax, ebp
	cdq
	idiv	esi
	jmp	SHORT $LN333@IsPossible
$LN458@IsPossible:
	mov	edx, ebp
$LN333@IsPossible:
	test	ecx, ecx
	jl	$LN144@IsPossible
	cmp	ecx, edi
	jge	$LN144@IsPossible
	test	edx, edx
	jl	$LN144@IsPossible
	cmp	edx, esi
	jge	$LN144@IsPossible
	imul	edx, edi
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [ebx+4068]

; 539  : 		if(pPlot != NULL)

	test	edx, edx
	je	$LN144@IsPossible

; 540  : 			pCity = pPlot->getPlotCity();

	mov	ecx, edx
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 541  : 
; 542  : 		if(pCity != NULL)

	test	eax, eax
	je	$LN144@IsPossible

; 543  : 		{
; 544  : 			// Can't trade someone else's city
; 545  : 			if(pCity->getOwner() != ePlayer)

	mov	ecx, DWORD PTR _ePlayer$[esp+60]
	cmp	DWORD PTR [eax+84], ecx

; 546  : 				return false;

	jne	$LN144@IsPossible

; 547  : 
; 548  : 			// Can't trade one's capital
; 549  : #ifdef AUI_DEAL_ALLOW_CAPITOL_GIFTING
; 550  : 			if (pCity->isCapital() && !GC.getGame().isOption("GAMEOPTION_ALLOW_CAPITOL_GIFTING"))
; 551  : #else
; 552  : 			if(pCity->isCapital())

	mov	ecx, eax
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al

; 553  : #endif
; 554  : 				return false;

	jne	$LN144@IsPossible

; 555  : 
; 556  : 			// Can't trade a city to a human in an OCC game
; 557  : 			if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && GET_PLAYER(eToPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN110@IsPossible
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1602[esp+64]
	lea	ecx, DWORD PTR [eax+edx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al

; 558  : 				return false;

	jne	$LN144@IsPossible
$LN110@IsPossible:

; 559  : 		}
; 560  : 		// Can't trade a null city
; 561  : 		else
; 562  : 			return false;
; 563  : 
; 564  : 		// Can't already have this city in the deal
; 565  : 		if(!bFinalizing && IsCityTrade(ePlayer, iData1, iData2))

	cmp	BYTE PTR _bFinalizing$[esp+60], 0
	jne	$LN1@IsPossible
	mov	ecx, DWORD PTR _iData1$[esp+60]
	mov	edx, DWORD PTR _ePlayer$[esp+60]
	push	ebp
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+72]
	push	edx
	call	?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::IsCityTrade
	test	al, al
	je	$LN1@IsPossible
	pop	edi
	pop	esi
	pop	ebp

; 566  : 			return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN115@IsPossible:

; 567  : 	}
; 568  : 	// Unit
; 569  : 	else if(eItem == TRADE_ITEM_UNITS)

	cmp	esi, 5

; 570  : 	{
; 571  : 		return false;

	je	$LN144@IsPossible

; 572  : 	}
; 573  : 	// Embassy
; 574  : 	else if(eItem == TRADE_ITEM_ALLOW_EMBASSY)

	cmp	esi, 17					; 00000011H
	jne	SHORT $LN104@IsPossible

; 575  : 	{
; 576  : 		// too few cities
; 577  : 		if (pToPlayer->getNumCities() < 1)

	mov	ecx, DWORD PTR _pToPlayer$[esp+64]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1

; 578  : 			return false;

	jl	$LN144@IsPossible

; 579  : 		// Does not have tech for Embassy trading
; 580  : 		if(!pToTeam->isAllowEmbassyTradingAllowed())

	mov	ecx, ebx
	call	?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isAllowEmbassyTradingAllowed
	test	al, al

; 581  : 			return false;

	je	$LN144@IsPossible

; 582  : 		// Already has embassy
; 583  : 		if(pToTeam->HasEmbassyAtTeam(eFromTeam))

	mov	esi, DWORD PTR $T235892[esp+64]
	push	esi
	mov	ecx, ebx
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	test	al, al

; 584  : 			return false;

	jne	$LN144@IsPossible

; 585  : 		// Same team
; 586  : 		if(eFromTeam == eToTeam)

	cmp	esi, DWORD PTR $T235916[esp+64]
	jne	$LN1@IsPossible
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN104@IsPossible:

; 587  : 			return false;
; 588  : 	}
; 589  : 	// Open Borders
; 590  : 	else if(eItem == TRADE_ITEM_OPEN_BORDERS)

	cmp	esi, 6
	jne	$LN98@IsPossible

; 591  : 	{
; 592  : 		// Neither of us yet has the Tech for OP
; 593  : 		if(!pFromTeam->isOpenBordersTradingAllowed() && !pToTeam->isOpenBordersTradingAllowed())

	mov	esi, DWORD PTR _pFromTeam$[esp+64]
	mov	ecx, esi
	call	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isOpenBordersTradingAllowed
	test	al, al
	jne	SHORT $LN97@IsPossible
	mov	ecx, ebx
	call	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isOpenBordersTradingAllowed
	test	al, al

; 594  : 			return false;

	je	$LN144@IsPossible
$LN97@IsPossible:

; 595  : 		// Embassy has not been established
; 596  : 		if(!pFromTeam->HasEmbassyAtTeam(eToTeam))

	mov	eax, DWORD PTR $T235916[esp+64]
	push	eax
	mov	ecx, esi
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	test	al, al

; 597  : 			return false;

	je	$LN144@IsPossible

; 598  : 		
; 599  : 		bool bIgnoreExistingOP = true;

	mov	BYTE PTR _bIgnoreExistingOP$221470[esp+60], 1

; 600  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 601  : 		TradedItemList::iterator it;
; 602  : #endif
; 603  : 		if (pRenewDeal)

	test	ebp, ebp
	je	$LN459@IsPossible

; 604  : 		{
; 605  : 			// count any that are in the renew deal
; 606  : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 607  : 			int iEndingTurn = -1;
; 608  : 			TradedItemList::iterator it;
; 609  : #endif
; 610  : 			for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR $T235867[esp+64]
	lea	edi, DWORD PTR [ebp+44]
	push	ecx
	mov	ecx, edi
	or	ebx, -1
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T235869[esp+64]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _it$221473[esp+68], edx
	mov	DWORD PTR _it$221473[esp+72], esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN92@IsPossible
	mov	ebp, DWORD PTR _ePlayer$[esp+60]
	npad	5
$LL454@IsPossible:

; 611  : 			{
; 612  : 				if(it->m_eItemType == TRADE_ITEM_OPEN_BORDERS && (it->m_eFromPlayer == ePlayer || it->m_eFromPlayer == eToPlayer == ePlayer))

	mov	ecx, DWORD PTR _it$221473[esp+64]
	imul	esi, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [esi+edx+8], 6
	lea	eax, DWORD PTR [esi+edx]
	jne	SHORT $LN93@IsPossible
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, ebp
	je	SHORT $LN90@IsPossible
	xor	edx, edx
	cmp	ecx, DWORD PTR _eToPlayer$[esp+60]
	sete	dl
	cmp	edx, ebp
	jne	SHORT $LN93@IsPossible
$LN90@IsPossible:

; 613  : 				{
; 614  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 615  : 					if (it->m_iTurnsRemaining == 0)
; 616  : 					{
; 617  : 						bIgnoreExistingOP = false;
; 618  : 						goto EndCheckCurrentlyEndingForOP;
; 619  : 					}
; 620  : #else
; 621  : 					iEndingTurn = it->m_iFinalTurn;

	mov	ebx, DWORD PTR [eax+16]
$LN93@IsPossible:

; 604  : 		{
; 605  : 			// count any that are in the renew deal
; 606  : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 607  : 			int iEndingTurn = -1;
; 608  : 			TradedItemList::iterator it;
; 609  : #endif
; 610  : 			for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR _it$221473[esp+64]
	call	??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
	lea	eax, DWORD PTR $T235869[esp+64]
	push	eax
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	esi, DWORD PTR _it$221473[esp+68]
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL454@IsPossible
$LN92@IsPossible:

; 622  : #endif
; 623  : 				}
; 624  : 			}
; 625  : 
; 626  : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 627  : 			if (iEndingTurn == GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	ebx, eax
	jne	SHORT $LN459@IsPossible

; 628  : 			{
; 629  : 				bIgnoreExistingOP = false;

	mov	BYTE PTR _bIgnoreExistingOP$221470[esp+60], 0
$LN459@IsPossible:

; 630  : 			}
; 631  : #endif
; 632  : 		}
; 633  : 
; 634  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 635  : 		CvDeal* pLoopDeal = NULL;
; 636  : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 637  : 		{
; 638  : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 639  : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 640  : 			{
; 641  : 				if (it->m_eItemType == TRADE_ITEM_OPEN_BORDERS && it->m_eFromPlayer == ePlayer)
; 642  : 				{
; 643  : 					bIgnoreExistingOP = false;
; 644  : 					goto EndCheckCurrentlyEndingForOP;
; 645  : 				}
; 646  : 			}
; 647  : 		}
; 648  : 	EndCheckCurrentlyEndingForOP:;
; 649  : #endif
; 650  : 
; 651  : 		// Already has OP
; 652  : 		if(pFromTeam->IsAllowsOpenBordersToTeam(eToTeam) && bIgnoreExistingOP)

	mov	esi, DWORD PTR $T235916[esp+64]
	mov	ecx, DWORD PTR _pFromTeam$[esp+64]
	push	esi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN88@IsPossible
	cmp	BYTE PTR _bIgnoreExistingOP$221470[esp+60], 0

; 653  : 			return false;

	jne	$LN144@IsPossible
$LN88@IsPossible:

; 654  : 		// Same Team
; 655  : 		if(eFromTeam == eToTeam)

	cmp	DWORD PTR $T235892[esp+64], esi
	jne	$LN1@IsPossible
	pop	edi
	pop	esi
	pop	ebp

; 656  : 			return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN98@IsPossible:

; 657  : 	}
; 658  : 	// Defensive Pact
; 659  : 	else if(eItem == TRADE_ITEM_DEFENSIVE_PACT)

	cmp	esi, 7
	jne	$LN85@IsPossible

; 660  : 	{
; 661  : 		// Neither of us yet has the Tech for DP
; 662  : 		if(!pFromTeam->isDefensivePactTradingAllowed() && !pToTeam->isDefensivePactTradingAllowed())

	mov	edi, DWORD PTR _pFromTeam$[esp+64]
	mov	ecx, edi
	call	?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isDefensivePactTradingAllowed
	test	al, al
	jne	SHORT $LN84@IsPossible
	mov	ecx, ebx
	call	?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isDefensivePactTradingAllowed
	test	al, al

; 663  : 			return false;

	je	$LN144@IsPossible
$LN84@IsPossible:

; 664  : 		// Embassy has not been established
; 665  : 		if(!pFromTeam->HasEmbassyAtTeam(eToTeam) || !pToTeam->HasEmbassyAtTeam(eFromTeam))

	mov	esi, DWORD PTR $T235916[esp+64]
	push	esi
	mov	ecx, edi
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	test	al, al
	je	$LN144@IsPossible
	mov	ebp, DWORD PTR $T235892[esp+64]
	push	ebp
	mov	ecx, ebx
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	test	al, al
	je	$LN144@IsPossible

; 666  : 			return false;
; 667  : 		// Already has DP
; 668  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 669  : 		bool bConsiderExistingDefensivePact = true;
; 670  : 		CvDeal* pLoopDeal = NULL;
; 671  : 		TradedItemList::iterator it;
; 672  : 		if (pRenewDeal)
; 673  : 		{
; 674  : 			// count any that are in the renew deal
; 675  : 			for (it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)
; 676  : 			{
; 677  : 				if (it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT && it->m_eFromPlayer == ePlayer)
; 678  : 				{
; 679  : 					if (it->m_iTurnsRemaining == 0)
; 680  : 					{
; 681  : 						bConsiderExistingDefensivePact = false;
; 682  : 						goto EndCheckCurrentlyEndingForDP;
; 683  : 					}
; 684  : 				}
; 685  : 			}
; 686  : 		}
; 687  : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 688  : 		{
; 689  : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 690  : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 691  : 			{
; 692  : 				if (it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT && it->m_eFromPlayer == ePlayer)
; 693  : 				{
; 694  : 					bConsiderExistingDefensivePact = false;
; 695  : 					goto EndCheckCurrentlyEndingForDP;
; 696  : 				}
; 697  : 			}
; 698  : 		}
; 699  : 	EndCheckCurrentlyEndingForDP:;
; 700  : 		if (bConsiderExistingDefensivePact && pFromTeam->IsHasDefensivePact(eToTeam))
; 701  : #else
; 702  : 		if(pFromTeam->IsHasDefensivePact(eToTeam))

	push	esi
	mov	ecx, edi
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	test	al, al

; 703  : #endif
; 704  : 			return false;

	jne	$LN144@IsPossible

; 705  : 		// Same Team
; 706  : 		if(eFromTeam == eToTeam)

	cmp	ebp, esi

; 707  : 			return false;

	je	$LN144@IsPossible

; 708  : 
; 709  : 		// Check to see if the other player can trade this item to us as well.  If we can't, we can't trade it either
; 710  : 		if(bCheckOtherPlayerValidity)

	cmp	BYTE PTR _bCheckOtherPlayerValidity$[esp+60], al
	je	$LN1@IsPossible

; 711  : 		{
; 712  : 			if(!IsPossibleToTradeItem(eToPlayer, ePlayer, eItem, iData1, iData2, iData3, bFlag1, /*bCheckOtherPlayerValidity*/ false))

	mov	ecx, DWORD PTR _bFlag1$[esp+60]
	mov	edx, DWORD PTR _iData3$[esp+60]
	mov	eax, DWORD PTR _iData2$[esp+60]
	push	0
	push	0
	push	ecx
	mov	ecx, DWORD PTR _iData1$[esp+72]
	push	edx
	push	eax
	push	ecx
	push	7
$LN464@IsPossible:
	mov	edx, DWORD PTR _ePlayer$[esp+88]
	mov	eax, DWORD PTR _eToPlayer$[esp+88]
	mov	ecx, DWORD PTR _this$[esp+92]
	push	edx
	push	eax
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
$LN466@IsPossible:
	test	al, al
$LN467@IsPossible:
	jne	$LN1@IsPossible
$LN465@IsPossible:
	pop	edi
	pop	esi
	pop	ebp

; 713  : 				return false;

	xor	al, al
	pop	ebx

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
$LN85@IsPossible:

; 714  : 		}
; 715  : 	}
; 716  : 	// Research Agreement
; 717  : 	else if(eItem == TRADE_ITEM_RESEARCH_AGREEMENT)

	cmp	esi, 8
	jne	$LN76@IsPossible

; 718  : 	{
; 719  : 		if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	17					; 00000011H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 720  : 			return false;

	jne	$LN144@IsPossible

; 721  : 
; 722  : 		// Neither of us yet has the Tech for RA
; 723  : 		if(!pFromTeam->IsResearchAgreementTradingAllowed() && !pToTeam->IsResearchAgreementTradingAllowed())

	mov	ebp, DWORD PTR _pFromTeam$[esp+64]
	mov	ecx, ebp
	call	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
	test	al, al
	jne	SHORT $LN74@IsPossible
	mov	ecx, ebx
	call	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
	test	al, al

; 724  : 			return false;

	je	$LN144@IsPossible
$LN74@IsPossible:

; 725  : 		// Embassy has not been established with this team
; 726  : 		if(!pFromTeam->HasEmbassyAtTeam(eToTeam) || !pToTeam->HasEmbassyAtTeam(eFromTeam))

	mov	esi, DWORD PTR $T235916[esp+64]
	push	esi
	mov	ecx, ebp
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	test	al, al
	je	$LN144@IsPossible
	mov	ecx, DWORD PTR $T235892[esp+64]
	push	ecx
	mov	ecx, ebx
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	test	al, al
	je	$LN144@IsPossible

; 727  : 			return false;
; 728  : 		// DoF has not been made with this player
; 729  : 		if(!pFromPlayer->GetDiplomacyAI()->IsDoFAccepted(eToPlayer) || !pToPlayer->GetDiplomacyAI()->IsDoFAccepted(ePlayer))

	mov	edx, DWORD PTR _eToPlayer$[esp+60]
	push	edx
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	$LN144@IsPossible
	mov	eax, DWORD PTR _ePlayer$[esp+60]
	mov	ecx, DWORD PTR _pToPlayer$[esp+64]
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	$LN144@IsPossible

; 730  : 			return false;
; 731  : 		// Already has RA
; 732  : 		if(pFromTeam->IsHasResearchAgreement(eToTeam))

	push	esi
	mov	ecx, ebp
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	test	al, al

; 733  : 			return false;

	jne	$LN144@IsPossible

; 734  : 		// Same Team
; 735  : 		if(eFromTeam == eToTeam)

	cmp	DWORD PTR $T235892[esp+64], esi

; 736  : 			return false;

	je	$LN144@IsPossible

; 737  : 		// Someone already has all techs
; 738  : 		if(pFromTeam->GetTeamTechs()->HasResearchedAllTechs() || pToTeam->GetTeamTechs()->HasResearchedAllTechs())

	mov	ecx, ebp
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ ; CvTeamTechs::HasResearchedAllTechs
	test	al, al
	jne	$LN144@IsPossible
	mov	ecx, ebx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ ; CvTeamTechs::HasResearchedAllTechs
	test	al, al
	jne	$LN144@IsPossible

; 739  : 			return false;
; 740  : 
; 741  : 		// Check to see if the other player can trade this item to us as well.  If we can't, we can't trade it either
; 742  : 		if(bCheckOtherPlayerValidity)

	cmp	BYTE PTR _bCheckOtherPlayerValidity$[esp+60], al
	je	$LN1@IsPossible

; 743  : 		{
; 744  : 			if(!IsPossibleToTradeItem(eToPlayer, ePlayer, eItem, iData1, iData2, iData3, bFlag1, /*bCheckOtherPlayerValidity*/ false))

	mov	ecx, DWORD PTR _bFlag1$[esp+60]
	mov	edx, DWORD PTR _iData3$[esp+60]
	mov	eax, DWORD PTR _iData2$[esp+60]
	push	0
	push	0
	push	ecx
	mov	ecx, DWORD PTR _iData1$[esp+72]
	push	edx
	push	eax
	push	ecx
	push	8

; 745  : 				return false;

	jmp	$LN464@IsPossible
$LN76@IsPossible:

; 746  : 		}
; 747  : 	}
; 748  : 	// Trade Agreement
; 749  : 	else if(eItem == TRADE_ITEM_TRADE_AGREEMENT)

	cmp	esi, 9
	jne	SHORT $LN62@IsPossible

; 750  : 	{
; 751  : 		// Neither of us yet has the Tech for TA
; 752  : 		if(!pFromTeam->IsTradeAgreementTradingAllowed() && !pToTeam->IsTradeAgreementTradingAllowed())

	mov	edi, DWORD PTR _pFromTeam$[esp+64]
	mov	ecx, edi
	call	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsTradeAgreementTradingAllowed
	test	al, al
	jne	SHORT $LN61@IsPossible
	mov	ecx, ebx
	call	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsTradeAgreementTradingAllowed
	test	al, al

; 753  : 			return false;

	je	$LN144@IsPossible
$LN61@IsPossible:

; 754  : 		// Already has TA
; 755  : 		if(pFromTeam->IsHasTradeAgreement(eToTeam))

	mov	esi, DWORD PTR $T235916[esp+64]
	push	esi
	mov	ecx, edi
	call	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasTradeAgreement
	test	al, al

; 756  : 			return false;

	jne	$LN144@IsPossible

; 757  : 		// Same Team
; 758  : 		if(eFromTeam == eToTeam)

	cmp	DWORD PTR $T235892[esp+64], esi

; 759  : 			return false;

	je	$LN144@IsPossible

; 760  : 
; 761  : 		// Check to see if the other player can trade this item to us as well.  If we can't, we can't trade it either
; 762  : 		if(bCheckOtherPlayerValidity)

	cmp	BYTE PTR _bCheckOtherPlayerValidity$[esp+60], al
	je	$LN1@IsPossible

; 763  : 		{
; 764  : 			if(!IsPossibleToTradeItem(eToPlayer, ePlayer, eItem, iData1, iData2, iData3, bFlag1, /*bCheckOtherPlayerValidity*/ false))

	mov	ecx, DWORD PTR _bFlag1$[esp+60]
	mov	edx, DWORD PTR _iData3$[esp+60]
	mov	eax, DWORD PTR _iData2$[esp+60]
	push	0
	push	0
	push	ecx
	mov	ecx, DWORD PTR _iData1$[esp+72]
	push	edx
	push	eax
	push	ecx
	push	9

; 765  : 				return false;

	jmp	$LN464@IsPossible
$LN62@IsPossible:

; 766  : 		}
; 767  : 	}
; 768  : 	// Permanent Alliance
; 769  : 	else if(eItem == TRADE_ITEM_PERMANENT_ALLIANCE)

	cmp	esi, 10					; 0000000aH

; 770  : 		return false;

	je	$LN144@IsPossible

; 771  : 	// Surrender
; 772  : 	else if(eItem == TRADE_ITEM_SURRENDER)

	cmp	esi, 11					; 0000000bH

; 773  : 		return false;

	je	$LN144@IsPossible

; 774  : 	// Truce
; 775  : 	else if(eItem == TRADE_ITEM_TRUCE)

	cmp	esi, 12					; 0000000cH

; 776  : 		return false;

	je	$LN144@IsPossible

; 777  : 	// Peace Treaty
; 778  : 	else if(eItem == TRADE_ITEM_PEACE_TREATY)

	cmp	esi, 13					; 0000000dH
	jne	$LN49@IsPossible

; 779  : 	{
; 780  : 		if(!pFromTeam->isAtWar(eToTeam))

	mov	ecx, DWORD PTR $T235916[esp+64]
	push	ecx
	mov	ecx, DWORD PTR _pFromTeam$[esp+68]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 781  : 			return false;

	je	$LN144@IsPossible

; 782  : 
; 783  : 		if(!pToTeam->isAtWar(eFromTeam))

	mov	edx, DWORD PTR $T235892[esp+64]
	push	edx
	mov	ecx, ebx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 784  : 			return false;

	je	$LN144@IsPossible

; 785  : 
; 786  : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 787  : 		if (pkScriptSystem)

	test	esi, esi
	je	$LN1@IsPossible

; 788  : 		{
; 789  : 			// Construct and push in some event arguments.
; 790  : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$221527[esp+60]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 791  : 			args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$221527[esp+60]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _ePlayer$[esp+60]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	eax

; 792  : 			args->Push(eToTeam);

	mov	ecx, DWORD PTR _args$221527[esp+60]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T235916[esp+64]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 793  : 
; 794  : 			// Attempt to execute the game events.
; 795  : 			// Will return false if there are no registered listeners.
; 796  : 			bool bResult = false;
; 797  : 			if (LuaSupport::CallTestAll(pkScriptSystem, "IsAbleToMakePeace", args.get(), bResult)) 

	mov	ecx, DWORD PTR _args$221527[esp+60]
	lea	eax, DWORD PTR _bResult$221528[esp+60]
	push	eax
	push	ecx
	push	OFFSET $SG221530
	push	esi
	mov	BYTE PTR _bResult$221528[esp+76], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN44@IsPossible

; 798  : 			{
; 799  : 				// Check the result.
; 800  : 				if (bResult == false)

	cmp	BYTE PTR _bResult$221528[esp+60], 0
	jne	SHORT $LN44@IsPossible

; 801  : 				{
; 802  : 					return false;

	lea	ecx, DWORD PTR _args$221527[esp+60]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	jmp	$LN465@IsPossible
$LN44@IsPossible:

; 803  : 				}
; 804  : 			}
; 805  : 		}

	lea	ecx, DWORD PTR _args$221527[esp+60]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle

; 806  : 	}

	jmp	$LN1@IsPossible
$LN49@IsPossible:

; 807  : 	// Third Party Peace
; 808  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_PEACE)

	cmp	esi, 14					; 0000000eH
	jne	$LN42@IsPossible

; 809  : 	{
; 810  : 		TeamTypes eThirdTeam = (TeamTypes) iData1;
; 811  : 
; 812  : 		// Can't be the same team
; 813  : 		if(eFromTeam == eThirdTeam)

	mov	ebp, DWORD PTR _iData1$[esp+60]
	mov	eax, DWORD PTR $T235892[esp+64]
	cmp	eax, ebp

; 814  : 			return false;

	je	$LN144@IsPossible

; 815  : 
; 816  : 		// Can't ask teammates
; 817  : 		if(eToTeam == eFromTeam)

	cmp	DWORD PTR $T235916[esp+64], eax

; 818  : 			return false;

	je	$LN144@IsPossible

; 819  : 
; 820  : 		// Must be alive
; 821  : 		if(!GET_TEAM(eThirdTeam).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, ebp
	imul	esi, 2980				; 00000ba4H
	cmp	DWORD PTR [esi+edx+12], 0

; 822  : 			return false;

	jle	$LN144@IsPossible

; 823  : 
; 824  : 		// Player that wants Peace hasn't yet met the 3rd Team
; 825  : 		if(!pToTeam->isHasMet(eThirdTeam))

	push	ebp
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 826  : 			return false;

	je	$LN144@IsPossible

; 827  : 		// Player that would go to Peace hasn't yet met the 3rd Team
; 828  : 		if(!pFromTeam->isHasMet(eThirdTeam))

	mov	ebx, DWORD PTR _pFromTeam$[esp+64]
	push	ebp
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 829  : 			return false;

	je	$LN144@IsPossible

; 830  : 		// Player that would go to peace is already at peace with the 3rd Team
; 831  : 		if(!pFromTeam->isAtWar(eThirdTeam))

	push	ebp
	mov	ecx, ebx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 832  : 			return false;

	je	$LN144@IsPossible

; 833  : 
; 834  : 		// Can't already have this in the deal
; 835  : 		//if (IsThirdPartyPeaceTrade( ePlayer, GET_TEAM(eThirdTeam).getLeaderID() ))
; 836  : 		//	return false;
; 837  : 
; 838  : 		// If eThirdTeam is an AI then they have to want peace with ToTeam
; 839  : 		CvPlayer* pOtherPlayer = &GET_PLAYER(GET_TEAM(eThirdTeam).getLeaderID());

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+eax]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax

; 840  : 		// Minor civ
; 841  : 		if(pOtherPlayer->isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 842  : 		{
; 843  : 			// Minor at permanent war with this player
; 844  : 			if(pOtherPlayer->GetMinorCivAI()->IsPermanentWar(eFromTeam))

	mov	ecx, esi
	test	al, al
	je	SHORT $LN35@IsPossible
	mov	edi, DWORD PTR $T235892[esp+64]
	push	edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	test	al, al

; 845  : 				return false;

	jne	$LN144@IsPossible

; 846  : 
; 847  : 			// Minor's ally at war with this player?
; 848  : 			else if(pOtherPlayer->GetMinorCivAI()->IsPeaceBlocked(eFromTeam))

	push	edi
	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPeaceBlocked
	test	al, al
	je	$LN1@IsPossible

; 849  : 			{
; 850  : 				// If the ally is us, don't block peace here
; 851  : 				if(pOtherPlayer->GetMinorCivAI()->GetAlly() != eToPlayer)

	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _eToPlayer$[esp+60]
	je	$LN1@IsPossible

; 852  : 					return false;

	jmp	$LN465@IsPossible
$LN35@IsPossible:

; 853  : 			}
; 854  : 		}
; 855  : 		// Major civ
; 856  : 		else
; 857  : 		{
; 858  : 			// Can't ask them to make peace with a human, because we have no way of knowing if the human wants peace
; 859  : 			if(pOtherPlayer->isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al

; 860  : 				return false;

	jne	$LN144@IsPossible

; 861  : 
; 862  : 			// Player does not want peace with eOtherPlayer
; 863  : 			if(pFromPlayer->isHuman() || pFromPlayer->GetDiplomacyAI()->GetWarGoal(pOtherPlayer->GetID()) < WAR_GOAL_DAMAGE)

	mov	ecx, edi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN144@IsPossible
	mov	eax, DWORD PTR [esi+44]
	push	eax
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 3
	jl	$LN144@IsPossible

; 864  : 				return false;
; 865  : 
; 866  : 			// Other player does not want peace with eToPlayer
; 867  : 			if(!pOtherPlayer->GetDiplomacyAI()->IsWantsPeaceWithPlayer(ePlayer))

	mov	ecx, DWORD PTR _ePlayer$[esp+60]
	push	ecx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantsPeaceWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantsPeaceWithPlayer

; 868  : 				return false;

	jmp	$LN466@IsPossible
$LN42@IsPossible:

; 869  : 		}
; 870  : 	}
; 871  : 	// Third Party War
; 872  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_WAR)

	cmp	esi, 15					; 0000000fH
	jne	$LN24@IsPossible

; 873  : 	{
; 874  : 		TeamTypes eThirdTeam = (TeamTypes) iData1;
; 875  : 
; 876  : 		// Can't be the same team
; 877  : 		if(eFromTeam == eThirdTeam)

	mov	edi, DWORD PTR _iData1$[esp+60]
	mov	eax, DWORD PTR $T235892[esp+64]
	cmp	eax, edi

; 878  : 			return false;

	je	$LN144@IsPossible

; 879  : 
; 880  : 		// Can't ask teammates
; 881  : 		if(eToTeam == eFromTeam)

	cmp	DWORD PTR $T235916[esp+64], eax

; 882  : 			return false;

	je	$LN144@IsPossible

; 883  : 
; 884  : 		// Must be alive
; 885  : 		if(!GET_TEAM(eThirdTeam).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, edi
	imul	esi, 2980				; 00000ba4H
	cmp	DWORD PTR [esi+edx+12], 0

; 886  : 			return false;

	jle	$LN144@IsPossible

; 887  : 
; 888  : 		// Player that would go to war hasn't yet met the 3rd Team
; 889  : 		if(!pToTeam->isHasMet(eThirdTeam))

	push	edi
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 890  : 			return false;

	je	$LN144@IsPossible

; 891  : 		// Player that wants war not met this team
; 892  : 		if(!pFromTeam->isHasMet(eThirdTeam))

	mov	ebx, DWORD PTR _pFromTeam$[esp+64]
	push	edi
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 893  : 			return false;

	je	$LN144@IsPossible

; 894  : 
; 895  : 		// Player that would go to war is already at war with the 3rd Team
; 896  : 		if(pFromTeam->isAtWar(eThirdTeam))

	push	edi
	mov	ecx, ebx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 897  : 			return false;

	jne	$LN144@IsPossible

; 898  : 
; 899  : 		// Can this player actually declare war?
; 900  : 		if(!pFromTeam->canDeclareWar(eThirdTeam))

	push	edi
	mov	ecx, ebx
	call	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::canDeclareWar
	test	al, al

; 901  : 			return false;

	je	$LN144@IsPossible

; 902  : 
; 903  : 		// Can't already have this in the deal
; 904  : 		//if (IsThirdPartyWarTrade( ePlayer, GET_TEAM(eThirdTeam).getLeaderID() ))
; 905  : 		//	return false;
; 906  : 
; 907  : 		// Can't ask a player to declare war on their ally
; 908  : 		if(GET_TEAM(eThirdTeam).isMinorCiv())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	$LN1@IsPossible

; 909  : 		{
; 910  : 			if(GET_PLAYER(GET_TEAM(eThirdTeam).getLeaderID()).GetMinorCivAI()->GetAlly() == ePlayer)

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _ePlayer$[esp+60]

; 911  : 				return false;

	jmp	$LN467@IsPossible
$LN24@IsPossible:

; 912  : 		}
; 913  : 	}
; 914  : 	// Third Party Embargo
; 915  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_EMBARGO)

	cmp	esi, 16					; 00000010H

; 916  : 	{
; 917  : 		return false;

	je	$LN144@IsPossible

; 918  : 	}
; 919  : 	// Declaration of friendship
; 920  : 	else if(eItem == TRADE_ITEM_DECLARATION_OF_FRIENDSHIP)

	cmp	esi, 18					; 00000012H
	jne	SHORT $LN11@IsPossible

; 921  : 	{
; 922  : 		// If we are at war, then we can't until we make peace
; 923  : 		if(pFromTeam->isAtWar(eToTeam))

	mov	edx, DWORD PTR $T235916[esp+64]
	mov	ecx, DWORD PTR _pFromTeam$[esp+64]
	push	edx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 924  : 			return false;

	jne	$LN144@IsPossible

; 925  : 
; 926  : 		// Already have a DoF?
; 927  : 		if (pFromPlayer->GetDiplomacyAI()->IsDoFAccepted(eToPlayer) && pToPlayer->GetDiplomacyAI()->IsDoFAccepted(ePlayer))

	mov	eax, DWORD PTR _eToPlayer$[esp+60]
	push	eax
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	$LN1@IsPossible
	mov	ecx, DWORD PTR _ePlayer$[esp+60]
	push	ecx
	mov	ecx, DWORD PTR _pToPlayer$[esp+68]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	$LN1@IsPossible

; 928  : 			return false;

	jmp	$LN465@IsPossible
$LN11@IsPossible:

; 929  : 	}
; 930  : 	// Promise to Vote in upcoming league session
; 931  : 	else if (eItem == TRADE_ITEM_VOTE_COMMITMENT)

	cmp	esi, 19					; 00000013H
	jne	$LN1@IsPossible

; 932  : 	{
; 933  : 		// If we are at war, then we can't until we make peace
; 934  : 		if(pFromTeam->isAtWar(eToTeam))

	mov	edx, DWORD PTR $T235916[esp+64]
	mov	ecx, DWORD PTR _pFromTeam$[esp+64]
	push	edx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 935  : 			return false;

	jne	$LN144@IsPossible

; 936  : 
; 937  : 		int iID = iData1;
; 938  : 		//antonjs: todo: verify iChoice is valid as well:
; 939  : 		//int iChoice = iData2;
; 940  : #ifdef CVASSERT_ENABLE
; 941  : 		int iNumVotes = iData3;
; 942  : #endif
; 943  : 		bool bRepeal = bFlag1;
; 944  : 
; 945  : #ifdef CVASSERT_ENABLE
; 946  : 		DEBUG_VARIABLE(iNumVotes);
; 947  : #endif
; 948  : 
; 949  : #ifndef AUI_LEAGUES_FIX_POSSIBLE_DEALLOCATION_CRASH
; 950  : 		if(GC.getGame().GetGameLeagues()->GetNumActiveLeagues() == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ ; CvGameLeagues::GetNumActiveLeagues
	test	eax, eax

; 951  : 			return false;

	je	$LN144@IsPossible

; 952  : #endif
; 953  : 
; 954  : 		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ ; CvGameLeagues::GetActiveLeague
	mov	esi, eax

; 955  : 		if(pLeague == NULL)

	test	esi, esi

; 956  : 			return false;

	je	$LN144@IsPossible

; 957  : 
; 958  : 		CvAssert(pLeague->IsProposed(iID, bRepeal));
; 959  : #ifdef CVASSERT_ENABLE
; 960  : 		CvAssert(iNumVotes <= pLeague->GetCoreVotesForMember(ePlayer));
; 961  : #endif
; 962  : 		
; 963  : 		// Can't already have a vote commitment in the deal
; 964  : 		if(!bFinalizing && IsVoteCommitmentTrade(ePlayer))

	cmp	BYTE PTR _bFinalizing$[esp+60], 0
	jne	SHORT $LN3@IsPossible
	mov	eax, DWORD PTR _ePlayer$[esp+60]
	mov	ecx, DWORD PTR _this$[esp+64]
	push	eax
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	test	al, al

; 965  : 			return false;

	jne	$LN144@IsPossible
$LN3@IsPossible:

; 966  : 
; 967  : 		// Must be a valid proposal
; 968  : 		if(!pLeague->IsProposed(iID, bRepeal))

	mov	ecx, DWORD PTR _bFlag1$[esp+60]
	mov	edx, DWORD PTR _iData1$[esp+60]
	push	0
	push	ecx
	push	edx
	mov	ecx, esi
	call	?IsProposed@CvLeague@@QAE_NH_N0@Z	; CvLeague::IsProposed
	test	al, al

; 969  : 			return false;

	je	$LN144@IsPossible

; 970  : 
; 971  : 		// This player must be allowed to
; 972  : 		if(!pFromPlayer->GetLeagueAI()->CanCommitVote(eToPlayer))

	mov	eax, DWORD PTR _eToPlayer$[esp+60]
	push	0
	push	eax
	mov	ecx, edi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?CanCommitVote@CvLeagueAI@@QAE_NW4PlayerTypes@@PAVCvString@@@Z ; CvLeagueAI::CanCommitVote
	test	al, al

; 973  : 			return false;

	je	$LN144@IsPossible
$LN1@IsPossible:

; 974  : 	}
; 975  : 
; 976  : 	return true;
; 977  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$0:
	lea	ecx, DWORD PTR _args$221527[ebp-4]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z:
	mov	eax, OFFSET __ehfuncinfo$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ENDP ; CvDeal::IsPossibleToTradeItem
PUBLIC	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iOldValue$ = -12					; size = 4
$T236677 = -8						; size = 8
$T236675 = -8						; size = 8
_eFrom$ = 8						; size = 4
_iNewAmount$ = 12					; size = 4
?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z PROC	; CvDeal::ChangeGoldTrade, COMDAT
; _this$ = ecx

; 1631 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi

; 1632 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1633 : 
; 1634 : 	int iOldValue;
; 1635 : 
; 1636 : 	TradedItemList::iterator it;
; 1637 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T236675[esp+28]
	lea	esi, DWORD PTR [ebp+44]
	push	eax
	mov	ecx, esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T236677[esp+28]
	push	ecx
	mov	ecx, esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	je	$LN4@ChangeGold
$LL17@ChangeGold:

; 1638 : 	{
; 1639 : 		if(it->m_eItemType == TRADE_ITEM_GOLD && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR [edi+8]
	mov	esi, ebx
	imul	esi, 44					; 0000002cH
	cmp	DWORD PTR [edx+esi+8], 0
	lea	eax, DWORD PTR [edx+esi]
	jne	SHORT $LN5@ChangeGold
	mov	edx, DWORD PTR _eFrom$[esp+24]
	cmp	DWORD PTR [eax+36], edx
	jne	SHORT $LN5@ChangeGold

; 1640 : 		{
; 1641 : 			// Reduce Gold value to 0 first, because otherwise IsPossibleToTradeItem will think we're trying to spend more than we have
; 1642 : 			iOldValue = it->m_iData1;

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [eax+esi+20]

; 1643 : 			it->m_iData1 = 0;
; 1644 : 
; 1645 : 			if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD, iNewAmount))

	push	0
	push	1
	push	0
	lea	eax, DWORD PTR [eax+esi+20]
	push	-1
	push	-1
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _iNewAmount$[esp+44]
	push	eax
	push	0
	mov	DWORD PTR _iOldValue$[esp+56], ecx
	push	edx
	mov	ecx, ebp
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	push	edx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	jne	SHORT $LN92@ChangeGold

; 1649 : 			}
; 1650 : 			// If we can't do this then restore the previous Gold quantity
; 1651 : 			else
; 1652 : 			{
; 1653 : 				it->m_iData1 = iOldValue;

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _iOldValue$[esp+28]
	mov	DWORD PTR [ecx+esi+20], edx
$LN5@ChangeGold:

; 1632 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1633 : 
; 1634 : 	int iOldValue;
; 1635 : 
; 1636 : 	TradedItemList::iterator it;
; 1637 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	ebx, 268435455				; 0fffffffH
	jne	SHORT $LN18@ChangeGold
	mov	ebx, DWORD PTR [edi+24]
	jmp	SHORT $LN93@ChangeGold
$LN18@ChangeGold:
	mov	eax, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR [esi+eax]
$LN93@ChangeGold:
	lea	ecx, DWORD PTR $T236677[esp+28]
	push	ecx
	lea	ecx, DWORD PTR [ebp+44]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	jne	$LL17@ChangeGold
$LN4@ChangeGold:
	pop	edi
	pop	esi
	pop	ebp

; 1654 : 			}
; 1655 : 		}
; 1656 : 	}
; 1657 : 	return false;

	xor	al, al
	pop	ebx

; 1658 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN92@ChangeGold:

; 1646 : 			{
; 1647 : 				it->m_iData1 = iNewAmount;

	mov	edx, DWORD PTR [edi+8]
	imul	ebx, 44					; 0000002cH
	mov	eax, DWORD PTR _iNewAmount$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+edx+20], eax
	pop	ebp

; 1648 : 				return true;

	mov	al, 1
	pop	ebx

; 1658 : }

	add	esp, 12					; 0000000cH
	ret	8
?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ENDP	; CvDeal::ChangeGoldTrade
_TEXT	ENDS
PUBLIC	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
$T236930 = -8						; size = 8
$T236928 = -8						; size = 8
_eFrom$ = 8						; size = 4
_iNewAmount$ = 12					; size = 4
_iDuration$ = 16					; size = 4
?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z PROC ; CvDeal::ChangeGoldPerTurnTrade, COMDAT
; _this$ = ecx

; 1674 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 1675 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1676 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1677 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1678 : 
; 1679 : 	TradedItemList::iterator it;
; 1680 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T236928[esp+24]
	lea	edi, DWORD PTR [ebx+44]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T236930[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN3@ChangeGold@2
	npad	2
$LL16@ChangeGold@2:

; 1681 : 	{
; 1682 : 		if(it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR [ebp+8]
	mov	edi, esi
	imul	edi, 44					; 0000002cH
	cmp	DWORD PTR [edx+edi+8], 1
	lea	eax, DWORD PTR [edx+edi]
	jne	SHORT $LN4@ChangeGold@2
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	jne	SHORT $LN4@ChangeGold@2

; 1683 : 		{
; 1684 : 			if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD_PER_TURN, iNewAmount, iDuration))

	mov	eax, DWORD PTR _iDuration$[esp+20]
	mov	ecx, DWORD PTR _iNewAmount$[esp+20]
	push	0
	push	1
	push	0
	push	-1
	push	eax
	push	ecx
	push	1
	push	edx
	mov	ecx, ebx
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	push	edx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	jne	SHORT $LN83@ChangeGold@2
$LN4@ChangeGold@2:

; 1675 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1676 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1677 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1678 : 
; 1679 : 	TradedItemList::iterator it;
; 1680 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN17@ChangeGold@2
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN84@ChangeGold@2
$LN17@ChangeGold@2:
	mov	edx, DWORD PTR [ebp+8]
	mov	esi, DWORD PTR [edi+edx]
$LN84@ChangeGold@2:
	lea	eax, DWORD PTR $T236930[esp+24]
	push	eax
	lea	ecx, DWORD PTR [ebx+44]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL16@ChangeGold@2
$LN3@ChangeGold@2:
	pop	edi
	pop	esi
	pop	ebp

; 1694 : 			}
; 1695 : 		}
; 1696 : 	}
; 1697 : 	return false;

	xor	al, al
	pop	ebx

; 1698 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN83@ChangeGold@2:

; 1685 : 			{
; 1686 : 				it->m_iData1 = iNewAmount;

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR _iNewAmount$[esp+20]

; 1687 : 				it->m_iDuration = iDuration;

	mov	edi, DWORD PTR _iDuration$[esp+20]
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	mov	DWORD PTR [ecx+eax+20], edx
	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ecx+eax+12], edi

; 1688 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1689 : 				it->m_iTurnsRemaining = iDuration;
; 1690 : #else
; 1691 : 				it->m_iFinalTurn = iDuration + GC.getGame().getGameTurn();

	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	esi, DWORD PTR [edx+eax+8]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, edi
	pop	edi
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp

; 1692 : #endif
; 1693 : 				return true;

	mov	al, 1
	pop	ebx

; 1698 : }

	add	esp, 8
	ret	12					; 0000000cH
?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ENDP ; CvDeal::ChangeGoldPerTurnTrade
_TEXT	ENDS
PUBLIC	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z
_TEXT	SEGMENT
$T237157 = -8						; size = 8
$T237155 = -8						; size = 8
_eFrom$ = 8						; size = 4
_eResource$ = 12					; size = 4
_iAmount$ = 16						; size = 4
_iDuration$ = 20					; size = 4
?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z PROC ; CvDeal::ChangeResourceTrade, COMDAT
; _this$ = ecx

; 1716 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi

; 1717 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1718 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1719 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1720 : 
; 1721 : 	TradedItemList::iterator it;
; 1722 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T237155[esp+24]
	lea	edi, DWORD PTR [ebp+44]
	push	eax
	mov	ecx, edi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T237157[esp+24]
	push	ecx
	mov	ecx, edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN3@ChangeReso
	npad	2
$LL16@ChangeReso:

; 1723 : 	{
; 1724 : 		if(it->m_eItemType == TRADE_ITEM_RESOURCES &&
; 1725 : 		        it->m_eFromPlayer == eFrom &&
; 1726 : 		        (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, DWORD PTR [ebx+8]
	mov	edi, esi
	imul	edi, 44					; 0000002cH
	cmp	DWORD PTR [edx+edi+8], 3
	lea	eax, DWORD PTR [edx+edi]
	jne	SHORT $LN4@ChangeReso
	mov	edx, DWORD PTR _eFrom$[esp+20]
	cmp	DWORD PTR [eax+36], edx
	jne	SHORT $LN4@ChangeReso
	mov	ecx, DWORD PTR _eResource$[esp+20]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN4@ChangeReso

; 1727 : 		{
; 1728 : 			if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_RESOURCES, eResource, iAmount))

	mov	eax, DWORD PTR _iAmount$[esp+20]
	push	0
	push	1
	push	0
	push	-1
	push	eax
	push	ecx
	push	3
	push	edx
	mov	ecx, ebp
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	push	edx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	jne	SHORT $LN93@ChangeReso
$LN4@ChangeReso:

; 1717 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1718 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1719 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1720 : 
; 1721 : 	TradedItemList::iterator it;
; 1722 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	cmp	esi, 268435455				; 0fffffffH
	jne	SHORT $LN17@ChangeReso
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN94@ChangeReso
$LN17@ChangeReso:
	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [edi+ecx]
$LN94@ChangeReso:
	lea	edx, DWORD PTR $T237157[esp+24]
	push	edx
	lea	ecx, DWORD PTR [ebp+44]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LL16@ChangeReso
$LN3@ChangeReso:
	pop	edi
	pop	esi
	pop	ebp

; 1738 : 			}
; 1739 : 		}
; 1740 : 	}
; 1741 : 	return false;

	xor	al, al
	pop	ebx

; 1742 : }

	add	esp, 8
	ret	16					; 00000010H
$LN93@ChangeReso:

; 1729 : 			{
; 1730 : 				it->m_iData2 = iAmount;

	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR _iAmount$[esp+20]
	mov	eax, esi

; 1731 : 				it->m_iDuration = iDuration;

	mov	esi, DWORD PTR _iDuration$[esp+20]
	imul	eax, 44					; 0000002cH
	mov	DWORD PTR [ecx+eax+24], edx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx+eax+12], esi

; 1732 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1733 : 				it->m_iTurnsRemaining = iDuration;
; 1734 : #else
; 1735 : 				it->m_iFinalTurn = iDuration + GC.getGame().getGameTurn();

	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	edi, DWORD PTR [edx+eax+8]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi
	pop	ebp

; 1736 : #endif
; 1737 : 				return true;

	mov	al, 1
	pop	ebx

; 1742 : }

	add	esp, 8
	ret	16					; 00000010H
?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ENDP ; CvDeal::ChangeResourceTrade
_TEXT	ENDS
PUBLIC	?DestroyDeal@CvGameDeals@@QAEXI@Z		; CvGameDeals::DestroyDeal
; Function compile flags: /Ogtpy
;	COMDAT ?DestroyDeal@CvGameDeals@@QAEXI@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?DestroyDeal@CvGameDeals@@QAEXI@Z PROC			; CvGameDeals::DestroyDeal, COMDAT
; _this$ = ecx

; 3879 : {

	push	esi
	push	edi
	mov	edi, ecx

; 3880 : 	std::vector<std::pair<uint, CvDeal*> >::iterator it = m_Deals.end();
; 3881 : 	for(it = m_Deals.begin();

	mov	esi, DWORD PTR [edi+4692]

; 3882 : 	        it != m_Deals.end(); ++it)

	mov	eax, DWORD PTR [edi+4696]
	cmp	esi, eax
	je	SHORT $LN71@DestroyDea
	mov	ecx, DWORD PTR _index$[esp+4]
$LL24@DestroyDea:

; 3883 : 	{
; 3884 : 		if((*it).first == index)

	cmp	DWORD PTR [esi], ecx
	je	SHORT $LN75@DestroyDea
	add	esi, 8
	cmp	esi, eax
	jne	SHORT $LL24@DestroyDea
$LN75@DestroyDea:

; 3885 : 			break;
; 3886 : 	}
; 3887 : 
; 3888 : 	if(it != m_Deals.end())

	cmp	esi, eax
	je	SHORT $LN71@DestroyDea

; 3889 : 	{
; 3890 : 		delete(*it).second;

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN8@DestroyDea
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN8@DestroyDea:

; 3891 : 		m_Deals.erase(it);

	mov	edx, DWORD PTR [edi+4696]
	lea	eax, DWORD PTR [esi+8]
	cmp	eax, edx
	je	SHORT $LN62@DestroyDea
	lea	ecx, DWORD PTR [eax-8]
$LL64@DestroyDea:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL64@DestroyDea
$LN62@DestroyDea:
	add	DWORD PTR [edi+4696], -8		; fffffff8H
$LN71@DestroyDea:
	pop	edi
	pop	esi

; 3892 : 	}
; 3893 : }

	ret	4
?DestroyDeal@CvGameDeals@@QAEXI@Z ENDP			; CvGameDeals::DestroyDeal
_TEXT	ENDS
PUBLIC	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z
_TEXT	SEGMENT
$T237618 = -44						; size = 44
_x$ = 8							; size = 4
?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z PROC ; FFastList<CvTradedItem,21,0>::push_back, COMDAT
; _this$ = ecx

; 177  : 	unsigned int push_back( const T& x ){

	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi

; 178  : 		return BASE_TYPE::push_back( MultiListNodePolicy< T >(x) );

	mov	esi, DWORD PTR _x$[esp+48]
	push	edi
	mov	ebx, ecx
	mov	ecx, 9
	lea	edi, DWORD PTR $T237618[esp+64]
	lea	eax, DWORD PTR $T237618[esp+56]
	rep movsd
	push	eax
	mov	ecx, ebx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebx+20]
	cmp	DWORD PTR [ebx+24], 268435455		; 0fffffffH
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+28], esi
	jne	SHORT $LN9@push_back@5
	mov	DWORD PTR [ebx+24], esi
$LN9@push_back@5:
	push	eax
	push	esi
	mov	ecx, ebx
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 179  : 	};

	add	esp, 44					; 0000002cH
	ret	4
?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ENDP ; FFastList<CvTradedItem,21,0>::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	je	SHORT $LN15@clear@2
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN40@clear@2
	push	edi
$LL42@clear@2:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL42@clear@2
	pop	edi
$LN40@clear@2:
	mov	DWORD PTR [ecx+8], edx
$LN15@clear@2:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::clear
_TEXT	ENDS
PUBLIC	??0?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ ; FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>::FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ PROC ; FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>::FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>, COMDAT
; _this$ = ecx

; 721  : 	FCustomList() : CORE() {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	edx, 268435455				; 0fffffffH
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], edx
	mov	DWORD PTR [eax+28], edx
	ret	0
??0?$FCustomList@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@$0A@@@QAE@XZ ENDP ; FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>::FCustomList<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,0>
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$2
__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$0
__unwindtable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
__Tmp$224043 = -24					; size = 8
__Tmp$224025 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$238086 = 8					; size = 1
__Cat$238014 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$224010 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T238083 = 16						; size = 1
$T238011 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$224010[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$238014[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T238011[ebp], 0
	mov	ecx, DWORD PTR $T238011[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$224010[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T238083[ebp], 0
	mov	edx, DWORD PTR $T238083[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$238086[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$224010[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224010[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$224025[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224025[ebp], edx
	call	??$_Umove@PAU?$pair@IPAVCvDeal@@@std@@@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@1@PAU21@00@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Umove<std::pair<unsigned int,CvDeal *> *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224025[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$224025[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z ; std::fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$224043[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224043[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAU?$pair@IPAVCvDeal@@@std@@@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEPAU?$pair@IPAVCvDeal@@@1@PAU21@00@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Umove<std::pair<unsigned int,CvDeal *> *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAU?$pair@IPAVCvDeal@@@std@@PAU12@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00@Z ; stdext::_Unchecked_move_backward<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$224043[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAU?$pair@IPAVCvDeal@@@std@@U12@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@0ABU10@@Z ; std::fill<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> >
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n
PUBLIC	??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ	; FFastList<CvTradedItem,21,0>::~FFastList<CvTradedItem,21,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC	; FFastList<CvTradedItem,21,0>::~FFastList<CvTradedItem,21,0>, COMDAT
; _this$ = ecx
	xor	eax, eax
	mov	DWORD PTR [ecx], 268435455		; 0fffffffH
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP	; FFastList<CvTradedItem,21,0>::~FFastList<CvTradedItem,21,0>
_TEXT	ENDS
PUBLIC	??_7CvDeal@@6B@					; CvDeal::`vftable'
PUBLIC	??1CvDeal@@UAE@XZ				; CvDeal::~CvDeal
PUBLIC	??_R4CvDeal@@6B@				; CvDeal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvDeal@@@8				; CvDeal `RTTI Type Descriptor'
PUBLIC	??_R3CvDeal@@8					; CvDeal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvDeal@@8					; CvDeal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvDeal@@8				; CvDeal::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECvDeal@@UAEPAXI@Z:PROC			; CvDeal::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvDeal@@8
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvDeal@@8 DD FLAT:??_R0?AVCvDeal@@@8	; CvDeal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvDeal@@8
rdata$r	ENDS
;	COMDAT ??_R2CvDeal@@8
rdata$r	SEGMENT
??_R2CvDeal@@8 DD FLAT:??_R1A@?0A@EA@CvDeal@@8		; CvDeal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvDeal@@8
rdata$r	SEGMENT
??_R3CvDeal@@8 DD 00H					; CvDeal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvDeal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvDeal@@@8
_DATA	SEGMENT
??_R0?AVCvDeal@@@8 DD FLAT:??_7type_info@@6B@		; CvDeal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvDeal@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvDeal@@6B@
rdata$r	SEGMENT
??_R4CvDeal@@6B@ DD 00H					; CvDeal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvDeal@@@8
	DD	FLAT:??_R3CvDeal@@8
rdata$r	ENDS
;	COMDAT ??_7CvDeal@@6B@
CONST	SEGMENT
??_7CvDeal@@6B@ DD FLAT:??_R4CvDeal@@6B@		; CvDeal::`vftable'
	DD	FLAT:??_ECvDeal@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
CONST	ENDS
;	COMDAT ??1CvDeal@@UAE@XZ
_TEXT	SEGMENT
??1CvDeal@@UAE@XZ PROC					; CvDeal::~CvDeal, COMDAT
; _this$ = ecx

; 207  : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvDeal@@6B@

; 208  : #ifdef AUI_EXPLICIT_DESTRUCTION
; 209  : 	m_TradedItems.clear();
; 210  : #endif
; 211  : }

	xor	eax, eax
	mov	DWORD PTR [ecx+44], 268435455		; 0fffffffH
	mov	DWORD PTR [ecx+56], eax
	mov	DWORD PTR [ecx+48], eax
	mov	ecx, DWORD PTR [ecx+52]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1CvDeal@@UAE@XZ ENDP					; CvDeal::~CvDeal
_TEXT	ENDS
PUBLIC	??4CvDeal@@QAEAAV0@ABV0@@Z			; CvDeal::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvDeal@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
tv384 = -64						; size = 4
_it$ = -60						; size = 8
$T238580 = -52						; size = 8
$T238578 = -52						; size = 8
$T238702 = -44						; size = 44
tv390 = 8						; size = 4
_source$ = 8						; size = 4
??4CvDeal@@QAEAAV0@ABV0@@Z PROC				; CvDeal::operator=, COMDAT
; _this$ = ecx

; 215  : {

	sub	esp, 64					; 00000040H
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi

; 216  : 	m_eFromPlayer = source.m_eFromPlayer;

	mov	esi, DWORD PTR _source$[esp+72]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebp+4], eax

; 217  : 	m_eToPlayer = source.m_eToPlayer;

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ebp+8], ecx

; 218  : 	m_iDuration = source.m_iDuration;

	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [ebp+20], edx

; 219  : 	m_iFinalTurn = source.m_iFinalTurn;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ebp+16], eax

; 220  : 	m_iStartTurn = source.m_iStartTurn;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ebp+12], ecx

; 221  : 	m_ePeaceTreatyType = source.m_ePeaceTreatyType;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [ebp+24], edx

; 222  : 	m_eSurrenderingPlayer = source.m_eSurrenderingPlayer;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ebp+28], eax

; 223  : 	m_eDemandingPlayer = source.m_eDemandingPlayer;

	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ebp+32], ecx

; 224  : 	m_eRequestingPlayer = source.m_eRequestingPlayer;

	mov	edx, DWORD PTR [esi+36]
	mov	DWORD PTR [ebp+36], edx

; 225  : 	m_bConsideringForRenewal = source.m_bConsideringForRenewal;

	mov	al, BYTE PTR [esi+40]
	mov	BYTE PTR [ebp+40], al

; 226  : 	m_bCheckedForRenewal = source.m_bCheckedForRenewal;

	mov	cl, BYTE PTR [esi+41]
	mov	BYTE PTR [ebp+41], cl

; 227  : 	m_bDealCancelled = source.m_bDealCancelled;

	mov	dl, BYTE PTR [esi+42]
	push	edi

; 228  : 	m_TradedItems.clear();

	lea	ebx, DWORD PTR [ebp+44]
	mov	BYTE PTR [ebp+42], dl
	mov	eax, DWORD PTR [ebx+24]
	push	268435455				; 0fffffffH
	push	eax
	mov	ecx, ebx
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 229  : 	TradedItemList::const_iterator it;
; 230  : 	for(it = source.m_TradedItems.begin(); it != source.m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR $T238578[esp+80]
	add	esi, 44					; 0000002cH
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR tv384[esp+84], esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T238580[esp+80]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _it$[esp+84], edx
	mov	DWORD PTR _it$[esp+88], edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	$LN55@operator@8
	jmp	SHORT $LN18@operator@8
	npad	1
$LL56@operator@8:
	mov	edi, DWORD PTR _it$[esp+84]
$LN18@operator@8:

; 231  : 	{
; 232  : 		m_TradedItems.push_back(*it);

	mov	ecx, DWORD PTR _it$[esp+80]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, edi
	imul	eax, 44					; 0000002cH
	lea	esi, DWORD PTR [edx+eax+8]
	mov	DWORD PTR tv390[esp+76], eax
	mov	ecx, 9
	lea	edi, DWORD PTR $T238702[esp+88]
	lea	eax, DWORD PTR $T238702[esp+80]
	rep movsd
	push	eax
	mov	ecx, ebx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+28]
	mov	esi, 268435455				; 0fffffffH
	mov	DWORD PTR [ebx+28], eax
	cmp	DWORD PTR [ebx+24], esi
	jne	SHORT $LN50@operator@8
	mov	DWORD PTR [ebx+24], eax
$LN50@operator@8:
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	cmp	DWORD PTR _it$[esp+84], esi
	jne	SHORT $LN19@operator@8
	mov	ecx, DWORD PTR _it$[esp+80]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[esp+84], edx
	jmp	SHORT $LN54@operator@8

; 229  : 	TradedItemList::const_iterator it;
; 230  : 	for(it = source.m_TradedItems.begin(); it != source.m_TradedItems.end(); ++it)

$LN19@operator@8:
	mov	eax, DWORD PTR _it$[esp+80]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR tv390[esp+76]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _it$[esp+84], eax
$LN54@operator@8:
	lea	ecx, DWORD PTR $T238580[esp+80]
	push	ecx
	mov	ecx, DWORD PTR tv384[esp+84]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	edx, DWORD PTR _it$[esp+84]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL56@operator@8
$LN55@operator@8:
	pop	edi
	pop	esi

; 233  : 	}
; 234  : 
; 235  : 	return (*this);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 236  : }

	add	esp, 64					; 00000040H
	ret	4
??4CvDeal@@QAEAAV0@ABV0@@Z ENDP				; CvDeal::operator=
_TEXT	ENDS
PUBLIC	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddGoldTrade
; Function compile flags: /Ogtpy
;	COMDAT ?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221648 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iAmount$ = 12						; size = 4
?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddGoldTrade, COMDAT
; _this$ = ecx

; 1120 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1121 : 	CvAssertMsg(iAmount >= 0, "DEAL: Trying to add a negative amount of Gold to a deal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1122 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1123 : 
; 1124 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD, iAmount))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN4@AddGoldTra
	mov	eax, DWORD PTR [esi+8]
$LN4@AddGoldTra:
	mov	ebp, DWORD PTR _iAmount$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	ebx
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN1@AddGoldTra

; 1125 : 	{
; 1126 : 		CvTradedItem item;
; 1127 : 		item.m_eItemType = TRADE_ITEM_GOLD;
; 1128 : 		item.m_iDuration = 0;
; 1129 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1130 : 		item.m_iTurnsRemaining = -1;
; 1131 : #else
; 1132 : 		item.m_iFinalTurn = -1;
; 1133 : #endif
; 1134 : 		item.m_iData1 = iAmount;
; 1135 : 		item.m_eFromPlayer = eFrom;
; 1136 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221648[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221648[esp+72], ebx
	mov	DWORD PTR _item$221648[esp+76], ebx
	mov	BYTE PTR _item$221648[esp+80], bl
	mov	BYTE PTR _item$221648[esp+88], bl
	mov	BYTE PTR _item$221648[esp+89], bl
	mov	DWORD PTR _item$221648[esp+56], ebx
	mov	DWORD PTR _item$221648[esp+60], ebx
	mov	DWORD PTR _item$221648[esp+64], -1
	mov	DWORD PTR _item$221648[esp+68], ebp
	mov	DWORD PTR _item$221648[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN1@AddGoldTra:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1137 : 	}
; 1138 : }

	add	esp, 36					; 00000024H
	ret	8
?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddGoldTrade
_TEXT	ENDS
PUBLIC	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
; Function compile flags: /Ogtpy
;	COMDAT ?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_item$221656 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iDuration$ = 16					; size = 4
?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z PROC ; CvDeal::AddGoldPerTurnTrade, COMDAT
; _this$ = ecx

; 1142 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1143 : 	CvAssertMsg(iAmount >= 0, "DEAL: Trying to add a negative amount of GPT to a deal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1144 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1145 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1146 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1147 : 
; 1148 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD_PER_TURN, iAmount, iDuration))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddGoldPer
	mov	eax, DWORD PTR [esi+8]
$LN5@AddGoldPer:
	mov	ebp, DWORD PTR _iDuration$[esp+48]
	mov	ecx, DWORD PTR _iAmount$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	ebp
	push	ecx
	push	1
	push	eax
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddGoldPer

; 1149 : 	{
; 1150 : 		CvTradedItem item;
; 1151 : 		item.m_eItemType = TRADE_ITEM_GOLD_PER_TURN;
; 1152 : 		item.m_iDuration = iDuration;
; 1153 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1154 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1155 : 		item.m_iTurnsRemaining = -1;
; 1156 : #else
; 1157 : 		item.m_iFinalTurn = -1;
; 1158 : #endif
; 1159 : 		item.m_iData1 = iAmount;

	mov	edx, DWORD PTR _iAmount$[esp+48]

; 1160 : 		item.m_eFromPlayer = eFrom;
; 1161 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221656[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221656[esp+72], ebx
	mov	DWORD PTR _item$221656[esp+76], ebx
	mov	BYTE PTR _item$221656[esp+80], bl
	mov	BYTE PTR _item$221656[esp+88], bl
	mov	BYTE PTR _item$221656[esp+89], bl
	mov	DWORD PTR _item$221656[esp+56], 1
	mov	DWORD PTR _item$221656[esp+60], ebp
	mov	DWORD PTR _item$221656[esp+64], -1
	mov	DWORD PTR _item$221656[esp+68], edx
	mov	DWORD PTR _item$221656[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddGoldPer:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1162 : 	}
; 1163 : 	else
; 1164 : 	{
; 1165 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid GPT amount to a deal");
; 1166 : 	}
; 1167 : }

	add	esp, 36					; 00000024H
	ret	12					; 0000000cH
?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ENDP ; CvDeal::AddGoldPerTurnTrade
_TEXT	ENDS
PUBLIC	?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::AddMapTrade
; Function compile flags: /Ogtpy
;	COMDAT ?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_item$221663 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z PROC		; CvDeal::AddMapTrade, COMDAT
; _this$ = ecx

; 1171 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1172 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1173 : 
; 1174 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_MAPS))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+44]
	cmp	eax, edi
	jne	SHORT $LN5@AddMapTrad
	mov	eax, DWORD PTR [esi+8]
$LN5@AddMapTrad:
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	-1
	push	2
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddMapTrad

; 1175 : 	{
; 1176 : 		CvTradedItem item;
; 1177 : 		item.m_eItemType = TRADE_ITEM_MAPS;
; 1178 : 		item.m_iDuration = 0;
; 1179 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1180 : 		item.m_iTurnsRemaining = -1;
; 1181 : #else
; 1182 : 		item.m_iFinalTurn = -1;
; 1183 : #endif
; 1184 : 		item.m_eFromPlayer = eFrom;
; 1185 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221663[esp+48]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221663[esp+64], ebx
	mov	DWORD PTR _item$221663[esp+68], ebx
	mov	DWORD PTR _item$221663[esp+72], ebx
	mov	BYTE PTR _item$221663[esp+76], bl
	mov	BYTE PTR _item$221663[esp+84], bl
	mov	BYTE PTR _item$221663[esp+85], bl
	mov	DWORD PTR _item$221663[esp+52], 2
	mov	DWORD PTR _item$221663[esp+56], ebx
	mov	DWORD PTR _item$221663[esp+60], -1
	mov	DWORD PTR _item$221663[esp+80], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddMapTrad:
	pop	edi
	pop	esi
	pop	ebx

; 1186 : 	}
; 1187 : 	else
; 1188 : 	{
; 1189 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Map item to a deal");
; 1190 : 	}
; 1191 : }

	add	esp, 36					; 00000024H
	ret	4
?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP		; CvDeal::AddMapTrade
_TEXT	ENDS
PUBLIC	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z
_TEXT	SEGMENT
_item$221673 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eResource$ = 12					; size = 4
_iAmount$ = 16						; size = 4
_iDuration$ = 20					; size = 4
?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z PROC ; CvDeal::AddResourceTrade, COMDAT
; _this$ = ecx

; 1195 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1196 : 	CvAssertMsg(iAmount >= 0, "DEAL: Trying to add a negative amount of a Resource to a deal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1197 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1198 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1199 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1200 : 
; 1201 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_RESOURCES, eResource, iAmount))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddResourc
	mov	eax, DWORD PTR [esi+8]
$LN5@AddResourc:
	mov	ebp, DWORD PTR _iAmount$[esp+48]
	mov	ebx, DWORD PTR _eResource$[esp+48]
	push	0
	push	1
	push	0
	push	-1
	push	ebp
	push	ebx
	push	3
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddResourc

; 1202 : 	{
; 1203 : 		CvTradedItem item;
; 1204 : 		item.m_eItemType = TRADE_ITEM_RESOURCES;
; 1205 : 		item.m_iDuration = iDuration;

	mov	eax, DWORD PTR _iDuration$[esp+48]

; 1206 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1207 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1208 : 		item.m_iTurnsRemaining = -1;
; 1209 : #else
; 1210 : 		item.m_iFinalTurn = -1;
; 1211 : #endif
; 1212 : 		item.m_iData1 = (int)eResource;
; 1213 : 		item.m_iData2 = iAmount;
; 1214 : 		item.m_eFromPlayer = eFrom;
; 1215 : 		m_TradedItems.push_back(item);

	lea	ecx, DWORD PTR _item$221673[esp+52]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221673[esp+76], 0
	mov	BYTE PTR _item$221673[esp+80], 0
	mov	BYTE PTR _item$221673[esp+88], 0
	mov	BYTE PTR _item$221673[esp+89], 0
	mov	DWORD PTR _item$221673[esp+56], 3
	mov	DWORD PTR _item$221673[esp+60], eax
	mov	DWORD PTR _item$221673[esp+64], -1
	mov	DWORD PTR _item$221673[esp+68], ebx
	mov	DWORD PTR _item$221673[esp+72], ebp
	mov	DWORD PTR _item$221673[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddResourc:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1216 : 	}
; 1217 : 	else
; 1218 : 	{
; 1219 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Resource to a deal");
; 1220 : 	}
; 1221 : }

	add	esp, 36					; 00000024H
	ret	16					; 00000010H
?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ENDP ; CvDeal::AddResourceTrade
_TEXT	ENDS
PUBLIC	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddCityTrade
; Function compile flags: /Ogtpy
;	COMDAT ?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221685 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iCityID$ = 12						; size = 4
?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddCityTrade, COMDAT
; _this$ = ecx

; 1226 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1227 : 
; 1228 : 	CvCity* pCity = GET_PLAYER(eFrom).getCity(iCityID);

	mov	eax, DWORD PTR _iCityID$[esp-4]
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	mov	esi, ecx
	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1229 : 	int x = pCity->getX();

	mov	ebp, DWORD PTR [eax+96]

; 1230 : 	int y = pCity->getY();

	mov	ebx, DWORD PTR [eax+108]

; 1231 : 
; 1232 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_CITIES, x, y))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	jne	SHORT $LN15@AddCityTra
	mov	eax, DWORD PTR [esi+8]
$LN15@AddCityTra:
	push	0
	push	1
	push	0
	push	-1
	push	ebx
	push	ebp
	push	4
	push	eax
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddCityTra

; 1233 : 	{
; 1234 : 		CvTradedItem item;

	xor	eax, eax

; 1235 : 		item.m_eItemType = TRADE_ITEM_CITIES;
; 1236 : 		item.m_iDuration = 0;
; 1237 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1238 : 		item.m_iTurnsRemaining = -1;
; 1239 : #else
; 1240 : 		item.m_iFinalTurn = -1;
; 1241 : #endif
; 1242 : 
; 1243 : 		item.m_iData1 = x;
; 1244 : 		item.m_iData2 = y;
; 1245 : 
; 1246 : 		item.m_eFromPlayer = eFrom;
; 1247 : 		m_TradedItems.push_back(item);

	lea	ecx, DWORD PTR _item$221685[esp+52]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221685[esp+76], eax
	mov	BYTE PTR _item$221685[esp+80], al
	mov	BYTE PTR _item$221685[esp+88], al
	mov	BYTE PTR _item$221685[esp+89], al
	mov	DWORD PTR _item$221685[esp+56], 4
	mov	DWORD PTR _item$221685[esp+60], eax
	mov	DWORD PTR _item$221685[esp+64], -1
	mov	DWORD PTR _item$221685[esp+68], ebp
	mov	DWORD PTR _item$221685[esp+72], ebx
	mov	DWORD PTR _item$221685[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddCityTra:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1248 : 	}
; 1249 : 	else
; 1250 : 	{
; 1251 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid City to a deal");
; 1252 : 	}
; 1253 : }

	add	esp, 36					; 00000024H
	ret	8
?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddCityTrade
_TEXT	ENDS
PUBLIC	?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddUnitTrade
; Function compile flags: /Ogtpy
;	COMDAT ?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221693 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iUnitID$ = 12						; size = 4
?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddUnitTrade, COMDAT
; _this$ = ecx

; 1257 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1258 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1259 : 
; 1260 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_UNITS, iUnitID))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddUnitTra
	mov	eax, DWORD PTR [esi+8]
$LN5@AddUnitTra:
	mov	ebp, DWORD PTR _iUnitID$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	5
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddUnitTra

; 1261 : 	{
; 1262 : 		CvTradedItem item;
; 1263 : 		item.m_eItemType = TRADE_ITEM_UNITS;
; 1264 : 		item.m_iDuration = 0;
; 1265 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1266 : 		item.m_iTurnsRemaining = -1;
; 1267 : #else
; 1268 : 		item.m_iFinalTurn = -1;
; 1269 : #endif
; 1270 : 		item.m_iData1 = iUnitID;
; 1271 : 		item.m_eFromPlayer = eFrom;
; 1272 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221693[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221693[esp+72], ebx
	mov	DWORD PTR _item$221693[esp+76], ebx
	mov	BYTE PTR _item$221693[esp+80], bl
	mov	BYTE PTR _item$221693[esp+88], bl
	mov	BYTE PTR _item$221693[esp+89], bl
	mov	DWORD PTR _item$221693[esp+56], 5
	mov	DWORD PTR _item$221693[esp+60], ebx
	mov	DWORD PTR _item$221693[esp+64], -1
	mov	DWORD PTR _item$221693[esp+68], ebp
	mov	DWORD PTR _item$221693[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddUnitTra:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1273 : 	}
; 1274 : 	else
; 1275 : 	{
; 1276 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Unit to a deal");
; 1277 : 	}
; 1278 : }

	add	esp, 36					; 00000024H
	ret	8
?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddUnitTrade
_TEXT	ENDS
PUBLIC	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::AddAllowEmbassy
; Function compile flags: /Ogtpy
;	COMDAT ?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_item$221700 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::AddAllowEmbassy, COMDAT
; _this$ = ecx

; 1282 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1283 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1284 : 
; 1285 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_ALLOW_EMBASSY))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+44]
	cmp	eax, edi
	jne	SHORT $LN5@AddAllowEm
	mov	eax, DWORD PTR [esi+8]
$LN5@AddAllowEm:
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddAllowEm

; 1286 : 	{
; 1287 : 		CvTradedItem item;
; 1288 : 		item.m_eItemType = TRADE_ITEM_ALLOW_EMBASSY;
; 1289 : 		item.m_eFromPlayer = eFrom;
; 1290 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221700[esp+48]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221700[esp+56], ebx
	mov	DWORD PTR _item$221700[esp+60], ebx
	mov	DWORD PTR _item$221700[esp+64], ebx
	mov	DWORD PTR _item$221700[esp+68], ebx
	mov	DWORD PTR _item$221700[esp+72], ebx
	mov	BYTE PTR _item$221700[esp+76], bl
	mov	BYTE PTR _item$221700[esp+84], bl
	mov	BYTE PTR _item$221700[esp+85], bl
	mov	DWORD PTR _item$221700[esp+52], 17	; 00000011H
	mov	DWORD PTR _item$221700[esp+80], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddAllowEm:
	pop	edi
	pop	esi
	pop	ebx

; 1291 : 	}
; 1292 : 	else
; 1293 : 	{
; 1294 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Allow Embassy item to a deal");
; 1295 : 	}
; 1296 : }

	add	esp, 36					; 00000024H
	ret	4
?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::AddAllowEmbassy
_TEXT	ENDS
PUBLIC	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddOpenBorders
; Function compile flags: /Ogtpy
;	COMDAT ?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221708 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddOpenBorders, COMDAT
; _this$ = ecx

; 1300 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1301 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1302 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1303 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1304 : 
; 1305 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_OPEN_BORDERS, iDuration))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddOpenBor
	mov	eax, DWORD PTR [esi+8]
$LN5@AddOpenBor:
	mov	ebp, DWORD PTR _iDuration$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	6
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddOpenBor

; 1306 : 	{
; 1307 : 		CvTradedItem item;
; 1308 : 		item.m_eItemType = TRADE_ITEM_OPEN_BORDERS;
; 1309 : 		item.m_iDuration = iDuration;
; 1310 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1311 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1312 : 		item.m_iTurnsRemaining = -1;
; 1313 : #else
; 1314 : 		item.m_iFinalTurn = -1;
; 1315 : #endif
; 1316 : 		item.m_eFromPlayer = eFrom;
; 1317 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221708[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221708[esp+68], ebx
	mov	DWORD PTR _item$221708[esp+72], ebx
	mov	DWORD PTR _item$221708[esp+76], ebx
	mov	BYTE PTR _item$221708[esp+80], bl
	mov	BYTE PTR _item$221708[esp+88], bl
	mov	BYTE PTR _item$221708[esp+89], bl
	mov	DWORD PTR _item$221708[esp+56], 6
	mov	DWORD PTR _item$221708[esp+60], ebp
	mov	DWORD PTR _item$221708[esp+64], -1
	mov	DWORD PTR _item$221708[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddOpenBor:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1318 : 	}
; 1319 : 	else
; 1320 : 	{
; 1321 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Open Borders item to a deal");
; 1322 : 	}
; 1323 : }

	add	esp, 36					; 00000024H
	ret	8
?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddOpenBorders
_TEXT	ENDS
PUBLIC	?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddDefensivePact
; Function compile flags: /Ogtpy
;	COMDAT ?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221716 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddDefensivePact, COMDAT
; _this$ = ecx

; 1327 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1328 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1329 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1330 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1331 : 
; 1332 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_DEFENSIVE_PACT, iDuration))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddDefensi
	mov	eax, DWORD PTR [esi+8]
$LN5@AddDefensi:
	mov	ebp, DWORD PTR _iDuration$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	7
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddDefensi

; 1333 : 	{
; 1334 : 		CvTradedItem item;
; 1335 : 		item.m_eItemType = TRADE_ITEM_DEFENSIVE_PACT;
; 1336 : 		item.m_iDuration = iDuration;
; 1337 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1338 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1339 : 		item.m_iTurnsRemaining = -1;
; 1340 : #else
; 1341 : 		item.m_iFinalTurn = -1;
; 1342 : #endif
; 1343 : 		item.m_eFromPlayer = eFrom;
; 1344 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221716[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221716[esp+68], ebx
	mov	DWORD PTR _item$221716[esp+72], ebx
	mov	DWORD PTR _item$221716[esp+76], ebx
	mov	BYTE PTR _item$221716[esp+80], bl
	mov	BYTE PTR _item$221716[esp+88], bl
	mov	BYTE PTR _item$221716[esp+89], bl
	mov	DWORD PTR _item$221716[esp+56], 7
	mov	DWORD PTR _item$221716[esp+60], ebp
	mov	DWORD PTR _item$221716[esp+64], -1
	mov	DWORD PTR _item$221716[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddDefensi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1345 : 	}
; 1346 : 	else
; 1347 : 	{
; 1348 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Defensive Pact item to a deal");
; 1349 : 	}
; 1350 : }

	add	esp, 36					; 00000024H
	ret	8
?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddDefensivePact
_TEXT	ENDS
PUBLIC	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddResearchAgreement
; Function compile flags: /Ogtpy
;	COMDAT ?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221724 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC ; CvDeal::AddResearchAgreement, COMDAT
; _this$ = ecx

; 1354 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1355 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1356 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1357 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1358 : 
; 1359 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_RESEARCH_AGREEMENT, iDuration))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddResearc
	mov	eax, DWORD PTR [esi+8]
$LN5@AddResearc:
	mov	ebp, DWORD PTR _iDuration$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	8
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddResearc

; 1360 : 	{
; 1361 : 		CvTradedItem item;
; 1362 : 		item.m_eItemType = TRADE_ITEM_RESEARCH_AGREEMENT;
; 1363 : 		item.m_iDuration = iDuration;
; 1364 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1365 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1366 : 		item.m_iTurnsRemaining = -1;
; 1367 : #else
; 1368 : 		item.m_iFinalTurn = -1;
; 1369 : #endif
; 1370 : 		item.m_eFromPlayer = eFrom;
; 1371 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221724[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221724[esp+68], ebx
	mov	DWORD PTR _item$221724[esp+72], ebx
	mov	DWORD PTR _item$221724[esp+76], ebx
	mov	BYTE PTR _item$221724[esp+80], bl
	mov	BYTE PTR _item$221724[esp+88], bl
	mov	BYTE PTR _item$221724[esp+89], bl
	mov	DWORD PTR _item$221724[esp+56], 8
	mov	DWORD PTR _item$221724[esp+60], ebp
	mov	DWORD PTR _item$221724[esp+64], -1
	mov	DWORD PTR _item$221724[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddResearc:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1372 : 	}
; 1373 : 	else
; 1374 : 	{
; 1375 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Research Agreement item to a deal");
; 1376 : 	}
; 1377 : }

	add	esp, 36					; 00000024H
	ret	8
?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP ; CvDeal::AddResearchAgreement
_TEXT	ENDS
PUBLIC	?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddTradeAgreement
; Function compile flags: /Ogtpy
;	COMDAT ?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221732 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddTradeAgreement, COMDAT
; _this$ = ecx

; 1381 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1382 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1383 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1384 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1385 : 
; 1386 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_TRADE_AGREEMENT, iDuration))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddTradeAg
	mov	eax, DWORD PTR [esi+8]
$LN5@AddTradeAg:
	mov	ebp, DWORD PTR _iDuration$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	9
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddTradeAg

; 1387 : 	{
; 1388 : 		CvTradedItem item;
; 1389 : 		item.m_eItemType = TRADE_ITEM_TRADE_AGREEMENT;
; 1390 : 		item.m_iDuration = iDuration;
; 1391 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1392 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1393 : 		item.m_iTurnsRemaining = -1;
; 1394 : #else
; 1395 : 		item.m_iFinalTurn = -1;
; 1396 : #endif
; 1397 : 		item.m_eFromPlayer = eFrom;
; 1398 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221732[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221732[esp+68], ebx
	mov	DWORD PTR _item$221732[esp+72], ebx
	mov	DWORD PTR _item$221732[esp+76], ebx
	mov	BYTE PTR _item$221732[esp+80], bl
	mov	BYTE PTR _item$221732[esp+88], bl
	mov	BYTE PTR _item$221732[esp+89], bl
	mov	DWORD PTR _item$221732[esp+56], 9
	mov	DWORD PTR _item$221732[esp+60], ebp
	mov	DWORD PTR _item$221732[esp+64], -1
	mov	DWORD PTR _item$221732[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddTradeAg:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1399 : 	}
; 1400 : 	else
; 1401 : 	{
; 1402 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Trade Agreement item to a deal");
; 1403 : 	}
; 1404 : }

	add	esp, 36					; 00000024H
	ret	8
?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddTradeAgreement
_TEXT	ENDS
PUBLIC	?AddPermamentAlliance@CvDeal@@QAEXXZ		; CvDeal::AddPermamentAlliance
; Function compile flags: /Ogtpy
;	COMDAT ?AddPermamentAlliance@CvDeal@@QAEXXZ
_TEXT	SEGMENT
_item$221737 = -80					; size = 36
$T238903 = -44						; size = 44
?AddPermamentAlliance@CvDeal@@QAEXXZ PROC		; CvDeal::AddPermamentAlliance, COMDAT
; _this$ = ecx

; 1408 : {

	sub	esp, 80					; 00000050H

; 1409 : //	if (IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_PERMANENT_ALLIANCE, iDuration))
; 1410 : 	{
; 1411 : 		CvTradedItem item;

	xor	eax, eax
	push	ebx
	push	esi
	push	edi

; 1412 : 		item.m_eItemType = TRADE_ITEM_PERMANENT_ALLIANCE;
; 1413 : 		item.m_iDuration = 0;
; 1414 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1415 : 		item.m_iTurnsRemaining = -1;
; 1416 : #else
; 1417 : 		item.m_iFinalTurn = -1;
; 1418 : #endif
; 1419 : 		m_TradedItems.push_back(item);

	lea	ebx, DWORD PTR [ecx+44]
	or	edx, -1
	mov	DWORD PTR _item$221737[esp+104], eax
	mov	DWORD PTR _item$221737[esp+108], eax
	mov	DWORD PTR _item$221737[esp+112], eax
	mov	BYTE PTR _item$221737[esp+116], al
	mov	BYTE PTR _item$221737[esp+124], al
	mov	BYTE PTR _item$221737[esp+125], al
	mov	DWORD PTR _item$221737[esp+96], eax
	mov	DWORD PTR _item$221737[esp+120], edx
	mov	DWORD PTR _item$221737[esp+100], edx
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221737[esp+92]
	lea	edi, DWORD PTR $T238903[esp+100]
	lea	eax, DWORD PTR $T238903[esp+92]
	mov	DWORD PTR _item$221737[esp+92], 10	; 0000000aH
	rep movsd
	push	eax
	mov	ecx, ebx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebx+20]
	cmp	DWORD PTR [ebx+24], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+28], eax
	jne	SHORT $LN13@AddPermame
	mov	DWORD PTR [ebx+24], eax
$LN13@AddPermame:
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	pop	edi
	pop	esi
	pop	ebx

; 1420 : 	}
; 1421 : //	else
; 1422 : 	{
; 1423 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Permanent Alliance item to a deal");
; 1424 : 	}
; 1425 : }

	add	esp, 80					; 00000050H
	ret	0
?AddPermamentAlliance@CvDeal@@QAEXXZ ENDP		; CvDeal::AddPermamentAlliance
_TEXT	ENDS
PUBLIC	?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::AddSurrender
; Function compile flags: /Ogtpy
;	COMDAT ?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_item$221743 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::AddSurrender, COMDAT
; _this$ = ecx

; 1429 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1430 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1431 : 
; 1432 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_SURRENDER))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+44]
	cmp	eax, edi
	jne	SHORT $LN5@AddSurrend
	mov	eax, DWORD PTR [esi+8]
$LN5@AddSurrend:
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	-1
	push	11					; 0000000bH
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddSurrend

; 1433 : 	{
; 1434 : 		CvTradedItem item;
; 1435 : 		item.m_eItemType = TRADE_ITEM_SURRENDER;
; 1436 : 		item.m_iDuration = 0;
; 1437 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1438 : 		item.m_iTurnsRemaining = -1;
; 1439 : #else
; 1440 : 		item.m_iFinalTurn = -1;
; 1441 : #endif
; 1442 : 		item.m_eFromPlayer = eFrom;
; 1443 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221743[esp+48]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221743[esp+64], ebx
	mov	DWORD PTR _item$221743[esp+68], ebx
	mov	DWORD PTR _item$221743[esp+72], ebx
	mov	BYTE PTR _item$221743[esp+76], bl
	mov	BYTE PTR _item$221743[esp+84], bl
	mov	BYTE PTR _item$221743[esp+85], bl
	mov	DWORD PTR _item$221743[esp+52], 11	; 0000000bH
	mov	DWORD PTR _item$221743[esp+56], ebx
	mov	DWORD PTR _item$221743[esp+60], -1
	mov	DWORD PTR _item$221743[esp+80], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddSurrend:
	pop	edi
	pop	esi
	pop	ebx

; 1444 : 	}
; 1445 : 	else
; 1446 : 	{
; 1447 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Surrender item to a deal");
; 1448 : 	}
; 1449 : }

	add	esp, 36					; 00000024H
	ret	4
?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::AddSurrender
_TEXT	ENDS
PUBLIC	?AddTruce@CvDeal@@QAEXXZ			; CvDeal::AddTruce
; Function compile flags: /Ogtpy
;	COMDAT ?AddTruce@CvDeal@@QAEXXZ
_TEXT	SEGMENT
_item$221748 = -80					; size = 36
$T238959 = -44						; size = 44
?AddTruce@CvDeal@@QAEXXZ PROC				; CvDeal::AddTruce, COMDAT
; _this$ = ecx

; 1453 : {

	sub	esp, 80					; 00000050H

; 1454 : //	if (IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_TRUCE))
; 1455 : 	{
; 1456 : 		CvTradedItem item;

	xor	eax, eax
	push	ebx
	push	esi
	push	edi

; 1457 : 		item.m_eItemType = TRADE_ITEM_TRUCE;
; 1458 : 		item.m_iDuration = 0;
; 1459 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1460 : 		item.m_iTurnsRemaining = -1;
; 1461 : #else
; 1462 : 		item.m_iFinalTurn = -1;
; 1463 : #endif
; 1464 : 		m_TradedItems.push_back(item);

	lea	ebx, DWORD PTR [ecx+44]
	or	edx, -1
	mov	DWORD PTR _item$221748[esp+104], eax
	mov	DWORD PTR _item$221748[esp+108], eax
	mov	DWORD PTR _item$221748[esp+112], eax
	mov	BYTE PTR _item$221748[esp+116], al
	mov	BYTE PTR _item$221748[esp+124], al
	mov	BYTE PTR _item$221748[esp+125], al
	mov	DWORD PTR _item$221748[esp+96], eax
	mov	DWORD PTR _item$221748[esp+120], edx
	mov	DWORD PTR _item$221748[esp+100], edx
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221748[esp+92]
	lea	edi, DWORD PTR $T238959[esp+100]
	lea	eax, DWORD PTR $T238959[esp+92]
	mov	DWORD PTR _item$221748[esp+92], 12	; 0000000cH
	rep movsd
	push	eax
	mov	ecx, ebx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebx+20]
	cmp	DWORD PTR [ebx+24], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+28], eax
	jne	SHORT $LN13@AddTruce
	mov	DWORD PTR [ebx+24], eax
$LN13@AddTruce:
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	pop	edi
	pop	esi
	pop	ebx

; 1465 : 	}
; 1466 : //	else
; 1467 : 	{
; 1468 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Truce item to a deal");
; 1469 : 	}
; 1470 : }

	add	esp, 80					; 00000050H
	ret	0
?AddTruce@CvDeal@@QAEXXZ ENDP				; CvDeal::AddTruce
_TEXT	ENDS
PUBLIC	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddPeaceTreaty
; Function compile flags: /Ogtpy
;	COMDAT ?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_item$221755 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddPeaceTreaty, COMDAT
; _this$ = ecx

; 1474 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1475 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1476 : 
; 1477 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_PEACE_TREATY))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+44]
	cmp	eax, edi
	jne	SHORT $LN5@AddPeaceTr
	mov	eax, DWORD PTR [esi+8]
$LN5@AddPeaceTr:
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	-1
	push	13					; 0000000dH
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddPeaceTr

; 1478 : 	{
; 1479 : 		CvTradedItem item;
; 1480 : 		item.m_eItemType = TRADE_ITEM_PEACE_TREATY;
; 1481 : 		item.m_iDuration = iDuration;

	mov	eax, DWORD PTR _iDuration$[esp+44]

; 1482 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1483 : 		item.m_iTurnsRemaining = -1;
; 1484 : #else
; 1485 : 		item.m_iFinalTurn = -1;
; 1486 : #endif
; 1487 : 		item.m_eFromPlayer = eFrom;
; 1488 : 		m_TradedItems.push_back(item);

	lea	ecx, DWORD PTR _item$221755[esp+48]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221755[esp+64], ebx
	mov	DWORD PTR _item$221755[esp+68], ebx
	mov	DWORD PTR _item$221755[esp+72], ebx
	mov	BYTE PTR _item$221755[esp+76], bl
	mov	BYTE PTR _item$221755[esp+84], bl
	mov	BYTE PTR _item$221755[esp+85], bl
	mov	DWORD PTR _item$221755[esp+52], 13	; 0000000dH
	mov	DWORD PTR _item$221755[esp+56], eax
	mov	DWORD PTR _item$221755[esp+60], -1
	mov	DWORD PTR _item$221755[esp+80], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddPeaceTr:
	pop	edi
	pop	esi
	pop	ebx

; 1489 : 	}
; 1490 : 	else
; 1491 : 	{
; 1492 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Peace Treaty item to a deal");
; 1493 : 	}
; 1494 : }

	add	esp, 36					; 00000024H
	ret	8
?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddPeaceTreaty
_TEXT	ENDS
PUBLIC	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::AddThirdPartyPeace
; Function compile flags: /Ogtpy
;	COMDAT ?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
_item$221764 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
_iDuration$ = 16					; size = 4
?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z PROC ; CvDeal::AddThirdPartyPeace, COMDAT
; _this$ = ecx

; 1498 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1499 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1500 : 
; 1501 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_THIRD_PARTY_PEACE, eThirdPartyTeam))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddThirdPa
	mov	eax, DWORD PTR [esi+8]
$LN5@AddThirdPa:
	mov	ebp, DWORD PTR _eThirdPartyTeam$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	14					; 0000000eH
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddThirdPa

; 1502 : 	{
; 1503 : 		CvTradedItem item;
; 1504 : 		item.m_eItemType = TRADE_ITEM_THIRD_PARTY_PEACE;
; 1505 : 		item.m_iDuration = iDuration;

	mov	eax, DWORD PTR _iDuration$[esp+48]

; 1506 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1507 : 		item.m_iTurnsRemaining = -1;
; 1508 : #else
; 1509 : 		item.m_iFinalTurn = -1;
; 1510 : #endif
; 1511 : 		item.m_iData1 = eThirdPartyTeam;
; 1512 : 		item.m_eFromPlayer = eFrom;
; 1513 : 		m_TradedItems.push_back(item);

	lea	ecx, DWORD PTR _item$221764[esp+52]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221764[esp+72], ebx
	mov	DWORD PTR _item$221764[esp+76], ebx
	mov	BYTE PTR _item$221764[esp+80], bl
	mov	BYTE PTR _item$221764[esp+88], bl
	mov	BYTE PTR _item$221764[esp+89], bl
	mov	DWORD PTR _item$221764[esp+56], 14	; 0000000eH
	mov	DWORD PTR _item$221764[esp+60], eax
	mov	DWORD PTR _item$221764[esp+64], -1
	mov	DWORD PTR _item$221764[esp+68], ebp
	mov	DWORD PTR _item$221764[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddThirdPa:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1514 : 	}
; 1515 : 	else
; 1516 : 	{
; 1517 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Third Party Peace item to a deal");
; 1518 : 	}
; 1519 : }

	add	esp, 36					; 00000024H
	ret	12					; 0000000cH
?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ENDP ; CvDeal::AddThirdPartyPeace
_TEXT	ENDS
PUBLIC	?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::AddThirdPartyWar
; Function compile flags: /Ogtpy
;	COMDAT ?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_item$221772 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::AddThirdPartyWar, COMDAT
; _this$ = ecx

; 1523 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1524 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1525 : 
; 1526 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_THIRD_PARTY_WAR, eThirdPartyTeam))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddThirdPa@2
	mov	eax, DWORD PTR [esi+8]
$LN5@AddThirdPa@2:
	mov	ebp, DWORD PTR _eThirdPartyTeam$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	ebp
	push	15					; 0000000fH
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddThirdPa@2

; 1527 : 	{
; 1528 : 		CvTradedItem item;
; 1529 : 		item.m_eItemType = TRADE_ITEM_THIRD_PARTY_WAR;
; 1530 : 		item.m_iDuration = 0;
; 1531 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1532 : 		item.m_iTurnsRemaining = -1;
; 1533 : #else
; 1534 : 		item.m_iFinalTurn = -1;
; 1535 : #endif
; 1536 : 		item.m_iData1 = eThirdPartyTeam;
; 1537 : 		item.m_eFromPlayer = eFrom;
; 1538 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221772[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221772[esp+72], ebx
	mov	DWORD PTR _item$221772[esp+76], ebx
	mov	BYTE PTR _item$221772[esp+80], bl
	mov	BYTE PTR _item$221772[esp+88], bl
	mov	BYTE PTR _item$221772[esp+89], bl
	mov	DWORD PTR _item$221772[esp+56], 15	; 0000000fH
	mov	DWORD PTR _item$221772[esp+60], ebx
	mov	DWORD PTR _item$221772[esp+64], -1
	mov	DWORD PTR _item$221772[esp+68], ebp
	mov	DWORD PTR _item$221772[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddThirdPa@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1539 : 	}
; 1540 : 	else
; 1541 : 	{
; 1542 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Third Party War item to a deal");
; 1543 : 	}
; 1544 : }

	add	esp, 36					; 00000024H
	ret	8
?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::AddThirdPartyWar
_TEXT	ENDS
PUBLIC	?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z ; CvDeal::AddThirdPartyEmbargo
; Function compile flags: /Ogtpy
;	COMDAT ?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z
_TEXT	SEGMENT
_item$221781 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eThirdParty$ = 12					; size = 4
_iDuration$ = 16					; size = 4
?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z PROC ; CvDeal::AddThirdPartyEmbargo, COMDAT
; _this$ = ecx

; 1548 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1549 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1550 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1551 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1552 : 
; 1553 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_THIRD_PARTY_EMBARGO, eThirdParty, iDuration))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddThirdPa@3
	mov	eax, DWORD PTR [esi+8]
$LN5@AddThirdPa@3:
	mov	ebp, DWORD PTR _iDuration$[esp+48]
	mov	ecx, DWORD PTR _eThirdParty$[esp+48]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	ebp
	push	ecx
	push	16					; 00000010H
	push	eax
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddThirdPa@3

; 1554 : 	{
; 1555 : 		CvTradedItem item;
; 1556 : 		item.m_eItemType = TRADE_ITEM_THIRD_PARTY_EMBARGO;
; 1557 : 		item.m_iDuration = iDuration;
; 1558 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1559 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1560 : 		item.m_iTurnsRemaining = -1;
; 1561 : #else
; 1562 : 		item.m_iFinalTurn = -1;
; 1563 : #endif
; 1564 : 		item.m_iData1 = eThirdParty;

	mov	edx, DWORD PTR _eThirdParty$[esp+48]

; 1565 : 		item.m_eFromPlayer = eFrom;
; 1566 : 		m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221781[esp+52]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221781[esp+72], ebx
	mov	DWORD PTR _item$221781[esp+76], ebx
	mov	BYTE PTR _item$221781[esp+80], bl
	mov	BYTE PTR _item$221781[esp+88], bl
	mov	BYTE PTR _item$221781[esp+89], bl
	mov	DWORD PTR _item$221781[esp+56], 16	; 00000010H
	mov	DWORD PTR _item$221781[esp+60], ebp
	mov	DWORD PTR _item$221781[esp+64], -1
	mov	DWORD PTR _item$221781[esp+68], edx
	mov	DWORD PTR _item$221781[esp+84], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddThirdPa@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1567 : 	}
; 1568 : 	else
; 1569 : 	{
; 1570 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Third Party Embargo item to a deal");
; 1571 : 	}
; 1572 : }

	add	esp, 36					; 00000024H
	ret	12					; 0000000cH
?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z ENDP ; CvDeal::AddThirdPartyEmbargo
_TEXT	ENDS
PUBLIC	?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddDeclarationOfFriendship
; Function compile flags: /Ogtpy
;	COMDAT ?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_item$221789 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z PROC ; CvDeal::AddDeclarationOfFriendship, COMDAT
; _this$ = ecx

; 1576 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1577 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!");
; 1578 : 
; 1579 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_DECLARATION_OF_FRIENDSHIP))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+44]
	cmp	eax, edi
	jne	SHORT $LN6@AddDeclara
	mov	eax, DWORD PTR [esi+8]
$LN6@AddDeclara:
	xor	ebx, ebx
	push	ebx
	push	1
	push	ebx
	push	-1
	push	-1
	push	-1
	push	18					; 00000012H
	push	eax
	push	edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddDeclara

; 1580 : 	{
; 1581 : 		if (!ContainsItemType(TRADE_ITEM_DECLARATION_OF_FRIENDSHIP, eFrom))

	push	edi
	push	18					; 00000012H
	mov	ecx, esi
	call	?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::ContainsItemType
	test	al, al
	jne	SHORT $LN2@AddDeclara

; 1582 : 		{
; 1583 : 			CvTradedItem item;
; 1584 : 			item.m_eItemType = TRADE_ITEM_DECLARATION_OF_FRIENDSHIP;
; 1585 : 			item.m_eFromPlayer = eFrom;
; 1586 : 			m_TradedItems.push_back(item);

	lea	eax, DWORD PTR _item$221789[esp+48]
	push	eax
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221789[esp+56], ebx
	mov	DWORD PTR _item$221789[esp+60], ebx
	mov	DWORD PTR _item$221789[esp+64], ebx
	mov	DWORD PTR _item$221789[esp+68], ebx
	mov	DWORD PTR _item$221789[esp+72], ebx
	mov	BYTE PTR _item$221789[esp+76], bl
	mov	BYTE PTR _item$221789[esp+84], bl
	mov	BYTE PTR _item$221789[esp+85], bl
	mov	DWORD PTR _item$221789[esp+52], 18	; 00000012H
	mov	DWORD PTR _item$221789[esp+80], edi
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddDeclara:
	pop	edi
	pop	esi
	pop	ebx

; 1587 : 		}
; 1588 : 	}
; 1589 : 	else
; 1590 : 	{
; 1591 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Declaration of Friendship item to a deal");
; 1592 : 	}
; 1593 : }

	add	esp, 36					; 00000024H
	ret	4
?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP ; CvDeal::AddDeclarationOfFriendship
_TEXT	ENDS
PUBLIC	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::AddVoteCommitment
; Function compile flags: /Ogtpy
;	COMDAT ?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
_TEXT	SEGMENT
_item$221800 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iResolutionID$ = 12					; size = 4
_iVoteChoice$ = 16					; size = 4
_iNumVotes$ = 20					; size = 4
_bRepeal$ = 24						; size = 1
?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z PROC ; CvDeal::AddVoteCommitment, COMDAT
; _this$ = ecx

; 1597 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1598 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!");
; 1599 : 
; 1600 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_VOTE_COMMITMENT, iResolutionID, iVoteChoice, iNumVotes, bRepeal))

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eFrom$[esp+48]
	cmp	eax, edi
	jne	SHORT $LN5@AddVoteCom
	mov	eax, DWORD PTR [esi+8]
$LN5@AddVoteCom:
	mov	ebx, DWORD PTR _bRepeal$[esp+48]
	mov	ebp, DWORD PTR _iNumVotes$[esp+48]
	mov	ecx, DWORD PTR _iVoteChoice$[esp+48]
	mov	edx, DWORD PTR _iResolutionID$[esp+48]
	push	0
	push	1
	push	ebx
	push	ebp
	push	ecx
	push	edx
	push	19					; 00000013H
	push	eax
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN2@AddVoteCom

; 1601 : 	{
; 1602 : 		CvTradedItem item;
; 1603 : 		item.m_eItemType = TRADE_ITEM_VOTE_COMMITMENT;
; 1604 : 		item.m_eFromPlayer = eFrom;
; 1605 : 		item.m_iData1 = iResolutionID;
; 1606 : 		item.m_iData2 = iVoteChoice;

	mov	ecx, DWORD PTR _iVoteChoice$[esp+48]
	xor	eax, eax
	mov	DWORD PTR _item$221800[esp+56], eax
	mov	DWORD PTR _item$221800[esp+60], eax
	mov	BYTE PTR _item$221800[esp+84], al
	mov	BYTE PTR _item$221800[esp+85], al
	mov	eax, DWORD PTR _iResolutionID$[esp+48]

; 1607 : 		item.m_iData3 = iNumVotes;
; 1608 : 		item.m_bFlag1 = bRepeal;
; 1609 : 		m_TradedItems.push_back(item);

	lea	edx, DWORD PTR _item$221800[esp+52]
	mov	DWORD PTR _item$221800[esp+68], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _item$221800[esp+56], 19	; 00000013H
	mov	DWORD PTR _item$221800[esp+84], edi
	mov	DWORD PTR _item$221800[esp+68], eax
	mov	DWORD PTR _item$221800[esp+76], ebp
	mov	BYTE PTR _item$221800[esp+80], bl
	call	?push_back@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEIABUCvTradedItem@@@Z ; FFastList<CvTradedItem,21,0>::push_back
$LN2@AddVoteCom:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1610 : 	}
; 1611 : 	else
; 1612 : 	{
; 1613 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Vote Commitment item to a deal");
; 1614 : 	}
; 1615 : }

	add	esp, 36					; 00000024H
	ret	20					; 00000014H
?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ENDP ; CvDeal::AddVoteCommitment
_TEXT	ENDS
PUBLIC	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z	; OldLoad
; Function compile flags: /Ogtpy
;	COMDAT ?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z
_TEXT	SEGMENT
tv241 = -84						; size = 4
_v$239114 = -84						; size = 4
_tempItem$ = -80					; size = 36
$T239152 = -44						; size = 44
_iEntriesToRead$ = 8					; size = 4
_loadFrom$ = 8						; size = 4
_v$239071 = 12						; size = 4
_iI$222270 = 12						; size = 4
_writeTo$ = 12						; size = 4
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z PROC	; OldLoad, COMDAT

; 2145 : {

	sub	esp, 84					; 00000054H
	push	ebx

; 2146 : 	int iEntriesToRead;
; 2147 : 	CvTradedItem tempItem;
; 2148 : 
; 2149 : 	loadFrom >> writeTo.m_eFromPlayer;

	mov	ebx, DWORD PTR _writeTo$[esp+84]
	or	eax, -1
	push	ebp
	mov	ebp, DWORD PTR _loadFrom$[esp+88]
	push	esi
	mov	DWORD PTR _tempItem$[esp+96], eax
	mov	DWORD PTR _tempItem$[esp+124], eax
	xor	esi, esi
	lea	eax, DWORD PTR [ebx+4]
	push	eax
	push	ebp
	mov	DWORD PTR _tempItem$[esp+108], esi
	mov	DWORD PTR _tempItem$[esp+112], esi
	mov	DWORD PTR _tempItem$[esp+116], esi
	mov	DWORD PTR _tempItem$[esp+120], esi
	mov	DWORD PTR _tempItem$[esp+124], esi
	mov	BYTE PTR _tempItem$[esp+128], 0
	mov	BYTE PTR _tempItem$[esp+136], 0
	mov	BYTE PTR _tempItem$[esp+137], 0
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2150 : 	loadFrom >> writeTo.m_eToPlayer;

	lea	ecx, DWORD PTR [ebx+8]
	push	ecx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 2151 : 	loadFrom >> writeTo.m_iFinalTurn;

	lea	edx, DWORD PTR [ebx+16]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2152 : 	loadFrom >> writeTo.m_iDuration;

	lea	eax, DWORD PTR [ebx+20]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2153 : 	loadFrom >> writeTo.m_iStartTurn;

	lea	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2154 : 	loadFrom >> writeTo.m_bConsideringForRenewal;

	lea	edx, DWORD PTR [ebx+40]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2155 : 	loadFrom >> writeTo.m_bDealCancelled;

	lea	eax, DWORD PTR [ebx+42]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2156 : 	loadFrom >> writeTo.m_ePeaceTreatyType;

	lea	ecx, DWORD PTR _v$239071[esp+92]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	edx, DWORD PTR _v$239071[esp+92]

; 2157 : 	loadFrom >> writeTo.m_eSurrenderingPlayer;

	lea	eax, DWORD PTR [ebx+28]
	push	eax
	push	ebp
	mov	DWORD PTR [ebx+24], edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2158 : 	loadFrom >> writeTo.m_eDemandingPlayer;

	lea	ecx, DWORD PTR [ebx+32]
	push	ecx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2159 : 	loadFrom >> writeTo.m_eRequestingPlayer;

	lea	edx, DWORD PTR [ebx+36]
	push	edx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 24					; 00000018H

; 2160 : 	loadFrom >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[esp+92]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2161 : 
; 2162 : 	writeTo.m_TradedItems.clear();

	mov	ecx, DWORD PTR [ebx+68]
	add	ebx, 44					; 0000002cH
	push	268435455				; 0fffffffH
	push	ecx
	mov	ecx, ebx
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 2163 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	cmp	DWORD PTR _iEntriesToRead$[esp+92], esi
	mov	DWORD PTR _iI$222270[esp+92], esi
	jle	$LN57@OldLoad
	push	edi
	npad	2
$LL3@OldLoad:

; 2164 : 	{
; 2165 : 		loadFrom = OldLoad(loadFrom, tempItem);

	lea	eax, DWORD PTR _v$239114[esp+100]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	ecx, DWORD PTR _v$239114[esp+100]
	lea	edx, DWORD PTR _tempItem$[esp+104]
	mov	DWORD PTR _tempItem$[esp+100], ecx
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	eax, DWORD PTR _tempItem$[esp+108]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _tempItem$[esp+112]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	edx, DWORD PTR _tempItem$[esp+116]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	eax, DWORD PTR _tempItem$[esp+128]
	push	eax
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	mov	BYTE PTR _tempItem$[esp+140], 0
	mov	BYTE PTR _tempItem$[esp+141], 0

; 2166 : 		writeTo.m_TradedItems.push_back(tempItem);

	mov	ecx, 9
	lea	esi, DWORD PTR _tempItem$[esp+108]
	lea	edi, DWORD PTR $T239152[esp+116]
	rep movsd
	add	esp, 8
	lea	ecx, DWORD PTR $T239152[esp+100]
	push	ecx
	mov	ecx, ebx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebx+20]
	cmp	DWORD PTR [ebx+24], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+28], eax
	jne	SHORT $LN52@OldLoad
	mov	DWORD PTR [ebx+24], eax
$LN52@OldLoad:
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	mov	eax, DWORD PTR _iI$222270[esp+96]
	inc	eax
	cmp	eax, DWORD PTR _iEntriesToRead$[esp+96]
	mov	DWORD PTR _iI$222270[esp+96], eax
	jl	$LL3@OldLoad
	pop	edi
$LN57@OldLoad:
	pop	esi

; 2167 : 	}
; 2168 : 	return loadFrom;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2169 : }

	add	esp, 84					; 00000054H
	ret	0
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ENDP	; OldLoad
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z
_TEXT	SEGMENT
_iEntriesToRead$ = -88					; size = 4
_v$239243 = -84						; size = 4
_tempItem$ = -80					; size = 36
$T239281 = -44						; size = 44
_uiVersion$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_v$239200 = 12						; size = 4
_iI$222286 = 12						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z PROC		; operator>>, COMDAT

; 2173 : {

	sub	esp, 88					; 00000058H
	push	ebx

; 2174 : 	uint uiVersion;
; 2175 : 	int iEntriesToRead;
; 2176 : 	CvTradedItem tempItem;
; 2177 : 
; 2178 : 	loadFrom >> uiVersion;

	mov	ebx, DWORD PTR _loadFrom$[esp+88]
	or	eax, -1
	push	ebp
	push	esi
	xor	esi, esi
	mov	DWORD PTR _tempItem$[esp+100], eax
	mov	DWORD PTR _tempItem$[esp+128], eax
	lea	eax, DWORD PTR _uiVersion$[esp+96]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _tempItem$[esp+108], esi
	mov	DWORD PTR _tempItem$[esp+112], esi
	mov	DWORD PTR _tempItem$[esp+116], esi
	mov	DWORD PTR _tempItem$[esp+120], esi
	mov	DWORD PTR _tempItem$[esp+124], esi
	mov	BYTE PTR _tempItem$[esp+128], 0
	mov	BYTE PTR _tempItem$[esp+136], 0
	mov	BYTE PTR _tempItem$[esp+137], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2179 : 	loadFrom >> writeTo.m_eFromPlayer;

	mov	ebp, DWORD PTR _writeTo$[esp+96]
	lea	ecx, DWORD PTR [ebp+4]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2180 : 	loadFrom >> writeTo.m_eToPlayer;

	lea	edx, DWORD PTR [ebp+8]
	push	edx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 2181 : 	loadFrom >> writeTo.m_iFinalTurn;

	lea	eax, DWORD PTR [ebp+16]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2182 : 	loadFrom >> writeTo.m_iDuration;

	lea	ecx, DWORD PTR [ebp+20]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2183 : 	loadFrom >> writeTo.m_iStartTurn;

	lea	edx, DWORD PTR [ebp+12]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2184 : 	loadFrom >> writeTo.m_bConsideringForRenewal;

	lea	eax, DWORD PTR [ebp+40]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2185 : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[esp+96], 3
	jb	SHORT $LN7@operator@9

; 2186 : 	{
; 2187 : 		loadFrom >> writeTo.m_bCheckedForRenewal;

	lea	ecx, DWORD PTR [ebp+41]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2188 : 	}
; 2189 : 	else

	jmp	SHORT $LN6@operator@9
$LN7@operator@9:

; 2190 : 	{
; 2191 : 		writeTo.m_bCheckedForRenewal = false;

	mov	BYTE PTR [ebp+41], 0
$LN6@operator@9:

; 2192 : 	}
; 2193 : 	loadFrom >> writeTo.m_bDealCancelled;

	lea	edx, DWORD PTR [ebp+42]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2194 : 	loadFrom >> writeTo.m_ePeaceTreatyType;

	lea	eax, DWORD PTR _v$239200[esp+96]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	ecx, DWORD PTR _v$239200[esp+96]

; 2195 : 	loadFrom >> writeTo.m_eSurrenderingPlayer;

	lea	edx, DWORD PTR [ebp+28]
	push	edx
	push	ebx
	mov	DWORD PTR [ebp+24], ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2196 : 	loadFrom >> writeTo.m_eDemandingPlayer;

	lea	eax, DWORD PTR [ebp+32]
	push	eax
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2197 : 	loadFrom >> writeTo.m_eRequestingPlayer;

	lea	ecx, DWORD PTR [ebp+36]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 24					; 00000018H

; 2198 : 	loadFrom >> iEntriesToRead;

	lea	edx, DWORD PTR _iEntriesToRead$[esp+100]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2199 : 
; 2200 : 	writeTo.m_TradedItems.clear();

	mov	eax, DWORD PTR [ebp+68]
	add	ebp, 44					; 0000002cH
	push	268435455				; 0fffffffH
	push	eax
	mov	ecx, ebp
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 2201 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	cmp	DWORD PTR _iEntriesToRead$[esp+100], esi
	mov	DWORD PTR _iI$222286[esp+96], esi
	jle	$LN65@operator@9
	push	edi
$LL5@operator@9:

; 2202 : 	{
; 2203 : 		if(uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+100], 2
	jb	SHORT $LN2@operator@9

; 2204 : 		{
; 2205 : 			loadFrom >> tempItem;

	lea	ecx, DWORD PTR _tempItem$[esp+104]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z ; operator>>

; 2206 : 		}
; 2207 : 		else

	jmp	SHORT $LN66@operator@9
$LN2@operator@9:

; 2208 : 		{
; 2209 : 			loadFrom = OldLoad(loadFrom, tempItem);

	lea	edx, DWORD PTR _v$239243[esp+104]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR _v$239243[esp+104]
	lea	ecx, DWORD PTR _tempItem$[esp+108]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR _tempItem$[esp+108], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	edx, DWORD PTR _tempItem$[esp+112]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	eax, DWORD PTR _tempItem$[esp+116]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _tempItem$[esp+120]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	edx, DWORD PTR _tempItem$[esp+132]
	push	edx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	mov	BYTE PTR _tempItem$[esp+144], 0
	mov	BYTE PTR _tempItem$[esp+145], 0
$LN66@operator@9:
	add	esp, 8

; 2210 : 		}
; 2211 : 		writeTo.m_TradedItems.push_back(tempItem);

	mov	ecx, 9
	lea	esi, DWORD PTR _tempItem$[esp+104]
	lea	edi, DWORD PTR $T239281[esp+112]
	lea	eax, DWORD PTR $T239281[esp+104]
	rep movsd
	push	eax
	mov	ecx, ebp
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebp+20]
	cmp	DWORD PTR [ebp+24], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR [ebp+28]
	mov	DWORD PTR [ebp+28], eax
	jne	SHORT $LN60@operator@9
	mov	DWORD PTR [ebp+24], eax
$LN60@operator@9:
	push	ecx
	push	eax
	mov	ecx, ebp
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	mov	eax, DWORD PTR _iI$222286[esp+100]
	inc	eax
	cmp	eax, DWORD PTR _iEntriesToRead$[esp+104]
	mov	DWORD PTR _iI$222286[esp+100], eax
	jl	$LL5@operator@9
	pop	edi
$LN65@operator@9:
	pop	esi
	pop	ebp

; 2212 : 	}
; 2213 : 	return loadFrom;

	mov	eax, ebx
	pop	ebx

; 2214 : }

	add	esp, 88					; 00000058H
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??_7CvGameDeals@@6B@				; CvGameDeals::`vftable'
PUBLIC	??1CvGameDeals@@UAE@XZ				; CvGameDeals::~CvGameDeals
PUBLIC	??_R4CvGameDeals@@6B@				; CvGameDeals::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvGameDeals@@@8				; CvGameDeals `RTTI Type Descriptor'
PUBLIC	??_R3CvGameDeals@@8				; CvGameDeals::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvGameDeals@@8				; CvGameDeals::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvGameDeals@@8			; CvGameDeals::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECvGameDeals@@UAEPAXI@Z:PROC			; CvGameDeals::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvGameDeals@@8
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvGameDeals@@8 DD FLAT:??_R0?AVCvGameDeals@@@8 ; CvGameDeals::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvGameDeals@@8
rdata$r	ENDS
;	COMDAT ??_R2CvGameDeals@@8
rdata$r	SEGMENT
??_R2CvGameDeals@@8 DD FLAT:??_R1A@?0A@EA@CvGameDeals@@8 ; CvGameDeals::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvGameDeals@@8
rdata$r	SEGMENT
??_R3CvGameDeals@@8 DD 00H				; CvGameDeals::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvGameDeals@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvGameDeals@@@8
_DATA	SEGMENT
??_R0?AVCvGameDeals@@@8 DD FLAT:??_7type_info@@6B@	; CvGameDeals `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvGameDeals@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvGameDeals@@6B@
rdata$r	SEGMENT
??_R4CvGameDeals@@6B@ DD 00H				; CvGameDeals::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvGameDeals@@@8
	DD	FLAT:??_R3CvGameDeals@@8
rdata$r	ENDS
;	COMDAT ??_7CvGameDeals@@6B@
CONST	SEGMENT
??_7CvGameDeals@@6B@ DD FLAT:??_R4CvGameDeals@@6B@	; CvGameDeals::`vftable'
	DD	FLAT:??_ECvGameDeals@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvGameDeals@@UAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CvGameDeals@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvGameDeals@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvGameDeals@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvGameDeals@@UAE@XZ PROC				; CvGameDeals::~CvGameDeals, COMDAT
; _this$ = ecx

; 2257 : {

	push	-1
	push	__ehhandler$??1CvGameDeals@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvGameDeals@@6B@

; 2258 : 	for(std::vector<std::pair<uint, CvDeal*> >::iterator it = m_Deals.begin();

	mov	edi, DWORD PTR [esi+4692]

; 2259 : 	        it != m_Deals.end(); ++it)

	mov	eax, DWORD PTR [esi+4696]
	mov	DWORD PTR __$EHRec$[esp+40], 4
	cmp	edi, eax
	je	SHORT $LN193@CvGameDeal
	npad	2
$LL21@CvGameDeal:

; 2260 : 	{
; 2261 : 		delete(*it).second;

	mov	ecx, DWORD PTR [edi+4]
	xor	ebp, ebp
	cmp	ecx, ebp
	je	SHORT $LN6@CvGameDeal
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN6@CvGameDeal:

; 2262 : 		it->second = NULL;

	mov	DWORD PTR [edi+4], ebp
	add	edi, 8
	cmp	edi, DWORD PTR [esi+4696]
	jne	SHORT $LL21@CvGameDeal

; 2259 : 	        it != m_Deals.end(); ++it)

	jmp	SHORT $LN1@CvGameDeal
$LN193@CvGameDeal:
	xor	ebp, ebp
$LN1@CvGameDeal:

; 2263 : 	}
; 2264 : 
; 2265 : 	m_Deals.clear();

	mov	edx, DWORD PTR [esi+4696]
	mov	ecx, DWORD PTR [esi+4692]
	cmp	ecx, edx
	je	SHORT $LN57@CvGameDeal
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN82@CvGameDeal
	npad	7
$LL84@CvGameDeal:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL84@CvGameDeal
$LN82@CvGameDeal:
	mov	DWORD PTR [esi+4696], ecx
$LN57@CvGameDeal:

; 2266 : #ifdef AUI_EXPLICIT_DESTRUCTION
; 2267 : 	Init(); //clears all the deal lists
; 2268 : #endif
; 2269 : }

	mov	eax, DWORD PTR [esi+4692]
	cmp	eax, ebp
	je	SHORT $LN92@CvGameDeal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN92@CvGameDeal:
	mov	DWORD PTR [esi+4692], ebp
	mov	DWORD PTR [esi+4696], ebp
	mov	DWORD PTR [esi+4700], ebp
	mov	DWORD PTR [esi+4612], OFFSET ??_7CvDeal@@6B@
	mov	DWORD PTR [esi+4656], 268435455		; 0fffffffH
	mov	DWORD PTR [esi+4668], ebp
	mov	DWORD PTR [esi+4660], ebp
	mov	eax, DWORD PTR [esi+4664]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+44], 2
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	eax, DWORD PTR [esi+3080]
	mov	ebx, DWORD PTR [esi+3076]
	add	esp, 4
	mov	BYTE PTR __$EHRec$[esp+40], 1
	cmp	eax, ebp
	jbe	SHORT $LN143@CvGameDeal
	mov	edi, ebx
	mov	ebp, eax
	npad	4
$LL145@CvGameDeal:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, edi
	call	edx
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL145@CvGameDeal
$LN143@CvGameDeal:
	lea	eax, DWORD PTR [esi+3088]
	cmp	ebx, eax
	je	SHORT $LN139@CvGameDeal
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN139@CvGameDeal:
	mov	ebp, DWORD PTR [esi+1544]
	mov	ebx, DWORD PTR [esi+1540]
	mov	BYTE PTR __$EHRec$[esp+40], 0
	test	ebp, ebp
	jbe	SHORT $LN157@CvGameDeal
	mov	edi, ebx
	npad	4
$LL195@CvGameDeal:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, edi
	call	eax
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL195@CvGameDeal
$LN157@CvGameDeal:
	lea	ecx, DWORD PTR [esi+1552]
	cmp	ebx, ecx
	je	SHORT $LN153@CvGameDeal
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN153@CvGameDeal:
	mov	ebp, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	test	ebp, ebp
	jbe	SHORT $LN171@CvGameDeal
	mov	edi, ebx
	npad	7
$LL194@CvGameDeal:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, edi
	call	eax
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL194@CvGameDeal
$LN171@CvGameDeal:
	add	esi, 16					; 00000010H
	cmp	ebx, esi
	je	SHORT $LN167@CvGameDeal
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN167@CvGameDeal:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvGameDeals@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$??1CvGameDeals@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	jmp	??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
__ehhandler$??1CvGameDeals@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvGameDeals@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvGameDeals@@UAE@XZ ENDP				; CvGameDeals::~CvGameDeals
PUBLIC	?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z	; CvGameDeals::SetTempDeal
; Function compile flags: /Ogtpy
;	COMDAT ?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z PROC	; CvGameDeals::SetTempDeal, COMDAT
; _this$ = ecx

; 2655 : 	m_TempDeal = *pDeal;

	add	ecx, 4612				; 00001204H
	jmp	??4CvDeal@@QAEAAV0@ABV0@@Z		; CvDeal::operator=
?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z ENDP	; CvGameDeals::SetTempDeal
_TEXT	ENDS
PUBLIC	??0?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ	; FFastList<CvTradedItem,21,0>::FFastList<CvTradedItem,21,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC	; FFastList<CvTradedItem,21,0>::FFastList<CvTradedItem,21,0>, COMDAT
; _this$ = ecx

; 159  : 	explicit FFastList() : BASE_TYPE() {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	edx, 268435455				; 0fffffffH
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], edx
	mov	DWORD PTR [eax+28], edx
	ret	0
??0?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP	; FFastList<CvTradedItem,21,0>::FFastList<CvTradedItem,21,0>
_TEXT	ENDS
PUBLIC	?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert
_TEXT	ENDS
PUBLIC	??0CvDeal@@QAE@XZ				; CvDeal::CvDeal
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ??0CvDeal@@QAE@XZ
_TEXT	SEGMENT
??0CvDeal@@QAE@XZ PROC					; CvDeal::CvDeal, COMDAT
; _this$ = ecx

; 153  : {

	push	ebx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi], OFFSET ??_7CvDeal@@6B@
	mov	edx, 268435455				; 0fffffffH
	mov	DWORD PTR [ecx], edx
	xor	ebx, ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+12], ebx
	mov	DWORD PTR [ecx+16], ebx
	mov	DWORD PTR [ecx+8], ebx

; 154  : 	m_eFromPlayer = NO_PLAYER;

	or	eax, -1
	mov	DWORD PTR [ecx+20], ebx
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [ecx+28], edx
	mov	DWORD PTR [esi+4], eax

; 155  : 	m_eToPlayer = NO_PLAYER;

	mov	DWORD PTR [esi+8], eax

; 156  : 	m_ePeaceTreatyType = NO_PEACE_TREATY_TYPE;

	mov	DWORD PTR [esi+24], eax

; 157  : 	m_eSurrenderingPlayer = NO_PLAYER;

	mov	DWORD PTR [esi+28], eax

; 158  : 	m_eDemandingPlayer = NO_PLAYER;

	mov	DWORD PTR [esi+32], eax

; 159  : 	m_eRequestingPlayer = NO_PLAYER;

	mov	DWORD PTR [esi+36], eax

; 160  : 	m_TradedItems.clear();

	mov	eax, DWORD PTR [ecx+24]
	push	edx
	push	eax
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 161  : 	m_iStartTurn = 0;

	mov	DWORD PTR [esi+12], ebx

; 162  : #ifdef AUI_WARNING_FIXES
; 163  : 	m_iFinalTurn = 0;
; 164  : 	m_iDuration = 0;
; 165  : #endif
; 166  : 	m_bConsideringForRenewal = false;

	mov	BYTE PTR [esi+40], bl

; 167  : 	m_bCheckedForRenewal = false;

	mov	BYTE PTR [esi+41], bl

; 168  : 	m_bDealCancelled = false;

	mov	BYTE PTR [esi+42], bl

; 169  : }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	0
??0CvDeal@@QAE@XZ ENDP					; CvDeal::CvDeal
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvDeal@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvDeal@@UAEPAXI@Z PROC				; CvDeal::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvDeal@@6B@
	xor	eax, eax
	mov	DWORD PTR [esi+44], 268435455		; 0fffffffH
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+48], eax
	mov	eax, DWORD PTR [esi+52]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN51@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvDeal@@UAEPAXI@Z ENDP				; CvDeal::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvDeal@@QAE@W4PlayerTypes@@0@Z		; CvDeal::CvDeal
; Function compile flags: /Ogtpy
;	COMDAT ??0CvDeal@@QAE@W4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
??0CvDeal@@QAE@W4PlayerTypes@@0@Z PROC			; CvDeal::CvDeal, COMDAT
; _this$ = ecx

; 174  : 	m_eFromPlayer = eFromPlayer;

	mov	edx, DWORD PTR _eFromPlayer$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi], OFFSET ??_7CvDeal@@6B@
	mov	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [ecx], eax
	xor	ebx, ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+12], ebx
	mov	DWORD PTR [ecx+16], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+20], ebx
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [esi+4], edx

; 175  : 	m_eToPlayer = eToPlayer;

	mov	edx, DWORD PTR _eToPlayer$[esp+4]

; 176  : 	m_TradedItems.clear();

	push	eax
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [ecx+24]
	push	eax
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 177  : 	m_bConsideringForRenewal = false;

	mov	BYTE PTR [esi+40], bl

; 178  : 	m_bCheckedForRenewal = false;

	mov	BYTE PTR [esi+41], bl

; 179  : 	m_bDealCancelled = false;

	mov	BYTE PTR [esi+42], bl

; 180  : }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	8
??0CvDeal@@QAE@W4PlayerTypes@@0@Z ENDP			; CvDeal::CvDeal
_TEXT	ENDS
PUBLIC	??0CvDeal@@QAE@ABV0@@Z				; CvDeal::CvDeal
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$??0CvDeal@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDeal@@QAE@ABV0@@Z$0
__ehfuncinfo$??0CvDeal@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvDeal@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvDeal@@QAE@ABV0@@Z
_TEXT	SEGMENT
tv496 = -80						; size = 4
_this$ = -76						; size = 4
_it$ = -72						; size = 8
$T240770 = -64						; size = 8
$T240768 = -64						; size = 8
$T241009 = -56						; size = 44
__$EHRec$ = -12						; size = 12
tv502 = 8						; size = 4
_source$ = 8						; size = 4
??0CvDeal@@QAE@ABV0@@Z PROC				; CvDeal::CvDeal, COMDAT
; _this$ = ecx

; 184  : {

	push	-1
	push	__ehhandler$??0CvDeal@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	ebp
	mov	ebp, ecx
	lea	ebx, DWORD PTR [ebp+44]
	mov	DWORD PTR [ebp], OFFSET ??_7CvDeal@@6B@
	xor	eax, eax
	mov	ecx, 268435455				; 0fffffffH
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+12], eax
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR [ebx+8], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+96], ebp
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+24], ecx
	mov	DWORD PTR [ebx+28], ecx

; 185  : 	m_eFromPlayer = source.m_eFromPlayer;

	mov	esi, DWORD PTR _source$[esp+92]
	mov	DWORD PTR __$EHRec$[esp+104], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebp+4], eax

; 186  : 	m_eToPlayer = source.m_eToPlayer;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ebp+8], edx

; 187  : 	m_iDuration = source.m_iDuration;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ebp+20], eax

; 188  : 	m_iFinalTurn = source.m_iFinalTurn;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [ebp+16], edx

; 189  : 	m_iStartTurn = source.m_iStartTurn;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ebp+12], eax

; 190  : 	m_ePeaceTreatyType = source.m_ePeaceTreatyType;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [ebp+24], edx

; 191  : 	m_eSurrenderingPlayer = source.m_eSurrenderingPlayer;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ebp+28], eax

; 192  : 	m_eDemandingPlayer = source.m_eDemandingPlayer;

	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [ebp+32], edx

; 193  : 	m_eRequestingPlayer = source.m_eRequestingPlayer;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ebp+36], eax

; 194  : 	m_bConsideringForRenewal = source.m_bConsideringForRenewal;

	movzx	edx, BYTE PTR [esi+40]
	mov	BYTE PTR [ebp+40], dl

; 195  : 	m_bCheckedForRenewal = source.m_bCheckedForRenewal;

	mov	al, BYTE PTR [esi+41]
	mov	BYTE PTR [ebp+41], al

; 196  : 	m_bDealCancelled = source.m_bDealCancelled;

	movzx	edx, BYTE PTR [esi+42]
	mov	BYTE PTR [ebp+42], dl

; 197  : 	m_TradedItems.clear();

	mov	eax, DWORD PTR [ebx+24]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 198  : 	TradedItemList::const_iterator it;
; 199  : 	for(it = source.m_TradedItems.begin(); it != source.m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR $T240768[esp+96]
	add	esi, 44					; 0000002cH
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR tv496[esp+100], esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T240770[esp+96]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _it$[esp+100], edx
	mov	DWORD PTR _it$[esp+104], edi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	$LN80@CvDeal
	jmp	SHORT $LN43@CvDeal
	npad	1
$LL81@CvDeal:
	mov	edi, DWORD PTR _it$[esp+100]
$LN43@CvDeal:

; 200  : 	{
; 201  : 		m_TradedItems.push_back(*it);

	mov	ecx, DWORD PTR _it$[esp+96]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, edi
	imul	eax, 44					; 0000002cH
	lea	esi, DWORD PTR [edx+eax+8]
	mov	DWORD PTR tv502[esp+92], eax
	mov	ecx, 9
	lea	edi, DWORD PTR $T241009[esp+104]
	lea	eax, DWORD PTR $T241009[esp+96]
	rep movsd
	push	eax
	mov	ecx, ebx
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	inc	DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+28]
	mov	esi, 268435455				; 0fffffffH
	mov	DWORD PTR [ebx+28], eax
	cmp	DWORD PTR [ebx+24], esi
	jne	SHORT $LN75@CvDeal
	mov	DWORD PTR [ebx+24], eax
$LN75@CvDeal:
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
	cmp	DWORD PTR _it$[esp+100], esi
	jne	SHORT $LN44@CvDeal
	mov	ecx, DWORD PTR _it$[esp+96]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[esp+100], edx
	jmp	SHORT $LN79@CvDeal

; 198  : 	TradedItemList::const_iterator it;
; 199  : 	for(it = source.m_TradedItems.begin(); it != source.m_TradedItems.end(); ++it)

$LN44@CvDeal:
	mov	eax, DWORD PTR _it$[esp+96]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR tv502[esp+92]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _it$[esp+100], eax
$LN79@CvDeal:
	lea	ecx, DWORD PTR $T240770[esp+96]
	push	ecx
	mov	ecx, DWORD PTR tv496[esp+100]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	edx, DWORD PTR _it$[esp+100]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL81@CvDeal
$LN80@CvDeal:

; 202  : 	}
; 203  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDeal@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
__ehhandler$??0CvDeal@@QAE@ABV0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvDeal@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDeal@@QAE@ABV0@@Z ENDP				; CvDeal::CvDeal
PUBLIC	??0CvGameDeals@@QAE@XZ				; CvGameDeals::CvGameDeals
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__ehfuncinfo$??0CvGameDeals@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CvGameDeals@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvGameDeals@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvGameDeals@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGameDeals@@QAE@XZ PROC				; CvGameDeals::CvGameDeals, COMDAT
; _this$ = ecx

; 2251 : {

	push	-1
	push	__ehhandler$??0CvGameDeals@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CvGameDeals@@6B@
	xor	edi, edi
	lea	eax, DWORD PTR [esi+16]
	mov	ecx, 20					; 00000014H
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+4], eax
	lea	eax, DWORD PTR [esi+1552]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+1544], edi
	mov	DWORD PTR [esi+1548], ecx
	mov	DWORD PTR [esi+1540], eax
	lea	eax, DWORD PTR [esi+3088]
	mov	DWORD PTR [esi+3080], edi
	mov	DWORD PTR [esi+3084], ecx
	mov	DWORD PTR [esi+3076], eax
	lea	ecx, DWORD PTR [esi+4612]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	mov	DWORD PTR [esi+4692], edi
	mov	DWORD PTR [esi+4696], edi
	mov	DWORD PTR [esi+4700], edi

; 2252 : 	Init();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+32], 4
	mov	DWORD PTR [esi+4704], edi
	call	?Init@CvGameDeals@@QAEXXZ		; CvGameDeals::Init

; 2253 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGameDeals@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??0CvGameDeals@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??0CvGameDeals@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??0CvGameDeals@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$??0CvGameDeals@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	jmp	??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
__ehhandler$??0CvGameDeals@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvGameDeals@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGameDeals@@QAE@XZ ENDP				; CvGameDeals::CvGameDeals
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvGameDeals@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvGameDeals@@UAEPAXI@Z PROC				; CvGameDeals::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvGameDeals@@UAE@XZ			; CvGameDeals::~CvGameDeals
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvGameDeals@@UAEPAXI@Z ENDP				; CvGameDeals::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
$T241289 = -4						; size = 1
__Cat$241292 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@6
	xor	eax, eax
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@6:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$241292[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T241289[esp+12], 0
	mov	eax, DWORD PTR $T241289[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pTemp$ = -20						; size = 4
$T241406 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T241440 = 8						; size = 4
_i$223812 = 8						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN39@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN39@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+28]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN34@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 20					; 00000014H
	jbe	SHORT $LN16@GrowSize@3
	mov	eax, edi
	imul	eax, 76					; 0000004cH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GP@KFAPCGLJ@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@GrowSize@3
$LN16@GrowSize@3:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 20			; 00000014H
$LN15@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	edi, edi
	push	ebp
	mov	DWORD PTR _pTemp$[esp+36], ebx
	mov	DWORD PTR _i$223812[esp+32], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN1@GrowSize@3
	or	ebp, -1
	npad	1
$LL3@GrowSize@3:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, edi
	imul	eax, 76					; 0000004cH
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR $T241406[esp+36], ecx
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN12@GrowSize@3
	mov	edx, DWORD PTR [esi]
	add	edx, eax
	push	edx
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN12@GrowSize@3:
	inc	edi
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR _i$223812[esp+32], edi
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@3
$LN1@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	ebp, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR $T241440[esp+32], edi
	test	ebp, ebp
	jbe	SHORT $LN25@GrowSize@3
	npad	3
$LL40@GrowSize@3:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, edi
	call	edx
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL40@GrowSize@3
	mov	edi, DWORD PTR $T241440[esp+32]
$LN25@GrowSize@3:
	lea	eax, DWORD PTR [esi+12]
	pop	ebp
	cmp	edi, eax
	je	SHORT $LN38@GrowSize@3
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN38@GrowSize@3:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;
; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [esi], ebx
	pop	edi
	mov	BYTE PTR [esi+1532], 1
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$223812[ebp-4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241406[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
PUBLIC	?CreateDeal@CvGameDeals@@QAEIXZ			; CvGameDeals::CreateDeal
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$?CreateDeal@CvGameDeals@@QAEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDeal@CvGameDeals@@QAEIXZ$0
__ehfuncinfo$?CreateDeal@CvGameDeals@@QAEIXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateDeal@CvGameDeals@@QAEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateDeal@CvGameDeals@@QAEIXZ
_TEXT	SEGMENT
$T241463 = -20						; size = 4
_entry$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
?CreateDeal@CvGameDeals@@QAEIXZ PROC			; CvGameDeals::CreateDeal, COMDAT
; _this$ = ecx

; 3858 : {

	push	-1
	push	__ehhandler$?CreateDeal@CvGameDeals@@QAEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 3859 : 	uint index = m_uiDealCounter++;

	mov	edi, DWORD PTR [esi+4704]
	lea	eax, DWORD PTR [edi+1]

; 3860 : 	std::pair<uint, CvDeal*> entry(index, FNEW(CvDeal, c_eCiv5GameplayDLL, 0));

	push	76					; 0000004cH
	mov	DWORD PTR [esi+4704], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T241463[esp+28], eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	eax, eax
	je	SHORT $LN3@CreateDeal
	mov	ecx, eax
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	jmp	SHORT $LN4@CreateDeal
$LN3@CreateDeal:
	xor	eax, eax
$LN4@CreateDeal:

; 3861 : 
; 3862 : 	m_Deals.push_back(entry);

	lea	ecx, DWORD PTR _entry$[esp+28]
	push	ecx
	lea	ecx, DWORD PTR [esi+4688]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	mov	DWORD PTR _entry$[esp+32], edi
	mov	DWORD PTR _entry$[esp+36], eax
	call	?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back

; 3863 : 	return index;
; 3864 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateDeal@CvGameDeals@@QAEIXZ$0:
	mov	eax, DWORD PTR $T241463[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateDeal@CvGameDeals@@QAEIXZ:
	mov	eax, OFFSET __ehfuncinfo$?CreateDeal@CvGameDeals@@QAEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateDeal@CvGameDeals@@QAEIXZ ENDP			; CvGameDeals::CreateDeal
PUBLIC	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T241480 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+24], esi
	mov	BYTE PTR [esi+1532], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@7

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN1@push_back@7:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T241480[esp+24], ecx
	mov	DWORD PTR __$EHRec$[esp+32], 0
	je	SHORT $LN4@push_back@7
	mov	eax, DWORD PTR _element$[esp+20]
	push	eax
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN4@push_back@7:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], ecx

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T241480[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::push_back
PUBLIC	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z	; CvGameDeals::AddProposedDeal
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z$0
__ehfuncinfo$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_kDeal$ = 8						; size = 76
?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z PROC	; CvGameDeals::AddProposedDeal, COMDAT
; _this$ = ecx

; 2288 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 2289 : 	// Store Deal away
; 2290 : 	m_ProposedDeals.push_back(kDeal);

	lea	eax, DWORD PTR _kDeal$[esp+8]
	push	eax
	add	ecx, 4
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 2291 : 
; 2292 : 	// Update UI if we were involved in the deal
; 2293 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 2294 : 	if(kDeal.m_eFromPlayer == eActivePlayer || kDeal.m_eToPlayer == eActivePlayer)

	cmp	DWORD PTR _kDeal$[esp+12], eax
	je	SHORT $LN1@AddPropose
	cmp	DWORD PTR _kDeal$[esp+16], eax
	jne	SHORT $LN2@AddPropose
$LN1@AddPropose:

; 2295 : 	{
; 2296 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
$LN2@AddPropose:

; 2297 : 	}
; 2298 : }

	mov	ecx, DWORD PTR _kDeal$[esp+60]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+24], -1
	mov	DWORD PTR _kDeal$[esp+12], OFFSET ??_7CvDeal@@6B@
	mov	DWORD PTR _kDeal$[esp+56], 268435455	; 0fffffffH
	mov	DWORD PTR _kDeal$[esp+68], 0
	mov	DWORD PTR _kDeal$[esp+60], 0
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	76					; 0000004cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _kDeal$[ebp-4]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__ehhandler$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z ENDP	; CvGameDeals::AddProposedDeal
PUBLIC	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getName@CvTeam@@QBE?AVCvString@@XZ:PROC	; CvTeam::getName
EXTRN	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z:PROC ; CvTeam::ChangeNumTurnsLockedIntoWar
EXTRN	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::declareWar
EXTRN	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z:PROC	; CvTeam::makePeace
EXTRN	?DoResearchAgreementNotification@CvGame@@QAEXW4TeamTypes@@0@Z:PROC ; CvGame::DoResearchAgreementNotification
EXTRN	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:PROC ; CvTreasury::LogExpenditure
EXTRN	?AddVoteCommitment@CvLeagueAI@@QAEXW4PlayerTypes@@HHH_N@Z:PROC ; CvLeagueAI::AddVoteCommitment
EXTRN	?SetDoFCounter@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::SetDoFCounter
EXTRN	?SetDoFAccepted@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::SetDoFAccepted
EXTRN	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasEmbassyAtTeam
EXTRN	?acquireCity@CvPlayer@@QAEXPAVCvCity@@_N1@Z:PROC ; CvPlayer::acquireCity
EXTRN	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassCount
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getLeaderTypeKey
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$16
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$17
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$18
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$6
	DD	09H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$7
	DD	0aH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$8
	DD	0aH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$9
	DD	0aH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$10
	DD	0dH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$11
	DD	0eH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$12
	DD	0dH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$13
	DD	010H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
_TEXT	SEGMENT
tv4848 = -2544						; size = 4
tv3818 = -2544						; size = 4
_iGoldCost$242756 = -2544				; size = 4
_iLongestDuration$222783 = -2544			; size = 4
_bValid$ = -2538					; size = 1
_bFoundIt$ = -2537					; size = 1
$T242708 = -2536					; size = 4
_iFromTeamIndex$222875 = -2536				; size = 4
_bSentResearchAgreementNotification$222793 = -2529	; size = 1
tv3817 = -2528						; size = 4
$T242166 = -2528					; size = 4
_iLatestItemLastTurn$222782 = -2528			; size = 4
$T241807 = -2524					; size = 8
_it$222784 = -2524					; size = 8
$T241804 = -2524					; size = 8
$T242555 = -2516					; size = 4
$T242284 = -2516					; size = 4
_eTargetTeam$222860 = -2516				; size = 4
$T241815 = -2516					; size = 4
_eAcceptedFromPlayer$222795 = -2516			; size = 4
_bTargetTeamIsMinor$222862 = -2512			; size = 1
$T242560 = -2512					; size = 4
$T242239 = -2512					; size = 4
$T242289 = -2512					; size = 4
$T244093 = -2508					; size = 4
_this$ = -2508						; size = 4
_elem$243981 = -2504					; size = 8
$T241810 = -2504					; size = 8
$T241808 = -2504					; size = 8
$T241805 = -2504					; size = 8
$T241802 = -2504					; size = 8
_strMessage$222898 = -2496				; size = 28
$T241814 = -2496					; size = 28
$T241812 = -2496					; size = 28
_kDeal$ = -2468						; size = 76
$T241820 = -2392					; size = 28
$T241819 = -2392					; size = 28
$T241817 = -2392					; size = 28
_strTemp$222883 = -2364					; size = 80
$T241822 = -2284					; size = 28
$T241823 = -2256					; size = 28
_strSummary$222886 = -2228				; size = 80
$T241821 = -2148					; size = 80
_veNowAtPeacePairs$ = -2068				; size = 520
_tempDeals$222772 = -1548				; size = 1536
__$EHRec$ = -12						; size = 12
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
_bAccepted$ = 16					; size = 1
?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z PROC ; CvGameDeals::FinalizeDeal, COMDAT
; _this$ = ecx

; 2303 : {

	push	-1
	push	__ehhandler$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2532				; 000009e4H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2304 : 	DealList::iterator dealIt;
; 2305 : 	CvDeal kDeal;

	lea	ecx, DWORD PTR _kDeal$[esp+2560]
	mov	DWORD PTR _this$[esp+2560], esi
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+2568], eax

; 2306 : 	bool bFoundIt = false;

	mov	BYTE PTR _bFoundIt$[esp+2560], al

; 2307 : 	bool bValid   = true;
; 2308 : 	CvWeightedVector<TeamTypes, MAX_CIV_TEAMS, true> veNowAtPeacePairs; // hacked CvWeighedVector to keep track of third party minors that this deal makes at peace

	mov	DWORD PTR _veNowAtPeacePairs$[esp+2564], eax
	lea	eax, DWORD PTR _veNowAtPeacePairs$[esp+2572]
	mov	BYTE PTR _bValid$[esp+2560], 1
	mov	DWORD PTR _veNowAtPeacePairs$[esp+2568], 63 ; 0000003fH
	mov	DWORD PTR _veNowAtPeacePairs$[esp+2560], eax

; 2309 : 
; 2310 : 	// Find the deal in the list of proposed deals
; 2311 : 	for(dealIt = m_ProposedDeals.begin(); dealIt != m_ProposedDeals.end(); ++dealIt)

	mov	ecx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	esi, 4
	add	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+2568], 1
	cmp	edi, ecx
	je	$LN843@FinalizeDe
	mov	ebx, DWORD PTR _eToPlayer$[esp+2556]
	mov	ebp, DWORD PTR _eFromPlayer$[esp+2556]
	npad	4
$LL86@FinalizeDe:

; 2312 : 	{
; 2313 : 		if(dealIt->m_eFromPlayer == eFromPlayer && dealIt->m_eToPlayer == eToPlayer)

	cmp	DWORD PTR [edi+4], ebp
	jne	SHORT $LN85@FinalizeDe
	cmp	DWORD PTR [edi+8], ebx
	jne	SHORT $LN85@FinalizeDe

; 2314 : 		{
; 2315 : 			kDeal = *dealIt;

	push	edi
	lea	ecx, DWORD PTR _kDeal$[esp+2564]
	call	??4CvDeal@@QAEAAV0@ABV0@@Z		; CvDeal::operator=

; 2316 : 
; 2317 : // EFB: once we can use list containers in AutoVariables, go back to this way of deleting
; 2318 : //			m_ProposedDeals.erase(dealIt);
; 2319 : 			bFoundIt = true;

	mov	BYTE PTR _bFoundIt$[esp+2560], 1
$LN85@FinalizeDe:
	mov	edx, DWORD PTR [esi+4]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [esi]
	add	edi, 76					; 0000004cH
	cmp	edi, edx
	jne	SHORT $LL86@FinalizeDe

; 2320 : 		}
; 2321 : 	}
; 2322 : 
; 2323 : 	if(bFoundIt)

	cmp	BYTE PTR _bFoundIt$[esp+2560], 0
	je	$LN843@FinalizeDe

; 2324 : 	{
; 2325 : 
; 2326 : 		TradedItemList::iterator iter;
; 2327 : 		for(iter = kDeal.m_TradedItems.begin(); iter != kDeal.m_TradedItems.end(); ++iter)

	lea	eax, DWORD PTR $T241802[esp+2560]
	push	eax
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T241804[esp+2560]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	setne	al
	test	al, al
	je	$LN79@FinalizeDe
$LL129@FinalizeDe:

; 2328 : 		{
; 2329 : 			if(iter->m_bToRenewed)  // slewis - added exception in case of something that was renewed

	mov	edx, DWORD PTR [ebp+8]
	mov	edi, ebx
	imul	edi, 44					; 0000002cH
	cmp	BYTE PTR [edi+edx+41], 0
	lea	ecx, DWORD PTR [edi+edx]
	jne	SHORT $LN80@FinalizeDe

; 2330 : 			{
; 2331 : 				continue;
; 2332 : 			}
; 2333 : 
; 2334 : 			if(!kDeal.IsPossibleToTradeItem(iter->m_eFromPlayer, kDeal.GetOtherPlayer(iter->m_eFromPlayer), iter->m_eItemType, iter->m_iData1, iter->m_iData2, iter->m_iData3, iter->m_bFlag1, false, true))

	mov	eax, edx
	mov	edx, DWORD PTR _kDeal$[esp+2564]
	cmp	edx, DWORD PTR [edi+eax+36]
	lea	eax, DWORD PTR [edi+eax+8]
	jne	SHORT $LN1053@FinalizeDe
	mov	edx, DWORD PTR _kDeal$[esp+2568]
$LN1053@FinalizeDe:
	push	1
	mov	DWORD PTR $T242166[esp+2564], edx
	movzx	edx, BYTE PTR [eax+24]
	push	0
	push	edx
	mov	edx, DWORD PTR [eax+20]
	push	edx
	mov	edx, DWORD PTR [eax+16]
	push	edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	edx, DWORD PTR $T242166[esp+2584]
	push	eax
	mov	eax, DWORD PTR [ecx+36]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _kDeal$[esp+2596]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN1024@FinalizeDe
$LN80@FinalizeDe:

; 2324 : 	{
; 2325 : 
; 2326 : 		TradedItemList::iterator iter;
; 2327 : 		for(iter = kDeal.m_TradedItems.begin(); iter != kDeal.m_TradedItems.end(); ++iter)

	cmp	ebx, 268435455				; 0fffffffH
	jne	SHORT $LN130@FinalizeDe
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN1026@FinalizeDe
$LN130@FinalizeDe:
	mov	ecx, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [edi+ecx]
$LN1026@FinalizeDe:
	lea	edx, DWORD PTR $T241804[esp+2560]
	push	edx
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	setne	al
	test	al, al
	jne	$LL129@FinalizeDe

; 2330 : 			{
; 2331 : 				continue;
; 2332 : 			}
; 2333 : 
; 2334 : 			if(!kDeal.IsPossibleToTradeItem(iter->m_eFromPlayer, kDeal.GetOtherPlayer(iter->m_eFromPlayer), iter->m_eItemType, iter->m_iData1, iter->m_iData2, iter->m_iData3, iter->m_bFlag1, false, true))

	jmp	SHORT $LN79@FinalizeDe
$LN1024@FinalizeDe:

; 2335 : 			{
; 2336 : 				// mark that the deal is no longer valid. We will still delete the deal but not commit its actions
; 2337 : 				bValid = false;

	mov	BYTE PTR _bValid$[esp+2560], 0
$LN79@FinalizeDe:

; 2338 : 				break;
; 2339 : 			}
; 2340 : 		}
; 2341 : 
; 2342 : 
; 2343 : 		// **** START HACK ****
; 2344 : 		// EFB: temporary delete method; recopy vector without this element
; 2345 : 		//
; 2346 : 		// Copy the deals into a temporary container
; 2347 : 		DealList tempDeals;

	xor	ebp, ebp
	mov	eax, 20					; 00000014H
	lea	ecx, DWORD PTR _tempDeals$222772[esp+2572]
	mov	DWORD PTR _tempDeals$222772[esp+2564], ebp
	mov	DWORD PTR _tempDeals$222772[esp+2568], eax
	mov	DWORD PTR _tempDeals$222772[esp+2560], ecx

; 2348 : 		for(dealIt = m_ProposedDeals.begin(); dealIt != m_ProposedDeals.end(); ++dealIt)

	mov	edx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	imul	edx, 76					; 0000004cH
	add	edx, edi
	mov	BYTE PTR __$EHRec$[esp+2568], 2
	cmp	edi, edx
	je	SHORT $LN74@FinalizeDe
	jmp	SHORT $LN76@FinalizeDe
	npad	9
$LL1051@FinalizeDe:
	mov	eax, DWORD PTR _tempDeals$222772[esp+2568]
$LN76@FinalizeDe:

; 2349 : 		{
; 2350 : 			tempDeals.push_back(*dealIt);

	mov	BYTE PTR _tempDeals$222772[esp+4092], 0
	cmp	DWORD PTR _tempDeals$222772[esp+2564], eax
	jne	SHORT $LN239@FinalizeDe
	push	eax
	lea	ecx, DWORD PTR _tempDeals$222772[esp+2564]
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN239@FinalizeDe:
	mov	ecx, DWORD PTR _tempDeals$222772[esp+2564]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR _tempDeals$222772[esp+2560]
	mov	DWORD PTR $T242239[esp+2560], ecx
	mov	BYTE PTR __$EHRec$[esp+2568], 3
	je	SHORT $LN242@FinalizeDe
	push	edi
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN242@FinalizeDe:
	mov	eax, DWORD PTR [esi+4]
	inc	DWORD PTR _tempDeals$222772[esp+2564]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [esi]
	add	edi, 76					; 0000004cH
	mov	BYTE PTR __$EHRec$[esp+2568], 2
	cmp	edi, eax
	jne	SHORT $LL1051@FinalizeDe
$LN74@FinalizeDe:

; 2351 : 		}
; 2352 : 
; 2353 : 		// Copy back in minus this element
; 2354 : 		m_ProposedDeals.clear();

	mov	ebx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	cmp	ebx, ebp
	jbe	SHORT $LN249@FinalizeDe
$LL251@FinalizeDe:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	ebp
	mov	ecx, edi
	call	eax
	add	edi, 76					; 0000004cH
	sub	ebx, 1
	jne	SHORT $LL251@FinalizeDe
$LN249@FinalizeDe:

; 2355 : 		for(dealIt = tempDeals.begin(); dealIt != tempDeals.end(); ++dealIt)

	mov	ecx, DWORD PTR _tempDeals$222772[esp+2564]
	mov	eax, DWORD PTR _tempDeals$222772[esp+2560]
	imul	ecx, 76					; 0000004cH
	add	ecx, eax
	mov	DWORD PTR [esi+4], ebp
	mov	edi, eax
	cmp	eax, ecx
	je	SHORT $LN71@FinalizeDe
	mov	ebx, DWORD PTR _eToPlayer$[esp+2556]
	mov	ebp, DWORD PTR _eFromPlayer$[esp+2556]
	npad	4
$LL73@FinalizeDe:

; 2356 : 		{
; 2357 : 			if(dealIt->m_eFromPlayer != eFromPlayer || dealIt->m_eToPlayer != eToPlayer)

	cmp	DWORD PTR [edi+4], ebp
	jne	SHORT $LN69@FinalizeDe
	cmp	DWORD PTR [edi+8], ebx
	je	SHORT $LN72@FinalizeDe
$LN69@FinalizeDe:

; 2358 : 			{
; 2359 : 				m_ProposedDeals.push_back(*dealIt);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T242289[esp+2560], esi
	mov	BYTE PTR [esi+1532], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN259@FinalizeDe
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN259@FinalizeDe:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T242284[esp+2560], ecx
	mov	BYTE PTR __$EHRec$[esp+2568], 4
	je	SHORT $LN262@FinalizeDe
	push	edi
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN262@FinalizeDe:
	inc	DWORD PTR [esi+4]
	mov	eax, DWORD PTR _tempDeals$222772[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 2
$LN72@FinalizeDe:
	mov	edx, DWORD PTR _tempDeals$222772[esp+2564]
	imul	edx, 76					; 0000004cH
	add	edi, 76					; 0000004cH
	add	edx, eax
	cmp	edi, edx
	jne	SHORT $LL73@FinalizeDe
$LN71@FinalizeDe:

; 2360 : 			}
; 2361 : 		}
; 2362 : 		// **** END HACK ****
; 2363 : 
; 2364 : 
; 2365 : 		if(bValid && bAccepted)

	cmp	BYTE PTR _bValid$[esp+2560], 0
	je	$LN68@FinalizeDe
	cmp	BYTE PTR _bAccepted$[esp+2556], 0
	je	$LN68@FinalizeDe

; 2366 : 		{
; 2367 : 			// Determine total duration of the Deal
; 2368 : 			int iLatestItemLastTurn = 0;

	xor	eax, eax
	mov	DWORD PTR _iLatestItemLastTurn$222782[esp+2560], eax

; 2369 : 			int iLongestDuration = 0;

	mov	DWORD PTR _iLongestDuration$222783[esp+2560], eax

; 2370 : 			//int iTemp;
; 2371 : 
; 2372 : 			TradedItemList::iterator it;
; 2373 : 			for(it = kDeal.m_TradedItems.begin(); it != kDeal.m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T241805[esp+2560]
	push	eax
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T241807[esp+2560]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	setne	al
	test	al, al
	je	SHORT $LN65@FinalizeDe
	mov	ebp, DWORD PTR [ebx+8]
	npad	3
$LL275@FinalizeDe:

; 2374 : 			{
; 2375 : 				CvAssertMsg(it->m_eFromPlayer == kDeal.m_eFromPlayer || it->m_eFromPlayer == kDeal.m_eToPlayer, "DEAL: Adding deal that has an item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2376 : 
; 2377 : 				// Calculate duration
; 2378 : 				if(it->m_iDuration > 0)

	mov	esi, edi
	imul	esi, 44					; 0000002cH
	cmp	DWORD PTR [esi+ebp+12], 0
	jle	SHORT $LN66@FinalizeDe

; 2379 : 				{
; 2380 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2381 : 					it->m_iTurnsRemaining = it->m_iDuration;
; 2382 : #else
; 2383 : 					it->m_iFinalTurn = it->m_iDuration + GC.getGame().getGameTurn();

	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	ebp, DWORD PTR [esi+edx+8]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebp+8], eax

; 2384 : #endif
; 2385 : 					if(it->m_iDuration > iLongestDuration)

	mov	ebp, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR _iLongestDuration$222783[esp+2560]
	cmp	DWORD PTR [esi+ebp+12], eax
	jle	SHORT $LN66@FinalizeDe

; 2386 : 					{
; 2387 : 						iLongestDuration = it->m_iDuration;

	mov	ecx, ebp
	mov	edx, DWORD PTR [esi+ecx+12]
	lea	eax, DWORD PTR [esi+ecx]

; 2388 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2389 : 						iLatestItemLastTurn = it->m_iDuration + GC.getGame().getGameTurn();
; 2390 : #else
; 2391 : 						iLatestItemLastTurn = it->m_iFinalTurn;

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _iLongestDuration$222783[esp+2560], edx
	mov	DWORD PTR _iLatestItemLastTurn$222782[esp+2560], eax
$LN66@FinalizeDe:

; 2370 : 			//int iTemp;
; 2371 : 
; 2372 : 			TradedItemList::iterator it;
; 2373 : 			for(it = kDeal.m_TradedItems.begin(); it != kDeal.m_TradedItems.end(); ++it)

	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN276@FinalizeDe
	mov	edi, DWORD PTR [ebx+24]
	jmp	SHORT $LN1030@FinalizeDe
$LN276@FinalizeDe:
	mov	edi, DWORD PTR [esi+ebp]
$LN1030@FinalizeDe:
	lea	ecx, DWORD PTR $T241807[esp+2560]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	setne	al
	test	al, al
	jne	SHORT $LL275@FinalizeDe
$LN65@FinalizeDe:

; 2392 : #endif
; 2393 : 					}
; 2394 : 				}
; 2395 : 			}
; 2396 : 
; 2397 : 			kDeal.m_iDuration = iLongestDuration;

	mov	edx, DWORD PTR _iLongestDuration$222783[esp+2560]

; 2398 : 			kDeal.m_iFinalTurn = iLatestItemLastTurn;

	mov	eax, DWORD PTR _iLatestItemLastTurn$222782[esp+2560]

; 2399 : 			kDeal.m_iStartTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kDeal$[esp+2580], edx
	mov	DWORD PTR _kDeal$[esp+2576], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2400 : 
; 2401 : 			// Add to current deals
; 2402 : 			CvAssertMsg(kDeal.m_TradedItems.size() > 0, "New deal has no tradeable items!");
; 2403 : 			m_CurrentDeals.push_back(kDeal);

	mov	esi, DWORD PTR _this$[esp+2560]
	add	esi, 1540				; 00000604H
	mov	DWORD PTR _kDeal$[esp+2572], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T242560[esp+2560], esi
	mov	BYTE PTR [esi+1532], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN353@FinalizeDe
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN353@FinalizeDe:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T242555[esp+2560], ecx
	mov	BYTE PTR __$EHRec$[esp+2568], 5
	je	SHORT $LN356@FinalizeDe
	lea	edx, DWORD PTR _kDeal$[esp+2560]
	push	edx
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN356@FinalizeDe:
	inc	DWORD PTR [esi+4]

; 2404 : 			kDeal.m_iStartTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+2568], 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _kDeal$[esp+2572], eax

; 2405 : 
; 2406 : 			bool bSentResearchAgreementNotification = false;
; 2407 : 
; 2408 : 			int iCost;
; 2409 : 
; 2410 : 			// What effects does this Deal have right now?
; 2411 : 			PlayerTypes eAcceptedFromPlayer;
; 2412 : 			PlayerTypes eAcceptedToPlayer;
; 2413 : 			TeamTypes eFromTeam;
; 2414 : 			TeamTypes eToTeam;
; 2415 : 
; 2416 : 			for(it = kDeal.m_TradedItems.begin(); it != kDeal.m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T241808[esp+2560]
	push	eax
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	mov	BYTE PTR _bSentResearchAgreementNotification$222793[esp+2564], 0
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T241810[esp+2560]
	mov	DWORD PTR _it$222784[esp+2560], ecx
	push	edx
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	mov	DWORD PTR _it$222784[esp+2568], esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	setne	al
	test	al, al
	je	$LN60@FinalizeDe
$LL363@FinalizeDe:

; 2417 : 			{
; 2418 : 				// if the deal is renewed do not start it up
; 2419 : 				if(it->m_bToRenewed)

	mov	eax, DWORD PTR _it$222784[esp+2564]
	mov	ecx, DWORD PTR _it$222784[esp+2560]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv3817[esp+2560], eax
	add	eax, edx
	cmp	BYTE PTR [eax+41], 0
	mov	DWORD PTR tv3818[esp+2560], eax
	jne	$LN61@FinalizeDe

; 2420 : 				{
; 2421 : 					continue;
; 2422 : 				}
; 2423 : 
; 2424 : 				eAcceptedFromPlayer = it->m_eFromPlayer;

	mov	esi, DWORD PTR [eax+36]

; 2425 : 				eAcceptedToPlayer = kDeal.GetOtherPlayer(eAcceptedFromPlayer);

	mov	edi, DWORD PTR _kDeal$[esp+2564]
	mov	DWORD PTR _eAcceptedFromPlayer$222795[esp+2560], esi
	cmp	edi, esi
	jne	SHORT $LN397@FinalizeDe
	mov	edi, DWORD PTR _kDeal$[esp+2568]
$LN397@FinalizeDe:

; 2426 : 				eFromTeam = GET_PLAYER(eAcceptedFromPlayer).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	mov	eax, DWORD PTR [esi+ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN407@FinalizeDe
	mov	ebx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN408@FinalizeDe
$LN407@FinalizeDe:
	or	ebx, -1
$LN408@FinalizeDe:

; 2427 : 				eToTeam = GET_PLAYER(eAcceptedToPlayer).getTeam();

	mov	ebp, edi
	imul	ebp, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN418@FinalizeDe
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T242708[esp+2560], eax
	jmp	SHORT $LN419@FinalizeDe
$LN418@FinalizeDe:
	mov	DWORD PTR $T242708[esp+2560], -1
$LN419@FinalizeDe:

; 2428 : 
; 2429 : 				CvAssertMsg(eAcceptedFromPlayer == kDeal.m_eFromPlayer || eAcceptedFromPlayer == kDeal.m_eToPlayer, "DEAL: Adding deal that has an item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2430 : 
; 2431 : 				// Deduct Gold cost (if applicable)
; 2432 : 				iCost = GetTradeItemGoldCost(it->m_eItemType, eAcceptedFromPlayer, eAcceptedToPlayer);

	mov	edx, DWORD PTR tv3818[esp+2560]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 8
	mov	DWORD PTR _iGoldCost$242756[esp+2560], 0
	je	SHORT $LN434@FinalizeDe
	sub	eax, 1
	jne	SHORT $LN435@FinalizeDe
	mov	DWORD PTR _iGoldCost$242756[esp+2560], 250 ; 000000faH
	jmp	SHORT $LN435@FinalizeDe
$LN434@FinalizeDe:
	mov	eax, DWORD PTR _eAcceptedFromPlayer$222795[esp+2560]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	push	eax
	call	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z ; CvGame::GetResearchAgreementCost
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _iGoldCost$242756[esp+2560], eax
$LN435@FinalizeDe:

; 2433 : 				GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->ChangeGold(-iCost);

	mov	edx, DWORD PTR _iGoldCost$242756[esp+2560]
	neg	edx
	add	ecx, esi
	push	edx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2434 : 
; 2435 : 				// Gold
; 2436 : 				if(it->m_eItemType == TRADE_ITEM_GOLD)

	mov	eax, DWORD PTR _it$222784[esp+2560]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR tv3817[esp+2560]
	mov	eax, DWORD PTR [ecx+edx+8]
	add	ecx, edx
	test	eax, eax
	jne	SHORT $LN58@FinalizeDe

; 2437 : 				{
; 2438 : 					int iGoldAmount = it->m_iData1;

	mov	edi, DWORD PTR [ecx+20]

; 2439 : 					GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->ChangeGold(-iGoldAmount);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, edi
	neg	eax
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2440 : 					GET_PLAYER(eAcceptedToPlayer).GetTreasury()->ChangeGold(iGoldAmount);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	push	edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold
	jmp	$LN61@FinalizeDe
$LN58@FinalizeDe:

; 2441 : 				}
; 2442 : 				// Gold Per Turn
; 2443 : 				else if(it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	cmp	eax, 1
	jne	SHORT $LN56@FinalizeDe

; 2444 : 				{
; 2445 : 					int iGoldPerTurn = it->m_iData1;

	mov	edi, DWORD PTR [ecx+20]

; 2446 : 					GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurn);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, edi
	neg	eax
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 2447 : 					GET_PLAYER(eAcceptedToPlayer).GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurn);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	push	edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
	jmp	$LN61@FinalizeDe
$LN56@FinalizeDe:

; 2448 : 				}
; 2449 : 				// Resource
; 2450 : 				else if(it->m_eItemType == TRADE_ITEM_RESOURCES)

	cmp	eax, 3
	jne	$LN54@FinalizeDe

; 2451 : 				{
; 2452 : 					ResourceTypes eResource = (ResourceTypes) it->m_iData1;

	mov	edx, DWORD PTR _it$222784[esp+2560]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR tv3817[esp+2560]

; 2453 : 					int iResourceQuantity = it->m_iData2;

	mov	ebx, DWORD PTR [eax+ecx+24]
	mov	edi, DWORD PTR [eax+ecx+20]

; 2454 : 					GET_PLAYER(eAcceptedFromPlayer).changeResourceExport(eResource, iResourceQuantity);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	eax, ecx
	push	ebx
	push	edi
	lea	ecx, DWORD PTR [esi+edx]
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 2455 : 					GET_PLAYER(eAcceptedToPlayer).changeResourceImport(eResource, iResourceQuantity);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	edi
	lea	ecx, DWORD PTR [eax+ebp]
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport

; 2456 : 
; 2457 : 					//Resource Trading Achievements
; 2458 : 					if(!GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN61@FinalizeDe

; 2459 : 					{
; 2460 : 						if(GET_PLAYER(eAcceptedFromPlayer).isHuman())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN61@FinalizeDe

; 2461 : 						{
; 2462 : 							gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_RESOURCESTRADED, 100, ACHIEVEMENT_100RESOURCES);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+848]
	push	93					; 0000005dH
	push	100					; 00000064H
	push	119					; 00000077H
	call	eax

; 2463 : 
; 2464 : 							if(GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	$LN61@FinalizeDe

; 2465 : 							{
; 2466 : 								//OutputDebugString("\nStep0");
; 2467 : 								if(((CvString)GET_PLAYER(eAcceptedFromPlayer).getLeaderTypeKey() == "LEADER_HARUN_AL_RASHID"))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ	; CvPlayer::getLeaderTypeKey
	test	eax, eax
	jne	SHORT $LN536@FinalizeDe
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN536@FinalizeDe:
	push	eax
	lea	ecx, DWORD PTR $T241812[esp+2564]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR $T241812[esp+2560]
	push	OFFSET $SG222823
	push	edx
	mov	BYTE PTR __$EHRec$[esp+2576], 6
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	lea	ecx, DWORD PTR $T241812[esp+2560]
	mov	bl, al
	mov	BYTE PTR __$EHRec$[esp+2568], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, bl
	je	$LN61@FinalizeDe

; 2468 : 								{
; 2469 : 									//OutputDebugString("\nStep1");
; 2470 : #ifdef AUI_WARNING_FIXES
; 2471 : 									for (uint iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
; 2472 : #else
; 2473 : 									int iJ;
; 2474 : 									for(iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN61@FinalizeDe
	npad	3
$LL49@FinalizeDe:

; 2475 : #endif
; 2476 : 									{
; 2477 : 										CvBuildingEntry* pkBuildingEntry = GC.getBuildingInfo((BuildingTypes)iJ);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 2478 : 										if(pkBuildingEntry)

	test	edi, edi
	je	$LN48@FinalizeDe

; 2479 : 										{
; 2480 : 											if((CvString)pkBuildingEntry->GetType() == "BUILDING_BAZAAR")

	lea	ecx, DWORD PTR [edi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN546@FinalizeDe
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN546@FinalizeDe:
	push	eax
	lea	ecx, DWORD PTR $T241814[esp+2564]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T241814[esp+2560]
	push	OFFSET $SG222835
	push	eax
	mov	BYTE PTR __$EHRec$[esp+2576], 7
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	lea	ecx, DWORD PTR $T241814[esp+2560]
	mov	bl, al
	mov	BYTE PTR __$EHRec$[esp+2568], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, bl
	je	SHORT $LN48@FinalizeDe

; 2481 : 											{
; 2482 : 												//OutputDebugString("\nStep2");
; 2483 : 												if(GET_PLAYER(eAcceptedFromPlayer).getBuildingClassCount((BuildingClassTypes)pkBuildingEntry->GetBuildingClassType()) >= 1)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ebx, DWORD PTR [esi+ecx]
	mov	ecx, edi
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	push	eax
	mov	ecx, ebx
	call	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassCount
	cmp	eax, 1
	jl	SHORT $LN48@FinalizeDe

; 2484 : 												{
; 2485 : 													gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_TRADER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	99					; 00000063H
	call	eax
$LN48@FinalizeDe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	ebp, eax
	jl	$LL49@FinalizeDe

; 2486 : 												}
; 2487 : 
; 2488 : 											}
; 2489 : 										}
; 2490 : 									}
; 2491 : 								}
; 2492 : 							}
; 2493 : 						}
; 2494 : 					}
; 2495 : 				}

	jmp	$LN61@FinalizeDe
$LN54@FinalizeDe:

; 2496 : 				// City
; 2497 : 				else if(it->m_eItemType == TRADE_ITEM_CITIES)

	cmp	eax, 4
	jne	$LN42@FinalizeDe

; 2498 : 				{
; 2499 : 					CvCity* pCity = GC.getMap().plot(it->m_iData1, it->m_iData2)->getPlotCity();

	mov	ecx, DWORD PTR _it$222784[esp+2560]
	mov	eax, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [edx+eax+24]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN587@FinalizeDe
	cmp	ebx, -2147483647			; 80000001H
	je	$LN587@FinalizeDe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN597@FinalizeDe
	test	eax, eax
	jge	SHORT $LN599@FinalizeDe
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN601@FinalizeDe
$LN599@FinalizeDe:
	cmp	eax, ecx
	jl	SHORT $LN597@FinalizeDe
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN601@FinalizeDe
$LN597@FinalizeDe:
	mov	esi, eax
$LN601@FinalizeDe:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN607@FinalizeDe
	test	ebx, ebx
	jge	SHORT $LN609@FinalizeDe
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN611@FinalizeDe
$LN609@FinalizeDe:
	cmp	ebx, edi
	jl	SHORT $LN607@FinalizeDe
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN611@FinalizeDe
$LN607@FinalizeDe:
	mov	edx, ebx
$LN611@FinalizeDe:
	test	esi, esi
	jl	SHORT $LN587@FinalizeDe
	cmp	esi, ecx
	jge	SHORT $LN587@FinalizeDe
	test	edx, edx
	jl	SHORT $LN587@FinalizeDe
	cmp	edx, edi
	jge	SHORT $LN587@FinalizeDe
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN589@FinalizeDe
$LN587@FinalizeDe:
	xor	ecx, ecx
$LN589@FinalizeDe:
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	$LN61@FinalizeDe
	cmp	eax, 64					; 00000040H
	jge	$LN61@FinalizeDe
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 2500 : 					if(pCity != NULL)

	test	eax, eax
	je	$LN61@FinalizeDe

; 2501 : 						GET_PLAYER(eAcceptedToPlayer).acquireCity(pCity, false, true);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	0
	push	eax
	lea	ecx, DWORD PTR [edx+ebp]
	call	?acquireCity@CvPlayer@@QAEXPAVCvCity@@_N1@Z ; CvPlayer::acquireCity

; 2502 : 				}

	jmp	$LN61@FinalizeDe
$LN42@FinalizeDe:

; 2503 : 				else if(it->m_eItemType == TRADE_ITEM_ALLOW_EMBASSY)

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN39@FinalizeDe

; 2504 : 				{
; 2505 : 					GET_TEAM(eToTeam).SetHasEmbassyAtTeam(eFromTeam, true);

	mov	ecx, DWORD PTR $T242708[esp+2560]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	ebx
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
	jmp	$LN61@FinalizeDe
$LN39@FinalizeDe:

; 2506 : 				}
; 2507 : 				else if(it->m_eItemType == TRADE_ITEM_DECLARATION_OF_FRIENDSHIP)

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN37@FinalizeDe

; 2508 : 				{
; 2509 : 					// Declaration of friendship always goes both ways.  We will most likely have two entries in the deal for this
; 2510 : 					// but just in case, set both anyway.
; 2511 : 					GET_PLAYER(eAcceptedFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eAcceptedToPlayer, true);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	lea	ecx, DWORD PTR [esi+eax]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFAccepted@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetDoFAccepted

; 2512 : 					GET_PLAYER(eAcceptedFromPlayer).GetDiplomacyAI()->SetDoFCounter(eAcceptedToPlayer, 0);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, ecx
	push	0
	push	edi
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFCounter@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::SetDoFCounter

; 2513 : 					GET_PLAYER(eAcceptedToPlayer).GetDiplomacyAI()->SetDoFAccepted(eAcceptedFromPlayer, true);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, DWORD PTR _eAcceptedFromPlayer$222795[esp+2560]
	push	1
	lea	ecx, DWORD PTR [edx+ebp]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFAccepted@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetDoFAccepted

; 2514 : 					GET_PLAYER(eAcceptedToPlayer).GetDiplomacyAI()->SetDoFCounter(eAcceptedFromPlayer, 0);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	ecx, DWORD PTR [eax+ebp]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFCounter@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::SetDoFCounter
	jmp	$LN61@FinalizeDe
$LN37@FinalizeDe:

; 2515 : 				}
; 2516 : 				// Vote Commitment
; 2517 : 				else if(it->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT)

	cmp	eax, 19					; 00000013H
	jne	SHORT $LN35@FinalizeDe

; 2518 : 				{
; 2519 : 					GET_PLAYER(eAcceptedFromPlayer).GetLeagueAI()->AddVoteCommitment(eAcceptedToPlayer, it->m_iData1, it->m_iData2, it->m_iData3, it->m_bFlag1);

	mov	ecx, DWORD PTR _it$222784[esp+2560]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+eax+8]
	movzx	edx, BYTE PTR [eax+24]
	push	edx
	mov	edx, DWORD PTR [eax+16]
	add	esi, ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+12]
	push	ecx
	push	edx
	push	eax
	push	edi
	mov	ecx, esi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?AddVoteCommitment@CvLeagueAI@@QAEXW4PlayerTypes@@HHH_N@Z ; CvLeagueAI::AddVoteCommitment
	jmp	$LN61@FinalizeDe
$LN35@FinalizeDe:

; 2520 : 				}
; 2521 : 				// Open Borders
; 2522 : 				else if(it->m_eItemType == TRADE_ITEM_OPEN_BORDERS)

	cmp	eax, 6
	jne	SHORT $LN33@FinalizeDe

; 2523 : 				{
; 2524 : 					GET_TEAM(eFromTeam).SetAllowsOpenBordersToTeam(eToTeam, true);

	mov	ecx, DWORD PTR $T242708[esp+2560]
	push	1
	push	ecx
	mov	ecx, ebx
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
	jmp	$LN61@FinalizeDe
$LN33@FinalizeDe:

; 2525 : 				}
; 2526 : 				// Defensive Pact
; 2527 : 				else if(it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT)

	cmp	eax, 7
	jne	SHORT $LN31@FinalizeDe

; 2528 : 				{
; 2529 : 					GET_TEAM(eFromTeam).SetHasDefensivePact(eToTeam, true);

	mov	edx, DWORD PTR $T242708[esp+2560]
	mov	ecx, ebx
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	edx
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
	jmp	$LN61@FinalizeDe
$LN31@FinalizeDe:

; 2530 : 				}
; 2531 : 				// Research Agreement
; 2532 : 				else if(it->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT)

	cmp	eax, 8
	jne	$LN29@FinalizeDe

; 2533 : 				{
; 2534 : 					GET_TEAM(eFromTeam).SetHasResearchAgreement(eToTeam, true);

	mov	edi, DWORD PTR $T242708[esp+2560]
	mov	ecx, ebx
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	edi
	call	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasResearchAgreement

; 2535 : 					GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->LogExpenditure(GET_PLAYER(eAcceptedToPlayer).getCivilizationShortDescription(), iCost, 9);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR _iGoldCost$242756[esp+2560]
	push	9
	add	ebp, ecx
	push	eax
	mov	ecx, ebp
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241815[esp+2596], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN755@FinalizeDe
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN755@FinalizeDe:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+2604], 8
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+2604], 2
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 2536 : 
; 2537 : 					if(!bSentResearchAgreementNotification)

	cmp	BYTE PTR _bSentResearchAgreementNotification$222793[esp+2560], 0
	jne	$LN61@FinalizeDe

; 2538 : 					{
; 2539 : 						bSentResearchAgreementNotification = true;
; 2540 : 						GC.getGame().DoResearchAgreementNotification(eFromTeam, eToTeam);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	push	ebx
	mov	BYTE PTR _bSentResearchAgreementNotification$222793[esp+2568], 1
	call	?DoResearchAgreementNotification@CvGame@@QAEXW4TeamTypes@@0@Z ; CvGame::DoResearchAgreementNotification

; 2541 : 					}
; 2542 : 				}

	jmp	$LN61@FinalizeDe
$LN29@FinalizeDe:

; 2543 : 				// Trade Agreement
; 2544 : 				else if(it->m_eItemType == TRADE_ITEM_TRADE_AGREEMENT)

	cmp	eax, 9
	jne	SHORT $LN26@FinalizeDe

; 2545 : 				{
; 2546 : 					GET_TEAM(eFromTeam).SetHasTradeAgreement(eToTeam, true);

	mov	eax, DWORD PTR $T242708[esp+2560]
	mov	ecx, ebx
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	eax
	call	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasTradeAgreement
	jmp	$LN61@FinalizeDe
$LN26@FinalizeDe:

; 2547 : 				}
; 2548 : 				// Third Party Peace
; 2549 : 				else if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE)

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN24@FinalizeDe

; 2550 : 				{
; 2551 : 					TeamTypes eTargetTeam = (TeamTypes) it->m_iData1;

	mov	ebp, DWORD PTR [ecx+20]

; 2552 : 					bool bTargetTeamIsMinor = GET_TEAM(eTargetTeam).isMinorCiv();

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, ebp
	imul	esi, 2980				; 00000ba4H
	add	ecx, esi
	mov	DWORD PTR _eTargetTeam$222860[esp+2560], ebp
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv

; 2553 : 					GET_TEAM(eFromTeam).makePeace(eTargetTeam, /*bBumpUnits*/ true, /*bSuppressNotification*/ bTargetTeamIsMinor);

	mov	edi, ebx
	imul	edi, 2980				; 00000ba4H
	mov	BYTE PTR _bTargetTeamIsMinor$222862[esp+2560], al
	mov	edx, DWORD PTR _bTargetTeamIsMinor$222862[esp+2560]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	push	1
	push	ebp
	lea	ecx, DWORD PTR [edi+eax]
	call	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ; CvTeam::makePeace

; 2554 : 					GET_TEAM(eFromTeam).setForcePeace(eTargetTeam, true);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	ebp
	add	ecx, edi
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 2555 : 					GET_TEAM(eTargetTeam).setForcePeace(eFromTeam, true);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	ebx
	lea	ecx, DWORD PTR [esi+edx]
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 2556 : 
; 2557 : 					if(bTargetTeamIsMinor)

	cmp	BYTE PTR _bTargetTeamIsMinor$222862[esp+2560], 0
	je	SHORT $LN61@FinalizeDe

; 2558 : 						veNowAtPeacePairs.push_back(eTargetTeam, eFromTeam); //eFromTeam is second so we can take advantage of CvWeightedVector's sort by weights

	push	ebx
	lea	eax, DWORD PTR _eTargetTeam$222860[esp+2564]
	push	eax
	lea	ecx, DWORD PTR _veNowAtPeacePairs$[esp+2568]
	call	?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z ; CvWeightedVector<enum TeamTypes,63,1>::push_back

; 2559 : 				}

	jmp	SHORT $LN61@FinalizeDe
$LN24@FinalizeDe:

; 2560 : 				// Third Party War
; 2561 : 				else if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR)

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN21@FinalizeDe

; 2562 : 				{
; 2563 : 					TeamTypes eTargetTeam = (TeamTypes) it->m_iData1;

	mov	esi, DWORD PTR [ecx+20]

; 2564 : 					GET_TEAM(eFromTeam).declareWar(eTargetTeam);

	imul	ebx, 2980				; 00000ba4H
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	esi
	add	ecx, ebx
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar

; 2565 : 
; 2566 : 					int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();
; 2567 : 					GET_TEAM(eFromTeam).ChangeNumTurnsLockedIntoWar(eTargetTeam, iLockedTurns);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6692
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	push	esi
	lea	ecx, DWORD PTR [ebx+eax]
	call	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsLockedIntoWar
	jmp	SHORT $LN61@FinalizeDe
$LN21@FinalizeDe:

; 2568 : 				}
; 2569 : 				// **** Peace Treaty **** this should always be the last item processed!!!
; 2570 : 				else if(it->m_eItemType == TRADE_ITEM_PEACE_TREATY)

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN61@FinalizeDe

; 2571 : 				{
; 2572 : 					GET_TEAM(eFromTeam).makePeace(eToTeam);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	ebx, 2980				; 00000ba4H
	mov	esi, DWORD PTR $T242708[esp+2560]
	push	0
	push	1
	push	esi
	add	ecx, ebx
	call	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ; CvTeam::makePeace

; 2573 : 					GET_TEAM(eFromTeam).setForcePeace(eToTeam, true);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	esi
	lea	ecx, DWORD PTR [ebx+edx]
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace
$LN61@FinalizeDe:

; 2405 : 
; 2406 : 			bool bSentResearchAgreementNotification = false;
; 2407 : 
; 2408 : 			int iCost;
; 2409 : 
; 2410 : 			// What effects does this Deal have right now?
; 2411 : 			PlayerTypes eAcceptedFromPlayer;
; 2412 : 			PlayerTypes eAcceptedToPlayer;
; 2413 : 			TeamTypes eFromTeam;
; 2414 : 			TeamTypes eToTeam;
; 2415 : 
; 2416 : 			for(it = kDeal.m_TradedItems.begin(); it != kDeal.m_TradedItems.end(); ++it)

	cmp	DWORD PTR _it$222784[esp+2564], 268435455 ; 0fffffffH
	jne	SHORT $LN364@FinalizeDe
	mov	eax, DWORD PTR _it$222784[esp+2560]
	mov	esi, DWORD PTR [eax+24]
	jmp	SHORT $LN1054@FinalizeDe
$LN364@FinalizeDe:
	mov	ecx, DWORD PTR _it$222784[esp+2560]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR tv3817[esp+2560]
	mov	esi, DWORD PTR [eax+edx]
$LN1054@FinalizeDe:
	lea	ecx, DWORD PTR $T241810[esp+2560]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[esp+2608]
	mov	DWORD PTR _it$222784[esp+2568], esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	esi, DWORD PTR [eax+4]
	setne	al
	test	al, al
	jne	$LL363@FinalizeDe
$LN60@FinalizeDe:

; 2574 : 				}
; 2575 : 				//////////////////////////////////////////////////////////////////////
; 2576 : 				// **** DO NOT PUT ANYTHING AFTER THIS LINE ****
; 2577 : 				//////////////////////////////////////////////////////////////////////
; 2578 : 			}
; 2579 : 
; 2580 : 			LogDealComplete(&kDeal);

	mov	ecx, DWORD PTR _this$[esp+2560]
	lea	edx, DWORD PTR _kDeal$[esp+2560]
	push	edx
	call	?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z ; CvGameDeals::LogDealComplete
$LN68@FinalizeDe:

; 2581 : 		}
; 2582 : 	}

	mov	edi, DWORD PTR _tempDeals$222772[esp+2564]
	mov	esi, DWORD PTR _tempDeals$222772[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 1
	mov	ebx, esi
	test	edi, edi
	jbe	SHORT $LN847@FinalizeDe
	npad	4
$LL849@FinalizeDe:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL849@FinalizeDe
$LN847@FinalizeDe:
	lea	eax, DWORD PTR _tempDeals$222772[esp+2572]
	cmp	ebx, eax
	je	SHORT $LN843@FinalizeDe
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN843@FinalizeDe:

; 2583 : 
; 2584 : 	// Update UI if we were involved in the deal
; 2585 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 2586 : 	if(eFromPlayer == eActivePlayer || eToPlayer == eActivePlayer)

	cmp	DWORD PTR _eFromPlayer$[esp+2556], eax
	je	SHORT $LN17@FinalizeDe
	cmp	DWORD PTR _eToPlayer$[esp+2556], eax
	jne	SHORT $LN18@FinalizeDe
$LN17@FinalizeDe:

; 2587 : 	{
; 2588 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
$LN18@FinalizeDe:

; 2589 : 	}
; 2590 : 
; 2591 : 	// Send out a condensed notification if peace was made with third party minor civs in this deal
; 2592 : 	if(veNowAtPeacePairs.size() > 0)

	cmp	DWORD PTR _veNowAtPeacePairs$[esp+2564], 0
	jle	$LN13@FinalizeDe

; 2593 : 	{
; 2594 : 		// Loop through all teams
; 2595 : 		for(int iFromTeamIndex = 0; iFromTeamIndex < MAX_CIV_TEAMS; iFromTeamIndex++)

	xor	eax, eax
	mov	DWORD PTR _iFromTeamIndex$222875[esp+2560], eax
	mov	DWORD PTR tv4848[esp+2560], eax
	npad	1
$LL15@FinalizeDe:

; 2596 : 		{
; 2597 : 			TeamTypes eFromTeam = (TeamTypes) iFromTeamIndex;
; 2598 : 			TeamTypes eToTeam = NO_TEAM;
; 2599 : 			bool bFromTeamMadePeace = false;
; 2600 : 
; 2601 : 			Localization::String strTemp = Localization::Lookup("TXT_KEY_MISC_MADE_PEACE_WITH_MINOR_ALLIES");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _strTemp$222883[esp+2560]
	push	OFFSET $SG222885
	push	ecx
	or	edi, -1
	xor	bl, bl
	call	esi

; 2602 : 			Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_MADE_PEACE_WITH_MINOR_ALLIES_SUMMARY");

	lea	edx, DWORD PTR _strSummary$222886[esp+2568]
	push	OFFSET $SG222888
	push	edx
	mov	BYTE PTR __$EHRec$[esp+2584], 9
	call	esi
	add	esp, 16					; 00000010H

; 2603 : 			strTemp << GET_TEAM(eFromTeam).getName().GetCString();

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, DWORD PTR tv4848[esp+2560]
	lea	edx, DWORD PTR $T241817[esp+2560]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+2572], 10	; 0000000aH
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+2568], 11	; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strTemp$222883[esp+2564]
	call	ebp
	lea	ecx, DWORD PTR $T241817[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 10	; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2604 : 			strSummary << GET_TEAM(eFromTeam).getName().GetCString();

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	edx, DWORD PTR $T241819[esp+2560]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+2568], 12	; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strSummary$222886[esp+2564]
	call	ebp
	lea	ecx, DWORD PTR $T241819[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 10	; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2605 : 			CvString strMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$222883[esp+2560]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN884@FinalizeDe
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN884@FinalizeDe:
	push	eax
	lea	ecx, DWORD PTR _strMessage$222898[esp+2564]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2606 : 
; 2607 : 			// Did this team make peace with someone in this deal?
; 2608 : 			for(int iPairIndex = 0; iPairIndex < veNowAtPeacePairs.size(); iPairIndex++)

	xor	ebp, ebp
	cmp	DWORD PTR _veNowAtPeacePairs$[esp+2564], ebp
	mov	BYTE PTR __$EHRec$[esp+2568], 13	; 0000000dH
	jle	$LN5@FinalizeDe
	mov	eax, DWORD PTR _veNowAtPeacePairs$[esp+2560]
	mov	esi, DWORD PTR _iFromTeamIndex$222875[esp+2560]
$LL12@FinalizeDe:

; 2609 : 			{
; 2610 : 				if(veNowAtPeacePairs.GetWeight(iPairIndex) == (int) eFromTeam)

	mov	ecx, DWORD PTR [eax+ebp*8]
	mov	DWORD PTR _elem$243981[esp+2560], ecx
	cmp	DWORD PTR [eax+ebp*8+4], esi
	jne	$LN11@FinalizeDe

; 2611 : 				{
; 2612 : 					eToTeam = veNowAtPeacePairs.GetElement(iPairIndex);

	mov	edi, ecx

; 2613 : 					strTemp = Localization::Lookup(GET_TEAM(eToTeam).getName().GetCString());

	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	edx, DWORD PTR $T241820[esp+2560]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+2568], 14	; 0000000eH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T241821[esp+2564]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTemp$222883[esp+2564]
	mov	BYTE PTR __$EHRec$[esp+2572], 15	; 0000000fH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241821[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 14	; 0000000eH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T241820[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 13	; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2614 : 					strMessage = strMessage + "[NEWLINE]" + strTemp.toUTF8();

	mov	ebx, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG222909
	lea	ecx, DWORD PTR _strMessage$222898[esp+2564]
	push	ecx
	lea	edx, DWORD PTR $T241822[esp+2568]
	push	edx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	esi, eax
	lea	ecx, DWORD PTR _strTemp$222883[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 16	; 00000010H
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T241823[esp+2564]
	push	esi
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+2568], 17	; 00000011H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$222898[esp+2564]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T241823[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 16	; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T241822[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 13	; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2615 : 					bFromTeamMadePeace = true;

	mov	eax, DWORD PTR _veNowAtPeacePairs$[esp+2560]
	mov	esi, DWORD PTR _iFromTeamIndex$222875[esp+2560]
	mov	bl, 1
$LN11@FinalizeDe:
	inc	ebp
	cmp	ebp, DWORD PTR _veNowAtPeacePairs$[esp+2564]
	jl	$LL12@FinalizeDe

; 2616 : 				}
; 2617 : 			}
; 2618 : 
; 2619 : 			// Send out notifications if there was a change
; 2620 : 			if(bFromTeamMadePeace)

	test	bl, bl
	je	$LN5@FinalizeDe

; 2621 : 			{
; 2622 : 				// Send out the notifications to other players
; 2623 : 				for(int iNotifPlayerLoop = 0; iNotifPlayerLoop < MAX_MAJOR_CIVS; iNotifPlayerLoop++)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx
$LL7@FinalizeDe:

; 2624 : 				{
; 2625 : 					PlayerTypes eNotifPlayer = (PlayerTypes) iNotifPlayerLoop;
; 2626 : 
; 2627 : 					if(!GET_PLAYER(eNotifPlayer).isAlive())

	cmp	BYTE PTR [ebx+ecx+2256], 0
	je	$LN6@FinalizeDe

; 2628 : 						continue;
; 2629 : 
; 2630 : 					if(GET_PLAYER(eNotifPlayer).getTeam() == eFromTeam)

	mov	eax, DWORD PTR [ebx+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN921@FinalizeDe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN922@FinalizeDe
$LN921@FinalizeDe:
	or	eax, -1
$LN922@FinalizeDe:
	cmp	eax, esi
	je	$LN6@FinalizeDe

; 2631 : 						continue;
; 2632 : 
; 2633 : 					if(GET_TEAM(GET_PLAYER(eNotifPlayer).getTeam()).isHasMet(eFromTeam))  //antonjs: consider: what if eNotifPlayer hasn't met one or more of the minors that eFromTeam made peace with?

	mov	eax, DWORD PTR [ebx+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN932@FinalizeDe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN933@FinalizeDe
$LN932@FinalizeDe:
	or	eax, -1
$LN933@FinalizeDe:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN1040@FinalizeDe

; 2634 : 					{
; 2635 : 						if(GET_PLAYER(eNotifPlayer).GetNotifications())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	SHORT $LN1040@FinalizeDe

; 2636 : 						{
; 2637 : 							GET_PLAYER(eNotifPlayer).GetNotifications()->Add(NOTIFICATION_PEACE, strMessage, strSummary.toUTF8(), -1, -1, GET_TEAM(eFromTeam).getLeaderID(), eToTeam);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR tv4848[esp+2560]
	lea	ebp, DWORD PTR [edx+ecx]
	lea	ecx, DWORD PTR _strMessage$222898[esp+2560]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR $T244093[esp+2560], ecx
	push	edi
	mov	ecx, ebp
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$222886[esp+2576]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR $T244093[esp+2576]
	push	eax
	push	esi
	push	818263651				; 30c5b663H
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	mov	esi, DWORD PTR _iFromTeamIndex$222875[esp+2560]
$LN1040@FinalizeDe:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN6@FinalizeDe:

; 2621 : 			{
; 2622 : 				// Send out the notifications to other players
; 2623 : 				for(int iNotifPlayerLoop = 0; iNotifPlayerLoop < MAX_MAJOR_CIVS; iNotifPlayerLoop++)

	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	$LL7@FinalizeDe
$LN5@FinalizeDe:

; 2638 : 						}
; 2639 : 					}
; 2640 : 				}
; 2641 : 			}
; 2642 : 		}

	lea	ecx, DWORD PTR _strMessage$222898[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 10	; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$222886[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 9
	call	esi
	lea	ecx, DWORD PTR _strTemp$222883[esp+2560]
	mov	BYTE PTR __$EHRec$[esp+2568], 1
	call	esi
	mov	eax, DWORD PTR tv4848[esp+2560]
	inc	DWORD PTR _iFromTeamIndex$222875[esp+2560]
	add	eax, 2980				; 00000ba4H
	cmp	eax, 187740				; 0002dd5cH
	mov	DWORD PTR tv4848[esp+2560], eax
	jl	$LL15@FinalizeDe
$LN13@FinalizeDe:

; 2643 : 	}
; 2644 : 
; 2645 : 	return bFoundIt && bValid;

	cmp	BYTE PTR _bFoundIt$[esp+2560], 0
	je	SHORT $LN89@FinalizeDe
	cmp	BYTE PTR _bValid$[esp+2560], 0
	je	SHORT $LN89@FinalizeDe
	mov	bl, 1
	jmp	SHORT $LN90@FinalizeDe
$LN89@FinalizeDe:
	xor	bl, bl
$LN90@FinalizeDe:
	mov	eax, DWORD PTR _veNowAtPeacePairs$[esp+2560]
	lea	edx, DWORD PTR _veNowAtPeacePairs$[esp+2572]
	mov	BYTE PTR __$EHRec$[esp+2568], 0
	cmp	eax, edx
	je	SHORT $LN955@FinalizeDe
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN955@FinalizeDe:
	xor	eax, eax
	mov	DWORD PTR _kDeal$[esp+2616], eax
	mov	DWORD PTR _kDeal$[esp+2608], eax
	mov	eax, DWORD PTR _kDeal$[esp+2612]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+2572], -1
	mov	DWORD PTR _kDeal$[esp+2564], OFFSET ??_7CvDeal@@6B@
	mov	DWORD PTR _kDeal$[esp+2608], 268435455	; 0fffffffH
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 2646 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2564]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 2544				; 000009f0H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$0:
	lea	ecx, DWORD PTR _kDeal$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$1:
	lea	ecx, DWORD PTR _veNowAtPeacePairs$[ebp]
	jmp	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$2:
	lea	ecx, DWORD PTR _tempDeals$222772[ebp]
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$16:
	mov	eax, DWORD PTR _tempDeals$222772[ebp+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR _tempDeals$222772[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242239[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$17:
	mov	eax, DWORD PTR $T242289[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T242289[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T242284[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$18:
	mov	eax, DWORD PTR $T242560[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T242560[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T242555[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$3:
	lea	ecx, DWORD PTR $T241812[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$4:
	lea	ecx, DWORD PTR $T241814[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$5:
	mov	ecx, DWORD PTR $T241815[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$6:
	lea	ecx, DWORD PTR _strTemp$222883[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$7:
	lea	ecx, DWORD PTR _strSummary$222886[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$8:
	lea	ecx, DWORD PTR $T241817[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$9:
	lea	ecx, DWORD PTR $T241819[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$10:
	lea	ecx, DWORD PTR _strMessage$222898[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$11:
	lea	ecx, DWORD PTR $T241820[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$12:
	lea	ecx, DWORD PTR $T241821[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$13:
	lea	ecx, DWORD PTR $T241822[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$14:
	lea	ecx, DWORD PTR $T241823[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ENDP ; CvGameDeals::FinalizeDeal
PUBLIC	?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ	; CvGameDeals::DoUpdateCurrentDealsList
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$2
__ehfuncinfo$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
_TEXT	SEGMENT
$T244586 = -1560					; size = 4
$T244572 = -1560					; size = 4
$T244567 = -1556					; size = 4
$T244591 = -1556					; size = 4
_this$ = -1552						; size = 4
_tempDeals$ = -1548					; size = 1536
__$EHRec$ = -12						; size = 12
?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ PROC	; CvGameDeals::DoUpdateCurrentDealsList, COMDAT
; _this$ = ecx

; 2970 : {

	push	-1
	push	__ehhandler$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1548				; 0000060cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2971 : 	DealList::iterator it;
; 2972 : 
; 2973 : 	DealList tempDeals;

	xor	ecx, ecx
	lea	eax, DWORD PTR _tempDeals$[esp+1584]
	push	edi
	mov	DWORD PTR _this$[esp+1576], esi
	xor	ebx, ebx
	mov	DWORD PTR _tempDeals$[esp+1580], ecx
	mov	DWORD PTR _tempDeals$[esp+1584], 20	; 00000014H
	mov	DWORD PTR _tempDeals$[esp+1576], eax

; 2974 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2975 : 	for (it = m_CurrentlyEndingDeals.begin(); it != m_CurrentlyEndingDeals.end(); ++it)
; 2976 : 	{
; 2977 : 		tempDeals.push_back(*it);
; 2978 : 	}
; 2979 : 	m_CurrentlyEndingDeals.clear();
; 2980 : 	for (it = tempDeals.begin(); it != tempDeals.end(); ++it)
; 2981 : 	{
; 2982 : 		if (it->m_eFromPlayer == eForPlayer || it->m_eToPlayer == eForPlayer)
; 2983 : 		{
; 2984 : 			m_HistoricalDeals.push_back(*it);
; 2985 : 		}
; 2986 : 		else
; 2987 : 		{
; 2988 : 			m_CurrentlyEndingDeals.push_back(*it);
; 2989 : 		}
; 2990 : 	}
; 2991 : 	tempDeals.clear();
; 2992 : #endif
; 2993 : 
; 2994 : 	// Copy the deals into a temporary container
; 2995 : 	for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	edx, DWORD PTR [esi+1544]
	mov	edi, DWORD PTR [esi+1540]
	imul	edx, 76					; 0000004cH
	add	esi, 1540				; 00000604H
	add	edx, edi
	mov	DWORD PTR __$EHRec$[esp+1584], ebx
	cmp	edi, edx
	je	SHORT $LN6@DoUpdateCu
	npad	1
$LL8@DoUpdateCu:

; 2996 : 	{
; 2997 : 		tempDeals.push_back(*it);

	push	edi
	lea	ecx, DWORD PTR _tempDeals$[esp+1580]
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
	mov	eax, DWORD PTR [esi+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [esi]
	add	edi, 76					; 0000004cH
	cmp	edi, eax
	jne	SHORT $LL8@DoUpdateCu
	mov	ecx, DWORD PTR _tempDeals$[esp+1580]
	mov	eax, DWORD PTR _tempDeals$[esp+1576]
$LN6@DoUpdateCu:

; 2998 : 	}
; 2999 : 
; 3000 : 	// Copy them to either current or historical deals based on whether or not they
; 3001 : 	// are still active
; 3002 : 	m_CurrentDeals.clear();

	mov	ebp, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	cmp	ebp, ebx
	jbe	SHORT $LN26@DoUpdateCu
	npad	6
$LL28@DoUpdateCu:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	ebx
	mov	ecx, edi
	call	eax
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL28@DoUpdateCu
	mov	ecx, DWORD PTR _tempDeals$[esp+1580]
	mov	eax, DWORD PTR _tempDeals$[esp+1576]
$LN26@DoUpdateCu:

; 3003 : 	for(it = tempDeals.begin(); it != tempDeals.end(); ++it)

	mov	edx, ecx
	imul	edx, 76					; 0000004cH
	add	edx, eax
	mov	DWORD PTR [esi+4], ebx
	mov	ebp, eax
	cmp	eax, edx
	je	$LN3@DoUpdateCu
	npad	3
$LL5@DoUpdateCu:

; 3004 : 	{
; 3005 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3006 : 		if (it->m_iFinalTurn == GC.getGame().getGameTurn() && (it->m_eFromPlayer == eForPlayer || it->m_eToPlayer == eForPlayer))
; 3007 : 		{
; 3008 : 			m_CurrentlyEndingDeals.push_back(*it);
; 3009 : 		}
; 3010 : 		else if (it->m_iFinalTurn < GC.getGame().getGameTurn())
; 3011 : #else
; 3012 : 		if(it->m_iFinalTurn <= GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR [ebp+16], eax
	jg	SHORT $LN2@DoUpdateCu

; 3013 : #endif
; 3014 : 		{
; 3015 : 			m_HistoricalDeals.push_back(*it);

	mov	edi, DWORD PTR _this$[esp+1576]
	mov	eax, DWORD PTR [edi+3084]
	add	edi, 3076				; 00000c04H
	mov	DWORD PTR $T244572[esp+1576], edi
	mov	BYTE PTR [edi+1532], bl
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN38@DoUpdateCu
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN38@DoUpdateCu:
	mov	ecx, DWORD PTR [edi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T244567[esp+1576], ecx
	mov	BYTE PTR __$EHRec$[esp+1584], 1
	je	SHORT $LN41@DoUpdateCu
	push	ebp
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN41@DoUpdateCu:
	inc	DWORD PTR [edi+4]

; 3016 : 		}
; 3017 : 		else

	jmp	SHORT $LN77@DoUpdateCu
$LN2@DoUpdateCu:

; 3018 : 		{
; 3019 : 			m_CurrentDeals.push_back(*it);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T244591[esp+1576], esi
	mov	BYTE PTR [esi+1532], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN46@DoUpdateCu
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN46@DoUpdateCu:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T244586[esp+1576], ecx
	mov	BYTE PTR __$EHRec$[esp+1584], 2
	je	SHORT $LN49@DoUpdateCu
	push	ebp
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN49@DoUpdateCu:
	inc	DWORD PTR [esi+4]
$LN77@DoUpdateCu:

; 3003 : 	for(it = tempDeals.begin(); it != tempDeals.end(); ++it)

	mov	ecx, DWORD PTR _tempDeals$[esp+1580]
	mov	eax, DWORD PTR _tempDeals$[esp+1576]
	mov	edx, ecx
	imul	edx, 76					; 0000004cH
	add	ebp, 76					; 0000004cH
	add	edx, eax

; 3018 : 		{
; 3019 : 			m_CurrentDeals.push_back(*it);

	mov	BYTE PTR __$EHRec$[esp+1584], bl
	cmp	ebp, edx
	jne	$LL5@DoUpdateCu
$LN3@DoUpdateCu:

; 3020 : 		}
; 3021 : 	}
; 3022 : }

	mov	DWORD PTR __$EHRec$[esp+1584], -1
	mov	ebp, eax
	cmp	ecx, ebx
	jbe	SHORT $LN60@DoUpdateCu
	mov	esi, eax
	mov	edi, ecx
$LL62@DoUpdateCu:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL62@DoUpdateCu
$LN60@DoUpdateCu:
	lea	eax, DWORD PTR _tempDeals$[esp+1588]
	cmp	ebp, eax
	je	SHORT $LN56@DoUpdateCu
	push	ebp
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN56@DoUpdateCu:
	mov	ecx, DWORD PTR __$EHRec$[esp+1576]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1560				; 00000618H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$0:
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$1:
	mov	eax, DWORD PTR $T244572[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T244572[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T244567[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$2:
	mov	eax, DWORD PTR $T244591[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T244591[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T244586[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ ENDP	; CvGameDeals::DoUpdateCurrentDealsList
PUBLIC	?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenPlayers
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$1
__ehfuncinfo$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_bSomethingChanged$223059 = -1577			; size = 1
tv892 = -1576						; size = 4
$T244894 = -1576					; size = 4
_this$ = -1572						; size = 4
$T244887 = -1568					; size = 4
$T244653 = -1564					; size = 8
$T244651 = -1556					; size = 8
_tempDeals$ = -1548					; size = 1536
__$EHRec$ = -12						; size = 12
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z PROC ; CvGameDeals::DoCancelDealsBetweenPlayers, COMDAT
; _this$ = ecx

; 3068 : {

	push	-1
	push	__ehhandler$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1568				; 00000620H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 3069 : 	DealList::iterator it;
; 3070 : 	DealList tempDeals;

	xor	edx, edx
	lea	eax, DWORD PTR _tempDeals$[esp+1604]
	push	edi
	mov	DWORD PTR _this$[esp+1596], ebp
	mov	DWORD PTR _tempDeals$[esp+1600], edx
	mov	DWORD PTR _tempDeals$[esp+1604], 20	; 00000014H
	mov	DWORD PTR _tempDeals$[esp+1596], eax

; 3071 : 
; 3072 : 	if(m_CurrentDeals.size() > 0)

	mov	ecx, DWORD PTR [ebp+1544]
	mov	DWORD PTR __$EHRec$[esp+1604], edx
	cmp	ecx, edx
	jbe	$LN147@DoCancelDe

; 3073 : 	{
; 3074 : 		bool bSomethingChanged = false;
; 3075 : 
; 3076 : 		// Copy the deals into a temporary container
; 3077 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	edi, DWORD PTR [ebp+1540]
	imul	ecx, 76					; 0000004cH
	add	ecx, edi
	mov	BYTE PTR _bSomethingChanged$223059[esp+1596], dl
	cmp	edi, ecx
	je	SHORT $LN14@DoCancelDe
$LL16@DoCancelDe:

; 3078 : 		{
; 3079 : 			tempDeals.push_back(*it);

	push	edi
	lea	ecx, DWORD PTR _tempDeals$[esp+1600]
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
	mov	edx, DWORD PTR [ebp+1544]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [ebp+1540]
	add	edi, 76					; 0000004cH
	cmp	edi, edx
	jne	SHORT $LL16@DoCancelDe

; 3073 : 	{
; 3074 : 		bool bSomethingChanged = false;
; 3075 : 
; 3076 : 		// Copy the deals into a temporary container
; 3077 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	eax, DWORD PTR _tempDeals$[esp+1596]
$LN14@DoCancelDe:

; 3080 : 		}
; 3081 : 
; 3082 : 		m_CurrentDeals.clear();

	mov	edi, DWORD PTR [ebp+1544]
	mov	esi, DWORD PTR [ebp+1540]
	test	edi, edi
	jbe	SHORT $LN37@DoCancelDe
$LL146@DoCancelDe:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL146@DoCancelDe
	mov	eax, DWORD PTR _tempDeals$[esp+1596]
$LN37@DoCancelDe:

; 3083 : 		for(it = tempDeals.begin(); it != tempDeals.end(); ++it)

	mov	ecx, DWORD PTR _tempDeals$[esp+1600]
	imul	ecx, 76					; 0000004cH
	add	ecx, eax
	mov	DWORD PTR [ebp+1544], 0
	cmp	eax, ecx
	je	$LN147@DoCancelDe
	lea	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR tv892[esp+1596], ebx
	npad	1
$LL13@DoCancelDe:

; 3084 : 		{
; 3085 : 			// Players on this deal match?
; 3086 : 			if(it->m_eFromPlayer == eFromPlayer && it->m_eToPlayer == eToPlayer ||
; 3087 : 			        it->m_eFromPlayer == eToPlayer && it->m_eToPlayer == eFromPlayer)

	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR _eFromPlayer$[esp+1592]
	cmp	eax, esi
	jne	SHORT $LN145@DoCancelDe
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, DWORD PTR _eToPlayer$[esp+1592]
	je	SHORT $LN9@DoCancelDe
$LN145@DoCancelDe:
	cmp	eax, DWORD PTR _eToPlayer$[esp+1592]
	jne	$LN10@DoCancelDe
	cmp	DWORD PTR [ebx+4], esi
	jne	$LN10@DoCancelDe
$LN9@DoCancelDe:

; 3088 : 			{
; 3089 : 				// Change final turn
; 3090 : 				it->m_iFinalTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [ebx+12], eax

; 3091 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3092 : 				it->m_bDealCancelled = true;
; 3093 : #endif
; 3094 : 
; 3095 : 				// Cancel individual items
; 3096 : 				TradedItemList::iterator itemIter;
; 3097 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	eax, DWORD PTR $T244651[esp+1596]
	lea	esi, DWORD PTR [ebx+40]
	push	eax
	mov	ecx, esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T244653[esp+1596]
	push	ecx
	mov	ecx, esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	setne	al
	test	al, al
	je	$LN5@DoCancelDe

; 3098 : 				{
; 3099 : 					bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$223059[esp+1596], 1

; 3091 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3092 : 				it->m_bDealCancelled = true;
; 3093 : #endif
; 3094 : 
; 3095 : 				// Cancel individual items
; 3096 : 				TradedItemList::iterator itemIter;
; 3097 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

$LL57@DoCancelDe:

; 3100 : 
; 3101 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3102 : 					itemIter->m_iTurnsRemaining = 0;
; 3103 : #else
; 3104 : 					itemIter->m_iFinalTurn = GC.getGame().getGameTurn();

	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, edi
	imul	esi, 44					; 0000002cH
	lea	ebx, DWORD PTR [esi+edx+8]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [ebx+8], eax

; 3105 : #endif
; 3106 : 
; 3107 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3108 : 					PlayerTypes eItemFromPlayer = itemIter->m_eFromPlayer;
; 3109 : 					PlayerTypes eItemToPlayer = it->GetOtherPlayer(eItemFromPlayer);
; 3110 : 
; 3111 : 					if (eItemToPlayer == eToPlayer || eItemToPlayer == eFromPlayer || itemIter->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT)
; 3112 : 					{
; 3113 : 						DoEndTradedItem(&*itemIter, eItemToPlayer, true);
; 3114 : 					}
; 3115 : #else
; 3116 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	eax, DWORD PTR [ebp+8]

; 3117 : 					eToPlayer = it->GetOtherPlayer(eFromPlayer);

	mov	ebx, DWORD PTR tv892[esp+1596]
	mov	edx, DWORD PTR [eax+esi+36]
	mov	ecx, DWORD PTR [ebx]
	add	eax, esi
	mov	DWORD PTR _eFromPlayer$[esp+1592], edx
	cmp	ecx, edx
	jne	SHORT $LN150@DoCancelDe
	mov	ecx, DWORD PTR [ebx+4]
$LN150@DoCancelDe:

; 3118 : 
; 3119 : 					DoEndTradedItem(&*itemIter, eToPlayer, true);

	push	1
	mov	edx, ecx
	push	edx
	add	eax, 8
	mov	DWORD PTR _eToPlayer$[esp+1600], ecx
	mov	ecx, DWORD PTR _this$[esp+1604]
	push	eax
	call	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem
	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN58@DoCancelDe

; 3091 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3092 : 				it->m_bDealCancelled = true;
; 3093 : #endif
; 3094 : 
; 3095 : 				// Cancel individual items
; 3096 : 				TradedItemList::iterator itemIter;
; 3097 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	mov	edi, DWORD PTR [ebp+24]
	jmp	SHORT $LN140@DoCancelDe
$LN58@DoCancelDe:
	mov	eax, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [esi+eax]
$LN140@DoCancelDe:
	lea	ecx, DWORD PTR $T244653[esp+1596]
	push	ecx
	lea	ecx, DWORD PTR [ebx+40]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	setne	al
	test	al, al
	jne	SHORT $LL57@DoCancelDe
	mov	ebx, DWORD PTR tv892[esp+1596]
$LN5@DoCancelDe:

; 3120 : #endif
; 3121 : 				}
; 3122 : 				m_HistoricalDeals.push_back(*it);

	mov	esi, DWORD PTR _this$[esp+1596]
	mov	eax, DWORD PTR [esi+3084]
	add	esi, 3076				; 00000c04H
	mov	DWORD PTR $T244894[esp+1596], esi
	mov	BYTE PTR [esi+1532], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN107@DoCancelDe
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN107@DoCancelDe:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T244887[esp+1596], ecx
	mov	BYTE PTR __$EHRec$[esp+1604], 1
	je	SHORT $LN110@DoCancelDe
	lea	edx, DWORD PTR [ebx-4]
	push	edx
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN110@DoCancelDe:
	inc	DWORD PTR [esi+4]

; 3123 : 			}
; 3124 : 			else

	mov	esi, DWORD PTR _eFromPlayer$[esp+1592]
	mov	ebp, DWORD PTR _this$[esp+1596]
	mov	BYTE PTR __$EHRec$[esp+1604], 0
	jmp	SHORT $LN12@DoCancelDe
$LN10@DoCancelDe:

; 3125 : 			{
; 3126 : 				m_CurrentDeals.push_back(*it);

	lea	eax, DWORD PTR [ebx-4]
	push	eax
	lea	ecx, DWORD PTR [ebp+1540]
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
$LN12@DoCancelDe:
	mov	ecx, DWORD PTR _tempDeals$[esp+1600]
	mov	eax, DWORD PTR _tempDeals$[esp+1596]
	imul	ecx, 76					; 0000004cH
	add	ebx, 76					; 0000004cH
	add	ecx, eax
	lea	edx, DWORD PTR [ebx-4]
	mov	DWORD PTR tv892[esp+1596], ebx
	cmp	edx, ecx
	jne	$LL13@DoCancelDe

; 3127 : 			}
; 3128 : 		}
; 3129 : 
; 3130 : 		if(bSomethingChanged)

	cmp	BYTE PTR _bSomethingChanged$223059[esp+1596], 0
	je	SHORT $LN147@DoCancelDe

; 3131 : 		{
; 3132 : 			// Update UI if we were involved in the deal
; 3133 : 			PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 3134 : 			if(eFromPlayer == eActivePlayer || eToPlayer == eActivePlayer)

	cmp	esi, eax
	je	SHORT $LN1@DoCancelDe
	cmp	DWORD PTR _eToPlayer$[esp+1592], eax
	jne	SHORT $LN143@DoCancelDe
$LN1@DoCancelDe:

; 3135 : 			{
; 3136 : 				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx
$LN143@DoCancelDe:
	mov	eax, DWORD PTR _tempDeals$[esp+1596]
$LN147@DoCancelDe:

; 3137 : 			}
; 3138 : 		}
; 3139 : 	}
; 3140 : }

	mov	edi, DWORD PTR _tempDeals$[esp+1600]
	mov	DWORD PTR __$EHRec$[esp+1604], -1
	mov	ebx, eax
	test	edi, edi
	jbe	SHORT $LN125@DoCancelDe
	mov	esi, eax
	npad	7
$LL148@DoCancelDe:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL148@DoCancelDe
$LN125@DoCancelDe:
	lea	eax, DWORD PTR _tempDeals$[esp+1608]
	cmp	ebx, eax
	je	SHORT $LN121@DoCancelDe
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN121@DoCancelDe:
	mov	ecx, DWORD PTR __$EHRec$[esp+1596]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1580				; 0000062cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$0:
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$1:
	mov	eax, DWORD PTR $T244894[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T244894[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T244887[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ENDP ; CvGameDeals::DoCancelDealsBetweenPlayers
PUBLIC	?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ; CvGameDeals::DoCancelAllDealsWithPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_pCancelTeam$ = 8					; size = 4
_eCancelPlayer$ = 8					; size = 4
?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z PROC ; CvGameDeals::DoCancelAllDealsWithPlayer, COMDAT
; _this$ = ecx

; 3144 : {

	push	ebx

; 3145 : 	CvTeam* pCancelTeam = &GET_TEAM(GET_PLAYER(eCancelPlayer).getTeam());

	mov	ebx, DWORD PTR _eCancelPlayer$[esp]
	mov	eax, ebx
	imul	eax, 63236				; 0000f704H
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN15@DoCancelAl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN16@DoCancelAl
$LN15@DoCancelAl:
	or	eax, -1
$LN16@DoCancelAl:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 3146 : 
; 3147 : 	// Loop through first set of players
; 3148 : 	TeamTypes eTeam;
; 3149 : 	PlayerTypes ePlayer;
; 3150 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	mov	DWORD PTR _pCancelTeam$[esp+12], eax
	xor	esi, esi
	jmp	SHORT $LN6@DoCancelAl
	npad	8
$LL42@DoCancelAl:

; 3145 : 	CvTeam* pCancelTeam = &GET_TEAM(GET_PLAYER(eCancelPlayer).getTeam());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN6@DoCancelAl:

; 3151 : 	{
; 3152 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 3153 : 
; 3154 : 		if(!GET_PLAYER(ePlayer).isEverAlive())

	cmp	BYTE PTR [esi+ecx+2268], 0
	je	SHORT $LN5@DoCancelAl

; 3155 : 		{
; 3156 : 			continue;
; 3157 : 		}
; 3158 : 
; 3159 : 		if(ePlayer == eCancelPlayer)

	cmp	edi, ebx
	je	SHORT $LN5@DoCancelAl

; 3160 : 		{
; 3161 : 			continue;
; 3162 : 		}
; 3163 : 
; 3164 : 		eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN34@DoCancelAl
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN35@DoCancelAl
$LN34@DoCancelAl:
	or	eax, -1
$LN35@DoCancelAl:

; 3165 : 
; 3166 : 		if(pCancelTeam->isHasMet(eTeam))

	mov	ecx, DWORD PTR _pCancelTeam$[esp+12]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN5@DoCancelAl

; 3167 : 		{
; 3168 : 			DoCancelDealsBetweenPlayers(eCancelPlayer, ePlayer);

	push	edi
	push	ebx
	mov	ecx, ebp
	call	?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenPlayers
$LN5@DoCancelAl:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL42@DoCancelAl
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3169 : 		}
; 3170 : 	}
; 3171 : }

	ret	4
?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ENDP ; CvGameDeals::DoCancelAllDealsWithPlayer
_TEXT	ENDS
PUBLIC	?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ; CvGameDeals::DoCancelAllProposedDealsWithPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eCancelPlayer$ = 8					; size = 4
?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z PROC ; CvGameDeals::DoCancelAllProposedDealsWithPlayer, COMDAT
; _this$ = ecx

; 3174 : {//Cancel all proposed deals involving eCancelPlayer.

	push	ebx

; 3175 : 	PlayerTypes eLoopPlayer;
; 3176 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	ebx, DWORD PTR _eCancelPlayer$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	xor	edi, edi
	npad	5
$LL5@DoCancelAl@2:

; 3177 : 	{
; 3178 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3179 : 		if(GetProposedDeal(eCancelPlayer, eLoopPlayer))

	cmp	DWORD PTR [esi+8], 0
	jbe	SHORT $LN4@DoCancelAl@2
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, eax
	cmp	eax, ecx
	je	SHORT $LN2@DoCancelAl@2
	mov	edx, DWORD PTR [esi+8]
	imul	edx, 76					; 0000004cH
	mov	ecx, eax
	add	ecx, edx
	npad	1
$LL11@DoCancelAl@2:
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN10@DoCancelAl@2
	cmp	DWORD PTR [eax+8], edi
	je	SHORT $LN13@DoCancelAl@2
$LN10@DoCancelAl@2:
	add	eax, 76					; 0000004cH
	cmp	eax, ecx
	jne	SHORT $LL11@DoCancelAl@2

; 3182 : 		}
; 3183 : 		if(GetProposedDeal(eLoopPlayer, eCancelPlayer))

	jmp	SHORT $LN2@DoCancelAl@2

; 3177 : 	{
; 3178 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3179 : 		if(GetProposedDeal(eCancelPlayer, eLoopPlayer))

$LN13@DoCancelAl@2:

; 3180 : 		{//deal from eCancelPlayer
; 3181 : 			FinalizeDeal(eCancelPlayer, eLoopPlayer, false);

	push	0
	push	edi
	push	ebx
	mov	ecx, esi
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal
$LN2@DoCancelAl@2:

; 3182 : 		}
; 3183 : 		if(GetProposedDeal(eLoopPlayer, eCancelPlayer))

	cmp	DWORD PTR [esi+8], 0
	jbe	SHORT $LN4@DoCancelAl@2
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	imul	edx, 76					; 0000004cH
	add	edx, eax
	cmp	eax, edx
	je	SHORT $LN4@DoCancelAl@2
	mov	ecx, DWORD PTR [esi+8]
	imul	ecx, 76					; 0000004cH
	mov	edx, eax
	add	ecx, edx
	npad	3
$LL24@DoCancelAl@2:
	cmp	DWORD PTR [eax+4], edi
	jne	SHORT $LN23@DoCancelAl@2
	cmp	DWORD PTR [eax+8], ebx
	je	SHORT $LN26@DoCancelAl@2
$LN23@DoCancelAl@2:
	add	eax, 76					; 0000004cH
	cmp	eax, ecx
	jne	SHORT $LL24@DoCancelAl@2
	jmp	SHORT $LN4@DoCancelAl@2
$LN26@DoCancelAl@2:

; 3184 : 		{//deal to eCancelPlayer
; 3185 : 			FinalizeDeal(eLoopPlayer, eCancelPlayer, false);

	push	0
	push	ebx
	push	edi
	mov	ecx, esi
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal
$LN4@DoCancelAl@2:
	inc	edi
	cmp	edi, 22					; 00000016H
	jl	$LL5@DoCancelAl@2
	pop	edi
	pop	esi
	pop	ebx

; 3186 : 		}
; 3187 : 	}
; 3188 : }

	ret	4
?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ENDP ; CvGameDeals::DoCancelAllProposedDealsWithPlayer
_TEXT	ENDS
PUBLIC	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z ; OldLoad
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$2
__ehfuncinfo$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
_TEXT	SEGMENT
_iEntriesToRead$ = -96					; size = 4
$T245182 = -92						; size = 4
_tempItem$ = -88					; size = 76
__$EHRec$ = -12						; size = 12
$T245229 = 8						; size = 4
$T245187 = 8						; size = 4
_loadFrom$ = 8						; size = 4
$T245234 = 12						; size = 4
_writeTo$ = 12						; size = 4
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z PROC ; OldLoad, COMDAT

; 3896 : {

	push	-1
	push	__ehhandler$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3897 : 	int iEntriesToRead;
; 3898 : 	CvDeal tempItem;

	lea	ecx, DWORD PTR _tempItem$[esp+112]
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal

; 3899 : 
; 3900 : 	writeTo.m_ProposedDeals.clear();

	mov	edi, DWORD PTR _writeTo$[esp+108]
	mov	eax, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	add	edi, 4
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+120], ebx
	cmp	eax, ebx
	jbe	SHORT $LN15@OldLoad@2

; 3897 : 	int iEntriesToRead;
; 3898 : 	CvDeal tempItem;

	mov	ebp, eax
	npad	2

; 3899 : 
; 3900 : 	writeTo.m_ProposedDeals.clear();

$LL17@OldLoad@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ecx, esi
	call	edx
	add	esi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL17@OldLoad@2
$LN15@OldLoad@2:

; 3901 : 	loadFrom >> iEntriesToRead;

	mov	esi, DWORD PTR _loadFrom$[esp+108]
	lea	eax, DWORD PTR _iEntriesToRead$[esp+112]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+4], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3902 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iEntriesToRead$[esp+112], ebx
	jle	SHORT $LN7@OldLoad@2
	npad	4
$LL9@OldLoad@2:

; 3903 : 	{
; 3904 : 		loadFrom = OldLoad(loadFrom, tempItem);

	lea	ecx, DWORD PTR _tempItem$[esp+112]
	push	ecx
	push	esi
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ; OldLoad
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	add	esp, 8

; 3905 : 		writeTo.m_ProposedDeals.push_back(tempItem);

	lea	ecx, DWORD PTR _tempItem$[esp+112]
	mov	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR [esi+16], eax
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
	inc	ebp
	cmp	ebp, DWORD PTR _iEntriesToRead$[esp+112]
	jl	SHORT $LL9@OldLoad@2
$LN7@OldLoad@2:

; 3906 : 	}
; 3907 : 
; 3908 : 	writeTo.m_CurrentDeals.clear();

	mov	ebx, DWORD PTR _writeTo$[esp+108]
	mov	edi, DWORD PTR [ebx+1544]
	mov	ebp, DWORD PTR [ebx+1540]
	add	ebx, 1540				; 00000604H
	test	edi, edi
	jbe	SHORT $LN27@OldLoad@2
$LL125@OldLoad@2:
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, ebp
	call	eax
	add	ebp, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL125@OldLoad@2
$LN27@OldLoad@2:

; 3909 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+112]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [ebx+4], 0
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3910 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iEntriesToRead$[esp+112], ebp
	jle	SHORT $LN4@OldLoad@2

; 3911 : 	{
; 3912 : 		loadFrom = OldLoad(loadFrom, tempItem);
; 3913 : 		writeTo.m_CurrentDeals.push_back(tempItem);

	mov	edi, ebx
	mov	DWORD PTR $T245187[esp+108], edi
$LL6@OldLoad@2:
	lea	edx, DWORD PTR _tempItem$[esp+112]
	push	edx
	push	esi
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ; OldLoad
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], cl
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], edx
	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	mov	BYTE PTR [edi+1532], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN37@OldLoad@2
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN37@OldLoad@2:
	mov	ecx, DWORD PTR [edi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T245182[esp+112], ecx
	mov	BYTE PTR __$EHRec$[esp+120], 1
	je	SHORT $LN40@OldLoad@2
	lea	eax, DWORD PTR _tempItem$[esp+112]
	push	eax
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN40@OldLoad@2:
	inc	DWORD PTR [edi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _iEntriesToRead$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	jl	SHORT $LL6@OldLoad@2
$LN4@OldLoad@2:

; 3914 : 	}
; 3915 : 
; 3916 : 	writeTo.m_HistoricalDeals.clear();

	mov	ebx, DWORD PTR _writeTo$[esp+108]
	mov	edi, DWORD PTR [ebx+3080]
	mov	ebp, DWORD PTR [ebx+3076]
	add	ebx, 3076				; 00000c04H
	test	edi, edi
	jbe	SHORT $LN47@OldLoad@2
	npad	6
$LL124@OldLoad@2:
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, ebp
	call	eax
	add	ebp, 76					; 0000004cH
	sub	edi, 1
	jne	SHORT $LL124@OldLoad@2
$LN47@OldLoad@2:

; 3917 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+112]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [ebx+4], 0
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3918 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iEntriesToRead$[esp+112], ebp
	jle	SHORT $LN1@OldLoad@2

; 3919 : 	{
; 3920 : 		loadFrom = OldLoad(loadFrom, tempItem);
; 3921 : 		writeTo.m_HistoricalDeals.push_back(tempItem);

	mov	edi, ebx
	mov	DWORD PTR $T245234[esp+108], edi
	mov	bl, 2
$LL3@OldLoad@2:
	lea	edx, DWORD PTR _tempItem$[esp+112]
	push	edx
	push	esi
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ; OldLoad
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], cl
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], edx
	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	mov	BYTE PTR [edi+1532], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN57@OldLoad@2
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN57@OldLoad@2:
	mov	ecx, DWORD PTR [edi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T245229[esp+108], ecx
	mov	BYTE PTR __$EHRec$[esp+120], bl
	je	SHORT $LN60@OldLoad@2
	lea	eax, DWORD PTR _tempItem$[esp+112]
	push	eax
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN60@OldLoad@2:
	inc	DWORD PTR [edi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _iEntriesToRead$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	jl	SHORT $LL3@OldLoad@2
$LN1@OldLoad@2:

; 3922 : 	}
; 3923 : 
; 3924 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3925 : 	writeTo.m_CurrentlyEndingDeals.clear();
; 3926 : 	loadFrom >> iEntriesToRead;
; 3927 : 	for (int iI = 0; iI < iEntriesToRead; iI++)
; 3928 : 	{
; 3929 : 		loadFrom = OldLoad(loadFrom, tempItem);
; 3930 : 		writeTo.m_CurrentlyEndingDeals.push_back(tempItem);
; 3931 : 	}
; 3932 : #endif
; 3933 : 
; 3934 : 	return loadFrom;

	mov	ecx, DWORD PTR _tempItem$[esp+164]
	xor	eax, eax
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+124], -1
	mov	DWORD PTR _tempItem$[esp+116], OFFSET ??_7CvDeal@@6B@
	mov	DWORD PTR _tempItem$[esp+160], 268435455 ; 0fffffffH
	mov	DWORD PTR _tempItem$[esp+172], eax
	mov	DWORD PTR _tempItem$[esp+164], eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 3935 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	add	esp, 4
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$0:
	lea	ecx, DWORD PTR _tempItem$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$1:
	mov	eax, DWORD PTR $T245187[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T245187[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T245182[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$2:
	mov	eax, DWORD PTR $T245234[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T245234[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T245229[ebp-4]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z ENDP ; OldLoad
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z	; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$2
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
_TEXT	SEGMENT
_iEntriesToRead$ = -104					; size = 4
_uiVersion$ = -100					; size = 4
$T245617 = -96						; size = 4
$T245612 = -92						; size = 4
_tempItem$ = -88					; size = 76
__$EHRec$ = -12						; size = 12
$T245660 = 8						; size = 4
_loadFrom$ = 8						; size = 4
$T245655 = 12						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z PROC	; operator>>, COMDAT

; 3939 : {

	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3940 : 	uint uiVersion;
; 3941 : 	int iEntriesToRead;
; 3942 : 	CvDeal tempItem;

	lea	ecx, DWORD PTR _tempItem$[esp+120]
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal

; 3943 : 
; 3944 : 	loadFrom >> uiVersion;

	mov	ebp, DWORD PTR _loadFrom$[esp+116]
	lea	eax, DWORD PTR _uiVersion$[esp+120]
	xor	ebx, ebx
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+132], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3945 : 
; 3946 : 	writeTo.m_ProposedDeals.clear();

	mov	edi, DWORD PTR _writeTo$[esp+116]
	mov	eax, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	add	edi, 4
	cmp	eax, ebx
	jbe	SHORT $LN17@operator@10

; 3940 : 	uint uiVersion;
; 3941 : 	int iEntriesToRead;
; 3942 : 	CvDeal tempItem;

	mov	ebp, eax

; 3945 : 
; 3946 : 	writeTo.m_ProposedDeals.clear();

$LL19@operator@10:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	ebx
	mov	ecx, esi
	call	eax
	add	esi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL19@operator@10
	mov	ebp, DWORD PTR _loadFrom$[esp+116]
$LN17@operator@10:

; 3947 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+120]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR [edi+4], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3948 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iEntriesToRead$[esp+120], ebx
	jle	SHORT $LN7@operator@10
	npad	3
$LL9@operator@10:

; 3949 : 	{
; 3950 : 		loadFrom >> tempItem;

	lea	edx, DWORD PTR _tempItem$[esp+120]
	push	edx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ; operator>>
	add	esp, 8

; 3951 : 		writeTo.m_ProposedDeals.push_back(tempItem);

	lea	eax, DWORD PTR _tempItem$[esp+120]
	push	eax
	mov	ecx, edi
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
	inc	esi
	cmp	esi, DWORD PTR _iEntriesToRead$[esp+120]
	jl	SHORT $LL9@operator@10
$LN7@operator@10:

; 3952 : 	}
; 3953 : 
; 3954 : 	writeTo.m_CurrentDeals.clear();

	mov	esi, DWORD PTR _writeTo$[esp+116]
	mov	ebp, DWORD PTR [esi+1544]
	mov	edi, DWORD PTR [esi+1540]
	add	esi, 1540				; 00000604H
	cmp	ebp, ebx
	jbe	SHORT $LN27@operator@10
	npad	2
$LL29@operator@10:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	ebx
	mov	ecx, edi
	call	eax
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL29@operator@10
$LN27@operator@10:

; 3955 : 	loadFrom >> iEntriesToRead;

	mov	ebp, DWORD PTR _loadFrom$[esp+116]
	lea	ecx, DWORD PTR _iEntriesToRead$[esp+120]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR [esi+4], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3956 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	edi, edi
	cmp	DWORD PTR _iEntriesToRead$[esp+120], ebx
	jle	SHORT $LN4@operator@10

; 3959 : 		writeTo.m_CurrentDeals.push_back(tempItem);

	mov	DWORD PTR $T245617[esp+120], esi
$LL6@operator@10:

; 3957 : 	{
; 3958 : 		loadFrom >> tempItem;

	lea	edx, DWORD PTR _tempItem$[esp+120]
	push	edx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ; operator>>

; 3959 : 		writeTo.m_CurrentDeals.push_back(tempItem);

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	BYTE PTR [esi+1532], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN35@operator@10
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN35@operator@10:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T245612[esp+120], ecx
	mov	BYTE PTR __$EHRec$[esp+128], 1
	je	SHORT $LN38@operator@10
	lea	eax, DWORD PTR _tempItem$[esp+120]
	push	eax
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN38@operator@10:
	inc	DWORD PTR [esi+4]
	inc	edi
	cmp	edi, DWORD PTR _iEntriesToRead$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	jl	SHORT $LL6@operator@10
$LN4@operator@10:

; 3960 : 	}
; 3961 : 
; 3962 : 	writeTo.m_HistoricalDeals.clear();

	mov	esi, DWORD PTR _writeTo$[esp+116]
	mov	ebp, DWORD PTR [esi+3080]
	mov	edi, DWORD PTR [esi+3076]
	add	esi, 3076				; 00000c04H
	cmp	ebp, ebx
	jbe	SHORT $LN45@operator@10
	npad	4
$LL47@operator@10:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	ebx
	mov	ecx, edi
	call	eax
	add	edi, 76					; 0000004cH
	sub	ebp, 1
	jne	SHORT $LL47@operator@10
$LN45@operator@10:

; 3963 : 	loadFrom >> iEntriesToRead;

	mov	ebp, DWORD PTR _loadFrom$[esp+116]
	lea	ecx, DWORD PTR _iEntriesToRead$[esp+120]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR [esi+4], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3964 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	edi, edi
	cmp	DWORD PTR _iEntriesToRead$[esp+120], ebx
	jle	SHORT $LN1@operator@10

; 3967 : 		writeTo.m_HistoricalDeals.push_back(tempItem);

	mov	DWORD PTR $T245660[esp+116], esi
$LL3@operator@10:

; 3965 : 	{
; 3966 : 		loadFrom >> tempItem;

	lea	edx, DWORD PTR _tempItem$[esp+120]
	push	edx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ; operator>>

; 3967 : 		writeTo.m_HistoricalDeals.push_back(tempItem);

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	BYTE PTR [esi+1532], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN53@operator@10
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
$LN53@operator@10:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T245655[esp+116], ecx
	mov	BYTE PTR __$EHRec$[esp+128], 2
	je	SHORT $LN56@operator@10
	lea	eax, DWORD PTR _tempItem$[esp+120]
	push	eax
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
$LN56@operator@10:
	inc	DWORD PTR [esi+4]
	inc	edi
	cmp	edi, DWORD PTR _iEntriesToRead$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	jl	SHORT $LL3@operator@10
$LN1@operator@10:

; 3968 : 	}
; 3969 : 
; 3970 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3971 : 	writeTo.m_CurrentlyEndingDeals.clear();
; 3972 : 	loadFrom >> iEntriesToRead;
; 3973 : 	for (int iI = 0; iI < iEntriesToRead; iI++)
; 3974 : 	{
; 3975 : 		loadFrom >> tempItem;
; 3976 : 		writeTo.m_CurrentlyEndingDeals.push_back(tempItem);
; 3977 : 	}
; 3978 : #endif
; 3979 : 
; 3980 : 	return loadFrom;

	mov	ecx, DWORD PTR _tempItem$[esp+172]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+132], -1
	mov	DWORD PTR _tempItem$[esp+124], OFFSET ??_7CvDeal@@6B@
	mov	DWORD PTR _tempItem$[esp+168], 268435455 ; 0fffffffH
	mov	DWORD PTR _tempItem$[esp+180], ebx
	mov	DWORD PTR _tempItem$[esp+172], ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 3981 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	add	esp, 4
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 104				; 00000068H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$0:
	lea	ecx, DWORD PTR _tempItem$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$1:
	mov	eax, DWORD PTR $T245617[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T245617[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T245612[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$2:
	mov	eax, DWORD PTR $T245660[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T245660[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T245655[ebp-4]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z ENDP	; operator>>
PUBLIC	?DoTurn@CvGameDeals@@QAEXXZ			; CvGameDeals::DoTurn
EXTRN	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceTotal
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvGameDeals@@QAEXXZ
_TEXT	SEGMENT
_bSomethingChanged$222936 = -54				; size = 1
_bInvalidDeal$222954 = -53				; size = 1
_this$ = -52						; size = 4
_eToPlayer$222935 = -48					; size = 4
_it$ = -44						; size = 4
$T246437 = -40						; size = 4
_eFromPlayer$222934 = -40				; size = 4
_iGameTurn$222937 = -36					; size = 4
$T245975 = -32						; size = 8
$T245972 = -32						; size = 8
$T245978 = -24						; size = 8
$T245970 = -24						; size = 8
$T245973 = -16						; size = 8
$T245976 = -8						; size = 8
?DoTurn@CvGameDeals@@QAEXXZ PROC			; CvGameDeals::DoTurn, COMDAT
; _this$ = ecx

; 2805 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2806 : 	DealList::iterator it;
; 2807 : 
; 2808 : 	if(m_CurrentDeals.size() > 0)

	cmp	DWORD PTR [esi+1544], 0
	push	edi
	mov	DWORD PTR _this$[esp+72], esi
	jbe	$LN27@DoTurn

; 2811 : 		PlayerTypes eToPlayer = NO_PLAYER;
; 2812 : 
; 2813 : 		bool bSomethingChanged = false;
; 2814 : 		//int iTemp;
; 2815 : 		//TradeableItems eTempItem;
; 2816 : 
; 2817 : 		int iGameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	or	eax, -1
	mov	DWORD PTR _eFromPlayer$222934[esp+72], eax
	mov	DWORD PTR _eToPlayer$222935[esp+72], eax
	mov	BYTE PTR _bSomethingChanged$222936[esp+72], 0
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2818 : 
; 2819 : 		// Check to see if any of our TradeItems in any of our Deals expire this turn
; 2820 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	ebx, DWORD PTR [esi+1540]
	mov	DWORD PTR _iGameTurn$222937[esp+72], eax
	mov	eax, DWORD PTR [esi+1544]
	imul	eax, 76					; 0000004cH
	add	eax, ebx
	mov	DWORD PTR _it$[esp+72], ebx
	cmp	ebx, eax
	je	$LN24@DoTurn

; 2809 : 	{
; 2810 : 		PlayerTypes eFromPlayer = NO_PLAYER;

	add	ebx, 44					; 0000002cH
	npad	1
$LL26@DoTurn:

; 2821 : 		{
; 2822 : 			TradedItemList::iterator itemIter;
; 2823 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	ecx, DWORD PTR $T245970[esp+72]
	push	ecx
	mov	ecx, ebx
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T245972[esp+72]
	push	edx
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	SHORT $LN21@DoTurn
$LL46@DoTurn:

; 2824 : 			{
; 2825 : 				int iFinalTurn = itemIter->m_iFinalTurn;

	mov	eax, DWORD PTR [ebp+8]
	mov	esi, edi
	imul	esi, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax+esi+16]
	add	eax, esi

; 2826 : 				CvAssertMsg(iFinalTurn >= -1, "DEAL: Trade item has a negative final turn.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2827 : 				CvAssertMsg(iFinalTurn < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a final turn way beyond the end of the game.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2828 : 				CvAssertMsg(itemIter->m_iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2829 : 				CvAssertMsg(itemIter->m_eFromPlayer == it->m_eFromPlayer || itemIter->m_eFromPlayer == it->m_eToPlayer, "DEAL: Processing turn for a deal that has an item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2830 : 
; 2831 : 				if(iFinalTurn > -1 && iFinalTurn == iGameTurn)

	cmp	ecx, -1
	jle	SHORT $LN22@DoTurn
	cmp	ecx, DWORD PTR _iGameTurn$222937[esp+72]
	jne	SHORT $LN22@DoTurn

; 2832 : 				{
; 2833 : 					//eTempItem = itemIter->m_eItemType;
; 2834 : 					//iTemp = iFinalTurn;
; 2835 : 
; 2836 : 					bSomethingChanged = true;
; 2837 : 
; 2838 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	edx, DWORD PTR [eax+36]

; 2839 : 					eToPlayer = it->GetOtherPlayer(eFromPlayer);

	mov	ecx, DWORD PTR [ebx-40]
	mov	BYTE PTR _bSomethingChanged$222936[esp+72], 1
	mov	DWORD PTR _eFromPlayer$222934[esp+72], edx
	cmp	ecx, edx
	jne	SHORT $LN243@DoTurn
	mov	ecx, DWORD PTR [ebx-36]
$LN243@DoTurn:

; 2840 : 
; 2841 : 					DoEndTradedItem(&*itemIter, eToPlayer, false);

	push	0
	mov	edx, ecx
	push	edx
	add	eax, 8
	mov	DWORD PTR _eToPlayer$222935[esp+80], ecx
	mov	ecx, DWORD PTR _this$[esp+80]
	push	eax
	call	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem
$LN22@DoTurn:

; 2821 : 		{
; 2822 : 			TradedItemList::iterator itemIter;
; 2823 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN47@DoTurn
	mov	edi, DWORD PTR [ebp+24]
	jmp	SHORT $LN232@DoTurn
$LN47@DoTurn:
	mov	eax, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [esi+eax]
$LN232@DoTurn:
	lea	ecx, DWORD PTR $T245972[esp+72]
	push	ecx
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	jne	SHORT $LL46@DoTurn
	mov	esi, DWORD PTR _this$[esp+72]
$LN21@DoTurn:

; 2818 : 
; 2819 : 		// Check to see if any of our TradeItems in any of our Deals expire this turn
; 2820 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	edx, DWORD PTR [esi+1544]
	mov	eax, DWORD PTR _it$[esp+72]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [esi+1540]
	add	eax, 76					; 0000004cH
	add	ebx, 76					; 0000004cH
	mov	DWORD PTR _it$[esp+72], eax
	cmp	eax, edx
	jne	$LL26@DoTurn
$LN24@DoTurn:

; 2842 : 				}
; 2843 : 			}
; 2844 : 		}
; 2845 : 
; 2846 : 		// check to see if one of our deals in no longer valid
; 2847 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	eax, DWORD PTR [esi+1544]
	mov	ebx, DWORD PTR [esi+1540]
	imul	eax, 76					; 0000004cH
	add	eax, ebx
	mov	DWORD PTR _it$[esp+72], ebx
	cmp	ebx, eax
	je	$LN17@DoTurn
	add	ebx, 44					; 0000002cH
$LL19@DoTurn:

; 2848 : 		{
; 2849 : 			TradedItemList::iterator itemIter;
; 2850 : 			bool bInvalidDeal = false;
; 2851 : 			bool bUnbreakable = false;
; 2852 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	ecx, DWORD PTR $T245973[esp+72]
	push	ecx
	mov	ecx, ebx
	mov	BYTE PTR _bInvalidDeal$222954[esp+76], 0
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T245975[esp+72]
	push	edx
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	$LN4@DoTurn
	npad	1
$LL106@DoTurn:

; 2853 : 			{
; 2854 : 				int iFinalTurn = itemIter->m_iFinalTurn;

	mov	eax, DWORD PTR [ebp+8]
	mov	esi, edi
	imul	esi, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax+esi+16]
	add	eax, esi

; 2855 : 				if(iFinalTurn > -1 && iFinalTurn != iGameTurn)  // if this was the last turn the deal was ending anyways

	cmp	ecx, -1
	jle	SHORT $LN15@DoTurn
	cmp	ecx, DWORD PTR _iGameTurn$222937[esp+72]
	je	SHORT $LN15@DoTurn

; 2856 : 				{
; 2857 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	ecx, DWORD PTR [ebp+8]

; 2858 : 					// check to see if we are negative on resource or gold
; 2859 : 					bool bHaveEnoughGold = true;
; 2860 : 					bool bHaveEnoughResource = true;
; 2861 : 					//if (itemIter->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)
; 2862 : 					//{
; 2863 : 					//	int iGoldPerTurn = itemIter->m_iData1;
; 2864 : 					//	bHaveEnoughGold = GET_PLAYER(eFromPlayer).GetTreasury()->GetGold() > iGoldPerTurn;
; 2865 : 					//}
; 2866 : 					// Resource
; 2867 : 					/*else */
; 2868 : 					if(itemIter->m_eItemType == TRADE_ITEM_RESOURCES)

	cmp	DWORD PTR [ecx+esi+8], 3
	lea	edx, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _eFromPlayer$222934[esp+72], ecx
	jne	SHORT $LN12@DoTurn

; 2869 : 					{
; 2870 : 						ResourceTypes eResource = (ResourceTypes) itemIter->m_iData1;

	mov	eax, DWORD PTR [eax+20]

; 2871 : 						//int iResourceQuantity = itemIter->m_iData2;
; 2872 : 						bHaveEnoughResource = GET_PLAYER(eFromPlayer).getNumResourceTotal(eResource) >= 0;

	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	eax
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	setge	al

; 2875 : 					{
; 2876 : 						bUnbreakable = true;
; 2877 : 						break;
; 2878 : 					}
; 2879 : 
; 2880 : 					if(!bHaveEnoughGold || !bHaveEnoughResource)

	test	al, al
	jne	SHORT $LN15@DoTurn

; 2881 : 					{
; 2882 : 						bInvalidDeal = true;

	mov	BYTE PTR _bInvalidDeal$222954[esp+72], 1
$LN15@DoTurn:

; 2848 : 		{
; 2849 : 			TradedItemList::iterator itemIter;
; 2850 : 			bool bInvalidDeal = false;
; 2851 : 			bool bUnbreakable = false;
; 2852 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN107@DoTurn
	mov	edi, DWORD PTR [ebp+24]
	jmp	SHORT $LN234@DoTurn
$LN12@DoTurn:

; 2873 : 					}
; 2874 : 					else if(itemIter->m_eItemType == TRADE_ITEM_PEACE_TREATY)

	cmp	DWORD PTR [eax+8], 13			; 0000000dH
	je	$LN242@DoTurn

; 2875 : 					{
; 2876 : 						bUnbreakable = true;
; 2877 : 						break;
; 2878 : 					}
; 2879 : 
; 2880 : 					if(!bHaveEnoughGold || !bHaveEnoughResource)

	jmp	SHORT $LN15@DoTurn

; 2848 : 		{
; 2849 : 			TradedItemList::iterator itemIter;
; 2850 : 			bool bInvalidDeal = false;
; 2851 : 			bool bUnbreakable = false;
; 2852 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

$LN107@DoTurn:
	mov	edx, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [esi+edx]
$LN234@DoTurn:
	lea	eax, DWORD PTR $T245975[esp+72]
	push	eax
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL106@DoTurn

; 2883 : 					}
; 2884 : 				}
; 2885 : 			}
; 2886 : 
; 2887 : 			if(!bUnbreakable && bInvalidDeal)

	cmp	BYTE PTR _bInvalidDeal$222954[esp+72], 0
	je	$LN242@DoTurn

; 2888 : 			{
; 2889 : 				bSomethingChanged = true;
; 2890 : 				it->m_iFinalTurn = iGameTurn;

	mov	ecx, DWORD PTR _iGameTurn$222937[esp+72]

; 2891 : 				it->m_bDealCancelled = true;
; 2892 : 
; 2893 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	edx, DWORD PTR $T245976[esp+72]
	mov	DWORD PTR [ebx-28], ecx
	push	edx
	mov	ecx, ebx
	mov	BYTE PTR _bSomethingChanged$222936[esp+76], 1
	mov	BYTE PTR [ebx-2], 1
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T245978[esp+72]
	push	eax
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	je	$LN242@DoTurn
$LL172@DoTurn:

; 2894 : 				{
; 2895 : 					// Cancel individual items
; 2896 : 					itemIter->m_iFinalTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR [ebp+8]
	mov	esi, edi
	imul	esi, 44					; 0000002cH
	lea	edx, DWORD PTR [ecx+esi+8]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T246437[esp+72], edx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T246437[esp+72]
	mov	DWORD PTR [ecx+8], eax

; 2897 : 
; 2898 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	edx, DWORD PTR [ebp+8]

; 2899 : 					eToPlayer = it->GetOtherPlayer(eFromPlayer);

	mov	ecx, DWORD PTR [ebx-40]
	lea	eax, DWORD PTR [edx+esi]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _eFromPlayer$222934[esp+72], edx
	cmp	ecx, edx
	jne	SHORT $LN244@DoTurn
	mov	ecx, DWORD PTR [ebx-36]
$LN244@DoTurn:

; 2900 : 
; 2901 : 					DoEndTradedItem(&*itemIter, eToPlayer, true);

	push	1
	mov	edx, ecx
	push	edx
	add	eax, 8
	mov	DWORD PTR _eToPlayer$222935[esp+80], ecx
	mov	ecx, DWORD PTR _this$[esp+80]
	push	eax
	call	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem
	cmp	edi, 268435455				; 0fffffffH
	jne	SHORT $LN173@DoTurn

; 2891 : 				it->m_bDealCancelled = true;
; 2892 : 
; 2893 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	mov	edi, DWORD PTR [ebp+24]
	jmp	SHORT $LN235@DoTurn
$LN173@DoTurn:
	mov	eax, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [esi+eax]
$LN235@DoTurn:
	lea	ecx, DWORD PTR $T245978[esp+72]
	push	ecx
	mov	ecx, ebx
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	edi, DWORD PTR [eax+4]
	jne	SHORT $LL172@DoTurn
$LN242@DoTurn:
	mov	esi, DWORD PTR _this$[esp+72]
$LN4@DoTurn:

; 2842 : 				}
; 2843 : 			}
; 2844 : 		}
; 2845 : 
; 2846 : 		// check to see if one of our deals in no longer valid
; 2847 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	edx, DWORD PTR [esi+1544]
	mov	eax, DWORD PTR _it$[esp+72]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR [esi+1540]
	add	eax, 76					; 0000004cH
	add	ebx, 76					; 0000004cH
	mov	DWORD PTR _it$[esp+72], eax
	cmp	eax, edx
	jne	$LL19@DoTurn
$LN17@DoTurn:

; 2902 : 				}
; 2903 : 			}
; 2904 : 		}
; 2905 : 
; 2906 : 		if(bSomethingChanged)

	cmp	BYTE PTR _bSomethingChanged$222936[esp+72], 0
	je	SHORT $LN2@DoTurn

; 2907 : 		{
; 2908 : 			// Update UI if we were involved in the deal
; 2909 : 			PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 2910 : 			if(eFromPlayer == eActivePlayer || eToPlayer == eActivePlayer)

	cmp	DWORD PTR _eFromPlayer$222934[esp+72], eax
	je	SHORT $LN1@DoTurn
	cmp	DWORD PTR _eToPlayer$222935[esp+72], eax
	jne	SHORT $LN2@DoTurn
$LN1@DoTurn:

; 2911 : 			{
; 2912 : 				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx
$LN2@DoTurn:

; 2913 : 			}
; 2914 : 		}
; 2915 : 
; 2916 : 		DoUpdateCurrentDealsList();

	mov	ecx, esi
	call	?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ ; CvGameDeals::DoUpdateCurrentDealsList
$LN27@DoTurn:

; 2917 : 	}
; 2918 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvGameDeals@@QAEXXZ ENDP			; CvGameDeals::DoTurn
_TEXT	ENDS
PUBLIC	?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenTeams
; Function compile flags: /Ogtpy
;	COMDAT ?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam1$ = 8						; size = 4
_eTeam2$ = 12						; size = 4
?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z PROC ; CvGameDeals::DoCancelDealsBetweenTeams, COMDAT
; _this$ = ecx

; 3026 : {

	push	ecx

; 3027 : 	if(m_CurrentDeals.size() > 0)

	cmp	DWORD PTR [ecx+1544], 0
	mov	DWORD PTR _this$[esp+4], ecx
	jbe	$LN8@DoCancelDe@2

; 3028 : 	{
; 3029 : 		PlayerTypes eFromPlayer, eToPlayer;
; 3030 : 		int iPlayerLoop1, iPlayerLoop2;
; 3031 : 
; 3032 : 		// Loop through first set of players
; 3033 : 		for(iPlayerLoop1 = 0; iPlayerLoop1 < MAX_MAJOR_CIVS; iPlayerLoop1++)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	xor	ebp, ebp
	push	edi
	xor	ebx, ebx
	npad	1
$LL56@DoCancelDe@2:

; 3034 : 		{
; 3035 : 			eFromPlayer = (PlayerTypes) iPlayerLoop1;
; 3036 : 
; 3037 : 			if(!GET_PLAYER(eFromPlayer).isEverAlive())

	cmp	BYTE PTR [ebx+ecx+2268], 0
	je	SHORT $LN9@DoCancelDe@2

; 3038 : 			{
; 3039 : 				continue;
; 3040 : 			}
; 3041 : 			if(GET_PLAYER(eFromPlayer).getTeam() != eTeam1)

	mov	eax, DWORD PTR [ebx+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN28@DoCancelDe@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@DoCancelDe@2
$LN28@DoCancelDe@2:
	or	eax, -1
$LN29@DoCancelDe@2:
	cmp	eax, DWORD PTR _eTeam1$[esp+16]
	jne	SHORT $LN9@DoCancelDe@2

; 3042 : 			{
; 3043 : 				continue;
; 3044 : 			}
; 3045 : 
; 3046 : 			// Loop through second set of players
; 3047 : 			for(iPlayerLoop2 = 0; iPlayerLoop2 < MAX_MAJOR_CIVS; iPlayerLoop2++)

	xor	edi, edi
	xor	esi, esi
	npad	2
$LL55@DoCancelDe@2:

; 3048 : 			{
; 3049 : 				eToPlayer = (PlayerTypes) iPlayerLoop2;
; 3050 : 
; 3051 : 				if(!GET_PLAYER(eToPlayer).isEverAlive())

	cmp	BYTE PTR [esi+ecx+2268], 0
	je	SHORT $LN4@DoCancelDe@2

; 3052 : 				{
; 3053 : 					continue;
; 3054 : 				}
; 3055 : 				if(GET_PLAYER(eToPlayer).getTeam() != eTeam2)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN45@DoCancelDe@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN46@DoCancelDe@2
$LN45@DoCancelDe@2:
	or	eax, -1
$LN46@DoCancelDe@2:
	cmp	eax, DWORD PTR _eTeam2$[esp+16]
	jne	SHORT $LN4@DoCancelDe@2

; 3056 : 				{
; 3057 : 					continue;
; 3058 : 				}
; 3059 : 
; 3060 : 				DoCancelDealsBetweenPlayers(eFromPlayer, eToPlayer);

	mov	ecx, DWORD PTR _this$[esp+20]
	push	edi
	push	ebp
	call	?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenPlayers
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN4@DoCancelDe@2:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL55@DoCancelDe@2
$LN9@DoCancelDe@2:

; 3028 : 	{
; 3029 : 		PlayerTypes eFromPlayer, eToPlayer;
; 3030 : 		int iPlayerLoop1, iPlayerLoop2;
; 3031 : 
; 3032 : 		// Loop through first set of players
; 3033 : 		for(iPlayerLoop1 = 0; iPlayerLoop1 < MAX_MAJOR_CIVS; iPlayerLoop1++)

	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 1391192				; 00153a58H
	jl	$LL56@DoCancelDe@2
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN8@DoCancelDe@2:

; 3061 : 			}
; 3062 : 		}
; 3063 : 	}
; 3064 : }

	pop	ecx
	ret	8
?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z ENDP ; CvGameDeals::DoCancelDealsBetweenTeams
_TEXT	ENDS
END
