; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod DLL versions\v31\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitCycler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::operator==, COMDAT
; _this$ = ecx

; 123  : 		return m_target == rhs;

	mov	ecx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	ecx, DWORD PTR _rhs$[esp-4]
	sete	al

; 124  : 	}

	ret	4
??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::operator==
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?getLength@?$CLinkList@H@@QBEHXZ		; CLinkList<int>::getLength
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
;	COMDAT ?getLength@?$CLinkList@H@@QBEHXZ
_TEXT	SEGMENT
?getLength@?$CLinkList@H@@QBEHXZ PROC			; CLinkList<int>::getLength, COMDAT
; _this$ = ecx

; 69   : 		return m_iLength;

	mov	eax, DWORD PTR [ecx+4]

; 70   : 	}

	ret	0
?getLength@?$CLinkList@H@@QBEHXZ ENDP			; CLinkList<int>::getLength
_TEXT	ENDS
PUBLIC	?head@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ	; CLinkList<int>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ
_TEXT	SEGMENT
?head@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ PROC		; CLinkList<int>::head, COMDAT
; _this$ = ecx

; 74   : 		return m_pHead;

	mov	eax, DWORD PTR [ecx+8]

; 75   : 	}

	ret	0
?head@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ ENDP		; CLinkList<int>::head
_TEXT	ENDS
PUBLIC	?head@?$CLinkList@H@@QAEPAV?$CLLNode@H@@XZ	; CLinkList<int>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$CLinkList@H@@QAEPAV?$CLLNode@H@@XZ
_TEXT	SEGMENT
?head@?$CLinkList@H@@QAEPAV?$CLLNode@H@@XZ PROC		; CLinkList<int>::head, COMDAT
; _this$ = ecx

; 79   : 		return m_pHead;

	mov	eax, DWORD PTR [ecx+8]

; 80   : 	}

	ret	0
?head@?$CLinkList@H@@QAEPAV?$CLLNode@H@@XZ ENDP		; CLinkList<int>::head
_TEXT	ENDS
PUBLIC	?tail@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ	; CLinkList<int>::tail
; Function compile flags: /Ogtpy
;	COMDAT ?tail@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ
_TEXT	SEGMENT
?tail@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ PROC		; CLinkList<int>::tail, COMDAT
; _this$ = ecx

; 84   : 		return m_pTail;

	mov	eax, DWORD PTR [ecx+12]

; 85   : 	}

	ret	0
?tail@?$CLinkList@H@@QBEPBV?$CLLNode@H@@XZ ENDP		; CLinkList<int>::tail
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??_7?$CLinkList@H@@6B@				; CLinkList<int>::`vftable'
PUBLIC	??0?$CLinkList@H@@QAE@XZ			; CLinkList<int>::CLinkList<int>
PUBLIC	??_R4?$CLinkList@H@@6B@				; CLinkList<int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CLinkList@H@@@8			; CLinkList<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$CLinkList@H@@8				; CLinkList<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CLinkList@H@@8				; CLinkList<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CLinkList@H@@8			; CLinkList<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CLinkList@H@@UAEPAXI@Z:PROC		; CLinkList<int>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CLinkList@H@@8
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CLinkList@H@@8 DD FLAT:??_R0?AV?$CLinkList@H@@@8 ; CLinkList<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CLinkList@H@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CLinkList@H@@8
rdata$r	SEGMENT
??_R2?$CLinkList@H@@8 DD FLAT:??_R1A@?0A@EA@?$CLinkList@H@@8 ; CLinkList<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CLinkList@H@@8
rdata$r	SEGMENT
??_R3?$CLinkList@H@@8 DD 00H				; CLinkList<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CLinkList@H@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CLinkList@H@@@8
_DATA	SEGMENT
??_R0?AV?$CLinkList@H@@@8 DD FLAT:??_7type_info@@6B@	; CLinkList<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CLinkList@H@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CLinkList@H@@6B@
rdata$r	SEGMENT
??_R4?$CLinkList@H@@6B@ DD 00H				; CLinkList<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CLinkList@H@@@8
	DD	FLAT:??_R3?$CLinkList@H@@8
rdata$r	ENDS
;	COMDAT ??_7?$CLinkList@H@@6B@
CONST	SEGMENT
??_7?$CLinkList@H@@6B@ DD FLAT:??_R4?$CLinkList@H@@6B@	; CLinkList<int>::`vftable'
	DD	FLAT:??_E?$CLinkList@H@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0?$CLinkList@H@@QAE@XZ
_TEXT	SEGMENT
??0?$CLinkList@H@@QAE@XZ PROC				; CLinkList<int>::CLinkList<int>, COMDAT
; _this$ = ecx

; 108  : {

	mov	eax, ecx

; 109  : 	m_iLength = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7?$CLinkList@H@@6B@
	mov	DWORD PTR [eax+4], ecx

; 110  : 
; 111  : 	m_pHead = NULL;

	mov	DWORD PTR [eax+8], ecx

; 112  : 	m_pTail = NULL;

	mov	DWORD PTR [eax+12], ecx

; 113  : }

	ret	0
??0?$CLinkList@H@@QAE@XZ ENDP				; CLinkList<int>::CLinkList<int>
_TEXT	ENDS
PUBLIC	?next@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z	; CLinkList<int>::next
; Function compile flags: /Ogtpy
;	COMDAT ?next@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z PROC	; CLinkList<int>::next, COMDAT
; _this$ = ecx

; 348  : 	assert(pNode != NULL);
; 349  : 	return (pNode) ? (pNode->m_pNext) : (NULL);

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN3@next
	mov	eax, DWORD PTR [eax+8]

; 350  : }

	ret	4
$LN3@next:

; 348  : 	assert(pNode != NULL);
; 349  : 	return (pNode) ? (pNode->m_pNext) : (NULL);

	xor	eax, eax

; 350  : }

	ret	4
?next@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z ENDP	; CLinkList<int>::next
_TEXT	ENDS
PUBLIC	?next@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z	; CLinkList<int>::next
; Function compile flags: /Ogtpy
;	COMDAT ?next@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z PROC	; CLinkList<int>::next, COMDAT
; _this$ = ecx

; 341  : 	assert(pNode != NULL);
; 342  : 	return (pNode) ? (pNode->m_pNext) : (NULL);

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN3@next@2
	mov	eax, DWORD PTR [eax+8]

; 343  : }

	ret	4
$LN3@next@2:

; 341  : 	assert(pNode != NULL);
; 342  : 	return (pNode) ? (pNode->m_pNext) : (NULL);

	xor	eax, eax

; 343  : }

	ret	4
?next@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z ENDP	; CLinkList<int>::next
_TEXT	ENDS
PUBLIC	?prev@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z	; CLinkList<int>::prev
; Function compile flags: /Ogtpy
;	COMDAT ?prev@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?prev@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z PROC	; CLinkList<int>::prev, COMDAT
; _this$ = ecx

; 356  : 	assert(pNode != NULL);
; 357  : 	return (pNode) ? (pNode->m_pPrev) : (NULL);

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN3@prev
	mov	eax, DWORD PTR [eax+12]

; 358  : }

	ret	4
$LN3@prev:

; 356  : 	assert(pNode != NULL);
; 357  : 	return (pNode) ? (pNode->m_pPrev) : (NULL);

	xor	eax, eax

; 358  : }

	ret	4
?prev@?$CLinkList@H@@QBEPBV?$CLLNode@H@@PBV2@@Z ENDP	; CLinkList<int>::prev
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??_7?$CLLNode@H@@6B@				; CLLNode<int>::`vftable'
PUBLIC	??0?$CLLNode@H@@QAE@ABH@Z			; CLLNode<int>::CLLNode<int>
PUBLIC	??_R4?$CLLNode@H@@6B@				; CLLNode<int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CLLNode@H@@@8				; CLLNode<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$CLLNode@H@@8				; CLLNode<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CLLNode@H@@8				; CLLNode<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CLLNode@H@@8			; CLLNode<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$CLLNode@H@@UAEPAXI@Z:PROC			; CLLNode<int>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CLLNode@H@@8
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CLLNode@H@@8 DD FLAT:??_R0?AV?$CLLNode@H@@@8 ; CLLNode<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CLLNode@H@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CLLNode@H@@8
rdata$r	SEGMENT
??_R2?$CLLNode@H@@8 DD FLAT:??_R1A@?0A@EA@?$CLLNode@H@@8 ; CLLNode<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CLLNode@H@@8
rdata$r	SEGMENT
??_R3?$CLLNode@H@@8 DD 00H				; CLLNode<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CLLNode@H@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CLLNode@H@@@8
_DATA	SEGMENT
??_R0?AV?$CLLNode@H@@@8 DD FLAT:??_7type_info@@6B@	; CLLNode<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CLLNode@H@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CLLNode@H@@6B@
rdata$r	SEGMENT
??_R4?$CLLNode@H@@6B@ DD 00H				; CLLNode<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CLLNode@H@@@8
	DD	FLAT:??_R3?$CLLNode@H@@8
rdata$r	ENDS
;	COMDAT ??_7?$CLLNode@H@@6B@
CONST	SEGMENT
??_7?$CLLNode@H@@6B@ DD FLAT:??_R4?$CLLNode@H@@6B@	; CLLNode<int>::`vftable'
	DD	FLAT:??_E?$CLLNode@H@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0?$CLLNode@H@@QAE@ABH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
??0?$CLLNode@H@@QAE@ABH@Z PROC				; CLLNode<int>::CLLNode<int>, COMDAT
; _this$ = ecx

; 19   :     CLLNode(const tVARTYPE& val)

	mov	eax, ecx

; 20   :           {
; 21   : 	          m_data = val;

	mov	ecx, DWORD PTR _val$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7?$CLLNode@H@@6B@
	mov	edx, DWORD PTR [ecx]

; 22   : 
; 23   : 	          m_pNext = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 24   : 	          m_pPrev = NULL;

	mov	DWORD PTR [eax+12], ecx

; 25   :           }

	ret	4
??0?$CLLNode@H@@QAE@ABH@Z ENDP				; CLLNode<int>::CLLNode<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@H@@YAXAAPAH@Z			; SAFE_DELETE<int>
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@H@@YAXAAPAH@Z PROC			; SAFE_DELETE<int>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE<int>
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??1?$CLLNode@H@@UAE@XZ				; CLLNode<int>::~CLLNode<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
;	COMDAT ??1?$CLLNode@H@@UAE@XZ
_TEXT	SEGMENT
??1?$CLLNode@H@@UAE@XZ PROC				; CLLNode<int>::~CLLNode<int>, COMDAT
; _this$ = ecx

; 26   : 	virtual ~CLLNode() {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$CLLNode@H@@6B@
	ret	0
??1?$CLLNode@H@@UAE@XZ ENDP				; CLLNode<int>::~CLLNode<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$CLLNode@H@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CLLNode@H@@UAEPAXI@Z PROC				; CLLNode<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$CLLNode@H@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$CLLNode@H@@UAEPAXI@Z ENDP				; CLLNode<int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@V?$CLLNode@H@@@@YAXAAPAV?$CLLNode@H@@@Z ; SAFE_DELETE<CLLNode<int> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@V?$CLLNode@H@@@@YAXAAPAV?$CLLNode@H@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@V?$CLLNode@H@@@@YAXAAPAV?$CLLNode@H@@@Z PROC ; SAFE_DELETE<CLLNode<int> >, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@V?$CLLNode@H@@@@YAXAAPAV?$CLLNode@H@@@Z ENDP ; SAFE_DELETE<CLLNode<int> >
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?NextNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z ; CvUnitCycler::NextNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunitcycler.cpp
;	COMDAT ?NextNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?NextNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z PROC	; CvUnitCycler::NextNode, COMDAT
; _this$ = ecx

; 285  : 	return m_kNodeList.next(pNode);

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN5@NextNode
	mov	eax, DWORD PTR [eax+8]

; 286  : }

	ret	4

; 285  : 	return m_kNodeList.next(pNode);

$LN5@NextNode:
	xor	eax, eax

; 286  : }

	ret	4
?NextNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z ENDP	; CvUnitCycler::NextNode
_TEXT	ENDS
PUBLIC	?NextNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z ; CvUnitCycler::NextNode
; Function compile flags: /Ogtpy
;	COMDAT ?NextNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?NextNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z PROC	; CvUnitCycler::NextNode, COMDAT
; _this$ = ecx

; 291  : 	return m_kNodeList.next(pNode);

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN5@NextNode@2
	mov	eax, DWORD PTR [eax+8]

; 292  : }

	ret	4

; 291  : 	return m_kNodeList.next(pNode);

$LN5@NextNode@2:
	xor	eax, eax

; 292  : }

	ret	4
?NextNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z ENDP	; CvUnitCycler::NextNode
_TEXT	ENDS
PUBLIC	?PreviousNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z ; CvUnitCycler::PreviousNode
; Function compile flags: /Ogtpy
;	COMDAT ?PreviousNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?PreviousNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z PROC ; CvUnitCycler::PreviousNode, COMDAT
; _this$ = ecx

; 297  : 	return m_kNodeList.prev(pNode);

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN5@PreviousNo
	mov	eax, DWORD PTR [eax+12]

; 298  : }

	ret	4

; 297  : 	return m_kNodeList.prev(pNode);

$LN5@PreviousNo:
	xor	eax, eax

; 298  : }

	ret	4
?PreviousNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@PBV2@@Z ENDP ; CvUnitCycler::PreviousNode
_TEXT	ENDS
PUBLIC	?HeadNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ	; CvUnitCycler::HeadNode
; Function compile flags: /Ogtpy
;	COMDAT ?HeadNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ
_TEXT	SEGMENT
?HeadNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ PROC	; CvUnitCycler::HeadNode, COMDAT
; _this$ = ecx

; 303  : 	return m_kNodeList.head();

	mov	eax, DWORD PTR [ecx+8]

; 304  : }

	ret	0
?HeadNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ ENDP	; CvUnitCycler::HeadNode
_TEXT	ENDS
PUBLIC	?HeadNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@XZ	; CvUnitCycler::HeadNode
; Function compile flags: /Ogtpy
;	COMDAT ?HeadNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@XZ
_TEXT	SEGMENT
?HeadNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@XZ PROC	; CvUnitCycler::HeadNode, COMDAT
; _this$ = ecx

; 309  : 	return m_kNodeList.head();

	mov	eax, DWORD PTR [ecx+8]

; 310  : }

	ret	0
?HeadNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@XZ ENDP	; CvUnitCycler::HeadNode
_TEXT	ENDS
PUBLIC	?TailNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ	; CvUnitCycler::TailNode
; Function compile flags: /Ogtpy
;	COMDAT ?TailNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ
_TEXT	SEGMENT
?TailNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ PROC	; CvUnitCycler::TailNode, COMDAT
; _this$ = ecx

; 315  : 	return m_kNodeList.tail();

	mov	eax, DWORD PTR [ecx+12]

; 316  : }

	ret	0
?TailNode@CvUnitCycler@@QBEPBV?$CLLNode@H@@XZ ENDP	; CvUnitCycler::TailNode
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@2

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@2:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@2

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@2:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?insertAtEnd@?$CLinkList@H@@QAEXABH@Z		; CLinkList<int>::insertAtEnd
EXTRN	??2@YAPAXI@Z:PROC				; operator new
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
;	COMDAT ?insertAtEnd@?$CLinkList@H@@QAEXABH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?insertAtEnd@?$CLinkList@H@@QAEXABH@Z PROC		; CLinkList<int>::insertAtEnd, COMDAT
; _this$ = ecx

; 175  : {	

	push	esi

; 176  : 	CLLNode<tVARTYPE>* pNode;
; 177  : 
; 178  : 	assert((m_pHead == NULL) || (m_iLength > 0));
; 179  : 
; 180  : 	pNode = FNEW(CLLNode<tVARTYPE>(val), c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	xor	edx, edx
	add	esp, 4
	cmp	eax, edx
	je	SHORT $LN5@insertAtEn
	mov	ecx, DWORD PTR _val$[esp]
	mov	DWORD PTR [eax], OFFSET ??_7?$CLLNode@H@@6B@
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN6@insertAtEn
$LN5@insertAtEn:
	xor	eax, eax
$LN6@insertAtEn:

; 181  : 
; 182  : 	if (m_pTail != NULL)

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, edx
	je	SHORT $LN2@insertAtEn

; 183  : 	{
; 184  : 		m_pTail->m_pNext = pNode;

	mov	DWORD PTR [ecx+8], eax

; 185  : 		pNode->m_pPrev = m_pTail;

	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx

; 186  : 		m_pTail = pNode;
; 187  : 	}
; 188  : 	else
; 189  : 	{
; 190  : 		m_pHead = pNode;
; 191  : 		m_pTail = pNode;
; 192  : 	}
; 193  : 
; 194  : 	m_iLength++;

	inc	DWORD PTR [esi+4]
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 195  : }

	ret	4
$LN2@insertAtEn:

; 186  : 		m_pTail = pNode;
; 187  : 	}
; 188  : 	else
; 189  : 	{
; 190  : 		m_pHead = pNode;
; 191  : 		m_pTail = pNode;
; 192  : 	}
; 193  : 
; 194  : 	m_iLength++;

	inc	DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 195  : }

	ret	4
?insertAtEnd@?$CLinkList@H@@QAEXABH@Z ENDP		; CLinkList<int>::insertAtEnd
_TEXT	ENDS
PUBLIC	?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z ; CLinkList<int>::deleteNode
; Function compile flags: /Ogtpy
;	COMDAT ?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z PROC ; CLinkList<int>::deleteNode, COMDAT
; _this$ = ecx

; 250  : {

	push	edi
	mov	edi, ecx

; 251  : 	CLLNode<tVARTYPE>* pPrevNode;
; 252  : 	CLLNode<tVARTYPE>* pNextNode;
; 253  : 
; 254  : 	assert(pNode != NULL);
; 255  : 	if (!pNode) return NULL;

	mov	ecx, DWORD PTR _pNode$[esp]
	xor	edx, edx
	cmp	ecx, edx
	jne	SHORT $LN7@deleteNode
	xor	eax, eax
	pop	edi

; 286  : }

	ret	4
$LN7@deleteNode:

; 256  : 
; 257  : 	pPrevNode = pNode->m_pPrev;

	mov	eax, DWORD PTR [ecx+12]
	push	esi

; 258  : 	pNextNode = pNode->m_pNext;

	mov	esi, DWORD PTR [ecx+8]

; 259  : 
; 260  : 	if ((pPrevNode != NULL) && (pNextNode != NULL))

	cmp	eax, edx
	je	SHORT $LN4@deleteNode
	cmp	esi, edx
	je	SHORT $LN6@deleteNode

; 261  : 	{
; 262  : 		pPrevNode->m_pNext = pNextNode;

	mov	DWORD PTR [eax+8], esi

; 263  : 		pNextNode->m_pPrev = pPrevNode;

	mov	DWORD PTR [esi+12], eax

; 279  : 	}
; 280  : 
; 281  : 	SAFE_DELETE(pNode);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 282  : 
; 283  : 	m_iLength--;

	dec	DWORD PTR [edi+4]

; 284  : 
; 285  : 	return pNextNode;

	mov	eax, esi
	pop	esi
	pop	edi

; 286  : }

	ret	4
$LN6@deleteNode:

; 264  : 	}
; 265  : 	else if (pPrevNode != NULL)
; 266  : 	{
; 267  : 		pPrevNode->m_pNext = NULL;

	mov	DWORD PTR [eax+8], edx

; 268  : 		m_pTail = pPrevNode;

	mov	DWORD PTR [edi+12], eax

; 279  : 	}
; 280  : 
; 281  : 	SAFE_DELETE(pNode);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 282  : 
; 283  : 	m_iLength--;

	dec	DWORD PTR [edi+4]

; 284  : 
; 285  : 	return pNextNode;

	mov	eax, esi
	pop	esi
	pop	edi

; 286  : }

	ret	4
$LN4@deleteNode:

; 269  : 	}
; 270  : 	else if (pNextNode != NULL)

	cmp	esi, edx
	je	SHORT $LN2@deleteNode

; 271  : 	{
; 272  : 		pNextNode->m_pPrev = NULL;

	mov	DWORD PTR [esi+12], edx

; 273  : 		m_pHead = pNextNode;

	mov	DWORD PTR [edi+8], esi

; 279  : 	}
; 280  : 
; 281  : 	SAFE_DELETE(pNode);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 282  : 
; 283  : 	m_iLength--;

	dec	DWORD PTR [edi+4]

; 284  : 
; 285  : 	return pNextNode;

	mov	eax, esi
	pop	esi
	pop	edi

; 286  : }

	ret	4
$LN2@deleteNode:

; 274  : 	}
; 275  : 	else
; 276  : 	{
; 277  : 		m_pHead = NULL;

	mov	DWORD PTR [edi+8], edx

; 278  : 		m_pTail = NULL;

	mov	DWORD PTR [edi+12], edx

; 279  : 	}
; 280  : 
; 281  : 	SAFE_DELETE(pNode);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 282  : 
; 283  : 	m_iLength--;

	dec	DWORD PTR [edi+4]

; 284  : 
; 285  : 	return pNextNode;

	mov	eax, esi
	pop	esi
	pop	edi

; 286  : }

	ret	4
?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z ENDP ; CLinkList<int>::deleteNode
_TEXT	ENDS
PUBLIC	?Write@?$CLinkList@H@@QBEXAAVFDataStream@@@Z	; CLinkList<int>::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@?$CLinkList@H@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iLength$ = -4						; size = 4
_kStream$ = 8						; size = 4
?Write@?$CLinkList@H@@QBEXAAVFDataStream@@@Z PROC	; CLinkList<int>::Write, COMDAT
; _this$ = ecx

; 488  : {

	push	ecx
	push	esi
	mov	esi, ecx

; 489  : 	int iLength = getLength();

	mov	eax, DWORD PTR [esi+4]
	push	edi

; 490  : 	kStream <<  iLength ;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	ecx, DWORD PTR _iLength$[esp+12]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iLength$[esp+16], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 491  : 	const CLLNode< T >* pNode = head();

	mov	esi, DWORD PTR [esi+8]

; 492  : 	while ( pNode )

	test	esi, esi
	je	SHORT $LN19@Write
$LL2@Write:

; 493  : 	{
; 494  : 		kStream << pNode->m_data ;

	lea	edx, DWORD PTR [esi+4]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 495  : 		pNode = next( pNode );

	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	jne	SHORT $LL2@Write
$LN19@Write:
	pop	edi
	pop	esi

; 496  : 	}
; 497  : }

	pop	ecx
	ret	4
?Write@?$CLinkList@H@@QBEXAAVFDataStream@@@Z ENDP	; CLinkList<int>::Write
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?clear@?$CLinkList@H@@QAEXXZ			; CLinkList<int>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
;	COMDAT ?clear@?$CLinkList@H@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CLinkList@H@@QAEXXZ PROC			; CLinkList<int>::clear, COMDAT
; _this$ = ecx

; 127  : {

	push	edi
	mov	edi, ecx

; 128  : 	CLLNode<tVARTYPE>* pCurrNode;
; 129  : 	CLLNode<tVARTYPE>* pNextNode;
; 130  : 
; 131  : 	pCurrNode = m_pHead;

	mov	ecx, DWORD PTR [edi+8]

; 132  : 	while (pCurrNode != NULL)

	test	ecx, ecx
	je	SHORT $LN1@clear
	push	esi
	npad	5
$LL2@clear:

; 133  : 	{
; 134  : 		pNextNode = pCurrNode->m_pNext;
; 135  : 		SAFE_DELETE(pCurrNode);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx+8]
	push	1
	call	edx

; 136  : 		pCurrNode = pNextNode;

	mov	ecx, esi
	test	esi, esi
	jne	SHORT $LL2@clear
	pop	esi
$LN1@clear:

; 137  : 	}
; 138  : 
; 139  : 	m_iLength = 0;

	mov	DWORD PTR [edi+4], 0

; 140  : 
; 141  : 	m_pHead = NULL;

	mov	DWORD PTR [edi+8], 0

; 142  : 	m_pTail = NULL;

	mov	DWORD PTR [edi+12], 0
	pop	edi

; 143  : }

	ret	0
?clear@?$CLinkList@H@@QAEXXZ ENDP			; CLinkList<int>::clear
_TEXT	ENDS
PUBLIC	?Clear@CvUnitCycler@@QAEXXZ			; CvUnitCycler::Clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunitcycler.cpp
;	COMDAT ?Clear@CvUnitCycler@@QAEXXZ
_TEXT	SEGMENT
?Clear@CvUnitCycler@@QAEXXZ PROC			; CvUnitCycler::Clear, COMDAT
; _this$ = ecx

; 23   : 	m_kNodeList.clear();

	jmp	?clear@?$CLinkList@H@@QAEXXZ		; CLinkList<int>::clear
?Clear@CvUnitCycler@@QAEXXZ ENDP			; CvUnitCycler::Clear
_TEXT	ENDS
PUBLIC	?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z ; CvUnitCycler::Cycle
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?ReadyToSelect@CvUnit@@QBE_NXZ:PROC		; CvUnit::ReadyToSelect
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z$0
__ehfuncinfo$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunitcycler.cpp
xdata$x	ENDS
;	COMDAT ?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z
_TEXT	SEGMENT
_pLoopUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_bForward$ = 12						; size = 1
_bWorkers$ = 16						; size = 1
_pFirstUnitNode$ = 20					; size = 4
_pbWrap$ = 20						; size = 4
?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z PROC	; CvUnitCycler::Cycle, COMDAT
; _this$ = ecx

; 152  : {

	push	-1
	push	__ehhandler$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp

; 153  : 	const CLLNode<int>* pUnitNode;
; 154  : 	const CLLNode<int>* pFirstUnitNode;
; 155  : 	UnitHandle pLoopUnit;

	xor	eax, eax
	push	esi
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _pLoopUnit$[esp+36], eax
	mov	BYTE PTR _pLoopUnit$[esp+40], al

; 156  : 
; 157  : 	if (pbWrap != NULL)

	mov	ebx, DWORD PTR _pbWrap$[esp+32]
	mov	DWORD PTR __$EHRec$[esp+44], eax
	cmp	ebx, eax
	je	SHORT $LN26@Cycle

; 158  : 	{
; 159  : 		*pbWrap = false;

	mov	BYTE PTR [ebx], al
$LN26@Cycle:

; 160  : 	}
; 161  : 
; 162  : 	pUnitNode = HeadNode();
; 163  : 
; 164  : 	if (pUnit != NULL)

	mov	edi, DWORD PTR _pUnit$[esp+32]
	mov	esi, DWORD PTR [ebp+8]
	cmp	edi, eax
	je	SHORT $LN119@Cycle

; 165  : 	{
; 166  : 		while (pUnitNode != NULL)

	cmp	esi, eax
	je	SHORT $LN120@Cycle
$LL24@Cycle:

; 167  : 		{
; 168  : 			if (m_pkPlayer->getUnit(pUnitNode->m_data) == pUnit)

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ebp+16]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	cmp	eax, edi
	je	SHORT $LN114@Cycle

; 177  : 				}
; 178  : 				break;
; 179  : 			}
; 180  : 
; 181  : 			pUnitNode = NextNode(pUnitNode);

	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	jne	SHORT $LL24@Cycle

; 261  : 					}
; 262  : 				}
; 263  : 			}
; 264  : 
; 265  : 			if (pUnitNode == pFirstUnitNode)

	jmp	SHORT $LN120@Cycle
$LN114@Cycle:

; 169  : 			{
; 170  : 				if (bForward)

	cmp	BYTE PTR _bForward$[esp+32], 0
	je	SHORT $LN21@Cycle

; 171  : 				{
; 172  : 					pUnitNode = NextNode(pUnitNode);

	mov	esi, DWORD PTR [esi+8]

; 173  : 				}
; 174  : 				else

	jmp	SHORT $LN119@Cycle
$LN21@Cycle:

; 175  : 				{
; 176  : 					pUnitNode = PreviousNode(pUnitNode);

	mov	esi, DWORD PTR [esi+12]
$LN119@Cycle:

; 182  : 		}
; 183  : 	}
; 184  : 
; 185  : 	if (pUnitNode == NULL)

	test	esi, esi
	jne	SHORT $LN117@Cycle
$LN120@Cycle:

; 186  : 	{
; 187  : 		if (bForward)

	cmp	BYTE PTR _bForward$[esp+32], 0
	je	SHORT $LN18@Cycle

; 188  : 		{
; 189  : 			pUnitNode = HeadNode();

	mov	esi, DWORD PTR [ebp+8]

; 190  : 		}
; 191  : 		else

	jmp	SHORT $LN17@Cycle
$LN18@Cycle:

; 192  : 		{
; 193  : 			pUnitNode = TailNode();

	mov	esi, DWORD PTR [ebp+12]
$LN17@Cycle:

; 194  : 		}
; 195  : 
; 196  : 		if (pbWrap != NULL)

	test	ebx, ebx
	je	SHORT $LN16@Cycle

; 197  : 		{
; 198  : 			*pbWrap = true;

	mov	BYTE PTR [ebx], 1
$LN16@Cycle:

; 199  : 		}
; 200  : 	}
; 201  : 
; 202  : 	if (pUnitNode != NULL)

	test	esi, esi
	je	$LN122@Cycle
$LN117@Cycle:

; 203  : 	{
; 204  : 		pFirstUnitNode = pUnitNode;

	mov	DWORD PTR _pFirstUnitNode$[esp+32], esi
$LL14@Cycle:

; 205  : 
; 206  : 		while (true)
; 207  : 		{
; 208  : #ifdef AUI_WARNING_FIXES
; 209  : 			if (pUnitNode)
; 210  : 			{
; 211  : 				pLoopUnit = m_pkPlayer->getUnit(pUnitNode->m_data);
; 212  : #else
; 213  : 			pLoopUnit = m_pkPlayer->getUnit(pUnitNode->m_data);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [ebp+16]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, DWORD PTR _pLoopUnit$[esp+36]
	mov	edi, eax
	test	ecx, ecx
	je	SHORT $LN66@Cycle
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN66@Cycle:
	mov	DWORD PTR _pLoopUnit$[esp+36], edi
	test	edi, edi
	je	SHORT $LN121@Cycle
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 214  : #endif
; 215  : 			CvAssertMsg(pLoopUnit, "LoopUnit is not assigned a valid value");
; 216  : 
; 217  : 			if (pLoopUnit && pLoopUnit->ReadyToSelect())

	mov	ecx, edi
	call	?ReadyToSelect@CvUnit@@QBE_NXZ		; CvUnit::ReadyToSelect
	test	al, al
	je	SHORT $LN121@Cycle

; 218  : 			{
; 219  : 				if (!bWorkers || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER_SEA)

	cmp	BYTE PTR _bWorkers$[esp+32], 0
	je	SHORT $LN10@Cycle
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN10@Cycle
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 17					; 00000011H
	je	SHORT $LN10@Cycle
$LN121@Cycle:

; 230  : 				}
; 231  : 			}
; 232  : #ifdef AUI_WARNING_FIXES
; 233  : 			}
; 234  : #endif
; 235  : 
; 236  : 			if (bForward)

	cmp	BYTE PTR _bForward$[esp+32], 0
	je	SHORT $LN7@Cycle

; 237  : 			{
; 238  : 				pUnitNode = NextNode(pUnitNode);

	mov	esi, DWORD PTR [esi+8]

; 239  : 
; 240  : 				if (pUnitNode == NULL)

	test	esi, esi
	jne	SHORT $LN2@Cycle

; 241  : 				{
; 242  : 					pUnitNode = HeadNode();

	mov	esi, DWORD PTR [ebp+8]

; 243  : 
; 244  : 					if (pbWrap != NULL)
; 245  : 					{
; 246  : 						*pbWrap = true;
; 247  : 					}
; 248  : 				}
; 249  : 			}
; 250  : 			else

	jmp	SHORT $LN125@Cycle
$LN7@Cycle:

; 251  : 			{
; 252  : 				pUnitNode = PreviousNode(pUnitNode);

	mov	esi, DWORD PTR [esi+12]

; 253  : 
; 254  : 				if (pUnitNode == NULL)

	test	esi, esi
	jne	SHORT $LN2@Cycle

; 255  : 				{
; 256  : 					pUnitNode = TailNode();

	mov	esi, DWORD PTR [ebp+12]
$LN125@Cycle:

; 257  : 
; 258  : 					if (pbWrap != NULL)

	test	ebx, ebx
	je	SHORT $LN2@Cycle

; 259  : 					{
; 260  : 						*pbWrap = true;

	mov	BYTE PTR [ebx], 1
$LN2@Cycle:

; 261  : 					}
; 262  : 				}
; 263  : 			}
; 264  : 
; 265  : 			if (pUnitNode == pFirstUnitNode)

	cmp	esi, DWORD PTR _pFirstUnitNode$[esp+32]
	jne	SHORT $LL14@Cycle
$LN122@Cycle:

; 266  : 			{
; 267  : 				break;
; 268  : 			}
; 269  : 		}
; 270  : 	}
; 271  : 
; 272  : 	return NULL;

	mov	ecx, DWORD PTR _pLoopUnit$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN110@Cycle
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN110@Cycle:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 273  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	16					; 00000010H
$LN10@Cycle:

; 220  : 				{
; 221  : 					if (pUnit && pLoopUnit== pUnit)

	mov	eax, DWORD PTR _pUnit$[esp+32]
	test	eax, eax
	je	SHORT $LN8@Cycle
	cmp	edi, eax
	jne	SHORT $LN8@Cycle

; 222  : 					{
; 223  : 						if (pbWrap != NULL)

	test	ebx, ebx
	je	SHORT $LN8@Cycle

; 224  : 						{
; 225  : 							*pbWrap = true;

	mov	BYTE PTR [ebx], 1
$LN8@Cycle:

; 226  : 						}
; 227  : 					}
; 228  : 
; 229  : 					return pLoopUnit.pointer();

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 273  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Cycle@CvUnitCycler@@QAEPAVCvUnit@@PAV2@_N1PA_N@Z ENDP	; CvUnitCycler::Cycle
PUBLIC	?DeleteNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z ; CvUnitCycler::DeleteNode
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?DeleteNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z PROC ; CvUnitCycler::DeleteNode, COMDAT
; _this$ = ecx

; 279  : 	return m_kNodeList.deleteNode(pNode);

	jmp	?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z ; CLinkList<int>::deleteNode
?DeleteNode@CvUnitCycler@@QAEPAV?$CLLNode@H@@PAV2@@Z ENDP ; CvUnitCycler::DeleteNode
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$CLinkList@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$CLinkList@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$CLinkList@H@@@Z PROC ; operator<<<int>, COMDAT

; 526  : 	readFrom.Write(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	?Write@?$CLinkList@H@@QBEXAAVFDataStream@@@Z ; CLinkList<int>::Write

; 527  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 528  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$CLinkList@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	?Read@?$CLinkList@H@@QAEXAAVFDataStream@@@Z	; CLinkList<int>::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@?$CLinkList@H@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iLength$ = -4						; size = 4
_kStream$ = 8						; size = 4
?Read@?$CLinkList@H@@QAEXAAVFDataStream@@@Z PROC	; CLinkList<int>::Read, COMDAT
; _this$ = ecx

; 469  : {

	push	ecx
	push	ebx
	push	esi

; 470  : 	int iLength;
; 471  : 	kStream >>  iLength ;

	lea	eax, DWORD PTR _iLength$[esp+12]
	mov	esi, ecx
	mov	ecx, DWORD PTR _kStream$[esp+8]
	push	eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 472  : 	clear();

	mov	ecx, esi
	call	?clear@?$CLinkList@H@@QAEXXZ		; CLinkList<int>::clear

; 473  : 
; 474  : 	if ( iLength )

	xor	ebx, ebx
	cmp	DWORD PTR _iLength$[esp+12], ebx
	je	SHORT $LN20@Read
	push	ebp
	push	edi

; 475  : 	{
; 476  : 		T* pData = FNEW(T, c_eCiv5GameplayDLL, 0);;

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 477  : 		for ( int i = 0; i < iLength; i++ )

	xor	ebp, ebp
	cmp	DWORD PTR _iLength$[esp+20], ebx
	mov	edi, eax
	jle	SHORT $LN1@Read
	npad	8
$LL3@Read:

; 478  : 		{
; 479  : 			kStream >>  *pData ;

	mov	ecx, DWORD PTR _kStream$[esp+16]
	push	edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 480  : 			insertAtEnd( *pData );

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN15@Read
	mov	DWORD PTR [eax], OFFSET ??_7?$CLLNode@H@@6B@
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	jmp	SHORT $LN16@Read
$LN15@Read:
	xor	eax, eax
$LN16@Read:
	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, ebx
	je	SHORT $LN12@Read
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN24@Read
$LN12@Read:
	mov	DWORD PTR [esi+8], eax
$LN24@Read:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _iLength$[esp+20]
	mov	DWORD PTR [esi+12], eax
	jl	SHORT $LL3@Read
$LN1@Read:

; 481  : 		}
; 482  : 		SAFE_DELETE( pData );

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	ebp
$LN20@Read:
	pop	esi
	pop	ebx

; 483  : 	}
; 484  : }

	pop	ecx
	ret	4
?Read@?$CLinkList@H@@QAEXAAVFDataStream@@@Z ENDP	; CLinkList<int>::Read
_TEXT	ENDS
PUBLIC	??1?$CLinkList@H@@UAE@XZ			; CLinkList<int>::~CLinkList<int>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CLinkList@H@@UAE@XZ
_TEXT	SEGMENT
??1?$CLinkList@H@@UAE@XZ PROC				; CLinkList<int>::~CLinkList<int>, COMDAT
; _this$ = ecx

; 120  : {

	mov	DWORD PTR [ecx], OFFSET ??_7?$CLinkList@H@@6B@

; 121  :   clear();

	jmp	?clear@?$CLinkList@H@@QAEXXZ		; CLinkList<int>::clear
??1?$CLinkList@H@@UAE@XZ ENDP				; CLinkList<int>::~CLinkList<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$CLinkList@H@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CLinkList@H@@UAEPAXI@Z PROC			; CLinkList<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$CLinkList@H@@6B@
	call	?clear@?$CLinkList@H@@QAEXXZ		; CLinkList<int>::clear
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$CLinkList@H@@UAEPAXI@Z ENDP			; CLinkList<int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvUnitCycler@@QAE@PAVCvPlayer@@@Z		; CvUnitCycler::CvUnitCycler
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunitcycler.cpp
;	COMDAT ??0CvUnitCycler@@QAE@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_pkPlayer$ = 8						; size = 4
??0CvUnitCycler@@QAE@PAVCvPlayer@@@Z PROC		; CvUnitCycler::CvUnitCycler, COMDAT
; _this$ = ecx

; 16   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 17   : 	m_pkPlayer = pkPlayer;

	mov	ecx, DWORD PTR _pkPlayer$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7?$CLinkList@H@@6B@
	mov	DWORD PTR [eax+16], ecx

; 18   : }

	ret	4
??0CvUnitCycler@@QAE@PAVCvPlayer@@@Z ENDP		; CvUnitCycler::CvUnitCycler
_TEXT	ENDS
PUBLIC	?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z	; CvUnitCycler::Rebuild
EXTRN	?GetCycleOrder@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCycleOrder
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z:PROC	; CvUnit::workRate
EXTRN	?SetCycleOrder@CvUnit@@QAEXH@Z:PROC		; CvUnit::SetCycleOrder
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z:PROC ; CvGlobals::UnwrapUnitPointer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z$1
__ehfuncinfo$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunitcycler.cpp
xdata$x	ENDS
;	COMDAT ?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_iLoop$ = -32						; size = 4
_iX$217640 = -28					; size = 4
_iNumUnits$217634 = -24					; size = 4
_pCurrentUnit$217633 = -20				; size = 8
__$EHRec$ = -12						; size = 12
_iY$217641 = 8						; size = 4
_pSelectedUnit$217611 = 8				; size = 4
_pkStartUnit$ = 8					; size = 4
?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z PROC		; CvUnitCycler::Rebuild, COMDAT
; _this$ = ecx

; 28   : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 29   : 	// Delete contents of old list
; 30   : 	Node* pUnitNode = HeadNode();

	mov	eax, DWORD PTR [edi+8]

; 31   : 	while(pUnitNode != NULL)

	test	eax, eax
	je	SHORT $LN19@Rebuild
$LL20@Rebuild:

; 32   : 	{
; 33   : 		DeleteNode(pUnitNode);

	push	eax
	mov	ecx, edi
	call	?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z ; CLinkList<int>::deleteNode

; 34   : 		pUnitNode = HeadNode();

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LL20@Rebuild
$LN19@Rebuild:

; 35   : 	}
; 36   : 
; 37   : 	if (pkStartUnit == NULL)

	mov	esi, DWORD PTR _pkStartUnit$[esp+44]
	test	esi, esi
	jne	SHORT $LN132@Rebuild

; 38   : 	{
; 39   : 		// If no unit supplied, use the selected unit.
; 40   : 		auto_ptr<ICvUnit1> pSelectedUnit(DLLUI->GetHeadSelectedUnit());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	ebx, eax
	mov	DWORD PTR _pSelectedUnit$217611[esp+44], ebx

; 41   : 		pkStartUnit = GC.UnwrapUnitPointer(pSelectedUnit.get());

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+60], esi
	call	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ; CvGlobals::UnwrapUnitPointer
	mov	esi, eax

; 42   : 
; 43   : 		if (pkStartUnit && pkStartUnit->getOwner() != m_pkPlayer->GetID())

	test	esi, esi
	je	SHORT $LN17@Rebuild
	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN17@Rebuild

; 44   : 		{
; 45   : 			// Not ours, fall back to just selecting a worker
; 46   : 			pkStartUnit = NULL;

	xor	esi, esi
$LN17@Rebuild:

; 47   : 		}
; 48   : 	}

	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	ebx, ebx
	je	SHORT $LN132@Rebuild
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+4]
	push	ebx
	call	eax
$LN132@Rebuild:

; 49   : 
; 50   : 	CvUnit* pLoopUnit;
; 51   : 	int iLoop;
; 52   : 	CvUnit* pkFirstUnit = m_pkPlayer->firstUnit(&iLoop);

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR [edi+16]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	ebp, eax

; 53   : 	for(pLoopUnit = pkFirstUnit; pLoopUnit != NULL; pLoopUnit = m_pkPlayer->nextUnit(&iLoop))

	mov	ebx, ebp
	test	ebp, ebp
	je	SHORT $LN14@Rebuild
	npad	4
$LL135@Rebuild:

; 54   : 	{
; 55   : 		// Reset cycle order (will be used later in this function)
; 56   : 		pLoopUnit->SetCycleOrder(0);

	push	0
	mov	ecx, ebx
	call	?SetCycleOrder@CvUnit@@QAEXH@Z		; CvUnit::SetCycleOrder

; 57   : 
; 58   : 		if (!pkStartUnit)

	test	esi, esi
	jne	SHORT $LN15@Rebuild

; 59   : 		{
; 60   : 			// Workers first
; 61   : 			if(pLoopUnit->workRate(true) > 0)

	push	-1
	push	1
	mov	ecx, ebx
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	test	eax, eax
	jle	SHORT $LN15@Rebuild

; 62   : 				pkStartUnit = pLoopUnit;

	mov	esi, ebx
$LN15@Rebuild:

; 53   : 	for(pLoopUnit = pkFirstUnit; pLoopUnit != NULL; pLoopUnit = m_pkPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [edi+16]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+52]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL135@Rebuild
$LN14@Rebuild:

; 63   : 		}
; 64   : 	}
; 65   : 
; 66   : 	if (!pkStartUnit)

	test	esi, esi
	jne	SHORT $LN131@Rebuild

; 67   : 		pkStartUnit = pkFirstUnit;

	mov	esi, ebp

; 68   : 
; 69   : 	// Add first unit to list
; 70   : 	if(pkStartUnit)

	test	ebp, ebp
	je	$LN122@Rebuild
$LN131@Rebuild:

; 71   : 	{
; 72   : 		m_kNodeList.insertAtEnd(pkStartUnit->GetID());

	mov	ebx, DWORD PTR [esi+100]
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	xor	edx, edx
	add	esp, 4
	cmp	eax, edx
	je	SHORT $LN62@Rebuild
	mov	DWORD PTR [eax], OFFSET ??_7?$CLLNode@H@@6B@
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN63@Rebuild
$LN62@Rebuild:
	xor	eax, eax
$LN63@Rebuild:
	mov	ecx, DWORD PTR [edi+12]
	cmp	ecx, edx
	je	SHORT $LN59@Rebuild
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ecx
	jmp	SHORT $LN138@Rebuild
$LN59@Rebuild:
	mov	DWORD PTR [edi+8], eax
$LN138@Rebuild:
	mov	ebx, 1
	add	DWORD PTR [edi+4], ebx

; 73   : 
; 74   : 		// Current unit is the first one
; 75   : 		UnitHandle pCurrentUnit = pkStartUnit;

	mov	ecx, esi
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR _pCurrentUnit$217633[esp+48], esi
	mov	BYTE PTR _pCurrentUnit$217633[esp+52], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 76   : 		pCurrentUnit->SetCycleOrder(1);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	call	?SetCycleOrder@CvUnit@@QAEXH@Z		; CvUnit::SetCycleOrder

; 77   : 
; 78   : 		// Loop through units until everyone is accounted for
; 79   : 		int iNumUnits = m_pkPlayer->getNumUnits();

	mov	ecx, DWORD PTR [edi+16]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits

; 80   : 		while(m_kNodeList.getLength() < iNumUnits)

	cmp	DWORD PTR [edi+4], eax
	mov	DWORD PTR _iNumUnits$217634[esp+48], eax
	jge	$LN2@Rebuild
	jmp	SHORT $LN9@Rebuild
	npad	6
$LL133@Rebuild:
	mov	esi, DWORD PTR _pCurrentUnit$217633[esp+48]
$LN9@Rebuild:

; 81   : 		{
; 82   : 			int iBestUnitScore = MAX_INT;
; 83   : 			CvUnit* pBestUnit = NULL;
; 84   : 
; 85   : 			int iX = pCurrentUnit->getX();

	mov	edx, DWORD PTR [esi+76]

; 86   : 			int iY = pCurrentUnit->getY();

	mov	eax, DWORD PTR [esi+88]
	xor	ebx, ebx

; 87   : 			for(pLoopUnit = m_pkPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pkPlayer->nextUnit(&iLoop))

	push	ebx
	lea	ecx, DWORD PTR _iLoop$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR [edi+16]
	mov	ebp, 2147483647				; 7fffffffH
	mov	DWORD PTR _iX$217640[esp+56], edx
	mov	DWORD PTR _iY$217641[esp+52], eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN134@Rebuild
$LL7@Rebuild:

; 88   : 			{
; 89   : 				// If we've already added this unit to the cycle list, skip it
; 90   : 				if(pLoopUnit->GetCycleOrder() == 1)

	mov	ecx, esi
	call	?GetCycleOrder@CvUnit@@QBEHXZ		; CvUnit::GetCycleOrder
	cmp	eax, 1
	je	SHORT $LN6@Rebuild

; 91   : 					continue;
; 92   : 
; 93   : 				int iScore = plotDistance(iX, iY, pLoopUnit->getX(), pLoopUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR _iY$217641[esp+44]
	push	eax
	mov	eax, DWORD PTR _iX$217640[esp+52]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 94   : 
; 95   : 				// Closest unit yet
; 96   : 				if(iScore < iBestUnitScore)

	cmp	eax, ebp
	jge	SHORT $LN6@Rebuild

; 97   : 				{
; 98   : 					iBestUnitScore = iScore;

	mov	ebp, eax

; 99   : 					pBestUnit = pLoopUnit;

	mov	ebx, esi
$LN6@Rebuild:
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR [edi+16]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL7@Rebuild

; 100  : 				}
; 101  : 			}
; 102  : 
; 103  : 			CvAssertMsg(pBestUnit, "Didn't find a unit to add to cycle list.");
; 104  : 
; 105  : 			if (pBestUnit)

	xor	ebp, ebp
	cmp	ebx, ebp
	je	SHORT $LN134@Rebuild

; 106  : 			{
; 107  : 				m_kNodeList.insertAtEnd(pBestUnit->GetID());

	mov	esi, DWORD PTR [ebx+100]
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN104@Rebuild
	mov	DWORD PTR [eax], OFFSET ??_7?$CLLNode@H@@6B@
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	jmp	SHORT $LN105@Rebuild
$LN104@Rebuild:
	xor	eax, eax
$LN105@Rebuild:
	mov	ecx, DWORD PTR [edi+12]
	cmp	ecx, ebp
	je	SHORT $LN101@Rebuild
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN139@Rebuild
$LN101@Rebuild:
	mov	DWORD PTR [edi+8], eax
$LN139@Rebuild:

; 108  : 
; 109  : 				// Now have a new current unit
; 110  : 				pCurrentUnit = pBestUnit;

	mov	ecx, DWORD PTR _pCurrentUnit$217633[esp+48]
	inc	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+12], eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, ebx
	mov	DWORD PTR _pCurrentUnit$217633[esp+48], ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 111  : 				pCurrentUnit->SetCycleOrder(1);

	push	1
	mov	ecx, ebx
	call	?SetCycleOrder@CvUnit@@QAEXH@Z		; CvUnit::SetCycleOrder
	mov	eax, DWORD PTR _iNumUnits$217634[esp+48]
	cmp	DWORD PTR [edi+4], eax
	jl	$LL133@Rebuild
$LN134@Rebuild:

; 80   : 		while(m_kNodeList.getLength() < iNumUnits)

	mov	esi, DWORD PTR _pCurrentUnit$217633[esp+48]
$LN2@Rebuild:

; 112  : 			}
; 113  : 			else
; 114  : 				break;
; 115  : 		}
; 116  : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN122@Rebuild:

; 117  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _pSelectedUnit$217611[ebp-4]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _pCurrentUnit$217633[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z ENDP		; CvUnitCycler::Rebuild
PUBLIC	?AddUnit@CvUnitCycler@@QAEXH@Z			; CvUnitCycler::AddUnit
; Function compile flags: /Ogtpy
;	COMDAT ?AddUnit@CvUnitCycler@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?AddUnit@CvUnitCycler@@QAEXH@Z PROC			; CvUnitCycler::AddUnit, COMDAT
; _this$ = ecx

; 126  : 	Rebuild();

	mov	DWORD PTR _iID$[esp-4], 0
	jmp	?Rebuild@CvUnitCycler@@QAEXPAVCvUnit@@@Z ; CvUnitCycler::Rebuild
?AddUnit@CvUnitCycler@@QAEXH@Z ENDP			; CvUnitCycler::AddUnit
_TEXT	ENDS
PUBLIC	?RemoveUnit@CvUnitCycler@@QAEXH@Z		; CvUnitCycler::RemoveUnit
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveUnit@CvUnitCycler@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?RemoveUnit@CvUnitCycler@@QAEXH@Z PROC			; CvUnitCycler::RemoveUnit, COMDAT
; _this$ = ecx

; 131  : 	CLLNode<int>* pUnitNode;
; 132  : 
; 133  : 	pUnitNode = HeadNode();

	mov	eax, DWORD PTR [ecx+8]

; 134  : 
; 135  : 	while(pUnitNode != NULL)

	test	eax, eax
	je	SHORT $LN3@RemoveUnit
	mov	edx, DWORD PTR _iID$[esp-4]
	npad	5
$LL4@RemoveUnit:

; 136  : 	{
; 137  : 		if(pUnitNode->m_data == iID)

	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN20@RemoveUnit

; 140  : 			break;
; 141  : 		}
; 142  : 		else
; 143  : 		{
; 144  : 			pUnitNode = NextNode(pUnitNode);

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	jne	SHORT $LL4@RemoveUnit
$LN3@RemoveUnit:

; 145  : 		}
; 146  : 	}
; 147  : }

	ret	4
$LN20@RemoveUnit:

; 138  : 		{
; 139  : 			pUnitNode = DeleteNode(pUnitNode);

	mov	DWORD PTR _iID$[esp-4], eax
	jmp	?deleteNode@?$CLinkList@H@@QAEPAV?$CLLNode@H@@PAV2@@Z ; CLinkList<int>::deleteNode
?RemoveUnit@CvUnitCycler@@QAEXH@Z ENDP			; CvUnitCycler::RemoveUnit
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvUnitCycler@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvUnitCycler@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvUnitCycler@@@Z PROC	; operator<<, COMDAT

; 329  : 	saveTo << readFrom.m_kNodeList;

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	?Write@?$CLinkList@H@@QBEXAAVFDataStream@@@Z ; CLinkList<int>::Write

; 330  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 331  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvUnitCycler@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$CLinkList@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredllutil\include\linkedlist.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$CLinkList@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$CLinkList@H@@@Z PROC ; operator>><int>, COMDAT

; 533  : 	writeTo.Read(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	?Read@?$CLinkList@H@@QAEXAAVFDataStream@@@Z ; CLinkList<int>::Read

; 534  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 535  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$CLinkList@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvUnitCycler@@@Z	; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod dll versions\v31\lekmod_dll\cvgamecoredll_expansion2\cvunitcycler.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvUnitCycler@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvUnitCycler@@@Z PROC	; operator>>, COMDAT

; 320  : {

	push	esi

; 321  : 	writeTo.Clear();

	mov	esi, DWORD PTR _writeTo$[esp]
	push	edi
	mov	ecx, esi
	call	?clear@?$CLinkList@H@@QAEXXZ		; CLinkList<int>::clear

; 322  : 	loadFrom >> writeTo.m_kNodeList;

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Read@?$CLinkList@H@@QAEXAAVFDataStream@@@Z ; CLinkList<int>::Read

; 323  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi

; 324  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvUnitCycler@@@Z ENDP	; operator>>
_TEXT	ENDS
END
