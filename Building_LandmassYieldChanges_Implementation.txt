IMPLEMENTATION GUIDE FOR BUILDING_SAMELANDMASSYIELDCHANGES AND BUILDING_DIFFERENTLANDMASSYIELDCHANGES
======================================================================================================

This implementation adds two new building tables that modify base city yields based on landmass relationships:
1. Building_SameLandMassYieldChanges - affects base yields of cities on the same landmass (including the building's city)
2. Building_DifferentLandMassYieldChanges - affects base yields of cities on different landmasses than the building

This works similar to Policy_CityYieldChanges and Policy_CoastalCityYieldChanges but based on landmass relationships.

STEP 1: XML TABLE DEFINITIONS
=============================

Add to LEKMOD/Override/CIV5Units.xml (or create a new XML file in LEKMOD/XML/):

<!-- Add these table definitions after the existing Building_YieldChanges table -->
<Table name="Building_SameLandMassYieldChanges">
    <Column name="BuildingType" type="text" reference="Buildings(Type)"/>
    <Column name="YieldType" type="text" reference="Yields(Type)"/>
    <Column name="Yield" type="integer" default="0"/>
</Table>

<Table name="Building_DifferentLandMassYieldChanges">
    <Column name="BuildingType" type="text" reference="Buildings(Type)"/>
    <Column name="YieldType" type="text" reference="Yields(Type)"/>
    <Column name="Yield" type="integer" default="0"/>
</Table>

STEP 2: HEADER FILE CHANGES (CvBuildingClasses.h)
==================================================

File: LEKMOD_DLL/CvGameCoreDLL_Expansion2/CvBuildingClasses.h

Add these member variables to the CvBuildingEntry class (around line 200-300, with other similar declarations):

#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
    std::pair<int**, size_t> m_ppaiSameLandMassYieldChange;
    std::pair<int**, size_t> m_ppaiDifferentLandMassYieldChange;
#else
    int** m_ppaiSameLandMassYieldChange;
    int** m_ppaiDifferentLandMassYieldChange;
#endif

Add these method declarations in the public section of CvBuildingEntry class (around line 400-500):

    int GetSameLandMassYieldChange(int i, int j) const;
    int GetDifferentLandMassYieldChange(int i, int j) const;

STEP 3: HEADER FILE CHANGES (CvPlayer.h)
=========================================

File: LEKMOD_DLL/CvGameCoreDLL_Expansion2/CvPlayer.h

Add these member variables after the existing yield arrays (around lines 2250-2260, after m_aiGreatWorkYieldChange):

    FAutoVariable<std::vector<int>, CvPlayer> m_aiSameLandMassYieldChange;
    FAutoVariable<std::vector<int>, CvPlayer> m_aiDifferentLandMassYieldChange;

Add these method declarations in the public section (around line 800-900, near other yield methods):

    int GetSameLandMassYieldChange(YieldTypes eIndex) const;
    void ChangeSameLandMassYieldChange(YieldTypes eIndex, int iChange);
    int GetDifferentLandMassYieldChange(YieldTypes eIndex) const;
    void ChangeDifferentLandMassYieldChange(YieldTypes eIndex, int iChange);

STEP 4: IMPLEMENTATION FILE CHANGES (CvBuildingClasses.cpp)
===========================================================

File: LEKMOD_DLL/CvGameCoreDLL_Expansion2/CvBuildingClasses.cpp

4A. Constructor initialization (around line 200):
Add these lines to the CvBuildingEntry constructor initialization list:

#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
    m_ppaiSameLandMassYieldChange(std::pair<int**, size_t>(NULL, 0)),
    m_ppaiDifferentLandMassYieldChange(std::pair<int**, size_t>(NULL, 0)),
#else
    m_ppaiSameLandMassYieldChange(NULL),
    m_ppaiDifferentLandMassYieldChange(NULL),
#endif

4B. Database loading (around line 800-900, after Building_TerrainYieldChanges section):
Add this code after the TerrainYieldChanges section:

    //SameLandMassYieldChanges
    {
#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
        kUtility.Initialize2DArray(m_ppaiSameLandMassYieldChange.first, "Buildings", "Yields");
        m_ppaiSameLandMassYieldChange.second = kUtility.MaxRows("Buildings");
#else
        kUtility.Initialize2DArray(m_ppaiSameLandMassYieldChange, "Buildings", "Yields");
#endif

        std::string strKey("Building_SameLandMassYieldChanges");
        Database::Results* pResults = kUtility.GetResults(strKey);
        if(pResults == NULL)
        {
            pResults = kUtility.PrepareResults(strKey, "select Buildings.ID as BuildingID, Yields.ID as YieldID, Yield from Building_SameLandMassYieldChanges inner join Buildings on Buildings.Type = BuildingType inner join Yields on Yields.Type = YieldType where BuildingType = ?");
        }

        pResults->Bind(1, szBuildingType);

        while(pResults->Step())
        {
            const int BuildingID = pResults->GetInt(0);
            const int YieldID = pResults->GetInt(1);
            const int yield = pResults->GetInt(2);

#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
            m_ppaiSameLandMassYieldChange.first[BuildingID][YieldID] = yield;
#else
            m_ppaiSameLandMassYieldChange[BuildingID][YieldID] = yield;
#endif
        }
    }

    //DifferentLandMassYieldChanges
    {
#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
        kUtility.Initialize2DArray(m_ppaiDifferentLandMassYieldChange.first, "Buildings", "Yields");
        m_ppaiDifferentLandMassYieldChange.second = kUtility.MaxRows("Buildings");
#else
        kUtility.Initialize2DArray(m_ppaiDifferentLandMassYieldChange, "Buildings", "Yields");
#endif

        std::string strKey("Building_DifferentLandMassYieldChanges");
        Database::Results* pResults = kUtility.GetResults(strKey);
        if(pResults == NULL)
        {
            pResults = kUtility.PrepareResults(strKey, "select Buildings.ID as BuildingID, Yields.ID as YieldID, Yield from Building_DifferentLandMassYieldChanges inner join Buildings on Buildings.Type = BuildingType inner join Yields on Yields.Type = YieldType where BuildingType = ?");
        }

        pResults->Bind(1, szBuildingType);

        while(pResults->Step())
        {
            const int BuildingID = pResults->GetInt(0);
            const int YieldID = pResults->GetInt(1);
            const int yield = pResults->GetInt(2);

#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
            m_ppaiDifferentLandMassYieldChange.first[BuildingID][YieldID] = yield;
#else
            m_ppaiDifferentLandMassYieldChange[BuildingID][YieldID] = yield;
#endif
        }
    }

4C. Method implementations (at the end of the file, around line 2500):
Add these method implementations:

/// Yield change for same landmass cities by yield type
int CvBuildingEntry::GetSameLandMassYieldChange(int i, int j) const
{
    CvAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
    CvAssertMsg(i > -1, "Index out of bounds");
    CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
    CvAssertMsg(j > -1, "Index out of bounds");
#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
    return m_ppaiSameLandMassYieldChange.first ? m_ppaiSameLandMassYieldChange.first[i][j] : 0;
#else
    return m_ppaiSameLandMassYieldChange[i][j];
#endif
}

/// Yield change for different landmass cities by yield type
int CvBuildingEntry::GetDifferentLandMassYieldChange(int i, int j) const
{
    CvAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
    CvAssertMsg(i > -1, "Index out of bounds");
    CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
    CvAssertMsg(j > -1, "Index out of bounds");
#ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
    return m_ppaiDifferentLandMassYieldChange.first ? m_ppaiDifferentLandMassYieldChange.first[i][j] : 0;
#else
    return m_ppaiDifferentLandMassYieldChange[i][j];
#endif
}

STEP 5: PLAYER CLASS CHANGES (CvPlayer.cpp)
============================================

File: LEKMOD_DLL/CvGameCoreDLL_Expansion2/CvPlayer.cpp

5A. Constructor initialization (around line 430-440, after m_aiGreatWorkYieldChange):
Add these lines to the CvPlayer constructor initialization list:

    , m_aiSameLandMassYieldChange("CvPlayer::m_aiSameLandMassYieldChange", m_syncArchive)
    , m_aiDifferentLandMassYieldChange("CvPlayer::m_aiDifferentLandMassYieldChange", m_syncArchive)

5B. Add the getter/setter methods (around line 21000-22000, with other yield methods):

int CvPlayer::GetSameLandMassYieldChange(YieldTypes eIndex) const
{
    CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
    CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
    if(eIndex >= 0 && eIndex < NUM_YIELD_TYPES && (int)m_aiSameLandMassYieldChange.size() > eIndex)
    {
        return m_aiSameLandMassYieldChange[eIndex];
    }
    return 0;
}

void CvPlayer::ChangeSameLandMassYieldChange(YieldTypes eIndex, int iChange)
{
    CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
    CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

    if(iChange != 0)
    {
        if((int)m_aiSameLandMassYieldChange.size() <= eIndex)
        {
            m_aiSameLandMassYieldChange.resize(eIndex + 1, 0);
        }
        m_aiSameLandMassYieldChange[eIndex] = (m_aiSameLandMassYieldChange[eIndex] + iChange);
        updateYield();
    }
}

int CvPlayer::GetDifferentLandMassYieldChange(YieldTypes eIndex) const
{
    CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
    CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
    if(eIndex >= 0 && eIndex < NUM_YIELD_TYPES && (int)m_aiDifferentLandMassYieldChange.size() > eIndex)
    {
        return m_aiDifferentLandMassYieldChange[eIndex];
    }
    return 0;
}

void CvPlayer::ChangeDifferentLandMassYieldChange(YieldTypes eIndex, int iChange)
{
    CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
    CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

    if(iChange != 0)
    {
        if((int)m_aiDifferentLandMassYieldChange.size() <= eIndex)
        {
            m_aiDifferentLandMassYieldChange.resize(eIndex + 1, 0);
        }
        m_aiDifferentLandMassYieldChange[eIndex] = (m_aiDifferentLandMassYieldChange[eIndex] + iChange);
        updateYield();
    }
}

5C. Add building processing logic (around line 10610-10674, in the doCreateBuilding function):
Add this code in the "Loop through Cities" section after the existing building class yield changes:

    // Apply landmass-based yield changes to player modifiers
    if(pBuildingInfo)
    {
        for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
        {
            YieldTypes eYield = (YieldTypes)iYield;
            
            // Same landmass yield changes
            int iSameYieldChange = pBuildingInfo->GetSameLandMassYieldChange(eBuilding, eYield);
            if(iSameYieldChange != 0)
            {
                ChangeSameLandMassYieldChange(eYield, iSameYieldChange * iChange);
            }
            
            // Different landmass yield changes  
            int iDiffYieldChange = pBuildingInfo->GetDifferentLandMassYieldChange(eBuilding, eYield);
            if(iDiffYieldChange != 0)
            {
                ChangeDifferentLandMassYieldChange(eYield, iDiffYieldChange * iChange);
            }
        }
    }

STEP 6: CITY YIELD CALCULATION (CvCity.cpp or CvPlot.cpp)
=========================================================

You'll need to add the landmass checking logic to apply these yield bonuses. Add this code to the appropriate yield calculation function in either CvCity.cpp or CvPlot.cpp:

    // Apply landmass-based yield changes from buildings
    if(bCity && pCity != NULL)
    {
        CvPlayer& kPlayer = GET_PLAYER(ePlayer);
        int iCityLandmass = pCity->plot()->getLandmass();
        
        // Check if player has any landmass-based building bonuses
        int iSameLandmassBonus = kPlayer.GetSameLandMassYieldChange(eYield);
        int iDifferentLandmassBonus = kPlayer.GetDifferentLandMassYieldChange(eYield);
        
        if(iSameLandmassBonus != 0 || iDifferentLandmassBonus != 0)
        {
            // Check all player cities to see if any have buildings that affect this city
            int iLoop;
            CvCity* pLoopCity;
            for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
            {
                int iBuildingLandmass = pLoopCity->plot()->getLandmass();
                
                // Check all buildings in this city
                for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
                {
                    BuildingTypes eBuilding = (BuildingTypes)iBuildingLoop;
                    if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
                    {
                        CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
                        if(pBuildingInfo)
                        {
                            if(iCityLandmass == iBuildingLandmass)
                            {
                                // Same landmass
                                int iSameYieldChange = pBuildingInfo->GetSameLandMassYieldChange(eBuilding, eYield);
                                if(iSameYieldChange != 0)
                                {
                                    iYield += iSameYieldChange;
                                }
                            }
                            else
                            {
                                // Different landmass
                                int iDiffYieldChange = pBuildingInfo->GetDifferentLandMassYieldChange(eBuilding, eYield);
                                if(iDiffYieldChange != 0)
                                {
                                    iYield += iDiffYieldChange;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

STEP 7: EXAMPLE XML USAGE
=========================

To use these new tables, add entries like this to building definitions:

<Building_SameLandMassYieldChanges>
    <Row>
        <BuildingType>BUILDING_LIGHTHOUSE</BuildingType>
        <YieldType>YIELD_FOOD</YieldType>
        <Yield>1</Yield>
    </Row>
    <Row>
        <BuildingType>BUILDING_LIGHTHOUSE</BuildingType>
        <YieldType>YIELD_GOLD</YieldType>
        <Yield>1</Yield>
    </Row>
</Building_SameLandMassYieldChanges>

<Building_DifferentLandMassYieldChanges>
    <Row>
        <BuildingType>BUILDING_HARBOR</BuildingType>
        <YieldType>YIELD_GOLD</YieldType>
        <Yield>2</Yield>
    </Row>
</Building_DifferentLandMassYieldChanges>

This would make:
- Lighthouse give +1 Food and +1 Gold base yield to all cities on the same landmass
- Harbor give +2 Gold base yield to all cities on different landmasses

STEP 8: COMPILATION NOTES
=========================

1. Compile the DLL after making these changes
2. The effects should stack if multiple buildings have the same yield bonuses
3. The landmass comparison uses the plot's getLandmass() function which returns the landmass ID
4. Effects are applied to base city yields, similar to how policies work
5. Effects are applied when buildings are constructed or destroyed (iChange parameter handles both cases)

ADDITIONAL CONSIDERATIONS
========================

1. Performance: This approach stores modifiers at the player level and applies them during yield calculation
2. Save game compatibility: These changes may require new save games to work properly
3. AI considerations: The AI may need additional code to properly evaluate these building bonuses
4. UI/Tooltips: Consider adding tooltip support to show these effects in building descriptions
5. The implementation follows the same pattern as Policy_CityYieldChanges and Policy_CoastalCityYieldChanges

This implementation now works like policies, affecting the base yields of cities rather than building-specific yields. 