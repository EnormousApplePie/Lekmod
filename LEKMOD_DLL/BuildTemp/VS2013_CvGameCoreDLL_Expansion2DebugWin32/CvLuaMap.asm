; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_03NBOPHIOC@Map?$AA@			; `string'
PUBLIC	?GetInstanceName@CvLuaMap@@SAPBDXZ		; CvLuaMap::GetInstanceName
;	COMDAT ??_C@_03NBOPHIOC@Map?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
CONST	SEGMENT
??_C@_03NBOPHIOC@Map?$AA@ DB 'Map', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetInstanceName@CvLuaMap@@SAPBDXZ
_TEXT	SEGMENT
?GetInstanceName@CvLuaMap@@SAPBDXZ PROC			; CvLuaMap::GetInstanceName, COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp

; 30   : 	return "Map";

	mov	eax, OFFSET ??_C@_03NBOPHIOC@Map?$AA@

; 31   : }

	pop	ebp
	ret	0
?GetInstanceName@CvLuaMap@@SAPBDXZ ENDP			; CvLuaMap::GetInstanceName
_TEXT	ENDS
PUBLIC	?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z ; CvLuaMap::GetInstance
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z
_TEXT	SEGMENT
$T219048 = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z PROC ; CvLuaMap::GetInstance, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 35   : 	return &GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219048[ebp], eax
	mov	eax, DWORD PTR $T219048[ebp]

; 36   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z ENDP ; CvLuaMap::GetInstance
_TEXT	ENDS
PUBLIC	?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetAIMapHint
PUBLIC	??_C@_0N@HOPKKBFA@GetAIMapHint?$AA@		; `string'
PUBLIC	?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lChangeAIMapHint
PUBLIC	??_C@_0BA@LBEOMNDN@ChangeAIMapHint?$AA@		; `string'
PUBLIC	?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lUpdateDeferredFog
PUBLIC	??_C@_0BC@NEIENBHI@UpdateDeferredFog?$AA@	; `string'
PUBLIC	?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetCustomOption
PUBLIC	??_C@_0BA@OFKJKAHO@GetCustomOption?$AA@		; `string'
PUBLIC	?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDoPlaceNaturalWonders
PUBLIC	??_C@_0BG@CKIMEJDO@DoPlaceNaturalWonders?$AA@	; `string'
PUBLIC	?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDefaultContinentStamper
PUBLIC	??_C@_0BI@FJEKNGCD@DefaultContinentStamper?$AA@	; `string'
PUBLIC	?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lPlotDirection
PUBLIC	??_C@_0O@KFLINAME@PlotDirection?$AA@		; `string'
PUBLIC	?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotXYWithRangeCheck
PUBLIC	??_C@_0BF@KECCBKDM@PlotXYWithRangeCheck?$AA@	; `string'
PUBLIC	?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lPlotDistance
PUBLIC	??_C@_0N@MEIOLADF@PlotDistance?$AA@		; `string'
PUBLIC	?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lRecalculateAreas
PUBLIC	??_C@_0BB@JKPMDLPA@RecalculateAreas?$AA@	; `string'
PUBLIC	?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lCalculateAreas
PUBLIC	??_C@_0P@NBDGMLOL@CalculateAreas?$AA@		; `string'
PUBLIC	?lRand@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lRand
PUBLIC	??_C@_04LLEMEMKG@Rand?$AA@			; `string'
PUBLIC	?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lMaxPlotDistance
PUBLIC	??_C@_0BA@CCIGDKDJ@MaxPlotDistance?$AA@		; `string'
PUBLIC	?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lIsWrapY
PUBLIC	??_C@_07FPAEKGCN@IsWrapY?$AA@			; `string'
PUBLIC	?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lIsWrapX
PUBLIC	??_C@_07EGBPJHGM@IsWrapX?$AA@			; `string'
PUBLIC	?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lIsPlot
PUBLIC	??_C@_06HPINNINL@IsPlot?$AA@			; `string'
PUBLIC	?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetWorldSize
PUBLIC	??_C@_0N@FPBKEFGF@GetWorldSize?$AA@		; `string'
PUBLIC	?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetSeaLevel
PUBLIC	??_C@_0M@KNAMEA@GetSeaLevel?$AA@		; `string'
PUBLIC	?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetRandomResourceQuantity
PUBLIC	??_C@_0BK@HOCFBNFL@GetRandomResourceQuantity?$AA@ ; `string'
PUBLIC	?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumLandAreas
PUBLIC	??_C@_0BA@FBJEIDBA@GetNumLandAreas?$AA@		; `string'
PUBLIC	?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumAreas
PUBLIC	??_C@_0M@JIPEEG@GetNumAreas?$AA@		; `string'
PUBLIC	?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetLandPlots
PUBLIC	??_C@_0N@NPJKCDAG@GetLandPlots?$AA@		; `string'
PUBLIC	?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetIndexAfterLastArea
PUBLIC	??_C@_0BG@JLBMIGG@GetIndexAfterLastArea?$AA@	; `string'
PUBLIC	?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lGetArea
PUBLIC	??_C@_07GGOHINDE@GetArea?$AA@			; `string'
PUBLIC	?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetPlotXY
PUBLIC	??_C@_09PEPHLIAF@GetPlotXY?$AA@			; `string'
PUBLIC	?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetPlotByIndex
PUBLIC	??_C@_0P@OBFALEHP@GetPlotByIndex?$AA@		; `string'
PUBLIC	?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lGetPlot
PUBLIC	??_C@_07LBIDHAGI@GetPlot?$AA@			; `string'
PUBLIC	?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumResourcesOnLand
PUBLIC	??_C@_0BG@EKLFIOEC@GetNumResourcesOnLand?$AA@	; `string'
PUBLIC	?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumResources
PUBLIC	??_C@_0BA@GNCPKBPM@GetNumResources?$AA@		; `string'
PUBLIC	?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumPlots
PUBLIC	??_C@_0M@GCJCINGE@GetNumPlots?$AA@		; `string'
PUBLIC	?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetGridSize
PUBLIC	??_C@_0M@LPEMLLNI@GetGridSize?$AA@		; `string'
PUBLIC	?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetFractalFlags
PUBLIC	??_C@_0BA@IOOBNKCD@GetFractalFlags?$AA@		; `string'
PUBLIC	?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetClimate
PUBLIC	??_C@_0L@JMDPNOGL@GetClimate?$AA@		; `string'
PUBLIC	?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lFindWater
PUBLIC	??_C@_09MHBIEOCI@FindWater?$AA@			; `string'
PUBLIC	?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lFindBiggestArea
PUBLIC	??_C@_0BA@GMHEAAJC@FindBiggestArea?$AA@		; `string'
PUBLIC	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
PUBLIC	?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lAreas
PUBLIC	??_C@_05EINELICJ@Areas?$AA@			; `string'
PUBLIC	?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z	; CvLuaMap::RegisterMembers
;	COMDAT ??_C@_0N@HOPKKBFA@GetAIMapHint?$AA@
CONST	SEGMENT
??_C@_0N@HOPKKBFA@GetAIMapHint?$AA@ DB 'GetAIMapHint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBEOMNDN@ChangeAIMapHint?$AA@
CONST	SEGMENT
??_C@_0BA@LBEOMNDN@ChangeAIMapHint?$AA@ DB 'ChangeAIMapHint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NEIENBHI@UpdateDeferredFog?$AA@
CONST	SEGMENT
??_C@_0BC@NEIENBHI@UpdateDeferredFog?$AA@ DB 'UpdateDeferredFog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OFKJKAHO@GetCustomOption?$AA@
CONST	SEGMENT
??_C@_0BA@OFKJKAHO@GetCustomOption?$AA@ DB 'GetCustomOption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CKIMEJDO@DoPlaceNaturalWonders?$AA@
CONST	SEGMENT
??_C@_0BG@CKIMEJDO@DoPlaceNaturalWonders?$AA@ DB 'DoPlaceNaturalWonders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FJEKNGCD@DefaultContinentStamper?$AA@
CONST	SEGMENT
??_C@_0BI@FJEKNGCD@DefaultContinentStamper?$AA@ DB 'DefaultContinentStamp'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KFLINAME@PlotDirection?$AA@
CONST	SEGMENT
??_C@_0O@KFLINAME@PlotDirection?$AA@ DB 'PlotDirection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KECCBKDM@PlotXYWithRangeCheck?$AA@
CONST	SEGMENT
??_C@_0BF@KECCBKDM@PlotXYWithRangeCheck?$AA@ DB 'PlotXYWithRangeCheck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MEIOLADF@PlotDistance?$AA@
CONST	SEGMENT
??_C@_0N@MEIOLADF@PlotDistance?$AA@ DB 'PlotDistance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JKPMDLPA@RecalculateAreas?$AA@
CONST	SEGMENT
??_C@_0BB@JKPMDLPA@RecalculateAreas?$AA@ DB 'RecalculateAreas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBDGMLOL@CalculateAreas?$AA@
CONST	SEGMENT
??_C@_0P@NBDGMLOL@CalculateAreas?$AA@ DB 'CalculateAreas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEMEMKG@Rand?$AA@
CONST	SEGMENT
??_C@_04LLEMEMKG@Rand?$AA@ DB 'Rand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CCIGDKDJ@MaxPlotDistance?$AA@
CONST	SEGMENT
??_C@_0BA@CCIGDKDJ@MaxPlotDistance?$AA@ DB 'MaxPlotDistance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FPAEKGCN@IsWrapY?$AA@
CONST	SEGMENT
??_C@_07FPAEKGCN@IsWrapY?$AA@ DB 'IsWrapY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGBPJHGM@IsWrapX?$AA@
CONST	SEGMENT
??_C@_07EGBPJHGM@IsWrapX?$AA@ DB 'IsWrapX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPINNINL@IsPlot?$AA@
CONST	SEGMENT
??_C@_06HPINNINL@IsPlot?$AA@ DB 'IsPlot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPBKEFGF@GetWorldSize?$AA@
CONST	SEGMENT
??_C@_0N@FPBKEFGF@GetWorldSize?$AA@ DB 'GetWorldSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KNAMEA@GetSeaLevel?$AA@
CONST	SEGMENT
??_C@_0M@KNAMEA@GetSeaLevel?$AA@ DB 'GetSeaLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOCFBNFL@GetRandomResourceQuantity?$AA@
CONST	SEGMENT
??_C@_0BK@HOCFBNFL@GetRandomResourceQuantity?$AA@ DB 'GetRandomResourceQu'
	DB	'antity', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FBJEIDBA@GetNumLandAreas?$AA@
CONST	SEGMENT
??_C@_0BA@FBJEIDBA@GetNumLandAreas?$AA@ DB 'GetNumLandAreas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIPEEG@GetNumAreas?$AA@
CONST	SEGMENT
??_C@_0M@JIPEEG@GetNumAreas?$AA@ DB 'GetNumAreas', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPJKCDAG@GetLandPlots?$AA@
CONST	SEGMENT
??_C@_0N@NPJKCDAG@GetLandPlots?$AA@ DB 'GetLandPlots', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JLBMIGG@GetIndexAfterLastArea?$AA@
CONST	SEGMENT
??_C@_0BG@JLBMIGG@GetIndexAfterLastArea?$AA@ DB 'GetIndexAfterLastArea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGOHINDE@GetArea?$AA@
CONST	SEGMENT
??_C@_07GGOHINDE@GetArea?$AA@ DB 'GetArea', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PEPHLIAF@GetPlotXY?$AA@
CONST	SEGMENT
??_C@_09PEPHLIAF@GetPlotXY?$AA@ DB 'GetPlotXY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OBFALEHP@GetPlotByIndex?$AA@
CONST	SEGMENT
??_C@_0P@OBFALEHP@GetPlotByIndex?$AA@ DB 'GetPlotByIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBIDHAGI@GetPlot?$AA@
CONST	SEGMENT
??_C@_07LBIDHAGI@GetPlot?$AA@ DB 'GetPlot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EKLFIOEC@GetNumResourcesOnLand?$AA@
CONST	SEGMENT
??_C@_0BG@EKLFIOEC@GetNumResourcesOnLand?$AA@ DB 'GetNumResourcesOnLand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNCPKBPM@GetNumResources?$AA@
CONST	SEGMENT
??_C@_0BA@GNCPKBPM@GetNumResources?$AA@ DB 'GetNumResources', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GCJCINGE@GetNumPlots?$AA@
CONST	SEGMENT
??_C@_0M@GCJCINGE@GetNumPlots?$AA@ DB 'GetNumPlots', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPEMLLNI@GetGridSize?$AA@
CONST	SEGMENT
??_C@_0M@LPEMLLNI@GetGridSize?$AA@ DB 'GetGridSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IOOBNKCD@GetFractalFlags?$AA@
CONST	SEGMENT
??_C@_0BA@IOOBNKCD@GetFractalFlags?$AA@ DB 'GetFractalFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JMDPNOGL@GetClimate?$AA@
CONST	SEGMENT
??_C@_0L@JMDPNOGL@GetClimate?$AA@ DB 'GetClimate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHBIEOCI@FindWater?$AA@
CONST	SEGMENT
??_C@_09MHBIEOCI@FindWater?$AA@ DB 'FindWater', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMHEAAJC@FindBiggestArea?$AA@
CONST	SEGMENT
??_C@_0BA@GMHEAAJC@FindBiggestArea?$AA@ DB 'FindBiggestArea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EINELICJ@Areas?$AA@
CONST	SEGMENT
??_C@_05EINELICJ@Areas?$AA@ DB 'Areas', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z PROC	; CvLuaMap::RegisterMembers, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp

; 40   : 	Method(Areas);

	push	OFFSET ??_C@_05EINELICJ@Areas?$AA@
	push	OFFSET ?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lAreas
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 41   : 	Method(FindBiggestArea);

	push	OFFSET ??_C@_0BA@GMHEAAJC@FindBiggestArea?$AA@
	push	OFFSET ?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lFindBiggestArea
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 42   : 	Method(FindWater);

	push	OFFSET ??_C@_09MHBIEOCI@FindWater?$AA@
	push	OFFSET ?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lFindWater
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 43   : 	Method(GetClimate);

	push	OFFSET ??_C@_0L@JMDPNOGL@GetClimate?$AA@
	push	OFFSET ?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetClimate
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 44   : 	Method(GetFractalFlags);

	push	OFFSET ??_C@_0BA@IOOBNKCD@GetFractalFlags?$AA@
	push	OFFSET ?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetFractalFlags
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 45   : 	Method(GetGridSize);

	push	OFFSET ??_C@_0M@LPEMLLNI@GetGridSize?$AA@
	push	OFFSET ?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetGridSize
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 46   : 	Method(GetNumPlots);

	push	OFFSET ??_C@_0M@GCJCINGE@GetNumPlots?$AA@
	push	OFFSET ?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumPlots
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 47   : 	Method(GetNumResources);

	push	OFFSET ??_C@_0BA@GNCPKBPM@GetNumResources?$AA@
	push	OFFSET ?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumResources
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 48   : 	Method(GetNumResourcesOnLand);

	push	OFFSET ??_C@_0BG@EKLFIOEC@GetNumResourcesOnLand?$AA@
	push	OFFSET ?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumResourcesOnLand
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 49   : 	Method(GetPlot);

	push	OFFSET ??_C@_07LBIDHAGI@GetPlot?$AA@
	push	OFFSET ?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 50   : 	Method(GetPlotByIndex);

	push	OFFSET ??_C@_0P@OBFALEHP@GetPlotByIndex?$AA@
	push	OFFSET ?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetPlotByIndex
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 51   : 	Method(GetPlotXY);

	push	OFFSET ??_C@_09PEPHLIAF@GetPlotXY?$AA@
	push	OFFSET ?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetPlotXY
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 52   : 	Method(GetArea);

	push	OFFSET ??_C@_07GGOHINDE@GetArea?$AA@
	push	OFFSET ?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 53   : 	Method(GetIndexAfterLastArea);

	push	OFFSET ??_C@_0BG@JLBMIGG@GetIndexAfterLastArea?$AA@
	push	OFFSET ?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetIndexAfterLastArea
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 54   : 	Method(GetLandPlots);

	push	OFFSET ??_C@_0N@NPJKCDAG@GetLandPlots?$AA@
	push	OFFSET ?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetLandPlots
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 55   : 	Method(GetNumAreas);

	push	OFFSET ??_C@_0M@JIPEEG@GetNumAreas?$AA@
	push	OFFSET ?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumAreas
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 56   : 	Method(GetNumLandAreas);

	push	OFFSET ??_C@_0BA@FBJEIDBA@GetNumLandAreas?$AA@
	push	OFFSET ?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumLandAreas
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 57   : 	Method(GetRandomResourceQuantity);

	push	OFFSET ??_C@_0BK@HOCFBNFL@GetRandomResourceQuantity?$AA@
	push	OFFSET ?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetRandomResourceQuantity
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 58   : 	Method(GetSeaLevel);

	push	OFFSET ??_C@_0M@KNAMEA@GetSeaLevel?$AA@
	push	OFFSET ?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetSeaLevel
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 59   : 	Method(GetWorldSize);

	push	OFFSET ??_C@_0N@FPBKEFGF@GetWorldSize?$AA@
	push	OFFSET ?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetWorldSize
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 60   : 	Method(IsPlot);

	push	OFFSET ??_C@_06HPINNINL@IsPlot?$AA@
	push	OFFSET ?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lIsPlot
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 61   : 	Method(IsWrapX);

	push	OFFSET ??_C@_07EGBPJHGM@IsWrapX?$AA@
	push	OFFSET ?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lIsWrapX
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 62   : 	Method(IsWrapY);

	push	OFFSET ??_C@_07FPAEKGCN@IsWrapY?$AA@
	push	OFFSET ?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lIsWrapY
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 63   : 	Method(MaxPlotDistance);

	push	OFFSET ??_C@_0BA@CCIGDKDJ@MaxPlotDistance?$AA@
	push	OFFSET ?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lMaxPlotDistance
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 64   : 	Method(Rand);

	push	OFFSET ??_C@_04LLEMEMKG@Rand?$AA@
	push	OFFSET ?lRand@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lRand
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 65   : 	Method(CalculateAreas);

	push	OFFSET ??_C@_0P@NBDGMLOL@CalculateAreas?$AA@
	push	OFFSET ?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lCalculateAreas
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 66   : 	Method(RecalculateAreas);

	push	OFFSET ??_C@_0BB@JKPMDLPA@RecalculateAreas?$AA@
	push	OFFSET ?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lRecalculateAreas
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 67   : 	Method(PlotDistance);

	push	OFFSET ??_C@_0N@MEIOLADF@PlotDistance?$AA@
	push	OFFSET ?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotDistance
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 68   : 	Method(PlotXYWithRangeCheck);

	push	OFFSET ??_C@_0BF@KECCBKDM@PlotXYWithRangeCheck?$AA@
	push	OFFSET ?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotXYWithRangeCheck
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 69   : 	Method(PlotDirection);

	push	OFFSET ??_C@_0O@KFLINAME@PlotDirection?$AA@
	push	OFFSET ?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotDirection
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 70   : 	Method(DefaultContinentStamper);

	push	OFFSET ??_C@_0BI@FJEKNGCD@DefaultContinentStamper?$AA@
	push	OFFSET ?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDefaultContinentStamper
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 71   : 	Method(DoPlaceNaturalWonders);

	push	OFFSET ??_C@_0BG@CKIMEJDO@DoPlaceNaturalWonders?$AA@
	push	OFFSET ?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDoPlaceNaturalWonders
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 72   : 	Method(GetCustomOption);

	push	OFFSET ??_C@_0BA@OFKJKAHO@GetCustomOption?$AA@
	push	OFFSET ?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetCustomOption
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 73   : 	Method(UpdateDeferredFog);

	push	OFFSET ??_C@_0BC@NEIENBHI@UpdateDeferredFog?$AA@
	push	OFFSET ?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lUpdateDeferredFog
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 74   : 	Method(ChangeAIMapHint);

	push	OFFSET ??_C@_0BA@LBEOMNDN@ChangeAIMapHint?$AA@
	push	OFFSET ?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lChangeAIMapHint
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 75   : 	Method(GetAIMapHint);

	push	OFFSET ??_C@_0N@HOPKKBFA@GetAIMapHint?$AA@
	push	OFFSET ?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetAIMapHint
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
	add	esp, 12					; 0000000cH

; 76   : }

	pop	ebp
	ret	0
?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z ENDP	; CvLuaMap::RegisterMembers
_TEXT	ENDS
PUBLIC	?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lAreasAux
EXTRN	_lua_pushcclosure:PROC
; Function compile flags: /Odtp
;	COMDAT ?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lAreas, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp

; 80   : 	lua_pushcclosure(L, CvLuaMap::lAreasAux, 0);

	push	0
	push	OFFSET ?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lAreasAux
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH

; 81   : 	return 1;

	mov	eax, 1

; 82   : }

	pop	ebp
	ret	0
?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lAreas
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
EXTRN	_lua_pushinteger:PROC
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	_lua_tointeger:PROC
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
EXTRN	_lua_type:PROC
; Function compile flags: /Odtp
;	COMDAT ?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219062 = -16						; size = 4
$T219058 = -12						; size = 4
_pkArea$ = -8						; size = 4
_it$ = -4						; size = 4
_L$ = 8							; size = 4
?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lAreasAux, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 86   : 	int it = 0;

	mov	DWORD PTR _it$[ebp], 0

; 87   : 	CvArea* pkArea = NULL;

	mov	DWORD PTR _pkArea$[ebp], 0

; 88   : 
; 89   : 	if(lua_isnoneornil(L, 2))

	push	2
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jg	SHORT $LN3@lAreasAux

; 90   : 	{
; 91   : 		pkArea = GC.getMap().firstArea(&it);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219058[ebp], ecx
	push	0
	lea	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219058[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pkArea$[ebp], eax

; 92   : 	}
; 93   : 	else

	jmp	SHORT $LN2@lAreasAux
$LN3@lAreasAux:

; 94   : 	{
; 95   : 		it = lua_tointeger(L, 2);

	push	2
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _it$[ebp], eax

; 96   : 		pkArea = GC.getMap().nextArea(&it);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219062[ebp], ecx
	push	0
	lea	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219062[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pkArea$[ebp], eax
$LN2@lAreasAux:

; 97   : 	}
; 98   : 
; 99   : 	if(pkArea)

	cmp	DWORD PTR _pkArea$[ebp], 0
	je	SHORT $LN1@lAreasAux

; 100  : 	{
; 101  : 		lua_pushinteger(L, it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 102  : 		CvLuaArea::Push(L, pkArea);

	mov	edx, DWORD PTR _pkArea$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 103  : 		return 2;

	mov	eax, 2
	jmp	SHORT $LN4@lAreasAux
$LN1@lAreasAux:

; 104  : 	}
; 105  : 
; 106  : 	return 0;

	xor	eax, eax
$LN4@lAreasAux:

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lAreasAux
_TEXT	ENDS
EXTRN	?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z:PROC	; CvMap::findBiggestArea
EXTRN	_lua_toboolean:PROC
; Function compile flags: /Odtp
;	COMDAT ?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219068 = -12						; size = 4
_pkArea$ = -8						; size = 4
_bWater$ = -1						; size = 1
_L$ = 8							; size = 4
?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lFindBiggestArea, COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 111  : 	const bool bWater = lua_toboolean(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	cl
	mov	BYTE PTR _bWater$[ebp], cl

; 112  : 
; 113  : 	CvArea* pkArea = GC.getMap().findBiggestArea(bWater);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219068[ebp], edx
	movzx	eax, BYTE PTR _bWater$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219068[ebp]
	call	?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z ; CvMap::findBiggestArea
	mov	DWORD PTR _pkArea$[ebp], eax

; 114  : 	if(pkArea)

	cmp	DWORD PTR _pkArea$[ebp], 0
	je	SHORT $LN1@lFindBigge

; 115  : 	{
; 116  : 		CvLuaArea::Push(L, pkArea);

	mov	ecx, DWORD PTR _pkArea$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 117  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@lFindBigge
$LN1@lFindBigge:

; 118  : 	}
; 119  : 
; 120  : 	return 0;

	xor	eax, eax
$LN2@lFindBigge:

; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lFindBiggestArea
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
EXTRN	_lua_pushboolean:PROC
EXTRN	?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z:PROC	; CvMap::findWater
EXTRN	_luaL_checkinteger:PROC
; Function compile flags: /Odtp
;	COMDAT ?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219074 = -16						; size = 4
_iRange$ = -12						; size = 4
_bResult$ = -6						; size = 1
_bFreshWater$ = -5					; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lFindWater, COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 125  : 	CvPlot* pkPlot = CvLuaPlot::GetInstance(L, 1);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 126  : 	const int iRange = luaL_checkint(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_luaL_checkinteger
	add	esp, 8
	mov	DWORD PTR _iRange$[ebp], eax

; 127  : 	const bool bFreshWater = lua_toboolean(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR _bFreshWater$[ebp], al

; 128  : 	const bool bResult = GC.getMap().findWater(pkPlot, iRange, bFreshWater);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219074[ebp], ecx
	movzx	edx, BYTE PTR _bFreshWater$[ebp]
	push	edx
	mov	eax, DWORD PTR _iRange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219074[ebp]
	call	?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z	; CvMap::findWater
	mov	BYTE PTR _bResult$[ebp], al

; 129  : 
; 130  : 	lua_pushboolean(L, bResult);

	movzx	edx, BYTE PTR _bResult$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 131  : 	return 1;

	mov	eax, 1

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lFindWater
_TEXT	ENDS
EXTRN	?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ:PROC	; CvMap::getClimate
; Function compile flags: /Odtp
;	COMDAT ?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219080 = -4						; size = 4
_L$ = 8							; size = 4
?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetClimate, COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 136  : 	lua_pushinteger(L, GC.getMap().getClimate());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219080[ebp], eax
	mov	ecx, DWORD PTR $T219080[ebp]
	call	?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ ; CvMap::getClimate
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 137  : 	return 1;

	mov	eax, 1

; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetClimate
_TEXT	ENDS
PUBLIC	??_C@_0M@GEPEHCFN@FRAC_WRAP_Y?$AA@		; `string'
PUBLIC	??_C@_0M@HNOPEDBM@FRAC_WRAP_X?$AA@		; `string'
EXTRN	_lua_setfield:PROC
EXTRN	_lua_createtable:PROC
EXTRN	?getMapFractalFlags@CvMap@@QAEHXZ:PROC		; CvMap::getMapFractalFlags
;	COMDAT ??_C@_0M@GEPEHCFN@FRAC_WRAP_Y?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0M@GEPEHCFN@FRAC_WRAP_Y?$AA@ DB 'FRAC_WRAP_Y', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNOPEDBM@FRAC_WRAP_X?$AA@
CONST	SEGMENT
??_C@_0M@HNOPEDBM@FRAC_WRAP_X?$AA@ DB 'FRAC_WRAP_X', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
CONST	ENDS
;	COMDAT ?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219086 = -8						; size = 4
_flags$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetFractalFlags, COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 142  : 	int flags = GC.getMap().getMapFractalFlags();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219086[ebp], eax
	mov	ecx, DWORD PTR $T219086[ebp]
	call	?getMapFractalFlags@CvMap@@QAEHXZ	; CvMap::getMapFractalFlags
	mov	DWORD PTR _flags$[ebp], eax

; 143  : 	lua_createtable(L, 0, 2);

	push	2
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 144  : 	if((flags & CvFractal::FRAC_WRAP_X) != 0)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	je	SHORT $LN2@lGetFracta

; 145  : 	{
; 146  : 		lua_pushboolean(L, TRUE);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 147  : 		lua_setfield(L, -2, "FRAC_WRAP_X");

	push	OFFSET ??_C@_0M@HNOPEDBM@FRAC_WRAP_X?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH
$LN2@lGetFracta:

; 148  : 	}
; 149  : 
; 150  : 	if((flags & CvFractal::FRAC_WRAP_Y) != 0)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN1@lGetFracta

; 151  : 	{
; 152  : 		lua_pushboolean(L, TRUE);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 153  : 		lua_setfield(L, -2, "FRAC_WRAP_Y");

	push	OFFSET ??_C@_0M@GEPEHCFN@FRAC_WRAP_Y?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH
$LN1@lGetFracta:

; 154  : 	}
; 155  : 
; 156  : 	return 1;

	mov	eax, 1

; 157  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetFractalFlags
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219099 = -16						; size = 4
$T219092 = -12						; size = 4
_width$ = -8						; size = 4
_height$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetGridSize, COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 161  : 	const int width  = GC.getMap().getGridWidth();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219092[ebp], eax
	mov	ecx, DWORD PTR $T219092[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR _width$[ebp], edx

; 162  : 	const int height = GC.getMap().getGridHeight();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219099[ebp], eax
	mov	ecx, DWORD PTR $T219099[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR _height$[ebp], edx

; 163  : 
; 164  : 	lua_pushinteger(L, width);

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 165  : 	lua_pushinteger(L, height);

	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 166  : 	return 2;

	mov	eax, 2

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetGridSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219112 = -8						; size = 4
$T219108 = -4						; size = 4
_L$ = 8							; size = 4
?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumPlots, COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 172  : 	lua_pushinteger(L, GC.getMap().numPlots());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219108[ebp], eax
	mov	ecx, DWORD PTR $T219108[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T219112[ebp], edx
	mov	eax, DWORD PTR $T219112[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 173  : 	return 1;

	mov	eax, 1

; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumPlots
_TEXT	ENDS
EXTRN	?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getNumResources
; Function compile flags: /Odtp
;	COMDAT ?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219118 = -12						; size = 4
_iResult$ = -8						; size = 4
_eResource$ = -4					; size = 4
_L$ = 8							; size = 4
?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumResources, COMDAT

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 178  : 	const ResourceTypes eResource = (ResourceTypes)luaL_checkinteger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checkinteger
	add	esp, 8
	mov	DWORD PTR _eResource$[ebp], eax

; 179  : 
; 180  : 	const int iResult = GC.getMap().getNumResources(eResource);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219118[ebp], ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219118[ebp]
	call	?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getNumResources
	mov	DWORD PTR _iResult$[ebp], eax

; 181  : 	lua_pushinteger(L, iResult);

	mov	eax, DWORD PTR _iResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 182  : 	return 1;

	mov	eax, 1

; 183  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumResources
_TEXT	ENDS
EXTRN	?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getNumResourcesOnLand
; Function compile flags: /Odtp
;	COMDAT ?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219124 = -12						; size = 4
_iResult$ = -8						; size = 4
_eResource$ = -4					; size = 4
_L$ = 8							; size = 4
?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lGetNumResourcesOnLand, COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 187  : 	const ResourceTypes eResource = (ResourceTypes)luaL_checkinteger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checkinteger
	add	esp, 8
	mov	DWORD PTR _eResource$[ebp], eax

; 188  : 
; 189  : 	const int iResult = GC.getMap().getNumResourcesOnLand(eResource);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219124[ebp], ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219124[ebp]
	call	?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getNumResourcesOnLand
	mov	DWORD PTR _iResult$[ebp], eax

; 190  : 	lua_pushinteger(L, iResult);

	mov	eax, DWORD PTR _iResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 191  : 	return 1;

	mov	eax, 1

; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lGetNumResourcesOnLand
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
; Function compile flags: /Odtp
;	COMDAT ?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv141 = -60						; size = 4
tv156 = -56						; size = 4
$T219187 = -52						; size = 4
$T219174 = -48						; size = 4
$T219170 = -44						; size = 4
$T219156 = -40						; size = 4
$T219152 = -33						; size = 1
$T219141 = -32						; size = 4
$T219137 = -25						; size = 1
_iMapY$219227 = -24					; size = 4
_iMapX$219226 = -20					; size = 4
$T219130 = -16						; size = 4
_pPlot$ = -12						; size = 4
_x$ = -8						; size = 4
_y$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetPlot, COMDAT

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 196  : 	const int x = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax

; 197  : 	const int y = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _y$[ebp], eax

; 198  : 
; 199  : 	CvPlot* pPlot = GC.getMap().plot(x, y);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219130[ebp], edx
	cmp	DWORD PTR _x$[ebp], -2147483647		; 80000001H
	je	SHORT $LN6@lGetPlot
	cmp	DWORD PTR _y$[ebp], -2147483647		; 80000001H
	jne	SHORT $LN7@lGetPlot
$LN6@lGetPlot:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN8@lGetPlot
$LN7@lGetPlot:
	mov	eax, DWORD PTR $T219130[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T219137[ebp], cl
	mov	edx, DWORD PTR $T219130[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T219141[ebp], eax
	movzx	ecx, BYTE PTR $T219137[ebp]
	test	ecx, ecx
	je	SHORT $LN19@lGetPlot
	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $LN18@lGetPlot
	mov	eax, DWORD PTR _x$[ebp]
	cdq
	idiv	DWORD PTR $T219141[ebp]
	add	edx, DWORD PTR $T219141[ebp]
	mov	DWORD PTR _iMapX$219226[ebp], edx
	jmp	SHORT $LN20@lGetPlot
	jmp	SHORT $LN19@lGetPlot
$LN18@lGetPlot:
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR $T219141[ebp]
	jl	SHORT $LN19@lGetPlot
	mov	eax, DWORD PTR _x$[ebp]
	cdq
	idiv	DWORD PTR $T219141[ebp]
	mov	DWORD PTR _iMapX$219226[ebp], edx
	jmp	SHORT $LN20@lGetPlot
$LN19@lGetPlot:
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _iMapX$219226[ebp], eax
$LN20@lGetPlot:
	mov	ecx, DWORD PTR $T219130[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T219152[ebp], dl
	mov	eax, DWORD PTR $T219130[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219156[ebp], ecx
	movzx	edx, BYTE PTR $T219152[ebp]
	test	edx, edx
	je	SHORT $LN29@lGetPlot
	cmp	DWORD PTR _y$[ebp], 0
	jge	SHORT $LN28@lGetPlot
	mov	eax, DWORD PTR _y$[ebp]
	cdq
	idiv	DWORD PTR $T219156[ebp]
	add	edx, DWORD PTR $T219156[ebp]
	mov	DWORD PTR _iMapY$219227[ebp], edx
	jmp	SHORT $LN30@lGetPlot
	jmp	SHORT $LN29@lGetPlot
$LN28@lGetPlot:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR $T219156[ebp]
	jl	SHORT $LN29@lGetPlot
	mov	eax, DWORD PTR _y$[ebp]
	cdq
	idiv	DWORD PTR $T219156[ebp]
	mov	DWORD PTR _iMapY$219227[ebp], edx
	jmp	SHORT $LN30@lGetPlot
$LN29@lGetPlot:
	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _iMapY$219227[ebp], ecx
$LN30@lGetPlot:
	cmp	DWORD PTR _iMapX$219226[ebp], 0
	jl	SHORT $LN34@lGetPlot
	mov	edx, DWORD PTR $T219130[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T219170[ebp], eax
	mov	ecx, DWORD PTR _iMapX$219226[ebp]
	cmp	ecx, DWORD PTR $T219170[ebp]
	jge	SHORT $LN34@lGetPlot
	cmp	DWORD PTR _iMapY$219227[ebp], 0
	jl	SHORT $LN34@lGetPlot
	mov	edx, DWORD PTR $T219130[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T219174[ebp], eax
	mov	ecx, DWORD PTR _iMapY$219227[ebp]
	cmp	ecx, DWORD PTR $T219174[ebp]
	jge	SHORT $LN34@lGetPlot
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN32@lGetPlot
$LN34@lGetPlot:
	mov	DWORD PTR tv156[ebp], 0
$LN32@lGetPlot:
	cmp	DWORD PTR tv156[ebp], 0
	je	SHORT $LN10@lGetPlot
	mov	edx, DWORD PTR $T219130[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T219187[ebp], eax
	mov	ecx, DWORD PTR _iMapY$219227[ebp]
	imul	ecx, DWORD PTR $T219187[ebp]
	add	ecx, DWORD PTR _iMapX$219226[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T219130[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv141[ebp], ecx
	jmp	SHORT $LN11@lGetPlot
$LN10@lGetPlot:
	mov	DWORD PTR tv141[ebp], 0
$LN11@lGetPlot:
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR _pPlot$[ebp], eax
$LN8@lGetPlot:

; 200  : 	if(pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN1@lGetPlot

; 201  : 	{
; 202  : 		CvLuaPlot::Push(L, pPlot);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 203  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@lGetPlot
$LN1@lGetPlot:

; 204  : 	}
; 205  : 	return 0;

	xor	eax, eax
$LN2@lGetPlot:

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetPlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv82 = -20						; size = 4
$T219244 = -16						; size = 4
$T219237 = -12						; size = 4
_pPlot$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetPlotByIndex, COMDAT

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 211  : 	const int iIndex = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iIndex$[ebp], eax

; 212  : 
; 213  : 	CvPlot* pPlot = GC.getMap().plotByIndex(iIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219237[ebp], ecx
	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN8@lGetPlotBy
	mov	edx, DWORD PTR $T219237[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T219244[ebp], eax
	mov	ecx, DWORD PTR _iIndex$[ebp]
	cmp	ecx, DWORD PTR $T219244[ebp]
	jge	SHORT $LN8@lGetPlotBy
	mov	edx, DWORD PTR _iIndex$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T219237[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN6@lGetPlotBy
$LN8@lGetPlotBy:
	mov	DWORD PTR tv82[ebp], 0
$LN6@lGetPlotBy:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx

; 214  : 	if(pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN1@lGetPlotBy

; 215  : 	{
; 216  : 		CvLuaPlot::Push(L, pPlot);

	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 217  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@lGetPlotBy
$LN1@lGetPlotBy:

; 218  : 	}
; 219  : 	return 0;

	xor	eax, eax
$LN2@lGetPlotBy:

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetPlotByIndex
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
EXTRN	_lua_gettop:PROC
; Function compile flags: /Odtp
;	COMDAT ?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_dx$ = -24						; size = 4
_x$ = -20						; size = 4
_y$ = -16						; size = 4
_dy$ = -12						; size = 4
_count$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetPlotXY, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 226  : 	int x, y, dx, dy;
; 227  : 	const int count = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 228  : 
; 229  : 	if(count == 2)

	cmp	DWORD PTR _count$[ebp], 2
	jne	SHORT $LN2@lGetPlotXY

; 230  : 	{
; 231  : 		x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 232  : 		y = 0;

	mov	DWORD PTR _y$[ebp], 0

; 233  : 		dx = lua_tointeger(L, 1);

	push	1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _dx$[ebp], eax

; 234  : 		dy = lua_tointeger(L, 2);

	push	2
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _dy$[ebp], eax

; 235  : 	}
; 236  : 	else

	jmp	SHORT $LN1@lGetPlotXY
$LN2@lGetPlotXY:

; 237  : 	{
; 238  : 		x = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax

; 239  : 		y = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _y$[ebp], eax

; 240  : 		dx = lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _dx$[ebp], eax

; 241  : 		dy = lua_tointeger(L, 4);

	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _dy$[ebp], eax
$LN1@lGetPlotXY:

; 242  : 	}
; 243  : 
; 244  : 	CvPlot* pkPlot = plotXY(x, y, dx, dy);

	mov	ecx, DWORD PTR _dy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dx$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pkPlot$[ebp], eax

; 245  : 	CvLuaPlot::Push(L, pkPlot);

	mov	edx, DWORD PTR _pkPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 246  : 	return 1;

	mov	eax, 1

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetPlotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T219495 = -56						; size = 4
$T219450 = -52						; size = 4
$T219437 = -48						; size = 4
$T219433 = -44						; size = 4
$T219419 = -40						; size = 4
$T219415 = -33						; size = 1
$T219404 = -32						; size = 4
$T219400 = -25						; size = 1
_iMapY$219494 = -24					; size = 4
_iMapX$219493 = -20					; size = 4
$T219393 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219393[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T219495[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T219393[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219400[ebp], dl
	mov	eax, DWORD PTR $T219393[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219404[ebp], ecx
	movzx	edx, BYTE PTR $T219400[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T219404[ebp]
	add	edx, DWORD PTR $T219404[ebp]
	mov	DWORD PTR _iMapX$219493[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T219404[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T219404[ebp]
	mov	DWORD PTR _iMapX$219493[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$219493[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T219393[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T219415[ebp], al
	mov	ecx, DWORD PTR $T219393[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T219419[ebp], edx
	movzx	eax, BYTE PTR $T219415[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T219419[ebp]
	add	edx, DWORD PTR $T219419[ebp]
	mov	DWORD PTR _iMapY$219494[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T219419[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T219419[ebp]
	mov	DWORD PTR _iMapY$219494[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$219494[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$219493[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T219393[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219433[ebp], ecx
	mov	edx, DWORD PTR _iMapX$219493[ebp]
	cmp	edx, DWORD PTR $T219433[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$219494[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T219393[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219437[ebp], ecx
	mov	edx, DWORD PTR _iMapY$219494[ebp]
	cmp	edx, DWORD PTR $T219437[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T219393[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219450[ebp], ecx
	mov	edx, DWORD PTR _iMapY$219494[ebp]
	imul	edx, DWORD PTR $T219450[ebp]
	add	edx, DWORD PTR _iMapX$219493[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T219393[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T219495[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T219495[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219501 = -12						; size = 4
_pArea$ = -8						; size = 4
_iID$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetArea, COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 252  : 	const int iID = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iID$[ebp], eax

; 253  : 
; 254  : 	CvArea* pArea = GC.getMap().getArea(iID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219501[ebp], ecx
	mov	edx, DWORD PTR _iID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219501[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pArea$[ebp], eax

; 255  : 	if(pArea)

	cmp	DWORD PTR _pArea$[ebp], 0
	je	SHORT $LN1@lGetArea

; 256  : 	{
; 257  : 		CvLuaArea::Push(L, pArea);

	mov	eax, DWORD PTR _pArea$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 258  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@lGetArea
$LN1@lGetArea:

; 259  : 	}
; 260  : 	return 0;

	xor	eax, eax
$LN2@lGetArea:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetArea
_TEXT	ENDS
EXTRN	?getIndexAfterLastArea@CvMap@@QAEHXZ:PROC	; CvMap::getIndexAfterLastArea
; Function compile flags: /Odtp
;	COMDAT ?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219507 = -8						; size = 4
_iResult$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lGetIndexAfterLastArea, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 265  : 	const int iResult = GC.getMap().getIndexAfterLastArea();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219507[ebp], eax
	mov	ecx, DWORD PTR $T219507[ebp]
	call	?getIndexAfterLastArea@CvMap@@QAEHXZ	; CvMap::getIndexAfterLastArea
	mov	DWORD PTR _iResult$[ebp], eax

; 266  : 	lua_pushinteger(L, iResult);

	mov	ecx, DWORD PTR _iResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 267  : 	return 1;

	mov	eax, 1

; 268  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lGetIndexAfterLastArea
_TEXT	ENDS
EXTRN	?getLandPlots@CvMap@@QAEHXZ:PROC		; CvMap::getLandPlots
; Function compile flags: /Odtp
;	COMDAT ?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219513 = -8						; size = 4
_iResult$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetLandPlots, COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 272  : 	const int iResult = GC.getMap().getLandPlots();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219513[ebp], eax
	mov	ecx, DWORD PTR $T219513[ebp]
	call	?getLandPlots@CvMap@@QAEHXZ		; CvMap::getLandPlots
	mov	DWORD PTR _iResult$[ebp], eax

; 273  : 	lua_pushinteger(L, iResult);

	mov	ecx, DWORD PTR _iResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 274  : 	return 1;

	mov	eax, 1

; 275  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetLandPlots
_TEXT	ENDS
EXTRN	?getNumAreas@CvMap@@QAEHXZ:PROC			; CvMap::getNumAreas
; Function compile flags: /Odtp
;	COMDAT ?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219519 = -8						; size = 4
_iResult$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumAreas, COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 279  : 	const int iResult = GC.getMap().getNumAreas();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219519[ebp], eax
	mov	ecx, DWORD PTR $T219519[ebp]
	call	?getNumAreas@CvMap@@QAEHXZ		; CvMap::getNumAreas
	mov	DWORD PTR _iResult$[ebp], eax

; 280  : 	lua_pushinteger(L, iResult);

	mov	ecx, DWORD PTR _iResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 281  : 	return 1;

	mov	eax, 1

; 282  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumAreas
_TEXT	ENDS
EXTRN	?getNumLandAreas@CvMap@@QAEHXZ:PROC		; CvMap::getNumLandAreas
; Function compile flags: /Odtp
;	COMDAT ?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219525 = -8						; size = 4
_iResult$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumLandAreas, COMDAT

; 285  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 286  : 	const int iResult = GC.getMap().getNumLandAreas();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219525[ebp], eax
	mov	ecx, DWORD PTR $T219525[ebp]
	call	?getNumLandAreas@CvMap@@QAEHXZ		; CvMap::getNumLandAreas
	mov	DWORD PTR _iResult$[ebp], eax

; 287  : 	lua_pushinteger(L, iResult);

	mov	ecx, DWORD PTR _iResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 288  : 	return 1;

	mov	eax, 1

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumLandAreas
_TEXT	ENDS
EXTRN	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getRandomResourceQuantity
; Function compile flags: /Odtp
;	COMDAT ?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219531 = -12						; size = 4
_iResult$ = -8						; size = 4
_eResource$ = -4					; size = 4
_L$ = 8							; size = 4
?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lGetRandomResourceQuantity, COMDAT

; 292  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 293  : 	const ResourceTypes eResource = (ResourceTypes)luaL_checkinteger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checkinteger
	add	esp, 8
	mov	DWORD PTR _eResource$[ebp], eax

; 294  : 
; 295  : 	const int iResult = GC.getMap().getRandomResourceQuantity(eResource);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219531[ebp], ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219531[ebp]
	call	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getRandomResourceQuantity
	mov	DWORD PTR _iResult$[ebp], eax

; 296  : 	lua_pushinteger(L, iResult);

	mov	eax, DWORD PTR _iResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 297  : 	return 1;

	mov	eax, 1

; 298  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lGetRandomResourceQuantity
_TEXT	ENDS
EXTRN	?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ:PROC ; CvMap::getSeaLevel
; Function compile flags: /Odtp
;	COMDAT ?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219537 = -4						; size = 4
_L$ = 8							; size = 4
?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetSeaLevel, COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 302  : 	lua_pushinteger(L, GC.getMap().getSeaLevel());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219537[ebp], eax
	mov	ecx, DWORD PTR $T219537[ebp]
	call	?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ ; CvMap::getSeaLevel
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 303  : 	return 1;

	mov	eax, 1

; 304  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetSeaLevel
_TEXT	ENDS
EXTRN	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ:PROC ; CvMap::getWorldSize
; Function compile flags: /Odtp
;	COMDAT ?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219543 = -4						; size = 4
_L$ = 8							; size = 4
?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetWorldSize, COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 308  : 	lua_pushinteger(L, GC.getMap().getWorldSize());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219543[ebp], eax
	mov	ecx, DWORD PTR $T219543[ebp]
	call	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ; CvMap::getWorldSize
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 309  : 	return 1;

	mov	eax, 1

; 310  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetWorldSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv89 = -28						; size = 4
$T219560 = -24						; size = 4
$T219556 = -20						; size = 4
$T219549 = -16						; size = 4
_bResult$ = -9						; size = 1
_x$ = -8						; size = 4
_y$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lIsPlot, COMDAT

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 314  : 	int x = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax

; 315  : 	int y = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _y$[ebp], eax

; 316  : 
; 317  : 	const bool bResult = GC.getMap().isPlot(x, y);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219549[ebp], edx
	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN7@lIsPlot
	mov	eax, DWORD PTR $T219549[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219556[ebp], ecx
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR $T219556[ebp]
	jge	SHORT $LN7@lIsPlot
	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN7@lIsPlot
	mov	eax, DWORD PTR $T219549[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219560[ebp], ecx
	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR $T219560[ebp]
	jge	SHORT $LN7@lIsPlot
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN5@lIsPlot
$LN7@lIsPlot:
	mov	DWORD PTR tv89[ebp], 0
$LN5@lIsPlot:
	cmp	DWORD PTR tv89[ebp], 0
	setne	al
	mov	BYTE PTR _bResult$[ebp], al

; 318  : 
; 319  : 	lua_pushboolean(L, bResult);

	movzx	ecx, BYTE PTR _bResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 320  : 	return 1;

	mov	eax, 1

; 321  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lIsPlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219578 = -5						; size = 1
$T219574 = -4						; size = 4
_L$ = 8							; size = 4
?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lIsWrapX, COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 325  : 	lua_pushboolean(L, GC.getMap().isWrapX());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219574[ebp], eax
	mov	ecx, DWORD PTR $T219574[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219578[ebp], dl
	movzx	eax, BYTE PTR $T219578[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 326  : 	return 1;

	mov	eax, 1

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lIsWrapX
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219588 = -5						; size = 1
$T219584 = -4						; size = 4
_L$ = 8							; size = 4
?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lIsWrapY, COMDAT

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 331  : 	lua_pushboolean(L, GC.getMap().isWrapY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219584[ebp], eax
	mov	ecx, DWORD PTR $T219584[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T219588[ebp], dl
	movzx	eax, BYTE PTR $T219588[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 332  : 	return 1;

	mov	eax, 1

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lIsWrapY
_TEXT	ENDS
EXTRN	?maxPlotDistance@CvMap@@QAEHXZ:PROC		; CvMap::maxPlotDistance
; Function compile flags: /Odtp
;	COMDAT ?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219594 = -8						; size = 4
_iResult$ = -4						; size = 4
_L$ = 8							; size = 4
?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lMaxPlotDistance, COMDAT

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 337  : 	int iResult = GC.getMap().maxPlotDistance();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219594[ebp], eax
	mov	ecx, DWORD PTR $T219594[ebp]
	call	?maxPlotDistance@CvMap@@QAEHXZ		; CvMap::maxPlotDistance
	mov	DWORD PTR _iResult$[ebp], eax

; 338  : 	lua_pushinteger(L, iResult);

	mov	ecx, DWORD PTR _iResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 339  : 	return 1;

	mov	eax, 1

; 340  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lMaxPlotDistance
_TEXT	ENDS
EXTRN	?getMapRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getMapRandNum
EXTRN	_luaL_checklstring:PROC
; Function compile flags: /Odtp
;	COMDAT ?lRand@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219600 = -16						; size = 4
_max_num$ = -12						; size = 4
_rand_val$ = -8						; size = 4
_strLog$ = -4						; size = 4
_L$ = 8							; size = 4
?lRand@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lRand, COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 344  : 	const int max_num = luaL_checkinteger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checkinteger
	add	esp, 8
	mov	DWORD PTR _max_num$[ebp], eax

; 345  : 	const char* strLog = luaL_checkstring(L, 2);

	push	0
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_luaL_checklstring
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _strLog$[ebp], eax

; 346  : 	const int rand_val = GC.getGame().getMapRandNum(max_num, strLog);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219600[ebp], edx
	mov	eax, DWORD PTR _strLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR _max_num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219600[ebp]
	call	?getMapRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getMapRandNum
	mov	DWORD PTR _rand_val$[ebp], eax

; 347  : 
; 348  : 	lua_pushinteger(L, rand_val);

	mov	edx, DWORD PTR _rand_val$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 349  : 	return 1;

	mov	eax, 1

; 350  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lRand@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lRand
_TEXT	ENDS
EXTRN	?calculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::calculateAreas
; Function compile flags: /Odtp
;	COMDAT ?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219606 = -4						; size = 4
_L$ = 8							; size = 4
?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lCalculateAreas, COMDAT

; 357  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 358  : 	GC.getMap().calculateAreas();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219606[ebp], eax
	mov	ecx, DWORD PTR $T219606[ebp]
	call	?calculateAreas@CvMap@@QAEXXZ		; CvMap::calculateAreas

; 359  : 	return 0;

	xor	eax, eax

; 360  : }//------------------------------------------------------------------------------

	mov	esp, ebp
	pop	ebp
	ret	0
?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lCalculateAreas
_TEXT	ENDS
EXTRN	?recalculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::recalculateAreas
; Function compile flags: /Odtp
;	COMDAT ?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T219612 = -4						; size = 4
_L$ = 8							; size = 4
?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lRecalculateAreas, COMDAT

; 366  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 367  : 	GC.getMap().recalculateAreas();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219612[ebp], eax
	mov	ecx, DWORD PTR $T219612[ebp]
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 368  : 	return 0;

	xor	eax, eax

; 369  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lRecalculateAreas
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Odtp
;	COMDAT ?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iY1$ = -20						; size = 4
_iRetVal$ = -16						; size = 4
_iX1$ = -12						; size = 4
_iX2$ = -8						; size = 4
_iY2$ = -4						; size = 4
_L$ = 8							; size = 4
?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lPlotDistance, COMDAT

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 373  : 	int iX1 = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iX1$[ebp], eax

; 374  : 	int iY1 = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iY1$[ebp], eax

; 375  : 	int iX2 = lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iX2$[ebp], eax

; 376  : 	int iY2 = lua_tointeger(L, 4);

	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iY2$[ebp], eax

; 377  : 
; 378  : 	int iRetVal = plotDistance(iX1, iY1, iX2, iY2);

	mov	ecx, DWORD PTR _iY2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iY1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX1$[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRetVal$[ebp], eax

; 379  : 
; 380  : 	lua_pushinteger(L, iRetVal);

	mov	edx, DWORD PTR _iRetVal$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 381  : 	return 1;

	mov	eax, 1

; 382  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lPlotDistance
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T219782 = -80						; size = 4
$T219756 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T219756[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T219756[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T219756[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T219782[ebp], edx
	mov	eax, DWORD PTR $T219782[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T219806 = -16						; size = 4
$T219798 = -12						; size = 4
$T219794 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219794[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219798[ebp], ecx
	movzx	edx, BYTE PTR $T219794[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T219798[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T219798[ebp]
	mov	DWORD PTR $T219806[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T219798[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T219798[ebp]
	mov	DWORD PTR $T219806[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T219806[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T219806[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T219827 = -16						; size = 4
$T219819 = -12						; size = 4
$T219815 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T219815[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219819[ebp], ecx
	movzx	edx, BYTE PTR $T219815[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T219819[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T219819[ebp]
	mov	DWORD PTR $T219827[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T219819[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T219819[ebp]
	mov	DWORD PTR $T219827[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T219827[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T219827[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iRange$ = -24						; size = 4
_iX$ = -20						; size = 4
_iY$ = -16						; size = 4
_iDeltaHexX$ = -12					; size = 4
_iDeltaHexY$ = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lPlotXYWithRangeCheck, COMDAT

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 386  : 	int iX = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iX$[ebp], eax

; 387  : 	int iY = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iY$[ebp], eax

; 388  : 	int iDeltaHexX = lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iDeltaHexX$[ebp], eax

; 389  : 	int iDeltaHexY = lua_tointeger(L, 4);

	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iDeltaHexY$[ebp], eax

; 390  : 	int iRange = lua_tointeger(L, 5);

	push	5
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iRange$[ebp], eax

; 391  : 	CvPlot* pkPlot = plotXYWithRangeCheck(iX, iY, iDeltaHexX, iDeltaHexY, iRange);

	mov	edx, DWORD PTR _iRange$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDeltaHexY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDeltaHexX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pkPlot$[ebp], eax

; 392  : 	CvLuaPlot::Push(L, pkPlot);

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 393  : 	return 1;

	mov	eax, 1

; 394  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lPlotXYWithRangeCheck
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$218146 = -20					; size = 4
_iAbsDX$218145 = -16					; size = 4
_iAbsDY$218143 = -12					; size = 4
_iAbsDX$218142 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$218142[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$218143[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$218142[ebp]
	add	edx, DWORD PTR _iAbsDY$218143[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$218145[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$218146[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$218145[ebp]
	cmp	eax, DWORD PTR _iAbsDY$218146[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$218145[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$218146[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iX$ = -16						; size = 4
_eDirection$ = -12					; size = 4
_iY$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lPlotDirection, COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H

; 398  : 	int iX = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iX$[ebp], eax

; 399  : 	int iY = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iY$[ebp], eax

; 400  : 	DirectionTypes eDirection = (DirectionTypes)lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eDirection$[ebp], eax

; 401  : 
; 402  : 	CvPlot* pkPlot = plotDirection(iX, iY, eDirection);

	mov	eax, DWORD PTR _eDirection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 403  : 
; 404  : 	CvLuaPlot::Push(L, pkPlot);

	mov	eax, DWORD PTR _pkPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 405  : 	return 1;

	mov	eax, 1

; 406  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lPlotDirection
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T220523 = -80						; size = 4
$T220478 = -76						; size = 4
$T220465 = -72						; size = 4
$T220461 = -68						; size = 4
$T220447 = -64						; size = 4
$T220443 = -57						; size = 1
$T220432 = -56						; size = 4
$T220428 = -49						; size = 1
_iMapY$220522 = -48					; size = 4
_iMapX$220521 = -44					; size = 4
$T220421 = -40						; size = 4
$T220397 = -36						; size = 4
$T220360 = -32						; size = 4
$T220348 = -28						; size = 4
$T220344 = -21						; size = 1
$T220333 = -20						; size = 4
$T220329 = -13						; size = 1
_iMapY$220396 = -12					; size = 4
_iMapX$220395 = -8					; size = 4
$T220322 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220322[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T220397[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T220322[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T220329[ebp], dl
	mov	eax, DWORD PTR $T220322[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220333[ebp], ecx
	movzx	edx, BYTE PTR $T220329[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T220333[ebp]
	add	edx, DWORD PTR $T220333[ebp]
	mov	DWORD PTR _iMapX$220395[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T220333[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T220333[ebp]
	mov	DWORD PTR _iMapX$220395[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$220395[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T220322[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T220344[ebp], al
	mov	ecx, DWORD PTR $T220322[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T220348[ebp], edx
	movzx	eax, BYTE PTR $T220344[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T220348[ebp]
	add	edx, DWORD PTR $T220348[ebp]
	mov	DWORD PTR _iMapY$220396[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T220348[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T220348[ebp]
	mov	DWORD PTR _iMapY$220396[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$220396[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$220396[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$220395[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220322[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T220322[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T220360[ebp], eax
	mov	ecx, DWORD PTR _iMapY$220396[ebp]
	imul	ecx, DWORD PTR $T220360[ebp]
	add	ecx, DWORD PTR _iMapX$220395[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T220322[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T220397[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T220397[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220421[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T220523[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T220421[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T220428[ebp], dl
	mov	eax, DWORD PTR $T220421[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220432[ebp], ecx
	movzx	edx, BYTE PTR $T220428[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T220432[ebp]
	add	edx, DWORD PTR $T220432[ebp]
	mov	DWORD PTR _iMapX$220521[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T220432[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T220432[ebp]
	mov	DWORD PTR _iMapX$220521[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$220521[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T220421[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T220443[ebp], al
	mov	ecx, DWORD PTR $T220421[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T220447[ebp], edx
	movzx	eax, BYTE PTR $T220443[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T220447[ebp]
	add	edx, DWORD PTR $T220447[ebp]
	mov	DWORD PTR _iMapY$220522[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T220447[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T220447[ebp]
	mov	DWORD PTR _iMapY$220522[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$220522[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$220521[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T220421[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220461[ebp], ecx
	mov	edx, DWORD PTR _iMapX$220521[ebp]
	cmp	edx, DWORD PTR $T220461[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$220522[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T220421[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T220465[ebp], ecx
	mov	edx, DWORD PTR _iMapY$220522[ebp]
	cmp	edx, DWORD PTR $T220465[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T220421[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220478[ebp], ecx
	mov	edx, DWORD PTR _iMapY$220522[ebp]
	imul	edx, DWORD PTR $T220478[ebp]
	add	edx, DWORD PTR _iMapX$220521[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T220421[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T220523[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T220523[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
EXTRN	?DefaultContinentStamper@CvMap@@QAEXXZ:PROC	; CvMap::DefaultContinentStamper
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T220529 = -4						; size = 4
_L$ = 8							; size = 4
?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lDefaultContinentStamper, COMDAT

; 413  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 414  : 	GC.getMap().DefaultContinentStamper();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220529[ebp], eax
	mov	ecx, DWORD PTR $T220529[ebp]
	call	?DefaultContinentStamper@CvMap@@QAEXXZ	; CvMap::DefaultContinentStamper

; 415  : 	return 0;

	xor	eax, eax

; 416  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lDefaultContinentStamper
_TEXT	ENDS
EXTRN	?DoPlaceNaturalWonders@CvMap@@QAEXXZ:PROC	; CvMap::DoPlaceNaturalWonders
; Function compile flags: /Odtp
;	COMDAT ?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T220535 = -4						; size = 4
_L$ = 8							; size = 4
?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lDoPlaceNaturalWonders, COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 424  : 	GC.getMap().DoPlaceNaturalWonders();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220535[ebp], eax
	mov	ecx, DWORD PTR $T220535[ebp]
	call	?DoPlaceNaturalWonders@CvMap@@QAEXXZ	; CvMap::DoPlaceNaturalWonders

; 425  : 	return 0;

	xor	eax, eax

; 426  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lDoPlaceNaturalWonders
_TEXT	ENDS
EXTRN	?GetMapOption@CvPreGame@@YA_NPBDAAH@Z:PROC	; CvPreGame::GetMapOption
; Function compile flags: /Odtp
;	COMDAT ?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_szOptionName$ = -8					; size = 4
_i$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetCustomOption, COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 430  : 	const char* szOptionName = luaL_checkstring(L, 1);

	push	0
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checklstring
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _szOptionName$[ebp], eax

; 431  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 432  : 	if(CvPreGame::GetMapOption(szOptionName, i))

	lea	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szOptionName$[ebp]
	push	edx
	call	?GetMapOption@CvPreGame@@YA_NPBDAAH@Z	; CvPreGame::GetMapOption
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@lGetCustom

; 433  : 	{
; 434  : 		lua_pushinteger(L, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 435  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@lGetCustom
$LN1@lGetCustom:

; 436  : 	}
; 437  : 
; 438  : 	return 0;

	xor	eax, eax
$LN2@lGetCustom:

; 439  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetCustomOption
_TEXT	ENDS
EXTRN	?updateDeferredFog@CvMap@@QAEXXZ:PROC		; CvMap::updateDeferredFog
; Function compile flags: /Odtp
;	COMDAT ?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T220543 = -4						; size = 4
_L$ = 8							; size = 4
?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lUpdateDeferredFog, COMDAT

; 446  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 447  : 	GC.getMap().updateDeferredFog();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220543[ebp], eax
	mov	ecx, DWORD PTR $T220543[ebp]
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog

; 448  : 	return 0;

	xor	eax, eax

; 449  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lUpdateDeferredFog
_TEXT	ENDS
EXTRN	?ChangeAIMapHint@CvMap@@QAEXH@Z:PROC		; CvMap::ChangeAIMapHint
; Function compile flags: /Odtp
;	COMDAT ?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T220549 = -8						; size = 4
_iHint$ = -4						; size = 4
_L$ = 8							; size = 4
?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lChangeAIMapHint, COMDAT

; 452  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 453  : 	int iHint = lua_tointeger(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iHint$[ebp], eax

; 454  : 	GC.getMap().ChangeAIMapHint(iHint);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220549[ebp], ecx
	mov	edx, DWORD PTR _iHint$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220549[ebp]
	call	?ChangeAIMapHint@CvMap@@QAEXH@Z		; CvMap::ChangeAIMapHint

; 455  : 	return 0;

	xor	eax, eax

; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lChangeAIMapHint
_TEXT	ENDS
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
; Function compile flags: /Odtp
;	COMDAT ?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T220555 = -4						; size = 4
_L$ = 8							; size = 4
?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetAIMapHint, COMDAT

; 459  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 460  : 	lua_pushinteger(L, GC.getMap().GetAIMapHint());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220555[ebp], eax
	mov	ecx, DWORD PTR $T220555[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 461  : 	return 1;

	mov	eax, 1

; 462  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetAIMapHint
_TEXT	ENDS
PUBLIC	??_C@_07NHABFFHN@__index?$AA@			; `string'
PUBLIC	??_C@_0L@GCADIOHF@__instance?$AA@		; `string'
PUBLIC	??_C@_01MHEDDDHA@v?$AA@				; `string'
PUBLIC	??_C@_06BPGFKLEK@__mode?$AA@			; `string'
PUBLIC	??_C@_0M@CEBPKMAI@__instances?$AA@		; `string'
EXTRN	_lua_pushnil:PROC
EXTRN	_lua_remove:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_lua_rawget:PROC
EXTRN	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z:PROC ; CvLuaArea::PushMethods
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_setmetatable:PROC
EXTRN	_lua_rawset:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_getfield:PROC
EXTRN	?GetTypeName@CvLuaArea@@SAPBDXZ:PROC		; CvLuaArea::GetTypeName
;	COMDAT ??_C@_07NHABFFHN@__index?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
CONST	SEGMENT
??_C@_07NHABFFHN@__index?$AA@ DB '__index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GCADIOHF@__instance?$AA@
CONST	SEGMENT
??_C@_0L@GCADIOHF@__instance?$AA@ DB '__instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MHEDDDHA@v?$AA@
CONST	SEGMENT
??_C@_01MHEDDDHA@v?$AA@ DB 'v', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPGFKLEK@__mode?$AA@
CONST	SEGMENT
??_C@_06BPGFKLEK@__mode?$AA@ DB '__mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEBPKMAI@__instances?$AA@
CONST	SEGMENT
??_C@_0M@CEBPKMAI@__instances?$AA@ DB '__instances', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z
_TEXT	SEGMENT
_instances_index$218785 = -8				; size = 4
_type_index$218784 = -4					; size = 4
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z PROC ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	cmp	DWORD PTR _pkType$[ebp], 0
	je	$LN4@Push

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN3@Push

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 59   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 63   : 			lua_newtable(L);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET ??_C@_06BPGFKLEK@__mode?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET ??_C@_01MHEDDDHA@v?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z ; CvLuaArea::PushMethods
	add	esp, 8
$LN3@Push:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _type_index$218784[ebp], eax

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawget
	add	esp, 8

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _instances_index$218785[ebp], eax

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawget
	add	esp, 8

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN2@Push

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 97   : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET ??_C@_07NHABFFHN@__index?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 102  : 			lua_pushvalue(L, type_index);

	mov	ecx, DWORD PTR _type_index$218784[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	mov	edx, DWORD PTR _instances_index$218785[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN2@Push:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	mov	ecx, DWORD PTR _instances_index$218785[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_remove
	add	esp, 8

; 114  : 		lua_remove(L, type_index);

	mov	eax, DWORD PTR _type_index$218784[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_remove
	add	esp, 8

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN5@Push
$LN4@Push:

; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN5@Push:

; 122  : 	}
; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ENDP ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluastaticinstance.h
_TEXT	ENDS
;	COMDAT ?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
_funcName$ = 16						; size = 4
?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z PROC ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   : 	lua_pushcclosure(L, func, 0);

	push	0
	mov	eax, DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH

; 60   : 	lua_setfield(L, -2, funcName);

	mov	edx, DWORD PTR _funcName$[ebp]
	push	edx
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 61   : }

	pop	ebp
	ret	0
?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ENDP ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
_TEXT	ENDS
EXTRN	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z:PROC ; CvLuaPlot::PushMethods
EXTRN	?GetTypeName@CvLuaPlot@@SAPBDXZ:PROC		; CvLuaPlot::GetTypeName
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_instances_index$218810 = -8				; size = 4
_type_index$218809 = -4					; size = 4
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	cmp	DWORD PTR _pkType$[ebp], 0
	je	$LN4@Push@2

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaPlot@@SAPBDXZ		; CvLuaPlot::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN3@Push@2

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 59   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 63   : 			lua_newtable(L);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET ??_C@_06BPGFKLEK@__mode?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET ??_C@_01MHEDDDHA@v?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaPlot@@SAPBDXZ		; CvLuaPlot::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z ; CvLuaPlot::PushMethods
	add	esp, 8
$LN3@Push@2:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _type_index$218809[ebp], eax

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawget
	add	esp, 8

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _instances_index$218810[ebp], eax

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawget
	add	esp, 8

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN2@Push@2

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 97   : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET ??_C@_07NHABFFHN@__index?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 102  : 			lua_pushvalue(L, type_index);

	mov	ecx, DWORD PTR _type_index$218809[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	mov	edx, DWORD PTR _instances_index$218810[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN2@Push@2:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	mov	ecx, DWORD PTR _instances_index$218810[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_remove
	add	esp, 8

; 114  : 		lua_remove(L, type_index);

	mov	eax, DWORD PTR _type_index$218809[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_remove
	add	esp, 8

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN5@Push@2
$LN4@Push@2:

; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN5@Push@2:

; 122  : 	}
; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
_TEXT	ENDS
PUBLIC	??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@ ; `string'
EXTRN	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z:PROC ; CvLuaPlot::HandleMissingInstance
EXTRN	_luaL_error:PROC
EXTRN	_lua_touserdata:PROC
;	COMDAT ??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@
CONST	SEGMENT
??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@ DB 'Not a val'
	DB	'id instance.  Either the instance is NULL or you used ''.'' i'
	DB	'nstead of '':''.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_stack_size$ = -12					; size = 4
_pkInstance$ = -8					; size = 4
_bFail$ = -1						; size = 1
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 128  : 	const int stack_size = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _stack_size$[ebp], eax

; 129  : 	bool bFail = true;

	mov	BYTE PTR _bFail$[ebp], 1

; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;

	mov	DWORD PTR _pkInstance$[ebp], 0

; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN5@GetInstanc

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 2
	jne	SHORT $LN5@GetInstanc

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$[ebp], eax

; 138  : 			if(pkInstance)

	cmp	DWORD PTR _pkInstance$[ebp], 0
	je	SHORT $LN5@GetInstanc

; 139  : 			{
; 140  : 				bFail = false;

	mov	BYTE PTR _bFail$[ebp], 0
$LN5@GetInstanc:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	mov	ecx, DWORD PTR _stack_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	movzx	eax, BYTE PTR _bFail$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetInstanc
	movzx	ecx, BYTE PTR _bErrorOnFail$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetInstanc

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[ebp], 1
	jne	SHORT $LN1@GetInstanc

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET ??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc:

; 151  : 		Derived::HandleMissingInstance(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ; CvLuaPlot::HandleMissingInstance
	add	esp, 4
$LN2@GetInstanc:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, DWORD PTR _pkInstance$[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T220575 = -8						; size = 4
$T220571 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220571[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T220571[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T220575[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T220575[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
END
