; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPopupReturn.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0PopupReturn@@QAE@ABV0@@Z			; PopupReturn::PopupReturn
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__ehfuncinfo$??0PopupReturn@@QAE@ABV0@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0PopupReturn@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0PopupReturn@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpopupreturn.cpp
xdata$x	ENDS
;	COMDAT ??0PopupReturn@@QAE@ABV0@@Z
_TEXT	SEGMENT
tv551 = -252						; size = 4
tv530 = -248						; size = 4
tv496 = -244						; size = 4
tv452 = -240						; size = 4
_this$ = -236						; size = 4
$T218443 = -232						; size = 4
$T218349 = -180						; size = 4
$T218341 = -176						; size = 4
$T218322 = -172						; size = 4
$T218312 = -168						; size = 4
$T218304 = -164						; size = 4
$T218285 = -160						; size = 4
$T218275 = -156						; size = 4
$T218267 = -152						; size = 4
$T218259 = -148						; size = 4
$T218247 = -144						; size = 4
$T218239 = -140						; size = 4
$T218220 = -136						; size = 4
$T218210 = -132						; size = 4
$T218202 = -128						; size = 4
$T218197 = -124						; size = 4
$T218188 = -120						; size = 4
$T218175 = -116						; size = 4
$T218171 = -112						; size = 4
$T218165 = -108						; size = 4
$T218160 = -104						; size = 4
$T218152 = -100						; size = 4
$T218144 = -96						; size = 4
$T218132 = -92						; size = 4
$T218124 = -88						; size = 4
$T218116 = -84						; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_popupReturn$ = 8					; size = 4
??0PopupReturn@@QAE@ABV0@@Z PROC			; PopupReturn::PopupReturn, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PopupReturn@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 20   : 	int iI;
; 21   : 
; 22   : 	for(iI = 0; iI < popupReturn.getRadioButtonSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN83@PopupRetur
$LN31@PopupRetur:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN83@PopupRetur:
	mov	ecx, DWORD PTR _popupReturn$[ebp]
	mov	edx, DWORD PTR _popupReturn$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN30@PopupRetur

; 23   : 	{
; 24   : 		CvPopup_SetAtGrow(m_aiSelectedRadioButton, iI, popupReturn.getSelectedRadioButton(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN93@PopupRetur
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN93@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T218116[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR $T218116[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 25   : 	}

	jmp	SHORT $LN31@PopupRetur
$LN30@PopupRetur:

; 26   : 
; 27   : 	for(iI = 0; iI < popupReturn.getCheckboxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN28@PopupRetur
$LN27@PopupRetur:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN28@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T218124[ebp], edx
	mov	eax, DWORD PTR $T218124[ebp]
	mov	ecx, DWORD PTR $T218124[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jge	SHORT $LN26@PopupRetur

; 28   : 	{
; 29   : 		CvPopup_SetAtGrow(m_aiBitField, iI, popupReturn.getCheckboxBitfield(iI));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T218132[ebp], eax
	mov	ecx, DWORD PTR $T218132[ebp]
	mov	edx, DWORD PTR $T218132[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN107@PopupRetur
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN107@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T218144[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR $T218144[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 30   : 	}

	jmp	SHORT $LN27@PopupRetur
$LN26@PopupRetur:

; 31   : 
; 32   : 	for(iI = 0; iI < popupReturn.getEditboxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN24@PopupRetur
$LN23@PopupRetur:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN24@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T218152[ebp], edx
	mov	eax, DWORD PTR $T218152[ebp]
	mov	ecx, DWORD PTR $T218152[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN22@PopupRetur

; 33   : 	{
; 34   : 		CvPopup_SetAtGrow(m_aszEditBoxString, iI, popupReturn.getEditBoxString(iI));

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T218160[ebp], edx
	mov	eax, DWORD PTR $T218160[ebp]
	mov	ecx, DWORD PTR $T218160[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN21@PopupRetur
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T218165[ebp], esp
	call	??0CvString@@QAE@XZ			; CvString::CvString
	mov	DWORD PTR tv452[ebp], eax
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
$LN21@PopupRetur:
	mov	eax, DWORD PTR _popupReturn$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T218171[ebp], eax
	mov	ecx, DWORD PTR $T218171[ebp]
	mov	edx, DWORD PTR $T218171[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _iI$[ebp], eax
	jae	SHORT $LN120@PopupRetur
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _popupReturn$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR $T218175[ebp], edx
	mov	ecx, DWORD PTR $T218175[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T218188[ebp], eax
	jmp	SHORT $LN129@PopupRetur
$LN120@PopupRetur:
	mov	DWORD PTR $T218188[ebp], 0
$LN129@PopupRetur:
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR $T218197[ebp], ecx
	cmp	DWORD PTR $T218188[ebp], 0
	je	SHORT $LN132@PopupRetur
	mov	eax, DWORD PTR $T218188[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218197[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN133@PopupRetur
$LN132@PopupRetur:
	mov	ecx, DWORD PTR $T218197[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN133@PopupRetur:

; 35   : 	}

	jmp	$LN23@PopupRetur
$LN22@PopupRetur:

; 36   : 
; 37   : 	for(iI = 0; iI < popupReturn.getSpinnerWidsize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN20@PopupRetur
$LN19@PopupRetur:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN20@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T218202[ebp], edx
	mov	eax, DWORD PTR $T218202[ebp]
	mov	ecx, DWORD PTR $T218202[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jge	$LN18@PopupRetur

; 38   : 	{
; 39   : 		CvPopup_SetAtGrow(m_aiSpinnerWidgetValues, iI, popupReturn.getSpinnerWidgetValue(iI));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T218210[ebp], eax
	mov	ecx, DWORD PTR $T218210[ebp]
	mov	edx, DWORD PTR $T218210[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN17@PopupRetur
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN17@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T218220[ebp], edx
	mov	eax, DWORD PTR $T218220[ebp]
	mov	ecx, DWORD PTR $T218220[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN145@PopupRetur
	mov	eax, DWORD PTR _popupReturn$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv496[ebp], eax
	jmp	SHORT $LN151@PopupRetur
$LN145@PopupRetur:
	mov	DWORD PTR tv496[ebp], -1
$LN151@PopupRetur:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR tv496[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 40   : 	}

	jmp	$LN19@PopupRetur
$LN18@PopupRetur:

; 41   : 
; 42   : 	for(iI = 0; iI < popupReturn.getPulldownSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN16@PopupRetur
$LN15@PopupRetur:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN16@PopupRetur:
	mov	eax, DWORD PTR _popupReturn$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T218239[ebp], eax
	mov	ecx, DWORD PTR $T218239[ebp]
	mov	edx, DWORD PTR $T218239[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN14@PopupRetur

; 43   : 	{
; 44   : 		CvPopup_SetAtGrow(m_aiPulldownID, iI, popupReturn.getSelectedPullDownValue(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR $T218247[ebp], ecx
	mov	edx, DWORD PTR $T218247[ebp]
	mov	eax, DWORD PTR $T218247[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _iI$[ebp]
	jg	SHORT $LN163@PopupRetur
	push	0
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN163@PopupRetur:
	mov	eax, DWORD PTR _popupReturn$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T218259[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR $T218259[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 45   : 	}

	jmp	$LN15@PopupRetur
$LN14@PopupRetur:

; 46   : 
; 47   : 	for(iI = 0; iI < popupReturn.getListBoxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@PopupRetur
$LN11@PopupRetur:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN12@PopupRetur:
	mov	eax, DWORD PTR _popupReturn$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR $T218267[ebp], eax
	mov	ecx, DWORD PTR $T218267[ebp]
	mov	edx, DWORD PTR $T218267[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN10@PopupRetur

; 48   : 	{
; 49   : 		CvPopup_SetAtGrow(m_aiListBoxID, iI, popupReturn.getSelectedListBoxValue(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR $T218275[ebp], ecx
	mov	edx, DWORD PTR $T218275[ebp]
	mov	eax, DWORD PTR $T218275[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _iI$[ebp]
	jg	SHORT $LN9@PopupRetur
	push	0
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN9@PopupRetur:
	mov	eax, DWORD PTR _popupReturn$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR $T218285[ebp], eax
	mov	ecx, DWORD PTR $T218285[ebp]
	mov	edx, DWORD PTR $T218285[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jae	SHORT $LN177@PopupRetur
	mov	ecx, DWORD PTR _popupReturn$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv530[ebp], ecx
	jmp	SHORT $LN183@PopupRetur
$LN177@PopupRetur:
	mov	DWORD PTR tv530[ebp], -1
$LN183@PopupRetur:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR tv530[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 50   : 	}

	jmp	$LN11@PopupRetur
$LN10@PopupRetur:

; 51   : 
; 52   : 	for(iI = 0; iI < popupReturn.getSpinBoxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN8@PopupRetur
$LN7@PopupRetur:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN8@PopupRetur:
	mov	ecx, DWORD PTR _popupReturn$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T218304[ebp], ecx
	mov	edx, DWORD PTR $T218304[ebp]
	mov	eax, DWORD PTR $T218304[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$[ebp], ecx
	jge	$LN6@PopupRetur

; 53   : 	{
; 54   : 		CvPopup_SetAtGrow(m_aiSpinBoxID, iI, popupReturn.getSpinnerWidgetValue(iI));

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T218312[ebp], edx
	mov	eax, DWORD PTR $T218312[ebp]
	mov	ecx, DWORD PTR $T218312[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR _iI$[ebp]
	jg	SHORT $LN5@PopupRetur
	push	0
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN5@PopupRetur:
	mov	ecx, DWORD PTR _popupReturn$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T218322[ebp], ecx
	mov	edx, DWORD PTR $T218322[ebp]
	mov	eax, DWORD PTR $T218322[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$[ebp], ecx
	jae	SHORT $LN195@PopupRetur
	mov	edx, DWORD PTR _popupReturn$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv551[ebp], edx
	jmp	SHORT $LN201@PopupRetur
$LN195@PopupRetur:
	mov	DWORD PTR tv551[ebp], -1
$LN201@PopupRetur:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR tv551[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 55   : 	}

	jmp	$LN7@PopupRetur
$LN6@PopupRetur:

; 56   : 
; 57   : 	for(iI = 0; iI < popupReturn.GetButtonSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@PopupRetur
$LN3@PopupRetur:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN4@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR $T218341[ebp], edx
	mov	eax, DWORD PTR $T218341[ebp]
	mov	ecx, DWORD PTR $T218341[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jge	SHORT $LN33@PopupRetur

; 58   : 	{
; 59   : 		CvPopup_SetAtGrow(m_aiButtonID, iI, popupReturn.GetButtonClicked(iI));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR $T218349[ebp], eax
	mov	ecx, DWORD PTR $T218349[ebp]
	mov	edx, DWORD PTR $T218349[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN248@PopupRetur
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN248@PopupRetur:
	mov	edx, DWORD PTR _popupReturn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T218443[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR $T218443[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	jmp	$LN3@PopupRetur
$LN33@PopupRetur:

; 60   : 	}
; 61   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??0PopupReturn@@QAE@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PopupReturn@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PopupReturn@@QAE@ABV0@@Z ENDP			; PopupReturn::PopupReturn
PUBLIC	??4PopupReturn@@QAEAAV0@ABV0@@Z			; PopupReturn::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PopupReturn@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
tv394 = -204						; size = 4
tv373 = -200						; size = 4
tv339 = -196						; size = 4
tv295 = -192						; size = 4
_this$ = -188						; size = 4
$T218879 = -184						; size = 4
$T218715 = -104						; size = 4
$T218707 = -100						; size = 4
$T218688 = -96						; size = 4
$T218678 = -92						; size = 4
$T218670 = -88						; size = 4
$T218651 = -84						; size = 4
$T218641 = -80						; size = 4
$T218633 = -76						; size = 4
$T218625 = -72						; size = 4
$T218613 = -68						; size = 4
$T218605 = -64						; size = 4
$T218586 = -60						; size = 4
$T218576 = -56						; size = 4
$T218568 = -52						; size = 4
$T218563 = -48						; size = 4
$T218554 = -44						; size = 4
$T218541 = -40						; size = 4
$T218537 = -36						; size = 4
$T218531 = -32						; size = 4
$T218526 = -28						; size = 4
$T218518 = -24						; size = 4
$T218510 = -20						; size = 4
$T218498 = -16						; size = 4
$T218490 = -12						; size = 4
$T218482 = -8						; size = 4
_iI$ = -4						; size = 4
_source$ = 8						; size = 4
??4PopupReturn@@QAEAAV0@ABV0@@Z PROC			; PopupReturn::operator=, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	int iI;
; 67   : 
; 68   : 	for(iI = 0; iI < source.getRadioButtonSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN35@operator
$LN31@operator:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN35@operator:
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN30@operator

; 69   : 	{
; 70   : 		CvPopup_SetAtGrow(m_aiSelectedRadioButton, iI, source.getSelectedRadioButton(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN45@operator
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN45@operator:
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T218482[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR $T218482[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 71   : 	}

	jmp	SHORT $LN31@operator
$LN30@operator:

; 72   : 
; 73   : 	for(iI = 0; iI < source.getCheckboxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN28@operator
$LN27@operator:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN28@operator:
	mov	edx, DWORD PTR _source$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T218490[ebp], edx
	mov	eax, DWORD PTR $T218490[ebp]
	mov	ecx, DWORD PTR $T218490[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jge	SHORT $LN26@operator

; 74   : 	{
; 75   : 		CvPopup_SetAtGrow(m_aiBitField, iI, source.getCheckboxBitfield(iI));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T218498[ebp], eax
	mov	ecx, DWORD PTR $T218498[ebp]
	mov	edx, DWORD PTR $T218498[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN59@operator
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN59@operator:
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T218510[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR $T218510[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 76   : 	}

	jmp	SHORT $LN27@operator
$LN26@operator:

; 77   : 
; 78   : 	for(iI = 0; iI < source.getEditboxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN24@operator
$LN23@operator:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN24@operator:
	mov	edx, DWORD PTR _source$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T218518[ebp], edx
	mov	eax, DWORD PTR $T218518[ebp]
	mov	ecx, DWORD PTR $T218518[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN22@operator

; 79   : 	{
; 80   : 		CvPopup_SetAtGrow(m_aszEditBoxString, iI, source.getEditBoxString(iI));

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T218526[ebp], edx
	mov	eax, DWORD PTR $T218526[ebp]
	mov	ecx, DWORD PTR $T218526[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN21@operator
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T218531[ebp], esp
	call	??0CvString@@QAE@XZ			; CvString::CvString
	mov	DWORD PTR tv295[ebp], eax
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
$LN21@operator:
	mov	eax, DWORD PTR _source$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T218537[ebp], eax
	mov	ecx, DWORD PTR $T218537[ebp]
	mov	edx, DWORD PTR $T218537[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _iI$[ebp], eax
	jae	SHORT $LN72@operator
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _source$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR $T218541[ebp], edx
	mov	ecx, DWORD PTR $T218541[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T218554[ebp], eax
	jmp	SHORT $LN81@operator
$LN72@operator:
	mov	DWORD PTR $T218554[ebp], 0
$LN81@operator:
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR $T218563[ebp], ecx
	cmp	DWORD PTR $T218554[ebp], 0
	je	SHORT $LN84@operator
	mov	eax, DWORD PTR $T218554[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218563[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN85@operator
$LN84@operator:
	mov	ecx, DWORD PTR $T218563[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN85@operator:

; 81   : 	}

	jmp	$LN23@operator
$LN22@operator:

; 82   : 
; 83   : 	for(iI = 0; iI < source.getSpinnerWidsize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN20@operator
$LN19@operator:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN20@operator:
	mov	edx, DWORD PTR _source$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T218568[ebp], edx
	mov	eax, DWORD PTR $T218568[ebp]
	mov	ecx, DWORD PTR $T218568[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jge	$LN18@operator

; 84   : 	{
; 85   : 		CvPopup_SetAtGrow(m_aiSpinnerWidgetValues, iI, source.getSpinnerWidgetValue(iI));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T218576[ebp], eax
	mov	ecx, DWORD PTR $T218576[ebp]
	mov	edx, DWORD PTR $T218576[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN17@operator
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN17@operator:
	mov	edx, DWORD PTR _source$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T218586[ebp], edx
	mov	eax, DWORD PTR $T218586[ebp]
	mov	ecx, DWORD PTR $T218586[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN97@operator
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv339[ebp], eax
	jmp	SHORT $LN103@operator
$LN97@operator:
	mov	DWORD PTR tv339[ebp], -1
$LN103@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR tv339[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 86   : 	}

	jmp	$LN19@operator
$LN18@operator:

; 87   : 
; 88   : 	for(iI = 0; iI < source.getPulldownSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN16@operator
$LN15@operator:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN16@operator:
	mov	eax, DWORD PTR _source$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T218605[ebp], eax
	mov	ecx, DWORD PTR $T218605[ebp]
	mov	edx, DWORD PTR $T218605[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN14@operator

; 89   : 	{
; 90   : 		CvPopup_SetAtGrow(m_aiPulldownID, iI, source.getSelectedPullDownValue(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR $T218613[ebp], ecx
	mov	edx, DWORD PTR $T218613[ebp]
	mov	eax, DWORD PTR $T218613[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _iI$[ebp]
	jg	SHORT $LN115@operator
	push	0
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN115@operator:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T218625[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR $T218625[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 91   : 	}

	jmp	SHORT $LN15@operator
$LN14@operator:

; 92   : 
; 93   : 	for(iI = 0; iI < source.getListBoxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@operator
$LN11@operator:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN12@operator:
	mov	eax, DWORD PTR _source$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR $T218633[ebp], eax
	mov	ecx, DWORD PTR $T218633[ebp]
	mov	edx, DWORD PTR $T218633[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN10@operator

; 94   : 	{
; 95   : 		CvPopup_SetAtGrow(m_aiListBoxID, iI, source.getSelectedListBoxValue(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR $T218641[ebp], ecx
	mov	edx, DWORD PTR $T218641[ebp]
	mov	eax, DWORD PTR $T218641[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _iI$[ebp]
	jg	SHORT $LN9@operator
	push	0
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN9@operator:
	mov	eax, DWORD PTR _source$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR $T218651[ebp], eax
	mov	ecx, DWORD PTR $T218651[ebp]
	mov	edx, DWORD PTR $T218651[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$[ebp], eax
	jae	SHORT $LN129@operator
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv373[ebp], ecx
	jmp	SHORT $LN135@operator
$LN129@operator:
	mov	DWORD PTR tv373[ebp], -1
$LN135@operator:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR tv373[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 96   : 	}

	jmp	$LN11@operator
$LN10@operator:

; 97   : 
; 98   : 	for(iI = 0; iI < source.getSpinBoxSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN8@operator:
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T218670[ebp], ecx
	mov	edx, DWORD PTR $T218670[ebp]
	mov	eax, DWORD PTR $T218670[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$[ebp], ecx
	jge	$LN6@operator

; 99   : 	{
; 100  : 		CvPopup_SetAtGrow(m_aiSpinBoxID, iI, source.getSpinnerWidgetValue(iI));

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T218678[ebp], edx
	mov	eax, DWORD PTR $T218678[ebp]
	mov	ecx, DWORD PTR $T218678[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR _iI$[ebp]
	jg	SHORT $LN5@operator
	push	0
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN5@operator:
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T218688[ebp], ecx
	mov	edx, DWORD PTR $T218688[ebp]
	mov	eax, DWORD PTR $T218688[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$[ebp], ecx
	jae	SHORT $LN147@operator
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv394[ebp], edx
	jmp	SHORT $LN153@operator
$LN147@operator:
	mov	DWORD PTR tv394[ebp], -1
$LN153@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR tv394[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 101  : 	}

	jmp	$LN7@operator
$LN6@operator:

; 102  : 
; 103  : 	for(iI = 0; iI < source.GetButtonSize(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN4@operator:
	mov	edx, DWORD PTR _source$[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR $T218707[ebp], edx
	mov	eax, DWORD PTR $T218707[ebp]
	mov	ecx, DWORD PTR $T218707[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jge	SHORT $LN2@operator

; 104  : 	{
; 105  : 		CvPopup_SetAtGrow(m_aiButtonID, iI, source.GetButtonClicked(iI));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR $T218715[ebp], eax
	mov	ecx, DWORD PTR $T218715[ebp]
	mov	edx, DWORD PTR $T218715[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _iI$[ebp]
	jg	SHORT $LN227@operator
	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN227@operator:
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T218879[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR $T218879[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 106  : 	}

	jmp	$LN3@operator
$LN2@operator:

; 107  : 
; 108  : 	return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4PopupReturn@@QAEAAV0@ABV0@@Z ENDP			; PopupReturn::operator=
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	__$ArrayPad$
PUBLIC	?read@PopupReturn@@QAEXAAVFDataStream@@@Z	; PopupReturn::read
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?read@PopupReturn@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@PopupReturn@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?read@PopupReturn@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@PopupReturn@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpopupreturn.cpp
xdata$x	ENDS
;	COMDAT ?read@PopupReturn@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv289 = -252						; size = 4
_this$ = -248						; size = 4
$T219107 = -144						; size = 4
$T219009 = -92						; size = 4
$T218993 = -88						; size = 4
$T218977 = -84						; size = 4
$T218961 = -80						; size = 4
$T218947 = -76						; size = 4
$T218939 = -72						; size = 4
$T218934 = -68						; size = 4
$T218914 = -64						; size = 4
_strValue$216950 = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_iSize$ = -28						; size = 4
_uiVersion$ = -24					; size = 4
_i$ = -20						; size = 4
_iValue$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?read@PopupReturn@@QAEXAAVFDataStream@@@Z PROC		; PopupReturn::read, COMDAT
; _this$ = ecx

; 115  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read@PopupReturn@@QAEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 	// Version number to maintain backwards compatibility
; 117  : 	uint uiVersion;
; 118  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 119  : 
; 120  : 	int iSize;
; 121  : 	int iValue;
; 122  : 	int i;
; 123  : 
; 124  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 125  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN32@read
$LN31@read:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN32@read:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN30@read

; 126  : 	{
; 127  : 		kStream >>  iValue ;

	lea	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 128  : 		CvPopup_SetAtGrow(m_aiSelectedRadioButton, i, iValue);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _i$[ebp]
	jg	SHORT $LN46@read
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN46@read:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 129  : 	}

	jmp	SHORT $LN31@read
$LN30@read:

; 130  : 
; 131  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 132  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN28@read
$LN27@read:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN28@read:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN26@read

; 133  : 	{
; 134  : 		kStream >>  iValue ;

	lea	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 135  : 		CvPopup_SetAtGrow(m_aiBitField, i, iValue);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T218914[ebp], edx
	mov	eax, DWORD PTR $T218914[ebp]
	mov	ecx, DWORD PTR $T218914[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR _i$[ebp]
	jg	SHORT $LN56@read
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN56@read:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 136  : 	}

	jmp	SHORT $LN27@read
$LN26@read:

; 137  : 
; 138  : 	kStream >>  iSize ;

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 139  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN24@read
$LN23@read:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN24@read:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iSize$[ebp]
	jge	$LN22@read

; 140  : 	{
; 141  : 		CvString strValue;

	lea	ecx, DWORD PTR _strValue$216950[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 142  : 		kStream >>  strValue ;

	lea	edx, DWORD PTR _strValue$216950[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 143  : 		CvPopup_SetAtGrow(m_aszEditBoxString, i, strValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T218934[ebp], eax
	mov	ecx, DWORD PTR $T218934[ebp]
	mov	edx, DWORD PTR $T218934[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR _i$[ebp]
	jg	SHORT $LN70@read
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T218939[ebp], esp
	call	??0CvString@@QAE@XZ			; CvString::CvString
	mov	DWORD PTR tv289[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
$LN70@read:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR $T218947[ebp], eax
	lea	edx, DWORD PTR _strValue$216950[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218947[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 144  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strValue$216950[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN23@read
$LN22@read:

; 145  : 
; 146  : 	kStream >>  iSize ;

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 147  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@read
$LN19@read:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN20@read:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN18@read

; 148  : 	{
; 149  : 		kStream >>  iValue ;

	lea	eax, DWORD PTR _iValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 150  : 		CvPopup_SetAtGrow(m_aiSpinnerWidgetValues, i, iValue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR $T218961[ebp], ecx
	mov	edx, DWORD PTR $T218961[ebp]
	mov	eax, DWORD PTR $T218961[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _i$[ebp]
	jg	SHORT $LN85@read
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN85@read:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 151  : 	}

	jmp	SHORT $LN19@read
$LN18@read:

; 152  : 
; 153  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 154  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@read
$LN15@read:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN16@read:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN14@read

; 155  : 	{
; 156  : 		kStream >>  iValue ;

	lea	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 157  : 		CvPopup_SetAtGrow(m_aiPulldownID, i, iValue);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR $T218977[ebp], edx
	mov	eax, DWORD PTR $T218977[ebp]
	mov	ecx, DWORD PTR $T218977[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR _i$[ebp]
	jg	SHORT $LN95@read
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN95@read:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 158  : 	}

	jmp	SHORT $LN15@read
$LN14@read:

; 159  : 
; 160  : 	kStream >>  iSize ;

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 161  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@read
$LN11@read:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@read:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN10@read

; 162  : 	{
; 163  : 		kStream >>  iValue ;

	lea	edx, DWORD PTR _iValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 164  : 		CvPopup_SetAtGrow(m_aiListBoxID, i, iValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR $T218993[ebp], eax
	mov	ecx, DWORD PTR $T218993[ebp]
	mov	edx, DWORD PTR $T218993[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _i$[ebp]
	jg	SHORT $LN105@read
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN105@read:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 165  : 	}

	jmp	SHORT $LN11@read
$LN10@read:

; 166  : 
; 167  : 	kStream >>  iSize ;

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 168  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@read
$LN7@read:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN8@read:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN6@read

; 169  : 	{
; 170  : 		kStream >>  iValue ;

	lea	eax, DWORD PTR _iValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 171  : 		CvPopup_SetAtGrow(m_aiSpinBoxID, i, iValue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T219009[ebp], ecx
	mov	edx, DWORD PTR $T219009[ebp]
	mov	eax, DWORD PTR $T219009[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	ecx, DWORD PTR _i$[ebp]
	jg	SHORT $LN150@read
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN150@read:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 172  : 	}

	jmp	SHORT $LN7@read
$LN6@read:

; 173  : 
; 174  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 175  : 	for(i = 0; i < iSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@read
$LN3@read:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@read:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iSize$[ebp]
	jge	SHORT $LN33@read

; 176  : 	{
; 177  : 		kStream >>  iValue ;

	lea	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 178  : 		CvPopup_SetAtGrow(m_aiButtonID, i, iValue);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR $T219107[ebp], edx
	mov	eax, DWORD PTR $T219107[ebp]
	mov	ecx, DWORD PTR $T219107[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR _i$[ebp]
	jg	SHORT $LN231@read
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN231@read:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN3@read
$LN33@read:

; 179  : 	}
; 180  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@PopupReturn@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _strValue$216950[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?read@PopupReturn@@QAEXAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read@PopupReturn@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@PopupReturn@@QAEXAAVFDataStream@@@Z ENDP		; PopupReturn::read
PUBLIC	?write@PopupReturn@@QBEXAAVFDataStream@@@Z	; PopupReturn::write
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?write@PopupReturn@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T219448 = -128						; size = 4
$T219441 = -124						; size = 4
$T219434 = -120						; size = 4
$T219430 = -116						; size = 4
$T219423 = -112						; size = 4
$T219416 = -108						; size = 4
$T219412 = -104						; size = 4
$T219405 = -100						; size = 4
$T219398 = -96						; size = 4
$T219394 = -92						; size = 4
$T219387 = -88						; size = 4
$T219380 = -84						; size = 4
$T219376 = -80						; size = 4
$T219369 = -76						; size = 4
$T219362 = -72						; size = 4
$T219358 = -68						; size = 4
$T219351 = -64						; size = 4
$T219344 = -60						; size = 4
$T219340 = -56						; size = 4
$T219333 = -52						; size = 4
$T219326 = -48						; size = 4
$T219322 = -44						; size = 4
$T219303 = -40						; size = 4
$T219302 = -36						; size = 4
$T219301 = -32						; size = 4
$T219300 = -28						; size = 4
$T219299 = -24						; size = 4
$T219298 = -20						; size = 4
$T219297 = -16						; size = 4
$T219296 = -12						; size = 4
_uiVersion$ = -8					; size = 4
_iI$ = -4						; size = 4
_kStream$ = 8						; size = 4
?write@PopupReturn@@QBEXAAVFDataStream@@@Z PROC		; PopupReturn::write, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 	// Current version number
; 188  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 189  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 190  : 
; 191  : 	unsigned int iI;
; 192  : 	//char szString[1024];
; 193  : 
; 194  : 	kStream <<  m_aiSelectedRadioButton.size() ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T219296[ebp], eax
	lea	ecx, DWORD PTR $T219296[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 195  : 	for(iI = 0; iI < m_aiSelectedRadioButton.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN33@write
$LN23@write:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN33@write:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN22@write

; 196  : 	{
; 197  : 		kStream <<  m_aiSelectedRadioButton[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219322[ebp], eax
	mov	ecx, DWORD PTR $T219322[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 198  : 	}

	jmp	SHORT $LN23@write
$LN22@write:

; 199  : 
; 200  : 	kStream <<  m_aiBitField.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T219326[ebp], edx
	mov	eax, DWORD PTR $T219326[ebp]
	mov	ecx, DWORD PTR $T219326[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219297[ebp], edx
	lea	eax, DWORD PTR $T219297[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 201  : 	for(iI = 0; iI < m_aiBitField.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN21@write
$LN20@write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN21@write:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T219333[ebp], edx
	mov	eax, DWORD PTR $T219333[ebp]
	mov	ecx, DWORD PTR $T219333[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN19@write

; 202  : 	{
; 203  : 		kStream <<  m_aiBitField[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219340[ebp], eax
	mov	ecx, DWORD PTR $T219340[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 204  : 	}

	jmp	SHORT $LN20@write
$LN19@write:

; 205  : 
; 206  : 	kStream <<  m_aszEditBoxString.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T219344[ebp], edx
	mov	eax, DWORD PTR $T219344[ebp]
	mov	ecx, DWORD PTR $T219344[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T219298[ebp], eax
	lea	edx, DWORD PTR $T219298[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 207  : 	for(iI = 0; iI < m_aszEditBoxString.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN18@write
$LN17@write:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN18@write:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T219351[ebp], ecx
	mov	edx, DWORD PTR $T219351[ebp]
	mov	eax, DWORD PTR $T219351[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _iI$[ebp], eax
	jae	SHORT $LN16@write

; 208  : 	{
; 209  : 		kStream <<  m_aszEditBoxString[iI] ;

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR $T219358[ebp], edx
	mov	ecx, DWORD PTR $T219358[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 210  : 	}

	jmp	SHORT $LN17@write
$LN16@write:

; 211  : 
; 212  : 	kStream <<  m_aiSpinnerWidgetValues.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T219362[ebp], edx
	mov	eax, DWORD PTR $T219362[ebp]
	mov	ecx, DWORD PTR $T219362[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219299[ebp], edx
	lea	eax, DWORD PTR $T219299[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 213  : 	for(iI = 0; iI < m_aiSpinnerWidgetValues.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN15@write
$LN14@write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN15@write:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T219369[ebp], edx
	mov	eax, DWORD PTR $T219369[ebp]
	mov	ecx, DWORD PTR $T219369[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN13@write

; 214  : 	{
; 215  : 		kStream <<  m_aiSpinnerWidgetValues[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219376[ebp], eax
	mov	ecx, DWORD PTR $T219376[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 216  : 	}

	jmp	SHORT $LN14@write
$LN13@write:

; 217  : 
; 218  : 	kStream <<  m_aiPulldownID.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR $T219380[ebp], edx
	mov	eax, DWORD PTR $T219380[ebp]
	mov	ecx, DWORD PTR $T219380[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219300[ebp], edx
	lea	eax, DWORD PTR $T219300[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 219  : 	for(iI = 0; iI < m_aiPulldownID.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@write
$LN11@write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN12@write:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR $T219387[ebp], edx
	mov	eax, DWORD PTR $T219387[ebp]
	mov	ecx, DWORD PTR $T219387[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN10@write

; 220  : 	{
; 221  : 		kStream <<  m_aiPulldownID[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219394[ebp], eax
	mov	ecx, DWORD PTR $T219394[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 222  : 	}

	jmp	SHORT $LN11@write
$LN10@write:

; 223  : 
; 224  : 	kStream <<  m_aiListBoxID.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	mov	DWORD PTR $T219398[ebp], edx
	mov	eax, DWORD PTR $T219398[ebp]
	mov	ecx, DWORD PTR $T219398[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219301[ebp], edx
	lea	eax, DWORD PTR $T219301[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 225  : 	for(iI = 0; iI < m_aiListBoxID.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@write
$LN8@write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN9@write:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	mov	DWORD PTR $T219405[ebp], edx
	mov	eax, DWORD PTR $T219405[ebp]
	mov	ecx, DWORD PTR $T219405[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN7@write

; 226  : 	{
; 227  : 		kStream <<  m_aiListBoxID[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219412[ebp], eax
	mov	ecx, DWORD PTR $T219412[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 228  : 	}

	jmp	SHORT $LN8@write
$LN7@write:

; 229  : 
; 230  : 	kStream <<  m_aiSpinBoxID.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T219416[ebp], edx
	mov	eax, DWORD PTR $T219416[ebp]
	mov	ecx, DWORD PTR $T219416[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219302[ebp], edx
	lea	eax, DWORD PTR $T219302[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 231  : 	for(iI = 0; iI < m_aiSpinBoxID.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@write
$LN5@write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN6@write:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T219423[ebp], edx
	mov	eax, DWORD PTR $T219423[ebp]
	mov	ecx, DWORD PTR $T219423[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN4@write

; 232  : 	{
; 233  : 		kStream <<  m_aiSpinBoxID[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219430[ebp], eax
	mov	ecx, DWORD PTR $T219430[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 234  : 	}

	jmp	SHORT $LN5@write
$LN4@write:

; 235  : 
; 236  : 	kStream <<  m_aiButtonID.size() ;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR $T219434[ebp], edx
	mov	eax, DWORD PTR $T219434[ebp]
	mov	ecx, DWORD PTR $T219434[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219303[ebp], edx
	lea	eax, DWORD PTR $T219303[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 237  : 	for(iI = 0; iI < m_aiButtonID.size(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@write
$LN2@write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN3@write:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR $T219441[ebp], edx
	mov	eax, DWORD PTR $T219441[ebp]
	mov	ecx, DWORD PTR $T219441[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _iI$[ebp], edx
	jae	SHORT $LN25@write

; 238  : 	{
; 239  : 		kStream <<  m_aiButtonID[iI] ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _iI$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219448[ebp], eax
	mov	ecx, DWORD PTR $T219448[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 240  : 	}

	jmp	SHORT $LN2@write
$LN25@write:

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write@PopupReturn@@QBEXAAVFDataStream@@@Z ENDP		; PopupReturn::write
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
PUBLIC	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T219480 = -30						; size = 1
$T219467 = -29						; size = 1
$T219463 = -28						; size = 4
$T219456 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T219480[ebp]
	mov	DWORD PTR $T219456[ebp], eax
	lea	ecx, DWORD PTR $T219467[ebp]
	mov	DWORD PTR $T219463[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
PUBLIC	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
__Tmp$219739 = -48					; size = 4
$T219717 = -44						; size = 4
$T219701 = -40						; size = 4
$T219679 = -36						; size = 4
$T219666 = -32						; size = 4
$T219665 = -28						; size = 4
$T219664 = -24						; size = 4
$T219663 = -20						; size = 4
$T219662 = -16						; size = 4
$T219661 = -12						; size = 4
$T219660 = -8						; size = 4
$T219659 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T219679[ebp], ecx
	mov	edx, DWORD PTR $T219679[ebp]
	mov	DWORD PTR $T219660[ebp], edx
	mov	eax, DWORD PTR $T219660[ebp]
	mov	DWORD PTR $T219659[ebp], eax
	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T219659[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN4@resize

; 720  : 		else if (_Newsize < size())

$LN16@resize:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219701[ebp], edx
	mov	eax, DWORD PTR $T219701[ebp]
	mov	DWORD PTR $T219662[ebp], eax
	mov	ecx, DWORD PTR $T219662[ebp]
	mov	DWORD PTR $T219661[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219717[ebp], eax
	mov	ecx, DWORD PTR $T219717[ebp]
	mov	DWORD PTR $T219664[ebp], ecx
	mov	edx, DWORD PTR $T219664[ebp]
	mov	DWORD PTR __Tmp$219739[ebp], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Tmp$219739[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$219739[ebp], edx
	mov	eax, DWORD PTR __Tmp$219739[ebp]
	mov	DWORD PTR $T219665[ebp], eax
	mov	ecx, DWORD PTR $T219665[ebp]
	mov	DWORD PTR $T219663[ebp], ecx
	mov	edx, DWORD PTR $T219661[ebp]
	push	edx
	mov	eax, DWORD PTR $T219663[ebp]
	push	eax
	lea	ecx, DWORD PTR $T219666[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase
PUBLIC	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z$0
__ehfuncinfo$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
_TEXT	SEGMENT
_this$ = -136						; size = 4
__Tmp$219911 = -64					; size = 4
$T219894 = -60						; size = 4
$T219878 = -56						; size = 4
$T219856 = -52						; size = 4
$T219842 = -48						; size = 4
$T219841 = -44						; size = 4
$T219840 = -40						; size = 4
$T219839 = -36						; size = 4
$T219838 = -32						; size = 4
$T219837 = -28						; size = 4
$T219836 = -24						; size = 4
$T219835 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 28
?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN17@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219856[ebp], eax
	mov	ecx, DWORD PTR $T219856[ebp]
	mov	DWORD PTR $T219836[ebp], ecx
	mov	edx, DWORD PTR $T219836[ebp]
	mov	DWORD PTR $T219835[ebp], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR $T219835[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
	jmp	SHORT $LN2@resize@2

; 720  : 		else if (_Newsize < size())

$LN17@resize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN2@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219878[ebp], eax
	mov	ecx, DWORD PTR $T219878[ebp]
	mov	DWORD PTR $T219838[ebp], ecx
	mov	edx, DWORD PTR $T219838[ebp]
	mov	DWORD PTR $T219837[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219894[ebp], ecx
	mov	edx, DWORD PTR $T219894[ebp]
	mov	DWORD PTR $T219840[ebp], edx
	mov	eax, DWORD PTR $T219840[ebp]
	mov	DWORD PTR __Tmp$219911[ebp], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Tmp$219911[ebp]
	mov	DWORD PTR __Tmp$219911[ebp], ecx
	mov	edx, DWORD PTR __Tmp$219911[ebp]
	mov	DWORD PTR $T219841[ebp], edx
	mov	eax, DWORD PTR $T219841[ebp]
	mov	DWORD PTR $T219839[ebp], eax
	mov	ecx, DWORD PTR $T219837[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219839[ebp]
	push	edx
	lea	eax, DWORD PTR $T219842[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase
$LN2@resize@2:

; 722  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Val$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z$0:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::resize
PUBLIC	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
PUBLIC	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$220125 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$220125[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$220125[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$220125[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Buy
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T220257 = -36						; size = 4
$T220256 = -32						; size = 4
$T220252 = -28						; size = 4
$T220251 = -24						; size = 4
$T220228 = -20						; size = 4
$T220227 = -16						; size = 4
$T220206 = -12						; size = 4
$T220205 = -8						; size = 4
__Cat$220229 = -2					; size = 1
$T220247 = -1						; size = 1
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220252[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220251[ebp], ecx
	mov	edx, DWORD PTR $T220252[ebp]
	mov	DWORD PTR $T220228[ebp], edx
	mov	eax, DWORD PTR $T220251[ebp]
	mov	DWORD PTR $T220227[ebp], eax
	mov	cl, BYTE PTR __Cat$220229[ebp]
	mov	BYTE PTR $T220247[ebp], cl
	mov	edx, DWORD PTR $T220228[ebp]
	mov	DWORD PTR $T220206[ebp], edx
	mov	eax, DWORD PTR $T220227[ebp]
	mov	DWORD PTR $T220205[ebp], eax
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	ecx, DWORD PTR $T220205[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T220205[ebp], ecx
$LN12@Tidy:
	mov	edx, DWORD PTR $T220205[ebp]
	cmp	edx, DWORD PTR $T220206[ebp]
	je	SHORT $LN4@Tidy
	mov	ecx, DWORD PTR $T220205[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy
	mov	ecx, DWORD PTR $T220205[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy:
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T220257[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220256[ebp], eax
	mov	ecx, DWORD PTR $T220256[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T220442 = -68						; size = 4
$T220419 = -64						; size = 4
$T220418 = -60						; size = 4
$T220397 = -56						; size = 4
$T220396 = -52						; size = 4
__Cat$220426 = -46					; size = 1
$T220423 = -45						; size = 1
$T220345 = -44						; size = 4
$T220344 = -40						; size = 4
$T220343 = -36						; size = 4
$T220324 = -30						; size = 1
$T220323 = -29						; size = 1
$T220322 = -28						; size = 4
$T220321 = -24						; size = 4
__Cat$220331 = -16					; size = 1
$T220328 = -15						; size = 1
$T220327 = -14						; size = 1
$T220326 = -13						; size = 1
__Ptr$217252 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220345[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220344[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T220343[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220326[ebp], cl
	mov	dl, BYTE PTR __Cat$220331[ebp]
	mov	BYTE PTR $T220327[ebp], dl
	mov	al, BYTE PTR $T220326[ebp]
	mov	BYTE PTR $T220324[ebp], al
	mov	cl, BYTE PTR $T220328[ebp]
	mov	BYTE PTR $T220323[ebp], cl
	mov	edx, DWORD PTR $T220345[ebp]
	mov	DWORD PTR $T220322[ebp], edx
	mov	eax, DWORD PTR $T220343[ebp]
	mov	DWORD PTR $T220321[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T220322[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T220322[ebp], ecx
	mov	edx, DWORD PTR $T220321[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T220321[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T220321[ebp]
	cmp	eax, DWORD PTR $T220344[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T220321[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220322[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	edx, DWORD PTR $T220322[ebp]
	mov	DWORD PTR __Ptr$217252[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220442[ebp], ecx
	mov	edx, DWORD PTR $T220442[ebp]
	mov	DWORD PTR $T220419[ebp], edx
	mov	eax, DWORD PTR __Ptr$217252[ebp]
	mov	DWORD PTR $T220418[ebp], eax
	mov	cl, BYTE PTR __Cat$220426[ebp]
	mov	BYTE PTR $T220423[ebp], cl
	mov	edx, DWORD PTR $T220419[ebp]
	mov	DWORD PTR $T220397[ebp], edx
	mov	eax, DWORD PTR $T220418[ebp]
	mov	DWORD PTR $T220396[ebp], eax
	jmp	SHORT $LN41@erase
$LN40@erase:
	mov	ecx, DWORD PTR $T220396[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T220396[ebp], ecx
$LN41@erase:
	mov	edx, DWORD PTR $T220396[ebp]
	cmp	edx, DWORD PTR $T220397[ebp]
	je	SHORT $LN33@erase
	mov	ecx, DWORD PTR $T220396[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN44@erase
	mov	ecx, DWORD PTR $T220396[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN44@erase:
	jmp	SHORT $LN40@erase
$LN33@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$217252[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::erase
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
PUBLIC	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$16 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$15
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$16
__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
_TEXT	SEGMENT
tv84 = -460						; size = 4
tv312 = -456						; size = 4
tv298 = -452						; size = 4
tv290 = -448						; size = 4
_this$ = -444						; size = 4
$T221241 = -440						; size = 4
$T221178 = -400						; size = 4
$T221159 = -396						; size = 4
$T221142 = -389						; size = 1
$T221141 = -388						; size = 4
$T221131 = -384						; size = 4
$T221130 = -380						; size = 4
__Cat$221176 = -374					; size = 1
$T221174 = -373						; size = 1
$T221173 = -372						; size = 1
__Cat$221167 = -371					; size = 1
$T221165 = -370						; size = 1
$T221164 = -369						; size = 1
$T221098 = -368						; size = 4
$T221088 = -364						; size = 4
$T221075 = -360						; size = 4
$T221052 = -356						; size = 4
$T221051 = -352						; size = 4
$T221030 = -348						; size = 4
$T221029 = -344						; size = 4
__Cat$221059 = -338					; size = 1
$T221057 = -337						; size = 1
$T220978 = -336						; size = 4
$T220977 = -332						; size = 4
$T220967 = -328						; size = 4
__Cat$220975 = -323					; size = 1
$T220973 = -322						; size = 1
$T220972 = -321						; size = 1
$T220951 = -320						; size = 4
$T220939 = -316						; size = 4
$T220929 = -309						; size = 1
$T220928 = -308						; size = 4
__Cat$220947 = -303					; size = 1
$T220945 = -302						; size = 1
$T220944 = -301						; size = 1
$T220912 = -300						; size = 4
$T220911 = -296						; size = 4
$T220907 = -292						; size = 4
$T220906 = -288						; size = 4
$T220883 = -284						; size = 4
$T220882 = -280						; size = 4
$T220861 = -276						; size = 4
$T220860 = -272						; size = 4
__Cat$220890 = -266					; size = 1
$T220888 = -265						; size = 1
$T220781 = -264						; size = 4
$T220780 = -260						; size = 4
$T220759 = -256						; size = 4
$T220758 = -252						; size = 4
__Cat$220788 = -246					; size = 1
$T220786 = -245						; size = 1
$T220685 = -244						; size = 4
$T220684 = -240						; size = 4
$T220663 = -236						; size = 4
$T220662 = -232						; size = 4
__Cat$220693 = -226					; size = 1
$T220690 = -225						; size = 1
$T220611 = -224						; size = 4
$T220599 = -220						; size = 4
$T220589 = -213						; size = 1
$T220588 = -212						; size = 4
__Cat$220607 = -207					; size = 1
$T220604 = -206						; size = 1
$T220603 = -205						; size = 1
$T220576 = -204						; size = 4
$T220564 = -200						; size = 4
$T220554 = -193						; size = 1
$T220553 = -192						; size = 4
__Cat$220571 = -187					; size = 1
$T220568 = -186						; size = 1
$T220567 = -185						; size = 1
$T220541 = -184						; size = 4
$T220531 = -180						; size = 4
__Cat$220539 = -175					; size = 1
$T220536 = -174						; size = 1
$T220535 = -173						; size = 1
__Count$220503 = -172					; size = 4
__Count$220477 = -100					; size = 4
__Tmp$217302 = -96					; size = 28
__Oldend$217303 = -68					; size = 4
__Tmp$217292 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
__Ncopied$217279 = -32					; size = 4
__Newvec$217277 = -28					; size = 4
__Whereoff$217278 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 444				; 000001bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n
$LN31@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$220477[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$220477[ebp], 0
	jbe	SHORT $LN37@Insert_n
	mov	eax, DWORD PTR __Count$220477[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n
$LN37@Insert_n:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$220503[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$220503[ebp], 0
	jbe	SHORT $LN50@Insert_n
	mov	edx, DWORD PTR __Count$220503[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n
$LN50@Insert_n:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8
	mov	DWORD PTR __Newvec$217277[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$217278[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$217279[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$217278[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR $T220541[ebp], edx
	mov	eax, DWORD PTR $T220541[ebp]
	mov	DWORD PTR $T220531[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220535[ebp], cl
	mov	dl, BYTE PTR __Cat$220539[ebp]
	mov	BYTE PTR $T220536[ebp], dl
	movzx	eax, BYTE PTR $T220535[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T220536[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220531[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$217279[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$217279[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220576[ebp], edx
	mov	eax, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR $T220564[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220567[ebp], cl
	mov	dl, BYTE PTR __Cat$220571[ebp]
	mov	BYTE PTR $T220568[ebp], dl
	mov	al, BYTE PTR $T220567[ebp]
	mov	BYTE PTR $T220554[ebp], al
	mov	ecx, DWORD PTR $T220564[ebp]
	mov	DWORD PTR $T220553[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220553[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220576[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$217279[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$217279[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220611[ebp], edx
	mov	eax, DWORD PTR __Whereoff$217278[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR $T220599[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220603[ebp], cl
	mov	dl, BYTE PTR __Cat$220607[ebp]
	mov	BYTE PTR $T220604[ebp], dl
	mov	al, BYTE PTR $T220603[ebp]
	mov	BYTE PTR $T220589[ebp], al
	mov	ecx, DWORD PTR $T220599[ebp]
	mov	DWORD PTR $T220588[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220588[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220611[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$217279[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$217278[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR $T220685[ebp], eax
	mov	ecx, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR $T220684[ebp], ecx
	mov	dl, BYTE PTR __Cat$220693[ebp]
	mov	BYTE PTR $T220690[ebp], dl
	mov	eax, DWORD PTR $T220685[ebp]
	mov	DWORD PTR $T220663[ebp], eax
	mov	ecx, DWORD PTR $T220684[ebp]
	mov	DWORD PTR $T220662[ebp], ecx
	jmp	SHORT $LN88@Insert_n
$LN87@Insert_n:
	mov	edx, DWORD PTR $T220662[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T220662[ebp], edx
$LN88@Insert_n:
	mov	eax, DWORD PTR $T220662[ebp]
	cmp	eax, DWORD PTR $T220663[ebp]
	je	SHORT $LN7@Insert_n
	mov	ecx, DWORD PTR $T220662[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN91@Insert_n
	mov	edx, DWORD PTR $T220662[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Insert_n:
	jmp	SHORT $LN87@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$217279[ebp], 0
	jle	$LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Whereoff$217278[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$217277[ebp]
	add	ecx, eax
	mov	DWORD PTR $T220781[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$217278[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR $T220780[ebp], edx
	mov	al, BYTE PTR __Cat$220788[ebp]
	mov	BYTE PTR $T220786[ebp], al
	mov	ecx, DWORD PTR $T220781[ebp]
	mov	DWORD PTR $T220759[ebp], ecx
	mov	edx, DWORD PTR $T220780[ebp]
	mov	DWORD PTR $T220758[ebp], edx
	jmp	SHORT $LN109@Insert_n
$LN108@Insert_n:
	mov	eax, DWORD PTR $T220758[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T220758[ebp], eax
$LN109@Insert_n:
	mov	ecx, DWORD PTR $T220758[ebp]
	cmp	ecx, DWORD PTR $T220759[ebp]
	je	SHORT $LN6@Insert_n
	mov	ecx, DWORD PTR $T220758[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN112@Insert_n
	mov	eax, DWORD PTR $T220758[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN112@Insert_n:
	jmp	SHORT $LN108@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$217277[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN124@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN124@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220907[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220906[ebp], eax
	mov	ecx, DWORD PTR $T220907[ebp]
	mov	DWORD PTR $T220883[ebp], ecx
	mov	edx, DWORD PTR $T220906[ebp]
	mov	DWORD PTR $T220882[ebp], edx
	mov	al, BYTE PTR __Cat$220890[ebp]
	mov	BYTE PTR $T220888[ebp], al
	mov	ecx, DWORD PTR $T220883[ebp]
	mov	DWORD PTR $T220861[ebp], ecx
	mov	edx, DWORD PTR $T220882[ebp]
	mov	DWORD PTR $T220860[ebp], edx
	jmp	SHORT $LN134@Insert_n
$LN133@Insert_n:
	mov	eax, DWORD PTR $T220860[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T220860[ebp], eax
$LN134@Insert_n:
	mov	ecx, DWORD PTR $T220860[ebp]
	cmp	ecx, DWORD PTR $T220861[ebp]
	je	SHORT $LN126@Insert_n
	mov	ecx, DWORD PTR $T220860[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN137@Insert_n
	mov	eax, DWORD PTR $T220860[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN137@Insert_n:
	jmp	SHORT $LN133@Insert_n
$LN126@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T220912[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220911[ebp], eax
	mov	ecx, DWORD PTR $T220911[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$217277[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$217277[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$217277[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$217292[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220951[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220939[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T220944[ebp], al
	mov	cl, BYTE PTR __Cat$220947[ebp]
	mov	BYTE PTR $T220945[ebp], cl
	mov	dl, BYTE PTR $T220944[ebp]
	mov	BYTE PTR $T220929[ebp], dl
	mov	eax, DWORD PTR $T220939[ebp]
	mov	DWORD PTR $T220928[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220928[ebp]
	push	edx
	mov	eax, DWORD PTR $T220951[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 16					; 00000010H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T220978[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220977[ebp], ecx
	mov	edx, DWORD PTR $T220977[ebp]
	mov	DWORD PTR $T220967[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T220972[ebp], al
	mov	cl, BYTE PTR __Cat$220975[ebp]
	mov	BYTE PTR $T220973[ebp], cl
	movzx	edx, BYTE PTR $T220972[ebp]
	push	edx
	movzx	eax, BYTE PTR $T220973[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$217292[ebp]
	push	edx
	mov	eax, DWORD PTR $T220978[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220967[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221075[ebp], edx
	mov	ecx, DWORD PTR $T221075[ebp]
	mov	DWORD PTR $T221052[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221051[ebp], edx
	mov	al, BYTE PTR __Cat$221059[ebp]
	mov	BYTE PTR $T221057[ebp], al
	mov	ecx, DWORD PTR $T221052[ebp]
	mov	DWORD PTR $T221030[ebp], ecx
	mov	edx, DWORD PTR $T221051[ebp]
	mov	DWORD PTR $T221029[ebp], edx
	jmp	SHORT $LN174@Insert_n
$LN173@Insert_n:
	mov	eax, DWORD PTR $T221029[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T221029[ebp], eax
$LN174@Insert_n:
	mov	ecx, DWORD PTR $T221029[ebp]
	cmp	ecx, DWORD PTR $T221030[ebp]
	je	SHORT $LN166@Insert_n
	mov	ecx, DWORD PTR $T221029[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN177@Insert_n
	mov	eax, DWORD PTR $T221029[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN177@Insert_n:
	jmp	SHORT $LN173@Insert_n
$LN166@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, __tryend$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T221098[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221088[ebp], ecx
	jmp	SHORT $LN191@Insert_n
$LN190@Insert_n:
	mov	edx, DWORD PTR $T221088[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T221088[ebp], edx
$LN191@Insert_n:
	mov	eax, DWORD PTR $T221088[ebp]
	cmp	eax, DWORD PTR $T221098[ebp]
	je	SHORT $LN187@Insert_n
	lea	ecx, DWORD PTR __Tmp$217292[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221088[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN190@Insert_n
$LN187@Insert_n:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$217292[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$217302[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$217303[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221178[ebp], eax
	mov	ecx, DWORD PTR $T221178[ebp]
	mov	DWORD PTR $T221159[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221164[ebp], dl
	mov	al, BYTE PTR __Cat$221167[ebp]
	mov	BYTE PTR $T221165[ebp], al
	mov	cl, BYTE PTR $T221164[ebp]
	mov	BYTE PTR $T221142[ebp], cl
	mov	edx, DWORD PTR $T221159[ebp]
	mov	DWORD PTR $T221141[ebp], edx
	mov	eax, DWORD PTR $T221141[ebp]
	mov	DWORD PTR $T221131[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Oldend$217303[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T221130[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221173[ebp], al
	mov	cl, BYTE PTR __Cat$221176[ebp]
	mov	BYTE PTR $T221174[ebp], cl
	movzx	edx, BYTE PTR $T221173[ebp]
	push	edx
	movzx	eax, BYTE PTR $T221174[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221131[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$217303[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221130[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$217303[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Oldend$217303[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221241[ebp], ecx
	jmp	SHORT $LN234@Insert_n
$LN233@Insert_n:
	mov	edx, DWORD PTR $T221241[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T221241[ebp], edx
$LN234@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T221241[ebp], eax
	je	SHORT $LN230@Insert_n
	lea	ecx, DWORD PTR __Tmp$217302[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221241[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN233@Insert_n
$LN230@Insert_n:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$217302[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@Insert_n:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$217292[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$217302[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-464]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221269 = -80						; size = 28
$T221268 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221269[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T221268[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T221268[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T221269[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221268[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T221268[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221268[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T221269[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221269[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221268[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
$T221345 = -34						; size = 1
$T221344 = -33						; size = 1
$T221343 = -32						; size = 4
$T221342 = -28						; size = 4
$T221328 = -21						; size = 1
$T221327 = -20						; size = 4
$T221326 = -16						; size = 4
$T221325 = -12						; size = 4
__Cat$221334 = -8					; size = 1
$T221331 = -7						; size = 1
$T221330 = -6						; size = 1
__Cat$221303 = -4					; size = 1
$T221299 = -3						; size = 1
$T221298 = -2						; size = 1
$T221297 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvString *,CvString *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T221297[ebp], al
	mov	cl, BYTE PTR __Cat$221303[ebp]
	mov	BYTE PTR $T221298[ebp], cl
	mov	dl, BYTE PTR $T221297[ebp]
	mov	BYTE PTR $T221345[ebp], dl
	mov	al, BYTE PTR $T221299[ebp]
	mov	BYTE PTR $T221344[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T221343[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T221342[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221330[ebp], al
	mov	cl, BYTE PTR __Cat$221334[ebp]
	mov	BYTE PTR $T221331[ebp], cl
	mov	dl, BYTE PTR $T221330[ebp]
	mov	BYTE PTR $T221328[ebp], dl
	mov	eax, DWORD PTR $T221343[ebp]
	mov	DWORD PTR $T221327[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T221326[ebp], ecx
	mov	edx, DWORD PTR $T221342[ebp]
	mov	DWORD PTR $T221325[ebp], edx
$LN12@Unchecked_:
	mov	eax, DWORD PTR $T221325[ebp]
	cmp	eax, DWORD PTR $T221326[ebp]
	je	SHORT $LN7@Unchecked_
	mov	ecx, DWORD PTR $T221326[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR $T221326[ebp], ecx
	mov	edx, DWORD PTR $T221327[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR $T221327[ebp], edx
	mov	eax, DWORD PTR $T221326[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221327[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN12@Unchecked_
$LN7@Unchecked_:
	mov	eax, DWORD PTR $T221327[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z
_TEXT	SEGMENT
$T221352 = -16						; size = 4
$T221348 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z PROC ; std::_Allocate<CvString>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T221352[ebp], 0
	lea	eax, DWORD PTR $T221352[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221348[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T221348[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221348[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ENDP ; std::_Allocate<CvString>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T221409 = -32						; size = 4
$T221408 = -28						; size = 4
__Vptr$221417 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$221417[ebp], eax
	mov	ecx, DWORD PTR __Vptr$221417[ebp]
	mov	DWORD PTR $T221409[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T221409[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221409[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T221409[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T221408[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN26@Uninit_fil
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_fil:
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$221417[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221409[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
__Cat$221465 = -3					; size = 1
$T221461 = -2						; size = 1
$T221460 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T221460[ebp], al
	mov	cl, BYTE PTR __Cat$221465[ebp]
	mov	BYTE PTR $T221461[ebp], cl
	movzx	edx, BYTE PTR $T221460[ebp]
	push	edx
	movzx	eax, BYTE PTR $T221461[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T221500 = -32						; size = 4
$T221499 = -28						; size = 4
__Vptr$221508 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$221508[ebp], ecx
	mov	edx, DWORD PTR __Vptr$221508[ebp]
	mov	DWORD PTR $T221500[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T221500[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221500[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T221500[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T221499[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN26@Uninit_cop
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_cop:
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$221508[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221500[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T221594 = -30						; size = 1
$T221581 = -29						; size = 1
$T221577 = -28						; size = 4
$T221570 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T221594[ebp]
	mov	DWORD PTR $T221570[ebp], eax
	lea	ecx, DWORD PTR $T221581[ebp]
	mov	DWORD PTR $T221577[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$221718 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$221718[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221718[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$221718[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T221784 = -28						; size = 4
$T221783 = -24						; size = 4
$T221779 = -20						; size = 4
$T221778 = -16						; size = 4
$T221767 = -12						; size = 4
$T221766 = -8						; size = 4
__Cat$221773 = -2					; size = 1
$T221771 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221779[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221778[ebp], ecx
	mov	edx, DWORD PTR $T221779[ebp]
	mov	DWORD PTR $T221767[ebp], edx
	mov	eax, DWORD PTR $T221778[ebp]
	mov	DWORD PTR $T221766[ebp], eax
	mov	cl, BYTE PTR __Cat$221773[ebp]
	mov	BYTE PTR $T221771[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T221784[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221783[ebp], eax
	mov	ecx, DWORD PTR $T221783[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221802 = -80						; size = 28
$T221801 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221802[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T221801[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T221801[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T221802[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221801[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T221801[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221801[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T221802[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221802[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221801[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T221827 = -16						; size = 4
$T221823 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T221827[ebp], 0
	lea	eax, DWORD PTR $T221827[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221823[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T221823[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221823[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T221923 = -52						; size = 4
$T221912 = -48						; size = 4
$T221911 = -44						; size = 4
__Cat$221919 = -40					; size = 1
$T221917 = -39						; size = 1
__Ptr$210227 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$210227[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221923[ebp], edx
	mov	eax, DWORD PTR $T221923[ebp]
	mov	DWORD PTR $T221912[ebp], eax
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR $T221911[ebp], ecx
	mov	dl, BYTE PTR __Cat$221919[ebp]
	mov	BYTE PTR $T221917[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T221946 = -26						; size = 1
$T221945 = -25						; size = 1
$T221944 = -24						; size = 4
$T221943 = -20						; size = 4
__Off$221939 = -16					; size = 4
__Result$221940 = -12					; size = 4
__Cat$221931 = -4					; size = 1
$T221928 = -3						; size = 1
$T221927 = -2						; size = 1
$T221926 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T221926[ebp], al
	mov	cl, BYTE PTR __Cat$221931[ebp]
	mov	BYTE PTR $T221927[ebp], cl
	mov	dl, BYTE PTR $T221926[ebp]
	mov	BYTE PTR $T221946[ebp], dl
	mov	al, BYTE PTR $T221928[ebp]
	mov	BYTE PTR $T221945[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T221944[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T221943[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T221943[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$221939[ebp], eax
	mov	ecx, DWORD PTR __Off$221939[ebp]
	mov	edx, DWORD PTR $T221944[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$221940[ebp], eax
	cmp	DWORD PTR __Off$221939[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$221939[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T221943[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$221939[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T221944[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$221940[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T222500 = -412						; size = 4
$T222448 = -368						; size = 4
$T222436 = -364						; size = 4
$T222426 = -357						; size = 1
$T222425 = -356						; size = 4
__Cat$222443 = -327					; size = 1
$T222440 = -326						; size = 1
$T222439 = -325						; size = 1
$T222397 = -324						; size = 4
$T222389 = -320						; size = 4
$T222381 = -316						; size = 4
$T222370 = -312						; size = 4
$T222369 = -308						; size = 4
__Cat$222376 = -302					; size = 1
$T222374 = -301						; size = 1
$T222298 = -276						; size = 4
$T222279 = -272						; size = 4
$T222262 = -265						; size = 1
$T222261 = -264						; size = 4
$T222251 = -260						; size = 4
$T222250 = -256						; size = 4
__Cat$222293 = -250					; size = 1
$T222290 = -249						; size = 1
$T222289 = -248						; size = 1
__Cat$222286 = -247					; size = 1
$T222283 = -246						; size = 1
$T222282 = -245						; size = 1
$T222226 = -244						; size = 4
$T222225 = -240						; size = 4
$T222221 = -236						; size = 4
$T222220 = -232						; size = 4
$T222209 = -228						; size = 4
$T222208 = -224						; size = 4
__Cat$222216 = -218					; size = 1
$T222214 = -217						; size = 1
$T222173 = -216						; size = 4
$T222172 = -212						; size = 4
__Cat$222180 = -206					; size = 1
$T222178 = -205						; size = 1
$T222143 = -204						; size = 4
$T222142 = -200						; size = 4
__Cat$222150 = -194					; size = 1
$T222148 = -193						; size = 1
$T222123 = -192						; size = 4
$T222111 = -188						; size = 4
$T222101 = -181						; size = 1
$T222100 = -180						; size = 4
__Cat$222119 = -175					; size = 1
$T222116 = -174						; size = 1
$T222115 = -173						; size = 1
$T222088 = -172						; size = 4
$T222076 = -168						; size = 4
$T222066 = -161						; size = 1
$T222065 = -160						; size = 4
__Cat$222084 = -155					; size = 1
$T222081 = -154						; size = 1
$T222080 = -153						; size = 1
$T222053 = -152						; size = 4
$T222041 = -148						; size = 4
$T222031 = -141						; size = 1
$T222030 = -140						; size = 4
__Cat$222049 = -135					; size = 1
$T222047 = -134						; size = 1
$T222046 = -133						; size = 1
__Count$222004 = -120					; size = 4
__Count$221978 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$221978[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221978[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$221978[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$222004[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$222004[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$222004[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T222053[ebp], edx
	mov	eax, DWORD PTR $T222053[ebp]
	mov	DWORD PTR $T222041[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222046[ebp], cl
	mov	dl, BYTE PTR __Cat$222049[ebp]
	mov	BYTE PTR $T222047[ebp], dl
	mov	al, BYTE PTR $T222046[ebp]
	mov	BYTE PTR $T222031[ebp], al
	mov	ecx, DWORD PTR $T222041[ebp]
	mov	DWORD PTR $T222030[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222030[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222088[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T222076[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222080[ebp], al
	mov	cl, BYTE PTR __Cat$222084[ebp]
	mov	BYTE PTR $T222081[ebp], cl
	mov	dl, BYTE PTR $T222080[ebp]
	mov	BYTE PTR $T222066[ebp], dl
	mov	eax, DWORD PTR $T222076[ebp]
	mov	DWORD PTR $T222065[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222065[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222088[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222123[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222111[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T222115[ebp], dl
	mov	al, BYTE PTR __Cat$222119[ebp]
	mov	BYTE PTR $T222116[ebp], al
	mov	cl, BYTE PTR $T222115[ebp]
	mov	BYTE PTR $T222101[ebp], cl
	mov	edx, DWORD PTR $T222111[ebp]
	mov	DWORD PTR $T222100[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222100[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222123[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T222143[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T222142[ebp], ecx
	mov	dl, BYTE PTR __Cat$222150[ebp]
	mov	BYTE PTR $T222148[ebp], dl
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T222173[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222172[ebp], ecx
	mov	dl, BYTE PTR __Cat$222180[ebp]
	mov	BYTE PTR $T222178[ebp], dl
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T222221[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T222220[ebp], edx
	mov	eax, DWORD PTR $T222221[ebp]
	mov	DWORD PTR $T222209[ebp], eax
	mov	ecx, DWORD PTR $T222220[ebp]
	mov	DWORD PTR $T222208[ebp], ecx
	mov	dl, BYTE PTR __Cat$222216[ebp]
	mov	BYTE PTR $T222214[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T222226[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222225[ebp], ecx
	mov	edx, DWORD PTR $T222225[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T222298[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T222279[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222282[ebp], cl
	mov	dl, BYTE PTR __Cat$222286[ebp]
	mov	BYTE PTR $T222283[ebp], dl
	mov	al, BYTE PTR $T222282[ebp]
	mov	BYTE PTR $T222262[ebp], al
	mov	ecx, DWORD PTR $T222279[ebp]
	mov	DWORD PTR $T222261[ebp], ecx
	mov	edx, DWORD PTR $T222261[ebp]
	mov	DWORD PTR $T222251[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222250[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222289[ebp], cl
	mov	dl, BYTE PTR __Cat$222293[ebp]
	mov	BYTE PTR $T222290[ebp], dl
	movzx	eax, BYTE PTR $T222289[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T222290[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T222251[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222298[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222250[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T222381[ebp], eax
	mov	ecx, DWORD PTR $T222381[ebp]
	mov	DWORD PTR $T222370[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222369[ebp], ecx
	mov	dl, BYTE PTR __Cat$222376[ebp]
	mov	BYTE PTR $T222374[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T222397[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222389[ebp], edx
	jmp	SHORT $LN151@Insert_n@2
$LN150@Insert_n@2:
	mov	eax, DWORD PTR $T222389[ebp]
	add	eax, 4
	mov	DWORD PTR $T222389[ebp], eax
$LN151@Insert_n@2:
	mov	ecx, DWORD PTR $T222389[ebp]
	cmp	ecx, DWORD PTR $T222397[ebp]
	je	SHORT $LN147@Insert_n@2
	mov	edx, DWORD PTR $T222389[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@2
$LN147@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T222448[ebp], eax
	mov	ecx, DWORD PTR $T222448[ebp]
	mov	DWORD PTR $T222436[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T222439[ebp], dl
	mov	al, BYTE PTR __Cat$222443[ebp]
	mov	BYTE PTR $T222440[ebp], al
	mov	cl, BYTE PTR $T222439[ebp]
	mov	BYTE PTR $T222426[ebp], cl
	mov	edx, DWORD PTR $T222436[ebp]
	mov	DWORD PTR $T222425[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222425[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222500[ebp], ecx
	jmp	SHORT $LN186@Insert_n@2
$LN185@Insert_n@2:
	mov	edx, DWORD PTR $T222500[ebp]
	add	edx, 4
	mov	DWORD PTR $T222500[ebp], edx
$LN186@Insert_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T222500[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T222500[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T222571 = -40						; size = 4
$T222561 = -33						; size = 1
$T222560 = -32						; size = 4
__Cat$222566 = -3					; size = 1
$T222564 = -2						; size = 1
$T222563 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T222571[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222563[ebp], cl
	mov	dl, BYTE PTR __Cat$222566[ebp]
	mov	BYTE PTR $T222564[ebp], dl
	mov	al, BYTE PTR $T222563[ebp]
	mov	BYTE PTR $T222561[ebp], al
	mov	ecx, DWORD PTR $T222571[ebp]
	mov	DWORD PTR $T222560[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222560[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T222616 = -38						; size = 1
$T222615 = -37						; size = 1
$T222614 = -36						; size = 4
$T222613 = -32						; size = 4
$T222600 = -25						; size = 1
$T222599 = -24						; size = 4
$T222598 = -20						; size = 4
__Off$222608 = -16					; size = 4
__Result$222609 = -12					; size = 4
__Cat$222605 = -8					; size = 1
$T222603 = -7						; size = 1
$T222602 = -6						; size = 1
__Cat$222580 = -4					; size = 1
$T222576 = -3						; size = 1
$T222575 = -2						; size = 1
$T222574 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T222574[ebp], al
	mov	cl, BYTE PTR __Cat$222580[ebp]
	mov	BYTE PTR $T222575[ebp], cl
	mov	dl, BYTE PTR $T222574[ebp]
	mov	BYTE PTR $T222616[ebp], dl
	mov	al, BYTE PTR $T222576[ebp]
	mov	BYTE PTR $T222615[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T222614[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222613[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222602[ebp], al
	mov	cl, BYTE PTR __Cat$222605[ebp]
	mov	BYTE PTR $T222603[ebp], cl
	mov	dl, BYTE PTR $T222602[ebp]
	mov	BYTE PTR $T222600[ebp], dl
	mov	eax, DWORD PTR $T222614[ebp]
	mov	DWORD PTR $T222599[ebp], eax
	mov	ecx, DWORD PTR $T222613[ebp]
	mov	DWORD PTR $T222598[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T222598[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$222608[ebp], edx
	mov	eax, DWORD PTR __Off$222608[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T222599[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$222609[ebp], ecx
	cmp	DWORD PTR __Off$222608[ebp], 0
	jle	SHORT $LN7@Unchecked_@2
	mov	edx, DWORD PTR __Off$222608[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T222598[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$222608[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$222609[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@2:
	mov	eax, DWORD PTR __Result$222609[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T222646 = -22						; size = 1
$T222645 = -21						; size = 1
$T222644 = -20						; size = 4
$T222635 = -13						; size = 1
$T222634 = -12						; size = 4
$T222633 = -8						; size = 4
$T222637 = -4						; size = 1
$T222620 = -2						; size = 1
$T222619 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T222619[ebp], al
	mov	cl, BYTE PTR $T222619[ebp]
	mov	BYTE PTR $T222646[ebp], cl
	mov	dl, BYTE PTR $T222620[ebp]
	mov	BYTE PTR $T222645[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222644[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222637[ebp], cl
	mov	dl, BYTE PTR $T222637[ebp]
	mov	BYTE PTR $T222635[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T222634[ebp], eax
	mov	ecx, DWORD PTR $T222644[ebp]
	mov	DWORD PTR $T222633[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T222634[ebp]
	sub	edx, 1
	mov	DWORD PTR $T222634[ebp], edx
	mov	eax, DWORD PTR $T222633[ebp]
	add	eax, 4
	mov	DWORD PTR $T222633[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T222634[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T222633[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T222663 = -21						; size = 1
$T222662 = -20						; size = 4
$T222661 = -16						; size = 4
__Result$222659 = -12					; size = 4
__Count$222658 = -8					; size = 4
__Cat$222653 = -3					; size = 1
$T222650 = -2						; size = 1
$T222649 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T222649[ebp], al
	mov	cl, BYTE PTR __Cat$222653[ebp]
	mov	BYTE PTR $T222650[ebp], cl
	mov	dl, BYTE PTR $T222649[ebp]
	mov	BYTE PTR $T222663[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T222662[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222661[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T222661[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$222658[ebp], edx
	mov	eax, DWORD PTR __Count$222658[ebp]
	mov	ecx, DWORD PTR $T222662[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$222659[ebp], edx
	cmp	DWORD PTR __Count$222658[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$222658[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T222661[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$222658[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T222662[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$222659[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
