; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMilitaryAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvMilitaryAIStrategyXMLEntry@@6B@		; CvMilitaryAIStrategyXMLEntry::`vftable'
PUBLIC	??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ		; CvMilitaryAIStrategyXMLEntry::CvMilitaryAIStrategyXMLEntry
PUBLIC	?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMilitaryAIStrategyXMLEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z:PROC ; CvMilitaryAIStrategyXMLEntry::`vector deleting destructor'
;	COMDAT ??_7CvMilitaryAIStrategyXMLEntry@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvMilitaryAIStrategyXMLEntry@@6B@ DD FLAT:?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMilitaryAIStrategyXMLEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ$0
__ehfuncinfo$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T229713 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ PROC		; CvMilitaryAIStrategyXMLEntry::CvMilitaryAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvMilitaryAIStrategyXMLEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+276], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+277], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+278], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+284], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+296], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 304				; 00000130H
	mov	DWORD PTR $T229713[ebp], edx
	mov	ecx, DWORD PTR $T229713[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+332], 1

; 39   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntry::CvMilitaryAIStrategyXMLEntry
PUBLIC	??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ		; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z PROC	; CvMilitaryAIStrategyXMLEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ	; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z ENDP	; CvMilitaryAIStrategyXMLEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T229782 = -48						; size = 4
$T229777 = -44						; size = 4
$T229772 = -40						; size = 4
$T229767 = -36						; size = 4
$T229762 = -32						; size = 4
$T229757 = -28						; size = 4
$T229752 = -24						; size = 4
$T229747 = -20						; size = 4
$T229742 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T229742[ebp], eax
	mov	ecx, DWORD PTR $T229742[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T229747[ebp], ecx
	mov	ecx, DWORD PTR $T229747[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T229752[ebp], edx
	mov	ecx, DWORD PTR $T229752[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T229757[ebp], eax
	mov	ecx, DWORD PTR $T229757[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T229762[ebp], ecx
	mov	ecx, DWORD PTR $T229762[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T229767[ebp], edx
	mov	ecx, DWORD PTR $T229767[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T229772[ebp], eax
	mov	ecx, DWORD PTR $T229772[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T229777[ebp], ecx
	mov	ecx, DWORD PTR $T229777[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T229782[ebp], edx
	mov	ecx, DWORD PTR $T229782[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ$0
__ehfuncinfo$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T229815 = -40						; size = 4
$T229810 = -36						; size = 4
$T229809 = -32						; size = 4
$T229804 = -28						; size = 4
$T229803 = -24						; size = 4
$T229798 = -20						; size = 4
$T229797 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ PROC		; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvMilitaryAIStrategyXMLEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 43   : 	SAFE_DELETE_ARRAY(m_piPlayerFlavorValue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	mov	DWORD PTR $T229798[ebp], ecx
	mov	edx, DWORD PTR $T229798[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T229797[ebp], eax
	mov	ecx, DWORD PTR $T229797[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T229798[ebp]
	mov	DWORD PTR [edx], 0

; 44   : 	SAFE_DELETE_ARRAY(m_piCityFlavorValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 264				; 00000108H
	mov	DWORD PTR $T229804[ebp], eax
	mov	ecx, DWORD PTR $T229804[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T229803[ebp], edx
	mov	eax, DWORD PTR $T229803[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T229804[ebp]
	mov	DWORD PTR [ecx], 0

; 45   : 	SAFE_DELETE_ARRAY(m_piPersonalityFlavorThresholdMod);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 272				; 00000110H
	mov	DWORD PTR $T229810[ebp], edx
	mov	eax, DWORD PTR $T229810[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T229809[ebp], ecx
	mov	edx, DWORD PTR $T229809[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T229810[ebp]
	mov	DWORD PTR [eax], 0

; 46   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 304				; 00000130H
	mov	DWORD PTR $T229815[ebp], ecx
	mov	ecx, DWORD PTR $T229815[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry
PUBLIC	??_C@_0DC@NJJCPLHN@AIMilitaryStrategy_PersonalityFl@ ; `string'
PUBLIC	??_C@_0CA@NDDNGMPC@AIMilitaryStrategy_City_Flavors?$AA@ ; `string'
PUBLIC	??_C@_0CC@BAEECPHN@AIMilitaryStrategy_Player_Flavor@ ; `string'
PUBLIC	??_C@_0BH@MJHABJOE@AIMilitaryStrategyType?$AA@	; `string'
PUBLIC	??_C@_0L@IANCLNMF@TechPrereq?$AA@		; `string'
PUBLIC	??_C@_0N@COMAJFAF@TechObsolete?$AA@		; `string'
PUBLIC	??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@		; `string'
PUBLIC	??_C@_07IMKJABN@SCIENCE?$AA@			; `string'
PUBLIC	??_C@_07OLAKHONA@FOREIGN?$AA@			; `string'
PUBLIC	??_C@_08LKDCODGK@ECONOMIC?$AA@			; `string'
PUBLIC	??_C@_08EBHPNIPO@MILITARY?$AA@			; `string'
PUBLIC	??_C@_07GOECOJOI@Advisor?$AA@			; `string'
PUBLIC	??_C@_0BA@BKBCAEL@WeightThreshold?$AA@		; `string'
PUBLIC	??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@	; `string'
PUBLIC	??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@	; `string'
PUBLIC	??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@	; `string'
PUBLIC	??_C@_0BK@EOGJDIMK@UpdateCitySpecializations?$AA@ ; `string'
PUBLIC	??_C@_0O@NKJGDEJ@OnlyMinorCivs?$AA@		; `string'
PUBLIC	??_C@_0M@PGLGACOH@NoMinorCivs?$AA@		; `string'
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0DC@NJJCPLHN@AIMilitaryStrategy_PersonalityFl@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
CONST	SEGMENT
??_C@_0DC@NJJCPLHN@AIMilitaryStrategy_PersonalityFl@ DB 'AIMilitaryStrate'
	DB	'gy_PersonalityFlavorThresholdMods', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NDDNGMPC@AIMilitaryStrategy_City_Flavors?$AA@
CONST	SEGMENT
??_C@_0CA@NDDNGMPC@AIMilitaryStrategy_City_Flavors?$AA@ DB 'AIMilitaryStr'
	DB	'ategy_City_Flavors', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BAEECPHN@AIMilitaryStrategy_Player_Flavor@
CONST	SEGMENT
??_C@_0CC@BAEECPHN@AIMilitaryStrategy_Player_Flavor@ DB 'AIMilitaryStrate'
	DB	'gy_Player_Flavors', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJHABJOE@AIMilitaryStrategyType?$AA@
CONST	SEGMENT
??_C@_0BH@MJHABJOE@AIMilitaryStrategyType?$AA@ DB 'AIMilitaryStrategyType'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IANCLNMF@TechPrereq?$AA@
CONST	SEGMENT
??_C@_0L@IANCLNMF@TechPrereq?$AA@ DB 'TechPrereq', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@COMAJFAF@TechObsolete?$AA@
CONST	SEGMENT
??_C@_0N@COMAJFAF@TechObsolete?$AA@ DB 'TechObsolete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@
CONST	SEGMENT
??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@ DB 'AdvisorCounsel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMKJABN@SCIENCE?$AA@
CONST	SEGMENT
??_C@_07IMKJABN@SCIENCE?$AA@ DB 'SCIENCE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLAKHONA@FOREIGN?$AA@
CONST	SEGMENT
??_C@_07OLAKHONA@FOREIGN?$AA@ DB 'FOREIGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LKDCODGK@ECONOMIC?$AA@
CONST	SEGMENT
??_C@_08LKDCODGK@ECONOMIC?$AA@ DB 'ECONOMIC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBHPNIPO@MILITARY?$AA@
CONST	SEGMENT
??_C@_08EBHPNIPO@MILITARY?$AA@ DB 'MILITARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOECOJOI@Advisor?$AA@
CONST	SEGMENT
??_C@_07GOECOJOI@Advisor?$AA@ DB 'Advisor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BKBCAEL@WeightThreshold?$AA@
CONST	SEGMENT
??_C@_0BA@BKBCAEL@WeightThreshold?$AA@ DB 'WeightThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@
CONST	SEGMENT
??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@ DB 'MinimumNumTurnsExecut'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@
CONST	SEGMENT
??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@ DB 'FirstTurnExecuted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@
CONST	SEGMENT
??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@ DB 'CheckTriggerTurnCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EOGJDIMK@UpdateCitySpecializations?$AA@
CONST	SEGMENT
??_C@_0BK@EOGJDIMK@UpdateCitySpecializations?$AA@ DB 'UpdateCitySpecializ'
	DB	'ations', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKJGDEJ@OnlyMinorCivs?$AA@
CONST	SEGMENT
??_C@_0O@NKJGDEJ@OnlyMinorCivs?$AA@ DB 'OnlyMinorCivs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGLGACOH@NoMinorCivs?$AA@
CONST	SEGMENT
??_C@_0M@PGLGACOH@NoMinorCivs?$AA@ DB 'NoMinorCivs', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv160 = -104						; size = 4
tv334 = -100						; size = 4
tv329 = -94						; size = 1
tv322 = -93						; size = 1
tv317 = -92						; size = 4
tv319 = -88						; size = 4
tv154 = -84						; size = 4
tv311 = -80						; size = 4
tv306 = -74						; size = 1
tv299 = -73						; size = 1
tv294 = -72						; size = 4
tv296 = -68						; size = 4
tv148 = -64						; size = 4
tv288 = -60						; size = 4
tv283 = -54						; size = 1
tv276 = -53						; size = 1
tv271 = -52						; size = 4
tv273 = -48						; size = 4
tv142 = -44						; size = 4
tv265 = -40						; size = 4
tv260 = -34						; size = 1
tv253 = -33						; size = 1
tv248 = -32						; size = 4
tv250 = -28						; size = 4
_this$ = -24						; size = 4
$T229885 = -20						; size = 4
$T229884 = -16						; size = 4
_szType$ = -12						; size = 4
_strAdvisor$ = -8					; size = 4
_szTextVal$ = -4					; size = 4
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvMilitaryAIStrategyXMLEntry::CacheResults, COMDAT
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@CacheResul

; 51   : 		return false;

	xor	al, al
	jmp	$LN10@CacheResul
$LN9@CacheResul:

; 52   : 
; 53   : 	//Basic Properties
; 54   : 	m_bNoMinorCivs				 = kResults.GetBool("NoMinorCivs");

	push	OFFSET ??_C@_0M@PGLGACOH@NoMinorCivs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+276], al

; 55   : 	m_bOnlyMinorCivs		     = kResults.GetBool("OnlyMinorCivs");

	push	OFFSET ??_C@_0O@NKJGDEJ@OnlyMinorCivs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+277], al

; 56   : 	m_bUpdateCitySpecializations = kResults.GetBool("UpdateCitySpecializations");

	push	OFFSET ??_C@_0BK@EOGJDIMK@UpdateCitySpecializations?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+278], al

; 57   : 	m_iCheckTriggerTurnCount	 = kResults.GetInt("CheckTriggerTurnCount");

	push	OFFSET ??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 58   : 	m_iFirstTurnExecuted            = kResults.GetInt("FirstTurnExecuted");

	push	OFFSET ??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 59   : 	m_iMinimumNumTurnsExecuted	 = kResults.GetInt("MinimumNumTurnsExecuted");

	push	OFFSET ??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], eax

; 60   : 	m_iWeightThreshold			 = kResults.GetInt("WeightThreshold");

	push	OFFSET ??_C@_0BA@BKBCAEL@WeightThreshold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 61   : 
; 62   : 	const char* strAdvisor = kResults.GetText("Advisor");

	push	OFFSET ??_C@_07GOECOJOI@Advisor?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _strAdvisor$[ebp], eax

; 63   : 	m_eAdvisor = NO_ADVISOR_TYPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], -1

; 64   : 	if(strAdvisor)

	cmp	DWORD PTR _strAdvisor$[ebp], 0
	je	$LN8@CacheResul

; 65   : 	{
; 66   : 		if(strcmp(strAdvisor, "MILITARY") == 0)

	mov	DWORD PTR tv250[ebp], OFFSET ??_C@_08EBHPNIPO@MILITARY?$AA@
	mov	eax, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv248[ebp], eax
$LL18@CacheResul:
	mov	ecx, DWORD PTR tv248[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv253[ebp], dl
	mov	eax, DWORD PTR tv250[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN19@CacheResul
	cmp	BYTE PTR tv253[ebp], 0
	je	SHORT $LN20@CacheResul
	mov	ecx, DWORD PTR tv248[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv260[ebp], dl
	mov	eax, DWORD PTR tv250[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN19@CacheResul
	add	DWORD PTR tv248[ebp], 2
	add	DWORD PTR tv250[ebp], 2
	cmp	BYTE PTR tv260[ebp], 0
	jne	SHORT $LL18@CacheResul
$LN20@CacheResul:
	mov	DWORD PTR tv265[ebp], 0
	jmp	SHORT $LN21@CacheResul
$LN19@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv265[ebp], ecx
$LN21@CacheResul:
	mov	edx, DWORD PTR tv265[ebp]
	mov	DWORD PTR tv142[ebp], edx
	cmp	DWORD PTR tv142[ebp], 0
	jne	SHORT $LN7@CacheResul

; 67   : 		{
; 68   : 			m_eAdvisor = ADVISOR_MILITARY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+300], 0
	jmp	$LN8@CacheResul
$LN7@CacheResul:

; 69   : 		}
; 70   : 		else if(strcmp(strAdvisor, "ECONOMIC") == 0)

	mov	DWORD PTR tv273[ebp], OFFSET ??_C@_08LKDCODGK@ECONOMIC?$AA@
	mov	ecx, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv271[ebp], ecx
$LL22@CacheResul:
	mov	edx, DWORD PTR tv271[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv276[ebp], al
	mov	ecx, DWORD PTR tv273[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN23@CacheResul
	cmp	BYTE PTR tv276[ebp], 0
	je	SHORT $LN24@CacheResul
	mov	edx, DWORD PTR tv271[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv283[ebp], al
	mov	ecx, DWORD PTR tv273[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN23@CacheResul
	add	DWORD PTR tv271[ebp], 2
	add	DWORD PTR tv273[ebp], 2
	cmp	BYTE PTR tv283[ebp], 0
	jne	SHORT $LL22@CacheResul
$LN24@CacheResul:
	mov	DWORD PTR tv288[ebp], 0
	jmp	SHORT $LN25@CacheResul
$LN23@CacheResul:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv288[ebp], edx
$LN25@CacheResul:
	mov	eax, DWORD PTR tv288[ebp]
	mov	DWORD PTR tv148[ebp], eax
	cmp	DWORD PTR tv148[ebp], 0
	jne	SHORT $LN5@CacheResul

; 71   : 		{
; 72   : 			m_eAdvisor = ADVISOR_ECONOMIC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], 1
	jmp	$LN8@CacheResul
$LN5@CacheResul:

; 73   : 		}
; 74   : 		else if(strcmp(strAdvisor, "FOREIGN") == 0)

	mov	DWORD PTR tv296[ebp], OFFSET ??_C@_07OLAKHONA@FOREIGN?$AA@
	mov	edx, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv294[ebp], edx
$LL26@CacheResul:
	mov	eax, DWORD PTR tv294[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv299[ebp], cl
	mov	edx, DWORD PTR tv296[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN27@CacheResul
	cmp	BYTE PTR tv299[ebp], 0
	je	SHORT $LN28@CacheResul
	mov	eax, DWORD PTR tv294[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv306[ebp], cl
	mov	edx, DWORD PTR tv296[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN27@CacheResul
	add	DWORD PTR tv294[ebp], 2
	add	DWORD PTR tv296[ebp], 2
	cmp	BYTE PTR tv306[ebp], 0
	jne	SHORT $LL26@CacheResul
$LN28@CacheResul:
	mov	DWORD PTR tv311[ebp], 0
	jmp	SHORT $LN29@CacheResul
$LN27@CacheResul:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv311[ebp], eax
$LN29@CacheResul:
	mov	ecx, DWORD PTR tv311[ebp]
	mov	DWORD PTR tv154[ebp], ecx
	cmp	DWORD PTR tv154[ebp], 0
	jne	SHORT $LN3@CacheResul

; 75   : 		{
; 76   : 			m_eAdvisor = ADVISOR_FOREIGN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 2
	jmp	SHORT $LN8@CacheResul
$LN3@CacheResul:

; 77   : 		}
; 78   : 		else if(strcmp(strAdvisor, "SCIENCE") == 0)

	mov	DWORD PTR tv319[ebp], OFFSET ??_C@_07IMKJABN@SCIENCE?$AA@
	mov	eax, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv317[ebp], eax
$LL30@CacheResul:
	mov	ecx, DWORD PTR tv317[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv322[ebp], dl
	mov	eax, DWORD PTR tv319[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN31@CacheResul
	cmp	BYTE PTR tv322[ebp], 0
	je	SHORT $LN32@CacheResul
	mov	ecx, DWORD PTR tv317[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv329[ebp], dl
	mov	eax, DWORD PTR tv319[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN31@CacheResul
	add	DWORD PTR tv317[ebp], 2
	add	DWORD PTR tv319[ebp], 2
	cmp	BYTE PTR tv329[ebp], 0
	jne	SHORT $LL30@CacheResul
$LN32@CacheResul:
	mov	DWORD PTR tv334[ebp], 0
	jmp	SHORT $LN33@CacheResul
$LN31@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv334[ebp], ecx
$LN33@CacheResul:
	mov	edx, DWORD PTR tv334[ebp]
	mov	DWORD PTR tv160[ebp], edx
	cmp	DWORD PTR tv160[ebp], 0
	jne	SHORT $LN8@CacheResul

; 79   : 		{
; 80   : 			m_eAdvisor = ADVISOR_SCIENCE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+300], 3
$LN8@CacheResul:

; 81   : 		}
; 82   : 	}
; 83   : 
; 84   : 	m_strAdvisorCounselText = kResults.GetText("AdvisorCounsel");

	push	OFFSET ??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR $T229885[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 304				; 00000130H
	mov	DWORD PTR $T229884[ebp], ecx
	cmp	DWORD PTR $T229885[ebp], 0
	je	SHORT $LN13@CacheResul
	mov	edx, DWORD PTR $T229885[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229884[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@CacheResul
$LN13@CacheResul:
	mov	ecx, DWORD PTR $T229884[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@CacheResul:

; 85   : 
; 86   : 	//References
; 87   : 	const char* szTextVal = NULL;

	mov	DWORD PTR _szTextVal$[ebp], 0

; 88   : 	szTextVal = kResults.GetText("TechObsolete");

	push	OFFSET ??_C@_0N@COMAJFAF@TechObsolete?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 89   : 	m_iTechObsolete = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 90   : 
; 91   : 	szTextVal = kResults.GetText("TechPrereq");

	push	OFFSET ??_C@_0L@IANCLNMF@TechPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 92   : 	m_iTechPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 93   : 
; 94   : 	//Arrays
; 95   : 	const char* szType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szType$[ebp], eax

; 96   : 	kUtility.SetFlavors(m_piPlayerFlavorValue, "AIMilitaryStrategy_Player_Flavors",
; 97   : 	                    "AIMilitaryStrategyType", szType);

	push	0
	mov	edx, DWORD PTR _szType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@MJHABJOE@AIMilitaryStrategyType?$AA@
	push	OFFSET ??_C@_0CC@BAEECPHN@AIMilitaryStrategy_Player_Flavor@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 98   : 	kUtility.SetFlavors(m_piCityFlavorValue, "AIMilitaryStrategy_City_Flavors",
; 99   : 		"AIMilitaryStrategyType", szType);

	push	0
	mov	ecx, DWORD PTR _szType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@MJHABJOE@AIMilitaryStrategyType?$AA@
	push	OFFSET ??_C@_0CA@NDDNGMPC@AIMilitaryStrategy_City_Flavors?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 264				; 00000108H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 100  : 
; 101  : 
; 102  : 	kUtility.SetFlavors(m_piPersonalityFlavorThresholdMod,
; 103  : 	                    "AIMilitaryStrategy_PersonalityFlavorThresholdMods",
; 104  : 	                    "AIMilitaryStrategyType", szType);

	push	0
	mov	eax, DWORD PTR _szType$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@MJHABJOE@AIMilitaryStrategyType?$AA@
	push	OFFSET ??_C@_0DC@NJJCPLHN@AIMilitaryStrategy_PersonalityFl@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 105  : 
; 106  : 	return true;

	mov	al, 1
$LN10@CacheResul:

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvMilitaryAIStrategyXMLEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z PROC ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue, COMDAT
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 113  : 	FAssertMsg(i > -1, "Index out of bounds");
; 114  : 	return m_piPlayerFlavorValue ? m_piPlayerFlavorValue[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN3@GetPlayerF
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPlayerF
$LN3@GetPlayerF:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPlayerF:
	mov	eax, DWORD PTR tv69[ebp]

; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue
_TEXT	ENDS
PUBLIC	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z PROC ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue, COMDAT
; _this$ = ecx

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 121  : 	FAssertMsg(i > -1, "Index out of bounds");
; 122  : 	return m_piCityFlavorValue ? m_piCityFlavorValue[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+264], 0
	je	SHORT $LN3@GetCityFla
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCityFla
$LN3@GetCityFla:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCityFla:
	mov	eax, DWORD PTR tv69[ebp]

; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
_TEXT	ENDS
PUBLIC	?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold
; Function compile flags: /Odtp
;	COMDAT ?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold, COMDAT
; _this$ = ecx

; 127  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 	return m_iWeightThreshold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 129  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold
_TEXT	ENDS
PUBLIC	?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
; Function compile flags: /Odtp
;	COMDAT ?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z PROC ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod, COMDAT
; _this$ = ecx

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 135  : 	FAssertMsg(i > -1, "Index out of bounds");
; 136  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+272], 0
	je	SHORT $LN3@GetPersona
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPersona
$LN3@GetPersona:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPersona:
	mov	eax, DWORD PTR tv69[ebp]

; 137  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
_TEXT	ENDS
PUBLIC	?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs
; Function compile flags: /Odtp
;	COMDAT ?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ PROC ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs, COMDAT
; _this$ = ecx

; 141  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 	return m_bNoMinorCivs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+276]

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs
_TEXT	ENDS
PUBLIC	?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs
; Function compile flags: /Odtp
;	COMDAT ?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ PROC ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 	return m_bOnlyMinorCivs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+277]

; 149  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs
_TEXT	ENDS
PUBLIC	?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate
; Function compile flags: /Odtp
;	COMDAT ?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ PROC ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	return m_bUpdateCitySpecializations;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+278]

; 155  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 159  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
; Function compile flags: /Odtp
;	COMDAT ?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete, COMDAT
; _this$ = ecx

; 165  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 	return m_iTechObsolete;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
_TEXT	ENDS
PUBLIC	?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
; Function compile flags: /Odtp
;	COMDAT ?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted, COMDAT
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 	return m_iMinimumNumTurnsExecuted;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 173  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
_TEXT	ENDS
PUBLIC	?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount
; Function compile flags: /Odtp
;	COMDAT ?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount, COMDAT
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 	return m_iCheckTriggerTurnCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 179  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount
_TEXT	ENDS
PUBLIC	?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted
; Function compile flags: /Odtp
;	COMDAT ?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted, COMDAT
; _this$ = ecx

; 183  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 	return m_iFirstTurnExecuted;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 185  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted
_TEXT	ENDS
PUBLIC	?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ; CvMilitaryAIStrategyXMLEntry::GetAdvisor
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ PROC ; CvMilitaryAIStrategyXMLEntry::GetAdvisor, COMDAT
; _this$ = ecx

; 188  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 	return m_eAdvisor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 190  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetAdvisor
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselText
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselText, COMDAT
; _this$ = ecx

; 193  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 194  : 	return m_strAdvisorCounselText.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 304				; 00000130H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 195  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselText
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselImportance
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselImportance, COMDAT
; _this$ = ecx

; 198  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 	return m_iAdvisorCounselImportance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]

; 200  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselImportance
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy
PUBLIC	??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ	; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T229974 = -30						; size = 1
$T229961 = -29						; size = 1
$T229957 = -28						; size = 4
$T229950 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ PROC		; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 207  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T229974[ebp]
	mov	DWORD PTR $T229950[ebp], eax
	lea	ecx, DWORD PTR $T229961[ebp]
	mov	DWORD PTR $T229957[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 208  : 
; 209  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries
PUBLIC	??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ ; CvMilitaryAIStrategyXMLEntries::DeleteArray
PUBLIC	??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ	; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ PROC		; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 213  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 214  : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ ; CvMilitaryAIStrategyXMLEntries::DeleteArray

; 215  : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
__unwindfunclet$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
PUBLIC	?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
; Function compile flags: /Odtp
;	COMDAT ?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries, COMDAT
; _this$ = ecx

; 219  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 	return m_paAIStrategyEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
_TEXT	ENDS
PUBLIC	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
; Function compile flags: /Odtp
;	COMDAT ?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ PROC ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies, COMDAT
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 	return m_paAIStrategyEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ENDP ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv145 = -116						; size = 4
_this$ = -112						; size = 4
$T230210 = -56						; size = 4
$T230194 = -52						; size = 4
$T230315 = -48						; size = 4
$T230314 = -44						; size = 4
$T230313 = -40						; size = 4
$T230312 = -36						; size = 4
$T230311 = -32						; size = 4
$T230178 = -28						; size = 4
$T230175 = -24						; size = 4
$T230174 = -20						; size = 4
$T230144 = -16						; size = 4
$T230120 = -12						; size = 4
$T230110 = -8						; size = 4
_it$224867 = -4						; size = 4
?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ PROC ; CvMilitaryAIStrategyXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 	for(std::vector<CvMilitaryAIStrategyXMLEntry*>::iterator it = m_paAIStrategyEntries.begin(); it != m_paAIStrategyEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230120[ebp], ecx
	mov	edx, DWORD PTR $T230120[ebp]
	mov	DWORD PTR _it$224867[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$224867[ebp]
	add	eax, 4
	mov	DWORD PTR _it$224867[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230144[ebp], edx
	mov	eax, DWORD PTR $T230144[ebp]
	mov	DWORD PTR $T230110[ebp], eax
	mov	ecx, DWORD PTR _it$224867[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T230110[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 233  : 	{
; 234  : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$224867[ebp]
	mov	DWORD PTR $T230178[ebp], edx
	mov	eax, DWORD PTR $T230178[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230175[ebp], ecx
	mov	edx, DWORD PTR $T230175[ebp]
	mov	DWORD PTR $T230174[ebp], edx
	cmp	DWORD PTR $T230174[ebp], 0
	je	SHORT $LN32@DeleteArra
	push	1
	mov	eax, DWORD PTR $T230174[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T230174[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv145[ebp], 0
$LN33@DeleteArra:
	mov	ecx, DWORD PTR $T230178[ebp]
	mov	DWORD PTR [ecx], 0

; 235  : 	}

	jmp	SHORT $LN2@DeleteArra
$LN1@DeleteArra:

; 236  : 
; 237  : 	m_paAIStrategyEntries.clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230194[ebp], eax
	mov	ecx, DWORD PTR $T230194[ebp]
	mov	DWORD PTR $T230312[ebp], ecx
	mov	edx, DWORD PTR $T230312[ebp]
	mov	DWORD PTR $T230311[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230210[ebp], ecx
	mov	edx, DWORD PTR $T230210[ebp]
	mov	DWORD PTR $T230314[ebp], edx
	mov	eax, DWORD PTR $T230314[ebp]
	mov	DWORD PTR $T230313[ebp], eax
	mov	ecx, DWORD PTR $T230311[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230313[ebp]
	push	edx
	lea	eax, DWORD PTR $T230315[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ ENDP ; CvMilitaryAIStrategyXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ; CvMilitaryAIStrategyXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z PROC ; CvMilitaryAIStrategyXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 242  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 	return m_paAIStrategyEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ENDP ; CvMilitaryAIStrategyXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??0CvMilitaryAI@@QAE@XZ				; CvMilitaryAI::CvMilitaryAI
; Function compile flags: /Odtp
;	COMDAT ??0CvMilitaryAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvMilitaryAI@@QAE@XZ PROC				; CvMilitaryAI::CvMilitaryAI, COMDAT
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 264  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvMilitaryAI@@QAE@XZ ENDP				; CvMilitaryAI::CvMilitaryAI
_TEXT	ENDS
PUBLIC	?Uninit@CvMilitaryAI@@QAEXXZ			; CvMilitaryAI::Uninit
PUBLIC	??1CvMilitaryAI@@QAE@XZ				; CvMilitaryAI::~CvMilitaryAI
; Function compile flags: /Odtp
;	COMDAT ??1CvMilitaryAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvMilitaryAI@@QAE@XZ PROC				; CvMilitaryAI::~CvMilitaryAI, COMDAT
; _this$ = ecx

; 268  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvMilitaryAI@@QAEXXZ		; CvMilitaryAI::Uninit

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvMilitaryAI@@QAE@XZ ENDP				; CvMilitaryAI::~CvMilitaryAI
_TEXT	ENDS
PUBLIC	?Reset@CvMilitaryAI@@QAEXXZ			; CvMilitaryAI::Reset
PUBLIC	?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z ; CvMilitaryAI::Init
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp
;	COMDAT ?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T230349 = -32						; size = 4
$T230345 = -28						; size = 4
$T230344 = -24						; size = 4
$T230343 = -20						; size = 4
$T230342 = -16						; size = 4
$T230341 = -12						; size = 4
$T230340 = -8						; size = 4
$T230339 = -4						; size = 4
_pAIStrategies$ = 8					; size = 4
_pPlayer$ = 12						; size = 4
_pDiplomacyAI$ = 16					; size = 4
?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z PROC ; CvMilitaryAI::Init, COMDAT
; _this$ = ecx

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 	// Store off the pointer to the AIStrategies active for this game
; 276  : 	m_pAIStrategies = pAIStrategies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pAIStrategies$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 277  : 	m_pPlayer = pPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [edx], eax

; 278  : 	m_pDiplomacyAI = pDiplomacyAI;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pDiplomacyAI$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 279  : 
; 280  : 	// Initialize arrays
; 281  : 	CvAssertMsg(m_pabUsingStrategy==NULL, "about to leak memory, CvMilitaryAI::m_pabUsingStrategy");
; 282  : 	m_pabUsingStrategy = FNEW(bool[m_pAIStrategies->GetNumMilitaryAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230339[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T230339[ebp]
	mov	DWORD PTR [ecx+12], edx

; 283  : 
; 284  : 	CvAssertMsg(m_paiTurnStrategyAdopted==NULL, "about to leak memory, CvMilitaryAI::m_paiTurnStrategyAdopted");
; 285  : 	m_paiTurnStrategyAdopted = FNEW(int[m_pAIStrategies->GetNumMilitaryAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230340[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T230340[ebp]
	mov	DWORD PTR [eax+16], ecx

; 286  : 
; 287  : 	CvAssertMsg(m_aiTempFlavors==NULL, "about to leak memory, CvMilitaryAI::m_aiTempFlavors");
; 288  : 	m_aiTempFlavors = FNEW(int[GC.getNumFlavorTypes()], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T230349[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T230349[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230341[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T230341[ebp]
	mov	DWORD PTR [eax+20], ecx

; 289  : 
; 290  : 	CvAssertMsg(m_paeLastTurnWarState==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnWarState");
; 291  : 	m_paeLastTurnWarState = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230342[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T230342[ebp]
	mov	DWORD PTR [edx+24], eax

; 292  : 
; 293  : 	CvAssertMsg(m_paeLastTurnMilitaryThreat==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnMilitaryThreat");
; 294  : 	m_paeLastTurnMilitaryThreat = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230343[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T230343[ebp]
	mov	DWORD PTR [ecx+28], edx

; 295  : 
; 296  : 	CvAssertMsg(m_paeLastTurnMilitaryStrength==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnMilitaryStrength");
; 297  : 	m_paeLastTurnMilitaryStrength = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230344[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T230344[ebp]
	mov	DWORD PTR [eax+32], ecx

; 298  : 
; 299  : 	CvAssertMsg(m_paeLastTurnTargetValue==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnTargetValue");
; 300  : 	m_paeLastTurnTargetValue = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230345[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T230345[ebp]
	mov	DWORD PTR [edx+36], eax

; 301  : 
; 302  : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvMilitaryAI@@QAEXXZ		; CvMilitaryAI::Reset

; 303  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z ENDP ; CvMilitaryAI::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T230393 = -56						; size = 4
$T230392 = -52						; size = 4
$T230387 = -48						; size = 4
$T230386 = -44						; size = 4
$T230381 = -40						; size = 4
$T230380 = -36						; size = 4
$T230375 = -32						; size = 4
$T230374 = -28						; size = 4
$T230369 = -24						; size = 4
$T230368 = -20						; size = 4
$T230363 = -16						; size = 4
$T230362 = -12						; size = 4
$T230357 = -8						; size = 4
$T230356 = -4						; size = 4
?Uninit@CvMilitaryAI@@QAEXXZ PROC			; CvMilitaryAI::Uninit, COMDAT
; _this$ = ecx

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 	SAFE_DELETE_ARRAY(m_pabUsingStrategy);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T230357[ebp], eax
	mov	ecx, DWORD PTR $T230357[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230356[ebp], edx
	mov	eax, DWORD PTR $T230356[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230357[ebp]
	mov	DWORD PTR [ecx], 0

; 309  : 	SAFE_DELETE_ARRAY(m_paiTurnStrategyAdopted);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T230363[ebp], edx
	mov	eax, DWORD PTR $T230363[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230362[ebp], ecx
	mov	edx, DWORD PTR $T230362[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230363[ebp]
	mov	DWORD PTR [eax], 0

; 310  : 	SAFE_DELETE_ARRAY(m_aiTempFlavors);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T230369[ebp], ecx
	mov	edx, DWORD PTR $T230369[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230368[ebp], eax
	mov	ecx, DWORD PTR $T230368[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230369[ebp]
	mov	DWORD PTR [edx], 0

; 311  : 	SAFE_DELETE_ARRAY(m_paeLastTurnWarState);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T230375[ebp], eax
	mov	ecx, DWORD PTR $T230375[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230374[ebp], edx
	mov	eax, DWORD PTR $T230374[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230375[ebp]
	mov	DWORD PTR [ecx], 0

; 312  : 	SAFE_DELETE_ARRAY(m_paeLastTurnMilitaryThreat);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T230381[ebp], edx
	mov	eax, DWORD PTR $T230381[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230380[ebp], ecx
	mov	edx, DWORD PTR $T230380[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230381[ebp]
	mov	DWORD PTR [eax], 0

; 313  : 	SAFE_DELETE_ARRAY(m_paeLastTurnMilitaryStrength);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T230387[ebp], ecx
	mov	edx, DWORD PTR $T230387[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230386[ebp], eax
	mov	ecx, DWORD PTR $T230386[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230387[ebp]
	mov	DWORD PTR [edx], 0

; 314  : 	SAFE_DELETE_ARRAY(m_paeLastTurnTargetValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR $T230393[ebp], eax
	mov	ecx, DWORD PTR $T230393[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230392[ebp], edx
	mov	eax, DWORD PTR $T230392[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230393[ebp]
	mov	DWORD PTR [ecx], 0

; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvMilitaryAI@@QAEXXZ ENDP			; CvMilitaryAI::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?Reset@CvMilitaryAI@@QAEXXZ PROC			; CvMilitaryAI::Reset, COMDAT
; _this$ = ecx

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 	int iI;
; 321  : 
; 322  : 	m_iTotalThreatWeight = 1;  // Don't ever assume there is no threat at all

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 1

; 323  : 	m_eArmyTypeBeingBuilt = NO_ARMY_TYPE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], -1

; 324  : 
; 325  : 	m_iNumLandUnits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 326  : 	m_iNumRangedLandUnits = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 327  : 	m_iNumMobileLandUnits = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 328  : 	m_iNumAirUnits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 329  : 	m_iNumAntiAirUnits = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 330  : 	m_iNumMeleeLandUnits = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 331  : 	m_iNumNavalUnits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 332  : 	m_iNumLandUnitsInArmies = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 333  : 	m_iNumNavalUnitsInArmies = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 334  : 	m_iBarbarianCampCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 0

; 335  : 	m_iVisibleBarbarianCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 336  : 	m_iRecommendedMilitarySize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 337  : 	m_iMandatoryReserveSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0

; 338  : 	m_eLandDefenseState = NO_DEFENSE_STATE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], -1

; 339  : 	m_eNavalDefenseState = NO_DEFENSE_STATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], -1

; 340  : 	m_iNumberOfTimesOpsBuildSkippedOver = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 341  : 
; 342  : 	for(iI = 0; iI < m_pAIStrategies->GetNumMilitaryAIStrategies(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN4@Reset

; 343  : 	{
; 344  : 		m_pabUsingStrategy[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 345  : 		m_paiTurnStrategyAdopted[iI] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 346  : 		m_paeLastTurnWarState[iI] = NO_WAR_STATE_TYPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 347  : 		m_paeLastTurnMilitaryThreat[iI] = NO_THREAT_VALUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 348  : 		m_paeLastTurnMilitaryStrength[iI] = NO_STRENGTH_VALUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 349  : 		m_paeLastTurnTargetValue[iI] = NO_TARGET_VALUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1
	jmp	SHORT $LN2@Reset
$LN4@Reset:

; 350  : 	}
; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvMilitaryAI@@QAEXXZ ENDP			; CvMilitaryAI::Reset
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
PUBLIC	?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z	; CvMilitaryAI::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T230438 = -92						; size = 4
$T230434 = -88						; size = 4
$T230430 = -84						; size = 4
$T230426 = -80						; size = 4
$T230422 = -76						; size = 4
$T230421 = -72						; size = 4
$T230417 = -68						; size = 4
$T230416 = -64						; size = 4
_wrapm_paiTurnStrategyAdopted$ = -60			; size = 8
_wrapm_paeLastTurnTargetValue$ = -52			; size = 8
_uiVersion$ = -44					; size = 4
_wrapm_pabUsingStrategy$ = -40				; size = 8
_wrapm_paeLastTurnWarState$ = -32			; size = 8
_temp$ = -24						; size = 4
_wrapm_paeLastTurnMilitaryThreat$ = -20			; size = 8
_wrapm_paeLastTurnMilitaryStrength$ = -12		; size = 8
_iNumStrategies$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z PROC		; CvMilitaryAI::Read, COMDAT
; _this$ = ecx

; 355  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 	// Version number to maintain backwards compatibility
; 357  : 	uint uiVersion;
; 358  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 359  : 
; 360  : 	FAssertMsg(m_pAIStrategies != NULL && m_pAIStrategies->GetNumMilitaryAIStrategies() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 361  : 	kStream >> m_iTotalThreatWeight;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 362  : 
; 363  : 	int temp;
; 364  : 	kStream >> temp;

	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 365  : 	m_eArmyTypeBeingBuilt = (ArmyType)temp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 366  : 
; 367  : 	kStream >> m_iNumberOfTimesOpsBuildSkippedOver;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 368  : 
; 369  : 	int iNumStrategies;
; 370  : 	kStream >> iNumStrategies;

	lea	eax, DWORD PTR _iNumStrategies$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 371  : #ifdef _MSC_VER
; 372  : #pragma warning ( push )
; 373  : #pragma warning ( disable : 6011 ) // dereferencing null : no recovery during load, go ahead and crash here.
; 374  : #endif//_MSC_VER
; 375  : 	ArrayWrapper<bool> wrapm_pabUsingStrategy(iNumStrategies, m_pabUsingStrategy);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T230417[ebp], edx
	mov	eax, DWORD PTR _iNumStrategies$[ebp]
	mov	DWORD PTR $T230416[ebp], eax
	mov	ecx, DWORD PTR $T230417[ebp]
	mov	DWORD PTR _wrapm_pabUsingStrategy$[ebp], ecx
	mov	edx, DWORD PTR $T230416[ebp]
	mov	DWORD PTR _wrapm_pabUsingStrategy$[ebp+4], edx

; 376  : #ifdef _MSC_VER
; 377  : #pragma warning ( pop )
; 378  : #endif//_MSC_VER
; 379  : 	kStream >> wrapm_pabUsingStrategy;

	lea	eax, DWORD PTR _wrapm_pabUsingStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 380  : 
; 381  : 	ArrayWrapper<int> wrapm_paiTurnStrategyAdopted(iNumStrategies, m_paiTurnStrategyAdopted);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T230422[ebp], eax
	mov	ecx, DWORD PTR _iNumStrategies$[ebp]
	mov	DWORD PTR $T230421[ebp], ecx
	mov	edx, DWORD PTR $T230422[ebp]
	mov	DWORD PTR _wrapm_paiTurnStrategyAdopted$[ebp], edx
	mov	eax, DWORD PTR $T230421[ebp]
	mov	DWORD PTR _wrapm_paiTurnStrategyAdopted$[ebp+4], eax

; 382  : 	kStream >> wrapm_paiTurnStrategyAdopted;

	lea	ecx, DWORD PTR _wrapm_paiTurnStrategyAdopted$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 383  : 
; 384  : 	ArrayWrapper<int> wrapm_paeLastTurnWarState(MAX_CIV_PLAYERS, m_paeLastTurnWarState);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T230426[ebp], ecx
	mov	edx, DWORD PTR $T230426[ebp]
	mov	DWORD PTR _wrapm_paeLastTurnWarState$[ebp], edx
	mov	DWORD PTR _wrapm_paeLastTurnWarState$[ebp+4], 63 ; 0000003fH

; 385  : 	kStream >> wrapm_paeLastTurnWarState;

	lea	eax, DWORD PTR _wrapm_paeLastTurnWarState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 386  : 
; 387  : 	ArrayWrapper<int> wrapm_paeLastTurnMilitaryThreat(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryThreat);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T230430[ebp], eax
	mov	ecx, DWORD PTR $T230430[ebp]
	mov	DWORD PTR _wrapm_paeLastTurnMilitaryThreat$[ebp], ecx
	mov	DWORD PTR _wrapm_paeLastTurnMilitaryThreat$[ebp+4], 63 ; 0000003fH

; 388  : 	kStream >> wrapm_paeLastTurnMilitaryThreat;

	lea	edx, DWORD PTR _wrapm_paeLastTurnMilitaryThreat$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 389  : 
; 390  : 	ArrayWrapper<int> wrapm_paeLastTurnMilitaryStrength(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryStrength);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T230434[ebp], edx
	mov	eax, DWORD PTR $T230434[ebp]
	mov	DWORD PTR _wrapm_paeLastTurnMilitaryStrength$[ebp], eax
	mov	DWORD PTR _wrapm_paeLastTurnMilitaryStrength$[ebp+4], 63 ; 0000003fH

; 391  : 	kStream >> wrapm_paeLastTurnMilitaryStrength;

	lea	ecx, DWORD PTR _wrapm_paeLastTurnMilitaryStrength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 392  : 
; 393  : 	ArrayWrapper<int> wrapm_paeLastTurnTargetValue(MAX_CIV_PLAYERS, m_paeLastTurnTargetValue);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR $T230438[ebp], ecx
	mov	edx, DWORD PTR $T230438[ebp]
	mov	DWORD PTR _wrapm_paeLastTurnTargetValue$[ebp], edx
	mov	DWORD PTR _wrapm_paeLastTurnTargetValue$[ebp+4], 63 ; 0000003fH

; 394  : 	kStream >> wrapm_paeLastTurnTargetValue;

	lea	eax, DWORD PTR _wrapm_paeLastTurnTargetValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 395  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z ENDP		; CvMilitaryAI::Read
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
PUBLIC	?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z	; CvMilitaryAI::Write
EXTRN	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumMilitaryAIStrategyInfos
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T230489 = -92						; size = 4
$T230485 = -88						; size = 4
$T230481 = -84						; size = 4
$T230477 = -80						; size = 4
$T230473 = -76						; size = 4
$T230472 = -72						; size = 4
$T230468 = -68						; size = 4
$T230467 = -64						; size = 4
$T230448 = -60						; size = 8
$T230447 = -52						; size = 8
$T230446 = -44						; size = 8
$T230445 = -36						; size = 8
$T230444 = -28						; size = 8
$T230443 = -20						; size = 8
$T230442 = -12						; size = 4
$T230441 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z PROC	; CvMilitaryAI::Write, COMDAT
; _this$ = ecx

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 400  : 	// Current version number
; 401  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 402  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 403  : 
; 404  : 	FAssertMsg(GC.getNumMilitaryAIStrategyInfos() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 405  : 	kStream << m_iTotalThreatWeight;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 406  : 	kStream << (int)m_eArmyTypeBeingBuilt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230441[ebp], eax
	lea	ecx, DWORD PTR $T230441[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 407  : 	kStream << m_iNumberOfTimesOpsBuildSkippedOver;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 408  : 	kStream << GC.getNumMilitaryAIStrategyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMilitaryAIStrategyInfos
	mov	DWORD PTR $T230442[ebp], eax
	lea	eax, DWORD PTR $T230442[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 409  : 	kStream << ArrayWrapper<bool>(m_pAIStrategies->GetNumMilitaryAIStrategies(), m_pabUsingStrategy);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T230468[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
	mov	DWORD PTR $T230467[ebp], eax
	mov	ecx, DWORD PTR $T230468[ebp]
	mov	DWORD PTR $T230443[ebp], ecx
	mov	edx, DWORD PTR $T230467[ebp]
	mov	DWORD PTR $T230443[ebp+4], edx
	lea	eax, DWORD PTR $T230443[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 410  : 	kStream << ArrayWrapper<int>(m_pAIStrategies->GetNumMilitaryAIStrategies(), m_paiTurnStrategyAdopted);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T230473[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
	mov	DWORD PTR $T230472[ebp], eax
	mov	edx, DWORD PTR $T230473[ebp]
	mov	DWORD PTR $T230444[ebp], edx
	mov	eax, DWORD PTR $T230472[ebp]
	mov	DWORD PTR $T230444[ebp+4], eax
	lea	ecx, DWORD PTR $T230444[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 411  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnWarState);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T230477[ebp], ecx
	mov	edx, DWORD PTR $T230477[ebp]
	mov	DWORD PTR $T230445[ebp], edx
	mov	DWORD PTR $T230445[ebp+4], 63		; 0000003fH
	lea	eax, DWORD PTR $T230445[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 412  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryThreat);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T230481[ebp], eax
	mov	ecx, DWORD PTR $T230481[ebp]
	mov	DWORD PTR $T230446[ebp], ecx
	mov	DWORD PTR $T230446[ebp+4], 63		; 0000003fH
	lea	edx, DWORD PTR $T230446[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 413  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryStrength);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T230485[ebp], edx
	mov	eax, DWORD PTR $T230485[ebp]
	mov	DWORD PTR $T230447[ebp], eax
	mov	DWORD PTR $T230447[ebp+4], 63		; 0000003fH
	lea	ecx, DWORD PTR $T230447[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 414  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnTargetValue);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR $T230489[ebp], ecx
	mov	edx, DWORD PTR $T230489[ebp]
	mov	DWORD PTR $T230448[ebp], edx
	mov	DWORD PTR $T230448[ebp+4], 63		; 0000003fH
	lea	eax, DWORD PTR $T230448[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 415  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z ENDP	; CvMilitaryAI::Write
_TEXT	ENDS
PUBLIC	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ	; CvMilitaryAI::GetPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ PROC	; CvMilitaryAI::GetPlayer, COMDAT
; _this$ = ecx

; 419  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 420  : 	return m_pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 421  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ENDP	; CvMilitaryAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
; Function compile flags: /Odtp
;	COMDAT ?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ PROC ; CvMilitaryAI::GetMilitaryAIStrategies, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 426  : 	return m_pAIStrategies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ENDP ; CvMilitaryAI::GetMilitaryAIStrategies
_TEXT	ENDS
PUBLIC	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
; Function compile flags: /Odtp
;	COMDAT ?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z PROC ; CvMilitaryAI::IsUsingStrategy, COMDAT
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	return m_pabUsingStrategy[(int) eStrategy];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ENDP ; CvMilitaryAI::IsUsingStrategy
_TEXT	ENDS
PUBLIC	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
PUBLIC	?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z ; CvMilitaryAI::SetTurnStrategyAdopted
PUBLIC	?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::SetUsingStrategy
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Odtp
;	COMDAT ?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T230501 = -4						; size = 4
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z PROC ; CvMilitaryAI::SetUsingStrategy, COMDAT
; _this$ = ecx

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 438  : 	if(m_pabUsingStrategy[eStrategy] != bValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN4@SetUsingSt

; 439  : 	{
; 440  : 		m_pabUsingStrategy[eStrategy] = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 441  : 
; 442  : 		if(bValue)

	movzx	eax, BYTE PTR _bValue$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetUsingSt

; 443  : 		{
; 444  : 			SetTurnStrategyAdopted(eStrategy, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230501[ebp], ecx
	mov	ecx, DWORD PTR $T230501[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z ; CvMilitaryAI::SetTurnStrategyAdopted

; 445  : 		}
; 446  : 		else

	jmp	SHORT $LN1@SetUsingSt
$LN2@SetUsingSt:

; 447  : 		{
; 448  : 			SetTurnStrategyAdopted(eStrategy, -1);

	push	-1
	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z ; CvMilitaryAI::SetTurnStrategyAdopted
$LN1@SetUsingSt:

; 449  : 		}
; 450  : 
; 451  : 		LogStrategy(eStrategy, bValue);

	movzx	ecx, BYTE PTR _bValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
$LN4@SetUsingSt:

; 452  : 	}
; 453  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z ENDP ; CvMilitaryAI::SetUsingStrategy
_TEXT	ENDS
PUBLIC	?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::GetTurnStrategyAdopted
; Function compile flags: /Odtp
;	COMDAT ?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z PROC ; CvMilitaryAI::GetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return m_paiTurnStrategyAdopted[(int) eStrategy];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z ENDP ; CvMilitaryAI::GetTurnStrategyAdopted
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z PROC ; CvMilitaryAI::SetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 463  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 	if(m_paiTurnStrategyAdopted[(int) eStrategy] != iValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _iValue$[ebp]
	je	SHORT $LN2@SetTurnStr

; 465  : 	{
; 466  : 		m_paiTurnStrategyAdopted[(int) eStrategy] = iValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _eStrategy$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN2@SetTurnStr:

; 467  : 	}
; 468  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z ENDP ; CvMilitaryAI::SetTurnStrategyAdopted
_TEXT	ENDS
PUBLIC	?LogAvailableForces@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::LogAvailableForces
PUBLIC	?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::LogMilitaryStatus
PUBLIC	?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::DisbandObsoleteUnits
PUBLIC	?RequestImprovements@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::RequestImprovements
PUBLIC	?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::MakeOffensivePurchases
PUBLIC	?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::MakeEmergencyPurchases
PUBLIC	?UpdateOperations@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateOperations
PUBLIC	?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateMilitaryStrategies
PUBLIC	?UpdateDefenseState@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateDefenseState
PUBLIC	?UpdateBaseData@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateBaseData
PUBLIC	?UpdateWars@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateWars
PUBLIC	?UpdateThreats@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateThreats
PUBLIC	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::ScanForBarbarians
PUBLIC	?DoTurn@CvMilitaryAI@@QAEXXZ			; CvMilitaryAI::DoTurn
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Odtp
;	COMDAT ?DoTurn@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T230511 = -4						; size = 4
?DoTurn@CvMilitaryAI@@QAEXXZ PROC			; CvMilitaryAI::DoTurn, COMDAT
; _this$ = ecx

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 473  : 	AI_PERF_FORMAT("AI-perf.csv", ("MilitaryAI DoTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 474  : 
; 475  : 	ScanForBarbarians();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::ScanForBarbarians

; 476  : 	UpdateThreats();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateThreats@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateThreats

; 477  : 	UpdateWars();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateWars@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateWars

; 478  : 	UpdateBaseData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateBaseData@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateBaseData

; 479  : 	UpdateDefenseState();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateDefenseState@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::UpdateDefenseState

; 480  : 	UpdateMilitaryStrategies();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::UpdateMilitaryStrategies

; 481  : 
; 482  : 	if(!m_pPlayer->isHuman())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@DoTurn

; 483  : 	{
; 484  : 		UpdateOperations();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateOperations@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateOperations

; 485  : 		MakeEmergencyPurchases();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::MakeEmergencyPurchases

; 486  : 		MakeOffensivePurchases();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::MakeOffensivePurchases

; 487  : 		RequestImprovements();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestImprovements@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::RequestImprovements

; 488  : 		DisbandObsoleteUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::DisbandObsoleteUnits
$LN2@DoTurn:

; 489  : 	}
; 490  : 
; 491  : 	LogMilitaryStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::LogMilitaryStatus

; 492  : 
; 493  : 	if(GetArmyBeingBuilt() != NO_ARMY_TYPE)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230511[ebp], eax
	cmp	DWORD PTR $T230511[ebp], -1
	je	SHORT $LN3@DoTurn

; 494  : 	{
; 495  : 		LogAvailableForces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogAvailableForces@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::LogAvailableForces
$LN3@DoTurn:

; 496  : 	}
; 497  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvMilitaryAI@@QAEXXZ ENDP			; CvMilitaryAI::DoTurn
_TEXT	ENDS
PUBLIC	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
PUBLIC	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
PUBLIC	?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestSneakAttack
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z:PROC ; CvPlayer::addAIOperation
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::haveAIOperationOfType
; Function compile flags: /Odtp
;	COMDAT ?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv174 = -80						; size = 4
_this$ = -76						; size = 4
$T230532 = -72						; size = 4
$T230528 = -68						; size = 4
$T230527 = -64						; size = 4
$T230523 = -60						; size = 4
$T230514 = -56						; size = 24
_pOperation$ = -32					; size = 4
_target$ = -28						; size = 24
_iOperationID$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestSneakAttack, COMDAT
; _this$ = ecx

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 502  : 	CvMilitaryTarget target;

	mov	DWORD PTR _target$[ebp], 0
	mov	DWORD PTR _target$[ebp+4], 0
	mov	DWORD PTR _target$[ebp+8], 0
	mov	DWORD PTR _target$[ebp+12], 0
	mov	DWORD PTR _target$[ebp+16], 0
	mov	BYTE PTR _target$[ebp+20], 0

; 503  : 	CvAIOperation* pOperation = 0;

	mov	DWORD PTR _pOperation$[ebp], 0

; 504  : 	int iOperationID;
; 505  : 
; 506  : 	// Let's only allow us to be sneak attacking one opponent at a time, so abort if already have one of these operations active against any opponent
; 507  : 	if (m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_SNEAK_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[ebp]
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@RequestSne

; 508  : 	{
; 509  : 		return false;

	xor	al, al
	jmp	$LN12@RequestSne
$LN11@RequestSne:

; 510  : 	}
; 511  : 	if (m_pPlayer->haveAIOperationOfType(AI_OPERATION_SNEAK_CITY_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@RequestSne

; 512  : 	{
; 513  : 		return false;

	xor	al, al
	jmp	$LN12@RequestSne
$LN10@RequestSne:

; 514  : 	}
; 515  : 
; 516  : 	target = FindBestAttackTarget(AI_OPERATION_SNEAK_CITY_ATTACK, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	push	6
	lea	ecx, DWORD PTR $T230514[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _target$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[ebp+20], eax

; 517  : 	if(target.m_pTargetCity)

	cmp	DWORD PTR _target$[ebp], 0
	je	$LN9@RequestSne

; 518  : 	{
; 519  : 		if(target.m_bAttackBySea)

	movzx	ecx, BYTE PTR _target$[ebp+20]
	test	ecx, ecx
	je	$LN8@RequestSne

; 520  : 		{
; 521  : 			if(IsAttackReady(MUFORMATION_NAVAL_INVASION, AI_OPERATION_NAVAL_SNEAK_ATTACK))

	push	14					; 0000000eH
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@RequestSne

; 522  : 			{
; 523  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SNEAK_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	eax, DWORD PTR _target$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	push	14					; 0000000eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 524  : 				if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN6@RequestSne
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@RequestSne

; 525  : 				{
; 526  : 					return true;

	mov	al, 1
	jmp	$LN12@RequestSne
$LN6@RequestSne:

; 527  : 				}
; 528  : 			}
; 529  : 			else

	jmp	SHORT $LN5@RequestSne
$LN7@RequestSne:

; 530  : 			{
; 531  : 				m_iNumNavalAttacksRequested++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 532  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+104]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+108]
	setle	dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], edx
$LN5@RequestSne:

; 533  : 			}
; 534  : 		}
; 535  : 		else

	jmp	$LN9@RequestSne
$LN8@RequestSne:

; 536  : 		{
; 537  : 			if(IsAttackReady((GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE, AI_OPERATION_SNEAK_CITY_ATTACK))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230523[ebp], ecx
	mov	ecx, DWORD PTR $T230523[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T230527[ebp], eax
	mov	edx, DWORD PTR $T230527[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T230528[ebp], eax
	cmp	DWORD PTR $T230528[ebp], 4
	jle	SHORT $LN14@RequestSne
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230532[ebp], ecx
	mov	ecx, DWORD PTR $T230532[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN14@RequestSne
	mov	DWORD PTR tv174[ebp], 18		; 00000012H
	jmp	SHORT $LN15@RequestSne
$LN14@RequestSne:
	mov	DWORD PTR tv174[ebp], 0
$LN15@RequestSne:
	push	6
	mov	edx, DWORD PTR tv174[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RequestSne

; 538  : 			{
; 539  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_SNEAK_CITY_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	ecx, DWORD PTR _target$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 540  : 				if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN2@RequestSne
	mov	edx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@RequestSne

; 541  : 				{
; 542  : 					return true;

	mov	al, 1
	jmp	SHORT $LN12@RequestSne
$LN2@RequestSne:

; 543  : 				}
; 544  : 			}
; 545  : 			else

	jmp	SHORT $LN9@RequestSne
$LN3@RequestSne:

; 546  : 			{
; 547  : 				m_iNumLandAttacksRequested++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], edx

; 548  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+104]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+108]
	setle	cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], ecx
$LN9@RequestSne:

; 549  : 			}
; 550  : 		}
; 551  : 	}
; 552  : 	return false;

	xor	al, al
$LN12@RequestSne:

; 553  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestSneakAttack
_TEXT	ENDS
PUBLIC	?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestShowOfForce
; Function compile flags: /Odtp
;	COMDAT ?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T230535 = -56						; size = 24
_pOperation$225120 = -32				; size = 4
_pOperation$225117 = -28				; size = 4
_target$ = -24						; size = 24
_eEnemy$ = 8						; size = 4
?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestShowOfForce, COMDAT
; _this$ = ecx

; 557  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 558  : 	CvMilitaryTarget target;

	mov	DWORD PTR _target$[ebp], 0
	mov	DWORD PTR _target$[ebp+4], 0
	mov	DWORD PTR _target$[ebp+8], 0
	mov	DWORD PTR _target$[ebp+12], 0
	mov	DWORD PTR _target$[ebp+16], 0
	mov	BYTE PTR _target$[ebp+20], 0

; 559  : 
; 560  : 	target = FindBestAttackTarget(AI_OPERATION_SNEAK_CITY_ATTACK, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	push	6
	lea	ecx, DWORD PTR $T230535[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _target$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[ebp+20], eax

; 561  : 	if(target.m_pTargetCity)

	cmp	DWORD PTR _target$[ebp], 0
	je	$LN5@RequestSho

; 562  : 	{
; 563  : 		if (target.m_bAttackBySea)

	movzx	ecx, BYTE PTR _target$[ebp+20]
	test	ecx, ecx
	je	SHORT $LN4@RequestSho

; 564  : 		{
; 565  : 			CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SNEAK_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	edx, DWORD PTR _target$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	push	ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$225117[ebp], eax

; 566  : 			if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$225117[ebp], 0
	je	SHORT $LN3@RequestSho
	mov	eax, DWORD PTR _pOperation$225117[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$225117[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@RequestSho

; 567  : 			{
; 568  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@RequestSho
$LN3@RequestSho:

; 569  : 			}
; 570  : 		}
; 571  : 		else

	jmp	SHORT $LN5@RequestSho
$LN4@RequestSho:

; 572  : 		{
; 573  : 			CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_SMALL_CITY_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	edx, DWORD PTR _target$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$225120[ebp], eax

; 574  : 			if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$225120[ebp], 0
	je	SHORT $LN5@RequestSho
	mov	eax, DWORD PTR _pOperation$225120[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$225120[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@RequestSho

; 575  : 			{
; 576  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@RequestSho
$LN5@RequestSho:

; 577  : 			}
; 578  : 		}
; 579  : 	}
; 580  : 
; 581  : 	return false;

	xor	al, al
$LN6@RequestSho:

; 582  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestShowOfForce
_TEXT	ENDS
PUBLIC	?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestNukeAttack
EXTRN	?getNumNukeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumNukeUnits
; Function compile flags: /Odtp
;	COMDAT ?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T230544 = -8						; size = 4
_pOperation$225127 = -4					; size = 4
_eEnemy$ = 8						; size = 4
?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestNukeAttack, COMDAT
; _this$ = ecx

; 587  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 588  : 	if(m_pPlayer->getNumNukeUnits() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jle	SHORT $LN2@RequestNuk

; 589  : 	{
; 590  : 		CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NUKE_ATTACK, eEnemy);

	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	push	ecx
	push	17					; 00000011H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$225127[ebp], eax

; 591  : 		if(pOperation != NULL && pOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)

	cmp	DWORD PTR _pOperation$225127[ebp], 0
	je	SHORT $LN2@RequestNuk
	mov	eax, DWORD PTR _pOperation$225127[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T230544[ebp], ecx
	cmp	DWORD PTR $T230544[ebp], 0
	je	SHORT $LN2@RequestNuk

; 592  : 		{
; 593  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@RequestNuk
$LN2@RequestNuk:

; 594  : 		}
; 595  : 	}
; 596  : 
; 597  : 	return false;

	xor	al, al
$LN3@RequestNuk:

; 598  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestNukeAttack
_TEXT	ENDS
PUBLIC	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
PUBLIC	?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestPillageAttack
; Function compile flags: /Odtp
;	COMDAT ?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T230551 = -20						; size = 4
_pOperation$225137 = -16				; size = 4
_iNumRequiredSlots$ = -12				; size = 4
_iLandReservesUsed$ = -8				; size = 4
_iFilledSlots$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestPillageAttack, COMDAT
; _this$ = ecx

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 	int iNumRequiredSlots = 0;

	mov	DWORD PTR _iNumRequiredSlots$[ebp], 0

; 605  : 	int iLandReservesUsed = 0;

	mov	DWORD PTR _iLandReservesUsed$[ebp], 0

; 606  : 	int iFilledSlots = 0;

	mov	DWORD PTR _iFilledSlots$[ebp], 0

; 607  : 	iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_FAST_PILLAGERS, false, &iNumRequiredSlots, &iLandReservesUsed);

	lea	eax, DWORD PTR _iLandReservesUsed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	ecx
	push	0
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 608  : 	if(iFilledSlots >= iNumRequiredSlots && iLandReservesUsed <= GetLandReservesAvailable())

	mov	ecx, DWORD PTR _iFilledSlots$[ebp]
	cmp	ecx, DWORD PTR _iNumRequiredSlots$[ebp]
	jl	SHORT $LN2@RequestPil
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T230551[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+52]
	sub	eax, DWORD PTR [edx+72]
	sub	eax, DWORD PTR $T230551[ebp]
	cmp	DWORD PTR _iLandReservesUsed$[ebp], eax
	jg	SHORT $LN2@RequestPil

; 609  : 	{
; 610  : 		CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_PILLAGE_ENEMY, eEnemy);

	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$225137[ebp], eax

; 611  : 		if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$225137[ebp], 0
	je	SHORT $LN2@RequestPil
	mov	eax, DWORD PTR _pOperation$225137[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$225137[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@RequestPil

; 612  : 		{
; 613  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@RequestPil
$LN2@RequestPil:

; 614  : 		}
; 615  : 	}
; 616  : 
; 617  : 	return false;

	xor	al, al
$LN3@RequestPil:

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestPillageAttack
_TEXT	ENDS
PUBLIC	?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ; CvMilitaryAI::RequestSpecificAttack
PUBLIC	?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ; CvMilitaryAI::RequestBasicAttack
; Function compile flags: /Odtp
;	COMDAT ?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T230558 = -48						; size = 24
_target$ = -24						; size = 24
_eEnemy$ = 8						; size = 4
_iNumUnitsWillingBuild$ = 12				; size = 4
?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z PROC ; CvMilitaryAI::RequestBasicAttack, COMDAT
; _this$ = ecx

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 624  : 	CvMilitaryTarget target;

	mov	DWORD PTR _target$[ebp], 0
	mov	DWORD PTR _target$[ebp+4], 0
	mov	DWORD PTR _target$[ebp+8], 0
	mov	DWORD PTR _target$[ebp+12], 0
	mov	DWORD PTR _target$[ebp+16], 0
	mov	BYTE PTR _target$[ebp+20], 0

; 625  : 
; 626  : 	target = FindBestAttackTarget(AI_OPERATION_BASIC_CITY_ATTACK, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR $T230558[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _target$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[ebp+20], eax

; 627  : 	return RequestSpecificAttack(target, iNumUnitsWillingBuild);

	mov	ecx, DWORD PTR _iNumUnitsWillingBuild$[ebp]
	push	ecx
	sub	esp, 24					; 00000018H
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _target$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _target$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _target$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _target$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _target$[ebp+20]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ; CvMilitaryAI::RequestSpecificAttack

; 628  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ENDP ; CvMilitaryAI::RequestBasicAttack
_TEXT	ENDS
PUBLIC	?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ; CvMilitaryAI::RequestPureNavalAttack
; Function compile flags: /Odtp
;	COMDAT ?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T230564 = -64						; size = 24
_pOperation$ = -40					; size = 4
_target$ = -36						; size = 24
_iNumRequiredSlots$ = -12				; size = 4
_iLandReservesUsed$ = -8				; size = 4
_iFilledSlots$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
_iNumUnitsWillingBuild$ = 12				; size = 4
?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z PROC ; CvMilitaryAI::RequestPureNavalAttack, COMDAT
; _this$ = ecx

; 632  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 	CvAIOperation* pOperation = NULL;

	mov	DWORD PTR _pOperation$[ebp], 0

; 634  : 	CvMilitaryTarget target;

	mov	DWORD PTR _target$[ebp], 0
	mov	DWORD PTR _target$[ebp+4], 0
	mov	DWORD PTR _target$[ebp+8], 0
	mov	DWORD PTR _target$[ebp+12], 0
	mov	DWORD PTR _target$[ebp+16], 0
	mov	BYTE PTR _target$[ebp+20], 0

; 635  : 	int iNumRequiredSlots = 0;

	mov	DWORD PTR _iNumRequiredSlots$[ebp], 0

; 636  : 	int iLandReservesUsed = 0;

	mov	DWORD PTR _iLandReservesUsed$[ebp], 0

; 637  : 	int iFilledSlots = 0;

	mov	DWORD PTR _iFilledSlots$[ebp], 0

; 638  : 
; 639  : 	target = FindBestAttackTarget(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	push	18					; 00000012H
	lea	ecx, DWORD PTR $T230564[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _target$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[ebp+20], eax

; 640  : 	if(target.m_pTargetCity)

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN3@RequestPur

; 641  : 	{
; 642  : 		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_PURE_NAVAL_CITY_ATTACK, true, &iNumRequiredSlots, &iLandReservesUsed);

	lea	ecx, DWORD PTR _iLandReservesUsed$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	edx
	push	1
	push	17					; 00000011H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 643  : 		if((iNumRequiredSlots - iFilledSlots) <= iNumUnitsWillingBuild)

	mov	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	sub	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumUnitsWillingBuild$[ebp]
	jg	SHORT $LN2@RequestPur

; 644  : 		{
; 645  : 			pOperation = m_pPlayer->addAIOperation(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	eax, DWORD PTR _target$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	push	18					; 00000012H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax
$LN2@RequestPur:

; 646  : 		}
; 647  : 
; 648  : 		if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN3@RequestPur
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@RequestPur

; 649  : 		{
; 650  : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@RequestPur
$LN3@RequestPur:

; 651  : 		}
; 652  : 	}
; 653  : 	return false;

	xor	al, al
$LN4@RequestPur:

; 654  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ENDP ; CvMilitaryAI::RequestPureNavalAttack
_TEXT	ENDS
PUBLIC	?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestCityStateAttack
; Function compile flags: /Odtp
;	COMDAT ?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T230570 = -52						; size = 24
_pOperation$ = -28					; size = 4
_target$ = -24						; size = 24
_eEnemy$ = 8						; size = 4
?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestCityStateAttack, COMDAT
; _this$ = ecx

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 659  : 	CvMilitaryTarget target;

	mov	DWORD PTR _target$[ebp], 0
	mov	DWORD PTR _target$[ebp+4], 0
	mov	DWORD PTR _target$[ebp+8], 0
	mov	DWORD PTR _target$[ebp+12], 0
	mov	DWORD PTR _target$[ebp+16], 0
	mov	BYTE PTR _target$[ebp+20], 0

; 660  : 	CvAIOperation* pOperation = 0;

	mov	DWORD PTR _pOperation$[ebp], 0

; 661  : 
; 662  : 	target = FindBestAttackTarget(AI_OPERATION_CITY_STATE_ATTACK, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	push	15					; 0000000fH
	lea	ecx, DWORD PTR $T230570[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _target$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[ebp+20], eax

; 663  : 	if(target.m_pTargetCity)

	cmp	DWORD PTR _target$[ebp], 0
	je	$LN9@RequestCit

; 664  : 	{
; 665  : 		if(target.m_bAttackBySea)

	movzx	ecx, BYTE PTR _target$[ebp+20]
	test	ecx, ecx
	je	$LN8@RequestCit

; 666  : 		{
; 667  : 			if(IsAttackReady(MUFORMATION_CITY_STATE_INVASION, AI_OPERATION_CITY_STATE_NAVAL_ATTACK))

	push	16					; 00000010H
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@RequestCit

; 668  : 			{
; 669  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_CITY_STATE_NAVAL_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	eax, DWORD PTR _target$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 670  : 				if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN6@RequestCit
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@RequestCit

; 671  : 				{
; 672  : 					return true;

	mov	al, 1
	jmp	$LN10@RequestCit
$LN6@RequestCit:

; 673  : 				}
; 674  : 			}
; 675  : 			else

	jmp	SHORT $LN5@RequestCit
$LN7@RequestCit:

; 676  : 			{
; 677  : 				m_iNumNavalAttacksRequested++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 678  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+104]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+108]
	setle	dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], edx
$LN5@RequestCit:

; 679  : 			}
; 680  : 		}
; 681  : 		else

	jmp	SHORT $LN4@RequestCit
$LN8@RequestCit:

; 682  : 		{
; 683  : 			if(IsAttackReady(MUFORMATION_CITY_STATE_ATTACK_FORCE, AI_OPERATION_CITY_STATE_ATTACK))

	push	15					; 0000000fH
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@RequestCit

; 684  : 			{
; 685  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_CITY_STATE_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	mov	edx, DWORD PTR _target$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	push	ecx
	push	15					; 0000000fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 686  : 				if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN2@RequestCit
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@RequestCit

; 687  : 				{
; 688  : 					return true;

	mov	al, 1
	jmp	SHORT $LN10@RequestCit
$LN2@RequestCit:

; 689  : 				}
; 690  : 			}
; 691  : 			else

	jmp	SHORT $LN4@RequestCit
$LN3@RequestCit:

; 692  : 			{
; 693  : 				m_iNumLandAttacksRequested++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 694  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+104]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+108]
	setle	dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], edx
$LN4@RequestCit:

; 695  : 			}
; 696  : 		}
; 697  : 
; 698  : 		return true;

	mov	al, 1
	jmp	SHORT $LN10@RequestCit
$LN9@RequestCit:

; 699  : 	}
; 700  : 	return false;

	xor	al, al
$LN10@RequestCit:

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestCityStateAttack
_TEXT	ENDS
PUBLIC	??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@		; `string'
EXTRN	?numOperationsOfType@CvPlayer@@QAEHH@Z:PROC	; CvPlayer::numOperationsOfType
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
;	COMDAT ??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@ DB 'FLAVOR_NAVAL', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z
_TEXT	SEGMENT
tv142 = -80						; size = 4
_this$ = -76						; size = 4
$T230634 = -72						; size = 4
$T230630 = -68						; size = 4
$T230626 = -64						; size = 4
$T230613 = -60						; size = 4
$T230608 = -56						; size = 4
$T230604 = -52						; size = 4
$T230603 = -48						; size = 4
$T230599 = -44						; size = 4
$T230595 = -40						; size = 4
$T230582 = -36						; size = 4
_iMaxOperations$225196 = -32				; size = 4
_iNumBombard$225195 = -28				; size = 4
_iNumSuperiority$225194 = -24				; size = 4
_iFlavorNaval$225191 = -20				; size = 4
_pOperation$ = -16					; size = 4
_iNumRequiredSlots$ = -12				; size = 4
_iLandReservesUsed$ = -8				; size = 4
_iFilledSlots$ = -4					; size = 4
_kTarget$ = 8						; size = 24
_iNumUnitsWillingToBuild$ = 32				; size = 4
?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z PROC ; CvMilitaryAI::RequestSpecificAttack, COMDAT
; _this$ = ecx

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 705  : 	CvAIOperation* pOperation = NULL;

	mov	DWORD PTR _pOperation$[ebp], 0

; 706  : 	int iNumRequiredSlots = 0;

	mov	DWORD PTR _iNumRequiredSlots$[ebp], 0

; 707  : 	int iLandReservesUsed = 0;

	mov	DWORD PTR _iLandReservesUsed$[ebp], 0

; 708  : 	int iFilledSlots = 0;

	mov	DWORD PTR _iFilledSlots$[ebp], 0

; 709  : 
; 710  : 	if(kTarget.m_pTargetCity)

	cmp	DWORD PTR _kTarget$[ebp], 0
	je	$LN9@RequestSpe

; 711  : 	{
; 712  : 		if(kTarget.m_bAttackBySea)

	movzx	eax, BYTE PTR _kTarget$[ebp+20]
	test	eax, eax
	je	SHORT $LN8@RequestSpe

; 713  : 		{
; 714  : 			iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_INVASION, true, &iNumRequiredSlots, &iLandReservesUsed);

	lea	ecx, DWORD PTR _iLandReservesUsed$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 715  : 			if((iNumRequiredSlots - iFilledSlots) <= iNumUnitsWillingToBuild && iLandReservesUsed <= GetLandReservesAvailable())

	mov	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	sub	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumUnitsWillingToBuild$[ebp]
	jg	SHORT $LN7@RequestSpe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T230582[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	sub	ecx, DWORD PTR [eax+72]
	sub	ecx, DWORD PTR $T230582[ebp]
	cmp	DWORD PTR _iLandReservesUsed$[ebp], ecx
	jg	SHORT $LN7@RequestSpe

; 716  : 			{
; 717  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_ATTACK, kTarget.m_pTargetCity->getOwner(), kTarget.m_pTargetCity->getArea(), kTarget.m_pTargetCity, kTarget.m_pMusterCity);

	mov	edx, DWORD PTR _kTarget$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230595[ebp], eax
	mov	ecx, DWORD PTR _kTarget$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _kTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTarget$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	eax, DWORD PTR $T230595[ebp]
	push	eax
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax
$LN7@RequestSpe:

; 718  : 			}
; 719  : 		}
; 720  : 		else

	jmp	$LN6@RequestSpe
$LN8@RequestSpe:

; 721  : 		{
; 722  : 			iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer,(GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE, false, &iNumRequiredSlots, &iLandReservesUsed);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230599[ebp], edx
	mov	ecx, DWORD PTR $T230599[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T230603[ebp], eax
	mov	eax, DWORD PTR $T230603[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230604[ebp], ecx
	cmp	DWORD PTR $T230604[ebp], 4
	jle	SHORT $LN12@RequestSpe
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230608[ebp], edx
	mov	ecx, DWORD PTR $T230608[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN12@RequestSpe
	mov	DWORD PTR tv142[ebp], 18		; 00000012H
	jmp	SHORT $LN13@RequestSpe
$LN12@RequestSpe:
	mov	DWORD PTR tv142[ebp], 0
$LN13@RequestSpe:
	lea	eax, DWORD PTR _iLandReservesUsed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv142[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 723  : 			if((iNumRequiredSlots - iFilledSlots) <= iNumUnitsWillingToBuild && iLandReservesUsed <= GetLandReservesAvailable())

	mov	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	sub	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumUnitsWillingToBuild$[ebp]
	jg	$LN6@RequestSpe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T230613[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	sub	ecx, DWORD PTR [eax+72]
	sub	ecx, DWORD PTR $T230613[ebp]
	cmp	DWORD PTR _iLandReservesUsed$[ebp], ecx
	jg	$LN6@RequestSpe

; 724  : 			{
; 725  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_BASIC_CITY_ATTACK, kTarget.m_pTargetCity->getOwner(), kTarget.m_pTargetCity->getArea(), kTarget.m_pTargetCity, kTarget.m_pMusterCity);

	mov	edx, DWORD PTR _kTarget$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230626[ebp], eax
	mov	ecx, DWORD PTR _kTarget$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _kTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTarget$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	eax, DWORD PTR $T230626[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 726  : 				if (pOperation != NULL && !pOperation->ShouldAbort() && kTarget.m_pTargetCity->isCoastal(GC.getMIN_WATER_SIZE_FOR_OCEAN()))

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	$LN6@RequestSpe
	mov	edx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	$LN6@RequestSpe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6876
	mov	DWORD PTR $T230630[ebp], ecx
	mov	edx, DWORD PTR $T230630[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTarget$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	$LN6@RequestSpe

; 727  : 				{
; 728  : 					int iFlavorNaval = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL"));

	push	0
	push	OFFSET ??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iFlavorNaval$225191[ebp], eax

; 729  : 					int iNumSuperiority = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_SUPERIORITY);

	push	10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType
	mov	DWORD PTR _iNumSuperiority$225194[ebp], eax

; 730  : 					int iNumBombard = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_BOMBARDMENT);

	push	9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType
	mov	DWORD PTR _iNumBombard$225195[ebp], eax

; 731  : 					int iMaxOperations = iFlavorNaval / 2;

	mov	eax, DWORD PTR _iFlavorNaval$225191[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iMaxOperations$225196[ebp], eax

; 732  : 					if(GC.getMap().GetAIMapHint() & 1)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230634[ebp], ecx
	mov	ecx, DWORD PTR $T230634[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	je	SHORT $LN3@RequestSpe

; 733  : 					{
; 734  : 						iMaxOperations *= 2;

	mov	edx, DWORD PTR _iMaxOperations$225196[ebp]
	shl	edx, 1
	mov	DWORD PTR _iMaxOperations$225196[ebp], edx
$LN3@RequestSpe:

; 735  : 					}
; 736  : 					if (iNumSuperiority+iNumBombard <= iMaxOperations)

	mov	eax, DWORD PTR _iNumSuperiority$225194[ebp]
	add	eax, DWORD PTR _iNumBombard$225195[ebp]
	cmp	eax, DWORD PTR _iMaxOperations$225196[ebp]
	jg	SHORT $LN6@RequestSpe

; 737  : 						m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SUPERIORITY, NO_PLAYER);

	push	0
	push	0
	push	-1
	push	-1
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN6@RequestSpe:

; 738  : 				}
; 739  : 			}
; 740  : 		}
; 741  : 
; 742  : 		if(pOperation != NULL && !pOperation->ShouldAbort())

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN9@RequestSpe
	mov	edx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@RequestSpe

; 743  : 		{
; 744  : 			return true;

	mov	al, 1
	jmp	SHORT $LN10@RequestSpe
$LN9@RequestSpe:

; 745  : 		}
; 746  : 	}
; 747  : 	return false;

	xor	al, al
$LN10@RequestSpe:

; 748  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ENDP ; CvMilitaryAI::RequestSpecificAttack
_TEXT	ENDS
PUBLIC	?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetSneakAttackOperation
EXTRN	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z:PROC ; CvPlayer::getAIOperation
; Function compile flags: /Odtp
;	COMDAT ?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bHasOperationOfType$225208 = -6			; size = 1
_bHasOperationUnderway$ = -5				; size = 1
_iOperationID$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetSneakAttackOperation, COMDAT
; _this$ = ecx

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 753  : 	int iOperationID;
; 754  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_SNEAK_CITY_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	6
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$[ebp], al

; 755  : 
; 756  : 	if(bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$[ebp]
	test	eax, eax
	je	SHORT $LN3@GetSneakAt

; 757  : 	{
; 758  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN4@GetSneakAt

; 759  : 	}
; 760  : 	else

	jmp	SHORT $LN2@GetSneakAt
$LN3@GetSneakAt:

; 761  : 	{
; 762  : 		bool bHasOperationOfType = m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_SNEAK_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationOfType$225208[ebp], al

; 763  : 
; 764  : 		if(bHasOperationOfType)

	movzx	eax, BYTE PTR _bHasOperationOfType$225208[ebp]
	test	eax, eax
	je	SHORT $LN2@GetSneakAt

; 765  : 		{
; 766  : 			return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN4@GetSneakAt
$LN2@GetSneakAt:

; 767  : 		}
; 768  : 	}
; 769  : 
; 770  : 	return NULL;

	xor	eax, eax
$LN4@GetSneakAt:

; 771  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetSneakAttackOperation
_TEXT	ENDS
PUBLIC	?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetShowOfForceOperation
; Function compile flags: /Odtp
;	COMDAT ?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bHasOperationUnderway$ = -5				; size = 1
_iOperationID$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetShowOfForceOperation, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 776  : 	int iOperationID;
; 777  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_SMALL_CITY_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$[ebp], al

; 778  : 
; 779  : 	if(bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$[ebp]
	test	eax, eax
	je	SHORT $LN1@GetShowOfF

; 780  : 	{
; 781  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN2@GetShowOfF
$LN1@GetShowOfF:

; 782  : 	}
; 783  : 
; 784  : 	return NULL;

	xor	eax, eax
$LN2@GetShowOfF:

; 785  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetShowOfForceOperation
_TEXT	ENDS
PUBLIC	?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetBasicAttackOperation
; Function compile flags: /Odtp
;	COMDAT ?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bHasOperationOfType$225225 = -6			; size = 1
_bHasOperationUnderway$ = -5				; size = 1
_iOperationID$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetBasicAttackOperation, COMDAT
; _this$ = ecx

; 789  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 790  : 	int iOperationID;
; 791  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$[ebp], al

; 792  : 
; 793  : 	if(bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$[ebp]
	test	eax, eax
	je	SHORT $LN3@GetBasicAt

; 794  : 	{
; 795  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN4@GetBasicAt

; 796  : 	}
; 797  : 	else

	jmp	SHORT $LN2@GetBasicAt
$LN3@GetBasicAt:

; 798  : 	{
; 799  : 		bool bHasOperationOfType = m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationOfType$225225[ebp], al

; 800  : 
; 801  : 		if(bHasOperationOfType)

	movzx	eax, BYTE PTR _bHasOperationOfType$225225[ebp]
	test	eax, eax
	je	SHORT $LN2@GetBasicAt

; 802  : 		{
; 803  : 			return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN4@GetBasicAt
$LN2@GetBasicAt:

; 804  : 		}
; 805  : 	}
; 806  : 
; 807  : 	return NULL;

	xor	eax, eax
$LN4@GetBasicAt:

; 808  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetBasicAttackOperation
_TEXT	ENDS
PUBLIC	?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetCityStateAttackOperation
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bHasOperationOfType$225235 = -6			; size = 1
_bHasOperationUnderway$ = -5				; size = 1
_iOperationID$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetCityStateAttackOperation, COMDAT
; _this$ = ecx

; 812  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 813  : 	int iOperationID;
; 814  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_STATE_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	15					; 0000000fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$[ebp], al

; 815  : 
; 816  : 	if(bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$[ebp]
	test	eax, eax
	je	SHORT $LN3@GetCitySta

; 817  : 	{
; 818  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN4@GetCitySta

; 819  : 	}
; 820  : 	else

	jmp	SHORT $LN2@GetCitySta
$LN3@GetCitySta:

; 821  : 	{
; 822  : 		bool bHasOperationOfType = m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_STATE_NAVAL_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationOfType$225235[ebp], al

; 823  : 
; 824  : 		if(bHasOperationOfType)

	movzx	eax, BYTE PTR _bHasOperationOfType$225235[ebp]
	test	eax, eax
	je	SHORT $LN2@GetCitySta

; 825  : 		{
; 826  : 			return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN4@GetCitySta
$LN2@GetCitySta:

; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	return NULL;

	xor	eax, eax
$LN4@GetCitySta:

; 831  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetCityStateAttackOperation
_TEXT	ENDS
PUBLIC	?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetPureNavalAttackOperation
; Function compile flags: /Odtp
;	COMDAT ?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bHasOperationUnderway$ = -5				; size = 1
_iOperationID$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetPureNavalAttackOperation, COMDAT
; _this$ = ecx

; 835  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 836  : 	int iOperationID;
; 837  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, &iOperationID, eEnemy);

	push	0
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	18					; 00000012H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$[ebp], al

; 838  : 
; 839  : 	if(bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$[ebp]
	test	eax, eax
	je	SHORT $LN1@GetPureNav

; 840  : 	{
; 841  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	jmp	SHORT $LN2@GetPureNav
$LN1@GetPureNav:

; 842  : 	}
; 843  : 
; 844  : 	return NULL;

	xor	eax, eax
$LN2@GetPureNav:

; 845  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetPureNavalAttackOperation
_TEXT	ENDS
PUBLIC	??_C@_0CE@HJDHFKAC@Emergency?5Faith?5Unit?5Purchase?3?5?$CF@ ; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0BP@MDCEEOOC@Emergency?5Unit?5Purchased?3?5?$CFs?0?5?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
EXTRN	?ChangeFaith@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::ChangeFaith
EXTRN	?GetFaithPurchaseCost@CvCity@@QAEHW4UnitTypes@@_N@Z:PROC ; CvCity::GetFaithPurchaseCost
EXTRN	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z:PROC ; CvTacticalAI::LogTacticalMessage
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?setMoves@CvUnit@@QAEXH@Z:PROC			; CvUnit::setMoves
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:PROC ; CvTreasury::LogExpenditure
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?GetText@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetText
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?CreateUnit@CvCity@@QAEHW4UnitTypes@@W4UnitAITypes@@_N@Z:PROC ; CvCity::CreateUnit
EXTRN	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z:PROC ; CvEconomicAI::CanWithdrawMoneyForPurchase
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?GetPurchaseCost@CvCity@@QAEHW4UnitTypes@@@Z:PROC ; CvCity::GetPurchaseCost
EXTRN	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z:PROC ; CvCity::IsCanPurchase
EXTRN	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z:PROC ; CvUnitProductionAI::RecommendUnit
EXTRN	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ:PROC ; CvCityStrategyAI::GetUnitProductionAI
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
;	COMDAT ??_C@_0CE@HJDHFKAC@Emergency?5Faith?5Unit?5Purchase?3?5?$CF@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@HJDHFKAC@Emergency?5Faith?5Unit?5Purchase?3?5?$CF@ DB 'Emergenc'
	DB	'y Faith Unit Purchase: %s, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MDCEEOOC@Emergency?5Unit?5Purchased?3?5?$CFs?0?5?$AA@
CONST	SEGMENT
??_C@_0BP@MDCEEOOC@Emergency?5Unit?5Purchased?3?5?$CFs?0?5?$AA@ DB 'Emerg'
	DB	'ency Unit Purchased: %s, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
tv296 = -240						; size = 4
tv318 = -236						; size = 4
tv292 = -232						; size = 4
tv349 = -228						; size = 4
tv289 = -224						; size = 4
tv307 = -220						; size = 4
_this$ = -216						; size = 4
$T230734 = -212						; size = 4
$T230726 = -208						; size = 4
$T230717 = -204						; size = 4
$T230700 = -200						; size = 4
$T230692 = -196						; size = 4
$T230691 = -192						; size = 4
$T230682 = -188						; size = 4
$T230673 = -184						; size = 4
$T230661 = -180						; size = 4
$T230652 = -176						; size = 4
$T230651 = -172						; size = 28
$T230650 = -144						; size = 4
$T230649 = -140						; size = 28
$T230648 = -112						; size = 4
_pUnit$225273 = -108					; size = 4
_iResult$225272 = -104					; size = 4
_szMsg$225274 = -100					; size = 28
_iFaithCost$225270 = -72				; size = 4
_pUnit$225260 = -68					; size = 4
_szMsg$225264 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_iResult$225258 = -32					; size = 4
_iPriority$225255 = -28					; size = 4
_iGoldCost$225254 = -24					; size = 4
_bIsVenice$ = -17					; size = 1
_eType$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eUnitType$ = 8						; size = 4
_pCity$ = 12						; size = 4
?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z PROC ; CvMilitaryAI::BuyEmergencyUnit, COMDAT
; _this$ = ecx

; 849  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 850  : 	bool bIsVenice = m_pPlayer->GetPlayerTraits()->IsNoAnnexing();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T230661[ebp], eax
	mov	ecx, DWORD PTR $T230661[ebp]
	mov	dl, BYTE PTR [ecx+351]
	mov	BYTE PTR _bIsVenice$[ebp], dl

; 851  : 
; 852  : 	// No units in puppet cities except for Venice!
; 853  : 	if(pCity->IsPuppet() && !bIsVenice)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@BuyEmergen
	movzx	ecx, BYTE PTR _bIsVenice$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@BuyEmergen

; 854  : 	{
; 855  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@BuyEmergen
$LN9@BuyEmergen:

; 856  : 	}
; 857  : 
; 858  : 	// Get best unit with this AI type
; 859  : 	UnitTypes eType = pCity->GetCityStrategyAI()->GetUnitProductionAI()->RecommendUnit(eUnitType);

	mov	edx, DWORD PTR _eUnitType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
	mov	ecx, eax
	call	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit
	mov	DWORD PTR _eType$[ebp], eax

; 860  : 	if(eType != NO_UNIT)

	cmp	DWORD PTR _eType$[ebp], -1
	je	$LN8@BuyEmergen

; 861  : 	{
; 862  : 		// Can we buy the primary unit type at the start city?
; 863  : 		if(pCity->IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eType, NO_BUILDING, NO_PROJECT, YIELD_GOLD))

	push	2
	push	-1
	push	-1
	mov	eax, DWORD PTR _eType$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z ; CvCity::IsCanPurchase
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@BuyEmergen

; 864  : 		{
; 865  : 			int iGoldCost = pCity->GetPurchaseCost(eType);

	mov	edx, DWORD PTR _eType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPurchaseCost@CvCity@@QAEHW4UnitTypes@@@Z ; CvCity::GetPurchaseCost
	mov	DWORD PTR _iGoldCost$225254[ebp], eax

; 866  : 			int iPriority = GC.getAI_GOLD_PRIORITY_UNIT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2092
	mov	DWORD PTR _iPriority$225255[ebp], eax

; 867  : 			if(m_pPlayer->GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_UNIT, iGoldCost, iPriority))

	mov	ecx, DWORD PTR _iPriority$225255[ebp]
	push	ecx
	mov	edx, DWORD PTR _iGoldCost$225254[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@BuyEmergen

; 868  : 			{
; 869  : 				if(pCity->getOwner() == m_pPlayer->GetID())		// Player must own the city or this will create a unit for another player

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230673[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230682[ebp], eax
	mov	ecx, DWORD PTR $T230673[ebp]
	cmp	ecx, DWORD PTR $T230682[ebp]
	jne	$LN7@BuyEmergen

; 870  : 				{
; 871  : 					// This is an EXTRA build for the operation beyond any that are already assigned to this city, so pass in the right flag to CreateUnit()
; 872  : 					int iResult = pCity->CreateUnit(eType, NO_UNITAI, false /*bUseToSatisfyOperation*/);

	push	0
	push	-1
	mov	edx, DWORD PTR _eType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?CreateUnit@CvCity@@QAEHW4UnitTypes@@W4UnitAITypes@@_N@Z ; CvCity::CreateUnit
	mov	DWORD PTR _iResult$225258[ebp], eax

; 873  : 
; 874  : 					CvAssertMsg(iResult != FFreeList::INVALID_INDEX, "Unable to create unit");
; 875  : 
; 876  : 					if (iResult != FFreeList::INVALID_INDEX)

	cmp	DWORD PTR _iResult$225258[ebp], -1
	je	$LN4@BuyEmergen

; 877  : 					{
; 878  : 						CvUnit* pUnit = m_pPlayer->getUnit(iResult);

	mov	eax, DWORD PTR _iResult$225258[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pUnit$225260[ebp], eax

; 879  : 						m_pPlayer->GetTreasury()->LogExpenditure((CvString)pUnit->getUnitInfo().GetText(), iGoldCost, 7);

	push	7
	mov	edx, DWORD PTR _iGoldCost$225254[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$225260[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetText@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetText
	mov	DWORD PTR $T230692[ebp], eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T230648[ebp], esp
	mov	DWORD PTR $T230691[ebp], eax
	cmp	DWORD PTR $T230692[ebp], 0
	je	SHORT $LN31@BuyEmergen
	mov	ecx, DWORD PTR $T230692[ebp]
	mov	DWORD PTR tv307[ebp], ecx
	jmp	SHORT $LN32@BuyEmergen
$LN31@BuyEmergen:
	mov	DWORD PTR tv307[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@BuyEmergen:
	mov	edx, DWORD PTR tv307[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230691[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T230691[ebp]
	mov	DWORD PTR tv289[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, eax
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 880  : 						m_pPlayer->GetTreasury()->ChangeGold(-iGoldCost);

	mov	edx, DWORD PTR _iGoldCost$225254[ebp]
	neg	edx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 881  : 
; 882  : 						pUnit->setMoves(0);

	push	0
	mov	ecx, DWORD PTR _pUnit$225260[ebp]
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves

; 883  : 
; 884  : 						CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$225264[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 885  : 						szMsg.Format("Emergency Unit Purchased: %s, ", pUnit->getUnitInfo().GetDescription());

	mov	ecx, DWORD PTR _pUnit$225260[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T230700[ebp], eax
	mov	ecx, DWORD PTR $T230700[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BP@MDCEEOOC@Emergency?5Unit?5Purchased?3?5?$CFs?0?5?$AA@
	lea	ecx, DWORD PTR _szMsg$225264[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 886  : 						szMsg += pCity->getName();

	lea	edx, DWORD PTR $T230649[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv349[ebp], eax
	mov	eax, DWORD PTR tv349[ebp]
	mov	DWORD PTR tv292[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv292[ebp]
	push	ecx
	lea	ecx, DWORD PTR _szMsg$225264[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T230649[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 887  : 						m_pPlayer->GetTacticalAI()->LogTacticalMessage(szMsg);

	push	1
	lea	edx, DWORD PTR _szMsg$225264[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 888  : 
; 889  : 						return pUnit;

	mov	ecx, DWORD PTR _pUnit$225260[ebp]
	mov	DWORD PTR $T230650[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szMsg$225264[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T230650[ebp]
	jmp	$LN10@BuyEmergen

; 890  : 					}
; 891  : 					else

	jmp	SHORT $LN7@BuyEmergen
$LN4@BuyEmergen:

; 892  : 					{
; 893  : 						return NULL;

	xor	eax, eax
	jmp	$LN10@BuyEmergen
$LN7@BuyEmergen:

; 894  : 					}
; 895  : 				}
; 896  : 			}
; 897  : 		}
; 898  : 
; 899  : 		// Try again with Faith
; 900  : 		if(pCity->IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eType, NO_BUILDING, NO_PROJECT, YIELD_FAITH))

	push	5
	push	-1
	push	-1
	mov	edx, DWORD PTR _eType$[ebp]
	push	edx
	push	1
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z ; CvCity::IsCanPurchase
	movzx	eax, al
	test	eax, eax
	je	$LN8@BuyEmergen

; 901  : 		{
; 902  : 			int iFaithCost = pCity->GetFaithPurchaseCost(eType, false /*bIncludeBeliefDiscounts*/);

	push	0
	mov	ecx, DWORD PTR _eType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetFaithPurchaseCost@CvCity@@QAEHW4UnitTypes@@_N@Z ; CvCity::GetFaithPurchaseCost
	mov	DWORD PTR _iFaithCost$225270[ebp], eax

; 903  : 
; 904  : 			if(pCity->getOwner() == m_pPlayer->GetID())		// Player must own the city or this will create a unit for another player

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230717[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230726[ebp], eax
	mov	ecx, DWORD PTR $T230717[ebp]
	cmp	ecx, DWORD PTR $T230726[ebp]
	jne	$LN8@BuyEmergen

; 905  : 			{
; 906  : 				m_pPlayer->ChangeFaith(-iFaithCost);

	mov	edx, DWORD PTR _iFaithCost$225270[ebp]
	neg	edx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ChangeFaith@CvPlayer@@QAEXH@Z		; CvPlayer::ChangeFaith

; 907  : 
; 908  : 				// This is an EXTRA build for the operation beyond any that are already assigned to this city, so pass in the right flag to CreateUnit()
; 909  : 				int iResult = pCity->CreateUnit(eType, NO_UNITAI, false /*bUseToSatisfyOperation*/);

	push	0
	push	-1
	mov	ecx, DWORD PTR _eType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?CreateUnit@CvCity@@QAEHW4UnitTypes@@W4UnitAITypes@@_N@Z ; CvCity::CreateUnit
	mov	DWORD PTR _iResult$225272[ebp], eax

; 910  : 
; 911  : 				CvAssertMsg(iResult != FFreeList::INVALID_INDEX, "Unable to create unit");
; 912  : 				CvUnit* pUnit = m_pPlayer->getUnit(iResult);

	mov	edx, DWORD PTR _iResult$225272[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pUnit$225273[ebp], eax

; 913  : 				pUnit->setMoves(0);

	push	0
	mov	ecx, DWORD PTR _pUnit$225273[ebp]
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves

; 914  : 
; 915  : 				CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$225274[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 916  : 				szMsg.Format("Emergency Faith Unit Purchase: %s, ", pUnit->getUnitInfo().GetDescription());

	mov	ecx, DWORD PTR _pUnit$225273[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T230734[ebp], eax
	mov	ecx, DWORD PTR $T230734[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CE@HJDHFKAC@Emergency?5Faith?5Unit?5Purchase?3?5?$CF@
	lea	ecx, DWORD PTR _szMsg$225274[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 917  : 				szMsg += pCity->getName();

	lea	edx, DWORD PTR $T230651[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv318[ebp], eax
	mov	eax, DWORD PTR tv318[ebp]
	mov	DWORD PTR tv296[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv296[ebp]
	push	ecx
	lea	ecx, DWORD PTR _szMsg$225274[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T230651[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 918  : 				m_pPlayer->GetTacticalAI()->LogTacticalMessage(szMsg);

	push	1
	lea	edx, DWORD PTR _szMsg$225274[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 919  : 
; 920  : 				return pUnit;

	mov	ecx, DWORD PTR _pUnit$225273[ebp]
	mov	DWORD PTR $T230652[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szMsg$225274[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T230652[ebp]
	jmp	SHORT $LN10@BuyEmergen
$LN8@BuyEmergen:

; 921  : 			}
; 922  : 		}
; 923  : 	}
; 924  : 	return NULL;

	xor	eax, eax
$LN10@BuyEmergen:

; 925  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$0:
	mov	ecx, DWORD PTR $T230648[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$1:
	lea	ecx, DWORD PTR _szMsg$225264[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$2:
	lea	ecx, DWORD PTR $T230649[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$3:
	lea	ecx, DWORD PTR _szMsg$225274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$4:
	lea	ecx, DWORD PTR $T230651[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ENDP ; CvMilitaryAI::BuyEmergencyUnit
PUBLIC	??_C@_0CD@BKABGIKA@Emergency?5Building?5Purchased?3?5?$CFs@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyBuilding
EXTRN	?CreateBuilding@CvCity@@QAE_NW4BuildingTypes@@@Z:PROC ; CvCity::CreateBuilding
EXTRN	?GetPurchaseCost@CvCity@@QAEHW4BuildingTypes@@@Z:PROC ; CvCity::GetPurchaseCost
EXTRN	?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetDefensePerCitizen
EXTRN	?GetDefenseModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetDefenseModifier
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
;	COMDAT ??_C@_0CD@BKABGIKA@Emergency?5Building?5Purchased?3?5?$CFs@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CD@BKABGIKA@Emergency?5Building?5Purchased?3?5?$CFs@ DB 'Emergency'
	DB	' Building Purchased: %s, ', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$2
__ehfuncinfo$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
_TEXT	SEGMENT
tv217 = -124						; size = 4
tv235 = -120						; size = 4
tv214 = -116						; size = 4
tv224 = -112						; size = 4
_this$ = -108						; size = 4
$T230769 = -104						; size = 4
$T230768 = -100						; size = 4
$T230753 = -96						; size = 28
$T230752 = -68						; size = 4
_szMsg$225299 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_iPriority$225294 = -32					; size = 4
_iGoldCost$225293 = -28					; size = 4
_eBldg$225286 = -24					; size = 4
_pkBuildingInfo$225288 = -20				; size = 4
_iBldgLoop$225282 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z PROC ; CvMilitaryAI::BuyEmergencyBuilding, COMDAT
; _this$ = ecx

; 929  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 	// Loop through adding the available buildings
; 931  : #ifdef AUI_WARNING_FIXES
; 932  : 	for (uint iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)
; 933  : #else
; 934  : 	for(int iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	DWORD PTR _iBldgLoop$225282[ebp], 0
	jmp	SHORT $LN8@BuyEmergen@2
$LN7@BuyEmergen@2:
	mov	eax, DWORD PTR _iBldgLoop$225282[ebp]
	add	eax, 1
	mov	DWORD PTR _iBldgLoop$225282[ebp], eax
$LN8@BuyEmergen@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _iBldgLoop$225282[ebp], eax
	jge	$LN6@BuyEmergen@2

; 935  : #endif
; 936  : 	{
; 937  : 		const BuildingTypes eBldg = static_cast<BuildingTypes>(iBldgLoop);

	mov	ecx, DWORD PTR _iBldgLoop$225282[ebp]
	mov	DWORD PTR _eBldg$225286[ebp], ecx

; 938  : 		CvBuildingEntry* pkBuildingInfo = GC.GetGameBuildings()->GetEntry(eBldg);

	mov	edx, DWORD PTR _eBldg$225286[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$225288[ebp], eax

; 939  : 		if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$225288[ebp], 0
	je	$LN5@BuyEmergen@2

; 940  : 		{
; 941  : 			// Make sure this building can be built now
; 942  : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 943  : 			if(pCity->canConstruct(eBldg) && (pkBuildingInfo->GetDefenseModifier() > 0 || pkBuildingInfo->GetDefensePerCitizen() > 0))

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _eBldg$225286[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@BuyEmergen@2
	mov	ecx, DWORD PTR _pkBuildingInfo$225288[ebp]
	call	?GetDefenseModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetDefenseModifier
	test	eax, eax
	jg	SHORT $LN3@BuyEmergen@2
	mov	ecx, DWORD PTR _pkBuildingInfo$225288[ebp]
	call	?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetDefensePerCitizen
	test	eax, eax
	jle	$LN5@BuyEmergen@2
$LN3@BuyEmergen@2:

; 944  : #else
; 945  : 			if(pCity->canConstruct(eBldg) && pkBuildingInfo->GetDefenseModifier() > 0)
; 946  : #endif
; 947  : 			{
; 948  : 				if(pCity->IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, NO_UNIT, eBldg, NO_PROJECT, YIELD_GOLD))

	push	2
	push	-1
	mov	edx, DWORD PTR _eBldg$225286[ebp]
	push	edx
	push	-1
	push	1
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z ; CvCity::IsCanPurchase
	movzx	eax, al
	test	eax, eax
	je	$LN5@BuyEmergen@2

; 949  : 				{
; 950  : 					int iGoldCost = pCity->GetPurchaseCost(eBldg);

	mov	ecx, DWORD PTR _eBldg$225286[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPurchaseCost@CvCity@@QAEHW4BuildingTypes@@@Z ; CvCity::GetPurchaseCost
	mov	DWORD PTR _iGoldCost$225293[ebp], eax

; 951  : 					int iPriority = GC.getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2096
	mov	DWORD PTR _iPriority$225294[ebp], edx

; 952  : 					if(m_pPlayer->GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_BUILDING, iGoldCost, iPriority))

	mov	eax, DWORD PTR _iPriority$225294[ebp]
	push	eax
	mov	ecx, DWORD PTR _iGoldCost$225293[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
	movzx	eax, al
	test	eax, eax
	je	$LN5@BuyEmergen@2

; 953  : 					{
; 954  : 						m_pPlayer->GetTreasury()->LogExpenditure((CvString)pkBuildingInfo->GetText(), iGoldCost, 8);

	push	8
	mov	ecx, DWORD PTR _iGoldCost$225293[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkBuildingInfo$225288[ebp]
	call	?GetText@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetText
	mov	DWORD PTR $T230769[ebp], eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T230752[ebp], esp
	mov	DWORD PTR $T230768[ebp], edx
	cmp	DWORD PTR $T230769[ebp], 0
	je	SHORT $LN18@BuyEmergen@2
	mov	eax, DWORD PTR $T230769[ebp]
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN19@BuyEmergen@2
$LN18@BuyEmergen@2:
	mov	DWORD PTR tv224[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN19@BuyEmergen@2:
	mov	ecx, DWORD PTR tv224[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230768[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T230768[ebp]
	mov	DWORD PTR tv214[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, eax
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 955  : 						m_pPlayer->GetTreasury()->ChangeGold(-iGoldCost);

	mov	ecx, DWORD PTR _iGoldCost$225293[ebp]
	neg	ecx
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 956  : #ifdef CVASSERT_ENABLE
; 957  : 						int iResult = pCity->CreateBuilding(eBldg);
; 958  : 
; 959  : 						DEBUG_VARIABLE(iResult);
; 960  : 						CvAssertMsg(iResult != FFreeList::INVALID_INDEX, "Unable to create building");
; 961  : #else
; 962  : 						pCity->CreateBuilding(eBldg);

	mov	eax, DWORD PTR _eBldg$225286[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?CreateBuilding@CvCity@@QAE_NW4BuildingTypes@@@Z ; CvCity::CreateBuilding

; 963  : #endif
; 964  : 
; 965  : 						CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$225299[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 966  : 						szMsg.Format("Emergency Building Purchased: %s, ", pkBuildingInfo->GetDescription());

	mov	ecx, DWORD PTR _pkBuildingInfo$225288[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CD@BKABGIKA@Emergency?5Building?5Purchased?3?5?$CFs@
	lea	ecx, DWORD PTR _szMsg$225299[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 967  : 						szMsg += pCity->getName();

	lea	edx, DWORD PTR $T230753[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv235[ebp], eax
	mov	eax, DWORD PTR tv235[ebp]
	mov	DWORD PTR tv217[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv217[ebp]
	push	ecx
	lea	ecx, DWORD PTR _szMsg$225299[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T230753[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 968  : 						m_pPlayer->GetTacticalAI()->LogTacticalMessage(szMsg);

	push	1
	lea	edx, DWORD PTR _szMsg$225299[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 969  : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szMsg$225299[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@BuyEmergen@2:

; 970  : 				}
; 971  : 			}
; 972  : 		}
; 973  : 	}

	jmp	$LN7@BuyEmergen@2
$LN6@BuyEmergen@2:

; 974  : 	return false;

	xor	al, al

; 975  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$0:
	mov	ecx, DWORD PTR $T230752[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$1:
	lea	ecx, DWORD PTR _szMsg$225299[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$2:
	lea	ecx, DWORD PTR $T230753[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z ENDP ; CvMilitaryAI::BuyEmergencyBuilding
PUBLIC	?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::LogChosenTarget
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices
PUBLIC	??_C@_0DA@CCDADIH@Choosing?5attack?5target?5from?5top?5@ ; `string'
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
PUBLIC	?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; CvMilitaryAI::LogAttackTargets
PUBLIC	?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ; CvMilitaryAI::ScoreTarget
PUBLIC	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
PUBLIC	?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back
PUBLIC	?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::ShouldAttackBySea
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z:PROC ; CvStepPathFinder::DoesPathExist
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?IsGreatGeneral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatGeneral
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	_atexit:PROC
;	COMDAT ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_BSS	SEGMENT
?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A DB 04610H DUP (?) ; `CvMilitaryAI::FindBestAttackTarget'::`43'::prelimWeightedTargetList
_BSS	ENDS
;	COMDAT ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
_BSS	SEGMENT
?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A DB 04610H DUP (?) ; `CvMilitaryAI::FindBestAttackTarget'::`2'::weightedTargetList
_BSS	ENDS
;	COMDAT ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
_BSS	SEGMENT
?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA DD 01H DUP (?) ; `CvMilitaryAI::FindBestAttackTarget'::`2'::$S1
_BSS	ENDS
;	COMDAT ??_C@_0DA@CCDADIH@Choosing?5attack?5target?5from?5top?5@
CONST	SEGMENT
??_C@_0DA@CCDADIH@Choosing?5attack?5target?5from?5top?5@ DB 'Choosing att'
	DB	'ack target from top 25%% of choices', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$1
__ehfuncinfo$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
_TEXT	SEGMENT
tv431 = -788						; size = 4
_this$ = -784						; size = 4
$T231450 = -724						; size = 4
$T231440 = -720						; size = 4
$T231435 = -716						; size = 4
$T231419 = -712						; size = 4
$T231374 = -708						; size = 4
$T231367 = -704						; size = 4
_elem$231381 = -700					; size = 28
_i$231377 = -672					; size = 4
_rtnValue$231376 = -668					; size = 4
$T231354 = -664						; size = 4
$T231335 = -648						; size = 4
$T231326 = -644						; size = 4
$T231312 = -612						; size = 4
$T231291 = -608						; size = 4
_i$231282 = -604					; size = 4
$T231248 = -600						; size = 4
$T231241 = -596						; size = 4
$T231178 = -508						; size = 4
$T231169 = -504						; size = 4
$T231160 = -500						; size = 4
$T231151 = -496						; size = 4
$T231139 = -492						; size = 4
_uiOffset$231137 = -488					; size = 4
$T231128 = -484						; size = 4
$T231127 = -480						; size = 4
$T231118 = -476						; size = 4
$T231114 = -472						; size = 4
_i$231105 = -468					; size = 4
$T231039 = -420						; size = 4
$T231030 = -416						; size = 4
$T230984 = -368						; size = 4
$T230975 = -364						; size = 4
_uiOffset$230951 = -360					; size = 4
$T230942 = -356						; size = 4
$T230941 = -352						; size = 4
$T230895 = -304						; size = 4
$T230886 = -300						; size = 4
$T230840 = -252						; size = 4
$T230831 = -248						; size = 4
$T230796 = -244						; size = 24
$T230795 = -220						; size = 4
$T230794 = -216						; size = 4
$T230793 = -212						; size = 8
_fcn$225732 = -204					; size = 8
_iNumChoices$225762 = -196				; size = 4
_pSeaPlotNearMuster$225603 = -192			; size = 4
_pSeaPlotNearTarget$225604 = -188			; size = 4
_target$225598 = -184					; size = 24
_iWeight$225599 = -160					; size = 4
_iI$225594 = -156					; size = 4
_target$225586 = -152					; size = 24
_iWeight$225587 = -128					; size = 4
_iDistance$225571 = -124				; size = 4
_iDistance$225568 = -120				; size = 4
_iPower$225563 = -116					; size = 4
_bGeneralInTheVicinity$225562 = -109			; size = 1
_iX$225560 = -108					; size = 4
_iY$225561 = -104					; size = 4
_pPlot$225558 = -100					; size = 4
_iDistance$225552 = -96					; size = 4
_iDistance$225549 = -92					; size = 4
_iPower$225544 = -88					; size = 4
_bGeneralInTheVicinity$225543 = -81			; size = 1
_pPlot$225540 = -80					; size = 4
_iX$225541 = -76					; size = 4
_iY$225542 = -72					; size = 4
_kEnemy$ = -68						; size = 4
_iTargetsConsidered$ = -64				; size = 4
_iEnemyLoop$ = -60					; size = 4
_chosenTarget$ = -56					; size = 24
_iFriendlyLoop$ = -32					; size = 4
_pLoopUnit$ = -28					; size = 4
_pFriendlyCity$ = -24					; size = 4
_iUnitLoop$ = -20					; size = 4
_pEnemyCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eAIOperationType$ = 12					; size = 4
_eEnemy$ = 16						; size = 4
_piWinningScore$ = 20					; size = 4
?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z PROC ; CvMilitaryAI::FindBestAttackTarget, COMDAT
; _this$ = ecx

; 981  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 776				; 00000308H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 	int iFriendlyLoop;
; 983  : 	int iEnemyLoop;
; 984  : 	int iUnitLoop;
; 985  : 	CvCity* pFriendlyCity;
; 986  : 	CvCity* pEnemyCity;
; 987  : 	CvUnit* pLoopUnit;
; 988  : 	static CvWeightedVector<CvMilitaryTarget, SAFE_ESTIMATE_NUM_CITIES* 10, true> weightedTargetList;

	mov	eax, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	and	eax, 1
	jne	SHORT $LN50@FindBestAt
	mov	ecx, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
	push	OFFSET ??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ; `CvMilitaryAI::FindBestAttackTarget'::`2'::`dynamic atexit destructor for 'weightedTargetList''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN50@FindBestAt:

; 989  : 	CvMilitaryTarget chosenTarget;

	mov	DWORD PTR _chosenTarget$[ebp], 0
	mov	DWORD PTR _chosenTarget$[ebp+4], 0
	mov	DWORD PTR _chosenTarget$[ebp+8], 0
	mov	DWORD PTR _chosenTarget$[ebp+12], 0
	mov	DWORD PTR _chosenTarget$[ebp+16], 0
	mov	BYTE PTR _chosenTarget$[ebp+20], 0

; 990  : 	CvPlayer &kEnemy = GET_PLAYER(eEnemy);

	mov	edx, DWORD PTR _eEnemy$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kEnemy$[ebp], edx

; 991  : 
; 992  : 	// Estimate the relative strength of units near our cities and near their cities (can't use TacticalAnalysisMap because we may not be at war - and that it isn't current if we are calling this from the DiploAI)
; 993  : 	for (pFriendlyCity = m_pPlayer->firstCity(&iFriendlyLoop); pFriendlyCity != NULL; pFriendlyCity = m_pPlayer->nextCity(&iFriendlyLoop))

	push	0
	lea	eax, DWORD PTR _iFriendlyLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pFriendlyCity$[ebp], eax
	jmp	SHORT $LN49@FindBestAt
$LN48@FindBestAt:
	push	0
	lea	edx, DWORD PTR _iFriendlyLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pFriendlyCity$[ebp], eax
$LN49@FindBestAt:
	cmp	DWORD PTR _pFriendlyCity$[ebp], 0
	je	$LN47@FindBestAt

; 994  : 	{
; 995  : 		CvPlot* pPlot = pFriendlyCity->plot();

	mov	ecx, DWORD PTR _pFriendlyCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$225540[ebp], eax

; 996  : 		int iX = pPlot->getX();

	mov	ecx, DWORD PTR _pPlot$225540[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR _iX$225541[ebp], edx

; 997  : 		int iY = pPlot->getY();

	mov	eax, DWORD PTR _pPlot$225540[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _iY$225542[ebp], ecx

; 998  : 		bool bGeneralInTheVicinity = false;

	mov	BYTE PTR _bGeneralInTheVicinity$225543[ebp], 0

; 999  : 		int iPower = 0;

	mov	DWORD PTR _iPower$225544[ebp], 0

; 1000 : 		for (pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN46@FindBestAt
$LN45@FindBestAt:
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN46@FindBestAt:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN44@FindBestAt

; 1001 : 		{
; 1002 : 			if (pLoopUnit->IsCombatUnit())

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN43@FindBestAt

; 1003 : 			{
; 1004 : 				int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T230831[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T230840[ebp], eax
	mov	ecx, DWORD PTR _iY$225542[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$225541[ebp]
	push	edx
	mov	eax, DWORD PTR $T230831[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230840[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225549[ebp], eax

; 1005 : 				if (iDistance <= 5)

	cmp	DWORD PTR _iDistance$225549[ebp], 5
	jg	SHORT $LN43@FindBestAt

; 1006 : 				{
; 1007 : 					iPower += pLoopUnit->GetPower();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	eax, DWORD PTR _iPower$225544[ebp]
	mov	DWORD PTR _iPower$225544[ebp], eax
$LN43@FindBestAt:

; 1008 : 				}
; 1009 : 			}
; 1010 : 			if (!bGeneralInTheVicinity && pLoopUnit->IsGreatGeneral())

	movzx	edx, BYTE PTR _bGeneralInTheVicinity$225543[ebp]
	test	edx, edx
	jne	SHORT $LN41@FindBestAt
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@FindBestAt

; 1011 : 			{
; 1012 : 				int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T230886[ebp], edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T230895[ebp], ecx
	mov	edx, DWORD PTR _iY$225542[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$225541[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230886[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230895[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225552[ebp], eax

; 1013 : 				if (iDistance <= 5)

	cmp	DWORD PTR _iDistance$225552[ebp], 5
	jg	SHORT $LN41@FindBestAt

; 1014 : 				{
; 1015 : 					bGeneralInTheVicinity = true;

	mov	BYTE PTR _bGeneralInTheVicinity$225543[ebp], 1
$LN41@FindBestAt:

; 1016 : 				}
; 1017 : 			}
; 1018 : 		}

	jmp	$LN45@FindBestAt
$LN44@FindBestAt:

; 1019 : 		if (bGeneralInTheVicinity)

	movzx	eax, BYTE PTR _bGeneralInTheVicinity$225543[ebp]
	test	eax, eax
	je	SHORT $LN39@FindBestAt

; 1020 : 		{
; 1021 : 			iPower *= 11;

	mov	ecx, DWORD PTR _iPower$225544[ebp]
	imul	ecx, 11					; 0000000bH
	mov	DWORD PTR _iPower$225544[ebp], ecx

; 1022 : 			iPower /= 10;

	mov	eax, DWORD PTR _iPower$225544[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _iPower$225544[ebp], eax
$LN39@FindBestAt:

; 1023 : 		}
; 1024 : 		pFriendlyCity->iScratch = iPower;

	mov	edx, DWORD PTR _pFriendlyCity$[ebp]
	mov	eax, DWORD PTR _iPower$225544[ebp]
	mov	DWORD PTR [edx+4], eax

; 1025 : 	}

	jmp	$LN48@FindBestAt
$LN47@FindBestAt:

; 1026 : 	for(pEnemyCity = kEnemy.firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = kEnemy.nextCity(&iEnemyLoop))

	push	0
	lea	ecx, DWORD PTR _iEnemyLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kEnemy$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pEnemyCity$[ebp], eax
	jmp	SHORT $LN38@FindBestAt
$LN37@FindBestAt:
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kEnemy$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pEnemyCity$[ebp], eax
$LN38@FindBestAt:
	cmp	DWORD PTR _pEnemyCity$[ebp], 0
	je	$LN36@FindBestAt

; 1027 : 	{
; 1028 : 		CvPlot* pPlot = pEnemyCity->plot();

	mov	ecx, DWORD PTR _pEnemyCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$225558[ebp], eax

; 1029 : 		if(pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230941[ebp], ecx
	mov	edx, DWORD PTR $T230941[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230942[ebp], eax
	mov	ecx, DWORD PTR $T230942[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$230951[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$230951[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T230942[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$230951[ebp]
	mov	edx, DWORD PTR _pPlot$225558[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN35@FindBestAt

; 1030 : 		{
; 1031 : 			int iX = pPlot->getX();

	mov	edx, DWORD PTR _pPlot$225558[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _iX$225560[ebp], eax

; 1032 : 			int iY = pPlot->getY();

	mov	ecx, DWORD PTR _pPlot$225558[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _iY$225561[ebp], edx

; 1033 : 			bool bGeneralInTheVicinity = false;

	mov	BYTE PTR _bGeneralInTheVicinity$225562[ebp], 0

; 1034 : 			int iPower = 0;

	mov	DWORD PTR _iPower$225563[ebp], 0

; 1035 : 			for (pLoopUnit = kEnemy.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kEnemy.nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kEnemy$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN34@FindBestAt
$LN33@FindBestAt:
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kEnemy$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN34@FindBestAt:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN32@FindBestAt

; 1036 : 			{
; 1037 : 				if (pLoopUnit->IsCombatUnit())

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+1044], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN31@FindBestAt

; 1038 : 				{
; 1039 : 					int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T230975[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T230984[ebp], edx
	mov	eax, DWORD PTR _iY$225561[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX$225560[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230975[ebp]
	push	edx
	mov	eax, DWORD PTR $T230984[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225568[ebp], eax

; 1040 : 					if (iDistance <= 5)

	cmp	DWORD PTR _iDistance$225568[ebp], 5
	jg	SHORT $LN31@FindBestAt

; 1041 : 					{
; 1042 : 						iPower += pLoopUnit->GetPower();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	eax, DWORD PTR _iPower$225563[ebp]
	mov	DWORD PTR _iPower$225563[ebp], eax
$LN31@FindBestAt:

; 1043 : 					}
; 1044 : 				}
; 1045 : 				if (!bGeneralInTheVicinity && pLoopUnit->IsGreatGeneral())

	movzx	ecx, BYTE PTR _bGeneralInTheVicinity$225562[ebp]
	test	ecx, ecx
	jne	SHORT $LN29@FindBestAt
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@FindBestAt

; 1046 : 				{
; 1047 : 					int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T231030[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T231039[ebp], eax
	mov	ecx, DWORD PTR _iY$225561[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$225560[ebp]
	push	edx
	mov	eax, DWORD PTR $T231030[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231039[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225571[ebp], eax

; 1048 : 					if (iDistance <= 5)

	cmp	DWORD PTR _iDistance$225571[ebp], 5
	jg	SHORT $LN29@FindBestAt

; 1049 : 					{
; 1050 : 						bGeneralInTheVicinity = true;

	mov	BYTE PTR _bGeneralInTheVicinity$225562[ebp], 1
$LN29@FindBestAt:

; 1051 : 					}
; 1052 : 				}
; 1053 : 			}

	jmp	$LN33@FindBestAt
$LN32@FindBestAt:

; 1054 : 			if (bGeneralInTheVicinity)

	movzx	edx, BYTE PTR _bGeneralInTheVicinity$225562[ebp]
	test	edx, edx
	je	SHORT $LN27@FindBestAt

; 1055 : 			{
; 1056 : 				iPower *= 11;

	mov	eax, DWORD PTR _iPower$225563[ebp]
	imul	eax, 11					; 0000000bH
	mov	DWORD PTR _iPower$225563[ebp], eax

; 1057 : 				iPower /= 10;

	mov	eax, DWORD PTR _iPower$225563[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _iPower$225563[ebp], eax
$LN27@FindBestAt:

; 1058 : 			}
; 1059 : 			pEnemyCity->iScratch = iPower;

	mov	edx, DWORD PTR _pEnemyCity$[ebp]
	mov	eax, DWORD PTR _iPower$225563[ebp]
	mov	DWORD PTR [edx+4], eax
$LN35@FindBestAt:

; 1060 : 		}
; 1061 : 	}

	jmp	$LN37@FindBestAt
$LN36@FindBestAt:

; 1062 : 
; 1063 : 	// Build a list of all the possible start city/target city pairs
; 1064 : 	static CvWeightedVector<CvMilitaryTarget, SAFE_ESTIMATE_NUM_CITIES* 10, true> prelimWeightedTargetList;

	mov	ecx, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	and	ecx, 2
	jne	SHORT $LN26@FindBestAt
	mov	edx, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	or	edx, 2
	mov	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, OFFSET ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
	push	OFFSET ??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ; `CvMilitaryAI::FindBestAttackTarget'::`43'::`dynamic atexit destructor for 'prelimWeightedTargetList''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN26@FindBestAt:

; 1065 : 	prelimWeightedTargetList.clear();

	xor	eax, eax
	je	SHORT $LN225@FindBestAt
	mov	DWORD PTR _i$231105[ebp], 0
	jmp	SHORT $LN223@FindBestAt
$LN222@FindBestAt:
	mov	ecx, DWORD PTR _i$231105[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$231105[ebp], ecx
$LN223@FindBestAt:
	mov	edx, DWORD PTR _i$231105[ebp]
	cmp	edx, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	jae	SHORT $LN225@FindBestAt
	jmp	SHORT $LN222@FindBestAt
$LN225@FindBestAt:
	mov	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, 0

; 1066 : 	for(pFriendlyCity = m_pPlayer->firstCity(&iFriendlyLoop); pFriendlyCity != NULL; pFriendlyCity = m_pPlayer->nextCity(&iFriendlyLoop))

	push	0
	lea	eax, DWORD PTR _iFriendlyLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pFriendlyCity$[ebp], eax
	jmp	SHORT $LN25@FindBestAt
$LN24@FindBestAt:
	push	0
	lea	edx, DWORD PTR _iFriendlyLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pFriendlyCity$[ebp], eax
$LN25@FindBestAt:
	cmp	DWORD PTR _pFriendlyCity$[ebp], 0
	je	$LN23@FindBestAt

; 1067 : 	{
; 1068 : 		for(pEnemyCity = GET_PLAYER(eEnemy).firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = GET_PLAYER(eEnemy).nextCity(&iEnemyLoop))

	mov	ecx, DWORD PTR _eEnemy$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231114[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231114[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pEnemyCity$[ebp], eax
	jmp	SHORT $LN22@FindBestAt
$LN21@FindBestAt:
	mov	eax, DWORD PTR _eEnemy$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231118[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iEnemyLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231118[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pEnemyCity$[ebp], eax
$LN22@FindBestAt:
	cmp	DWORD PTR _pEnemyCity$[ebp], 0
	je	$LN20@FindBestAt

; 1069 : 		{
; 1070 : 			if(pEnemyCity->plot()->isRevealed(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T231127[ebp], eax
	mov	ecx, DWORD PTR $T231127[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231128[ebp], eax
	mov	ecx, DWORD PTR _pEnemyCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T231139[ebp], eax
	mov	eax, DWORD PTR $T231128[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$231137[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$231137[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T231128[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$231137[ebp]
	mov	edx, DWORD PTR $T231139[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@FindBestAt

; 1071 : 			{
; 1072 : 				CvMilitaryTarget target;

	mov	DWORD PTR _target$225586[ebp], 0
	mov	DWORD PTR _target$225586[ebp+4], 0
	mov	DWORD PTR _target$225586[ebp+8], 0
	mov	DWORD PTR _target$225586[ebp+12], 0
	mov	DWORD PTR _target$225586[ebp+16], 0
	mov	BYTE PTR _target$225586[ebp+20], 0

; 1073 : 				int iWeight;
; 1074 : 				target.m_pMusterCity = pFriendlyCity;

	mov	edx, DWORD PTR _pFriendlyCity$[ebp]
	mov	DWORD PTR _target$225586[ebp+4], edx

; 1075 : 				target.m_pTargetCity = pEnemyCity;

	mov	eax, DWORD PTR _pEnemyCity$[ebp]
	mov	DWORD PTR _target$225586[ebp], eax

; 1076 : 				target.iMusterNearbyUnitPower = pFriendlyCity->iScratch;

	mov	ecx, DWORD PTR _pFriendlyCity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _target$225586[ebp+12], edx

; 1077 : 				target.iTargetNearbyUnitPower = pEnemyCity->iScratch;

	mov	eax, DWORD PTR _pEnemyCity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$225586[ebp+8], ecx

; 1078 : 
; 1079 : 				if (eAIOperationType == AI_OPERATION_PURE_NAVAL_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 18	; 00000012H
	jne	$LN18@FindBestAt

; 1080 : 				{
; 1081 : 					target.m_bAttackBySea = true;

	mov	BYTE PTR _target$225586[ebp+20], 1

; 1082 : 					if (target.m_pMusterCity->isCoastal() && target.m_pTargetCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _target$225586[ebp+4]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@FindBestAt
	push	-1
	mov	ecx, DWORD PTR _target$225586[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@FindBestAt

; 1083 : 					{
; 1084 : 						target.m_iPathLength = plotDistance(target.m_pMusterCity->getX(), target.m_pMusterCity->getY(), target.m_pTargetCity->getX(), target.m_pTargetCity->getY());

	mov	ecx, DWORD PTR _target$225586[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T231151[ebp], edx
	mov	eax, DWORD PTR _target$225586[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231160[ebp], ecx
	mov	edx, DWORD PTR _target$225586[ebp+4]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T231169[ebp], eax
	mov	ecx, DWORD PTR _target$225586[ebp+4]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T231178[ebp], edx
	mov	eax, DWORD PTR $T231151[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231160[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231169[ebp]
	push	edx
	mov	eax, DWORD PTR $T231178[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _target$225586[ebp+16], eax
$LN17@FindBestAt:

; 1085 : 					}
; 1086 : 				}
; 1087 : 
; 1088 : 				else

	jmp	SHORT $LN16@FindBestAt
$LN18@FindBestAt:

; 1089 : 				{
; 1090 : 					ShouldAttackBySea(eEnemy, target);

	lea	ecx, DWORD PTR _target$225586[ebp]
	push	ecx
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::ShouldAttackBySea

; 1091 : 
; 1092 : 					if (!pFriendlyCity->isCoastal() && target.m_bAttackBySea)

	push	-1
	mov	ecx, DWORD PTR _pFriendlyCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@FindBestAt
	movzx	ecx, BYTE PTR _target$225586[ebp+20]
	test	ecx, ecx
	je	SHORT $LN16@FindBestAt

; 1093 : 					{
; 1094 : 						continue;

	jmp	$LN21@FindBestAt
$LN16@FindBestAt:

; 1095 : 					}
; 1096 : 				}
; 1097 : 
; 1098 : 				if(target.m_iPathLength > 0)

	cmp	DWORD PTR _target$225586[ebp+16], 0
	jle	SHORT $LN19@FindBestAt

; 1099 : 				{
; 1100 : 					iWeight = (10000 - target.m_iPathLength);   // Start by using the path length as the weight, shorter paths have higher weight

	mov	edx, 10000				; 00002710H
	sub	edx, DWORD PTR _target$225586[ebp+16]
	mov	DWORD PTR _iWeight$225587[ebp], edx

; 1101 : 					prelimWeightedTargetList.push_back(target, iWeight);

	mov	eax, DWORD PTR _iWeight$225587[ebp]
	push	eax
	lea	ecx, DWORD PTR _target$225586[ebp]
	push	ecx
	mov	ecx, OFFSET ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back
$LN19@FindBestAt:

; 1102 : 				}
; 1103 : 			}
; 1104 : 		}

	jmp	$LN21@FindBestAt
$LN20@FindBestAt:

; 1105 : 	}

	jmp	$LN24@FindBestAt
$LN23@FindBestAt:

; 1106 : 
; 1107 : 	// Let's score the 25 shortest paths ... anything more than that means there are too many interior cities from one (or both) sides being considered
; 1108 : 	prelimWeightedTargetList.SortItems();

	mov	edx, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T231241[ebp], edx
	mov	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T231248[ebp], eax
	mov	eax, DWORD PTR $T231241[ebp]
	sub	eax, DWORD PTR $T231248[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR $T231241[ebp]
	push	edx
	mov	eax, DWORD PTR $T231248[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 1109 : 	weightedTargetList.clear();

	xor	ecx, ecx
	je	SHORT $LN311@FindBestAt
	mov	DWORD PTR _i$231282[ebp], 0
	jmp	SHORT $LN309@FindBestAt
$LN308@FindBestAt:
	mov	edx, DWORD PTR _i$231282[ebp]
	add	edx, 1
	mov	DWORD PTR _i$231282[ebp], edx
$LN309@FindBestAt:
	mov	eax, DWORD PTR _i$231282[ebp]
	cmp	eax, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	jae	SHORT $LN311@FindBestAt
	jmp	SHORT $LN308@FindBestAt
$LN311@FindBestAt:
	mov	DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, 0

; 1110 : 	int iTargetsConsidered = 0;

	mov	DWORD PTR _iTargetsConsidered$[ebp], 0

; 1111 : 	for (int iI = 0; iI < prelimWeightedTargetList.size() && iTargetsConsidered < 25; iI++)

	mov	DWORD PTR _iI$225594[ebp], 0
	jmp	SHORT $LN13@FindBestAt
$LN12@FindBestAt:
	mov	ecx, DWORD PTR _iI$225594[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225594[ebp], ecx
$LN13@FindBestAt:
	mov	edx, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR $T231291[ebp], edx
	mov	eax, DWORD PTR _iI$225594[ebp]
	cmp	eax, DWORD PTR $T231291[ebp]
	jge	$LN11@FindBestAt
	cmp	DWORD PTR _iTargetsConsidered$[ebp], 25	; 00000019H
	jge	$LN11@FindBestAt

; 1112 : 	{
; 1113 : 		CvMilitaryTarget target = prelimWeightedTargetList.GetElement(iI);

	mov	ecx, DWORD PTR _iI$225594[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _target$225598[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _target$225598[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _target$225598[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _target$225598[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _target$225598[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _target$225598[ebp+20], eax

; 1114 : 		int iWeight;
; 1115 : 
; 1116 : 		// If a sea target, we haven't checked the path yet.  Do that now
; 1117 : 		if (target.m_bAttackBySea)

	movzx	ecx, BYTE PTR _target$225598[ebp+20]
	test	ecx, ecx
	je	$LN10@FindBestAt

; 1118 : 		{
; 1119 : 			if (!target.m_pMusterCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _target$225598[ebp+4]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@FindBestAt

; 1120 : 			{
; 1121 : 				continue;

	jmp	$LN12@FindBestAt
$LN9@FindBestAt:

; 1122 : 			}
; 1123 : 			if (!target.m_pTargetCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _target$225598[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@FindBestAt

; 1124 : 			{
; 1125 : 				continue;

	jmp	$LN12@FindBestAt
$LN8@FindBestAt:

; 1126 : 			}
; 1127 : 			CvPlot *pSeaPlotNearMuster = GetCoastalPlotAdjacentToTarget(target.m_pMusterCity->plot(), NULL);

	push	0
	mov	ecx, DWORD PTR _target$225598[ebp+4]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pSeaPlotNearMuster$225603[ebp], eax

; 1128 : 			CvPlot *pSeaPlotNearTarget = GetCoastalPlotAdjacentToTarget(target.m_pTargetCity->plot(), NULL);

	push	0
	mov	ecx, DWORD PTR _target$225598[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pSeaPlotNearTarget$225604[ebp], eax

; 1129 : 			if(!GC.getStepFinder().DoesPathExist(m_pPlayer->GetID(), eEnemy, pSeaPlotNearMuster, pSeaPlotNearTarget))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T231312[ebp], eax
	mov	ecx, DWORD PTR _pSeaPlotNearTarget$225604[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSeaPlotNearMuster$225603[ebp]
	push	edx
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231312[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@FindBestAt

; 1130 : 			{
; 1131 : 				continue;

	jmp	$LN12@FindBestAt
$LN10@FindBestAt:

; 1132 : 			}
; 1133 : 		}
; 1134 : 
; 1135 : 		iWeight = ScoreTarget(target, eAIOperationType);

	mov	eax, DWORD PTR _eAIOperationType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _target$225598[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ; CvMilitaryAI::ScoreTarget
	mov	DWORD PTR _iWeight$225599[ebp], eax

; 1136 : 		weightedTargetList.push_back(target, iWeight);

	mov	edx, DWORD PTR _iWeight$225599[ebp]
	push	edx
	lea	eax, DWORD PTR _target$225598[ebp]
	push	eax
	mov	ecx, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back

; 1137 : 		iTargetsConsidered++;

	mov	ecx, DWORD PTR _iTargetsConsidered$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTargetsConsidered$[ebp], ecx

; 1138 : 	}

	jmp	$LN12@FindBestAt
$LN11@FindBestAt:

; 1139 : 
; 1140 : 	// Didn't find anything, abort
; 1141 : 	if(weightedTargetList.size() == 0)

	mov	edx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR $T231326[ebp], edx
	cmp	DWORD PTR $T231326[ebp], 0
	jne	SHORT $LN6@FindBestAt

; 1142 : 	{
; 1143 : 		chosenTarget.m_pTargetCity = NULL;   // Call off the attack

	mov	DWORD PTR _chosenTarget$[ebp], 0

; 1144 : 		if (piWinningScore)

	cmp	DWORD PTR _piWinningScore$[ebp], 0
	je	SHORT $LN5@FindBestAt

; 1145 : 		{
; 1146 : 			*piWinningScore = -1;

	mov	eax, DWORD PTR _piWinningScore$[ebp]
	mov	DWORD PTR [eax], -1
$LN5@FindBestAt:

; 1147 : 		}
; 1148 : 		return chosenTarget;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _chosenTarget$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _chosenTarget$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _chosenTarget$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _chosenTarget$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _chosenTarget$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _chosenTarget$[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN51@FindBestAt
$LN6@FindBestAt:

; 1149 : 	}
; 1150 : 
; 1151 : 	weightedTargetList.SortItems();

	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T231335[ebp], ecx
	mov	edx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T231354[ebp], edx
	mov	eax, DWORD PTR $T231335[ebp]
	sub	eax, DWORD PTR $T231354[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR $T231335[ebp]
	push	edx
	mov	eax, DWORD PTR $T231354[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 1152 : 	LogAttackTargets(eAIOperationType, eEnemy, weightedTargetList);

	push	OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eAIOperationType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; CvMilitaryAI::LogAttackTargets

; 1153 : 
; 1154 : 	if(weightedTargetList.GetTotalWeight() > 0)

	mov	DWORD PTR _rtnValue$231376[ebp], 0
	mov	DWORD PTR _i$231377[ebp], 0
	jmp	SHORT $LN360@FindBestAt
$LN359@FindBestAt:
	mov	eax, DWORD PTR _i$231377[ebp]
	add	eax, 1
	mov	DWORD PTR _i$231377[ebp], eax
$LN360@FindBestAt:
	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR $T231367[ebp], ecx
	mov	edx, DWORD PTR _i$231377[ebp]
	cmp	edx, DWORD PTR $T231367[ebp]
	jae	SHORT $LN361@FindBestAt
	mov	eax, DWORD PTR _i$231377[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T231374[ebp], eax
	mov	ecx, DWORD PTR $T231374[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _elem$231381[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$231381[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _elem$231381[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _elem$231381[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _elem$231381[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _elem$231381[ebp+20], eax
	mov	ecx, DWORD PTR $T231374[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _elem$231381[ebp+24], edx
	mov	eax, DWORD PTR _rtnValue$231376[ebp]
	add	eax, DWORD PTR _elem$231381[ebp+24]
	mov	DWORD PTR _rtnValue$231376[ebp], eax
	jmp	$LN359@FindBestAt
$LN361@FindBestAt:
	cmp	DWORD PTR _rtnValue$231376[ebp], 0
	jle	$LN4@FindBestAt

; 1155 : 	{
; 1156 : 		RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$225732[ebp], 0
	mov	DWORD PTR _fcn$225732[ebp+4], 0
	mov	DWORD PTR _fcn$225732[ebp], 0
	mov	DWORD PTR _fcn$225732[ebp+4], 0

; 1157 : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231419[ebp], ecx
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	edx, DWORD PTR $T231419[ebp]
	push	edx
	lea	eax, DWORD PTR $T230793[ebp]
	push	eax
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T231435[ebp], eax
	mov	ecx, DWORD PTR $T231435[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _fcn$225732[ebp+4], edx
	mov	eax, DWORD PTR $T231435[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fcn$225732[ebp], ecx

; 1158 : 		int iNumChoices = max (1, (weightedTargetList.size() * 25 / 100));

	mov	edx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR $T231440[ebp], edx
	mov	eax, DWORD PTR $T231440[ebp]
	imul	eax, 25					; 00000019H
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR $T230794[ebp], eax
	mov	DWORD PTR $T230795[ebp], 1
	mov	edx, DWORD PTR $T230795[ebp]
	cmp	edx, DWORD PTR $T230794[ebp]
	jge	SHORT $LN393@FindBestAt
	lea	eax, DWORD PTR $T230794[ebp]
	mov	DWORD PTR tv431[ebp], eax
	jmp	SHORT $LN394@FindBestAt
$LN393@FindBestAt:
	lea	ecx, DWORD PTR $T230795[ebp]
	mov	DWORD PTR tv431[ebp], ecx
$LN394@FindBestAt:
	mov	edx, DWORD PTR tv431[ebp]
	mov	DWORD PTR $T231450[ebp], edx
	mov	eax, DWORD PTR $T231450[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumChoices$225762[ebp], ecx

; 1159 : 		chosenTarget = weightedTargetList.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing attack target from top 25%% of choices");

	push	OFFSET ??_C@_0DA@CCDADIH@Choosing?5attack?5target?5from?5top?5@
	lea	edx, DWORD PTR _fcn$225732[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumChoices$225762[ebp]
	push	eax
	lea	ecx, DWORD PTR $T230796[ebp]
	push	ecx
	mov	ecx, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _chosenTarget$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _chosenTarget$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _chosenTarget$[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _chosenTarget$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _chosenTarget$[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _chosenTarget$[ebp+20], eax

; 1160 : 		// if we need the winning score
; 1161 : 		if (piWinningScore)

	cmp	DWORD PTR _piWinningScore$[ebp], 0
	je	SHORT $LN3@FindBestAt

; 1162 : 		{
; 1163 : 			*piWinningScore = ScoreTarget(chosenTarget, eAIOperationType);

	mov	ecx, DWORD PTR _eAIOperationType$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chosenTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ; CvMilitaryAI::ScoreTarget
	mov	ecx, DWORD PTR _piWinningScore$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@FindBestAt:

; 1164 : 		}
; 1165 : 		LogChosenTarget(eAIOperationType, eEnemy, chosenTarget);

	lea	edx, DWORD PTR _chosenTarget$[ebp]
	push	edx
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eAIOperationType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::LogChosenTarget

; 1166 : 	}
; 1167 : 	else

	jmp	SHORT $LN2@FindBestAt
$LN4@FindBestAt:

; 1168 : 	{
; 1169 : 		chosenTarget.m_pTargetCity = NULL;   // Call off the attack

	mov	DWORD PTR _chosenTarget$[ebp], 0

; 1170 : 		if (piWinningScore)

	cmp	DWORD PTR _piWinningScore$[ebp], 0
	je	SHORT $LN2@FindBestAt

; 1171 : 		{
; 1172 : 			*piWinningScore = -1;

	mov	edx, DWORD PTR _piWinningScore$[ebp]
	mov	DWORD PTR [edx], -1
$LN2@FindBestAt:

; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	return chosenTarget;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _chosenTarget$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _chosenTarget$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _chosenTarget$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _chosenTarget$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _chosenTarget$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _chosenTarget$[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN51@FindBestAt:

; 1177 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$0:
	mov	eax, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, eax
	ret	0
__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$1:
	mov	eax, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, eax
	ret	0
__ehhandler$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-780]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ENDP ; CvMilitaryAI::FindBestAttackTarget
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T231581 = -80						; size = 4
$T231554 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T231554[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T231554[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T231554[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T231581[ebp], edx
	mov	eax, DWORD PTR $T231581[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T231604 = -16						; size = 4
$T231596 = -12						; size = 4
$T231592 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T231592[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231596[ebp], ecx
	movzx	edx, BYTE PTR $T231592[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T231596[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T231596[ebp]
	mov	DWORD PTR $T231604[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T231596[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T231596[ebp]
	mov	DWORD PTR $T231604[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T231604[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T231604[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T231625 = -16						; size = 4
$T231617 = -12						; size = 4
$T231613 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T231613[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T231617[ebp], ecx
	movzx	edx, BYTE PTR $T231613[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T231617[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T231617[ebp]
	mov	DWORD PTR $T231625[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T231617[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T231617[ebp]
	mov	DWORD PTR $T231625[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T231625[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T231625[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
; Function compile flags: /Odtp
;	COMDAT ??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ
text$yd	SEGMENT
??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ PROC ; `CvMilitaryAI::FindBestAttackTarget'::`43'::`dynamic atexit destructor for 'prelimWeightedTargetList'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ENDP ; `CvMilitaryAI::FindBestAttackTarget'::`43'::`dynamic atexit destructor for 'prelimWeightedTargetList''
; Function compile flags: /Odtp
text$yd	ENDS
;	COMDAT ??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ
text$yd	SEGMENT
??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ PROC ; `CvMilitaryAI::FindBestAttackTarget'::`2'::`dynamic atexit destructor for 'weightedTargetList'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ENDP ; `CvMilitaryAI::FindBestAttackTarget'::`2'::`dynamic atexit destructor for 'weightedTargetList''
text$yd	ENDS
EXTRN	?canEmbark@CvTeam@@QBE_NXZ:PROC			; CvTeam::canEmbark
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T231818 = -112						; size = 4
$T231814 = -108						; size = 4
$T231805 = -104						; size = 4
$T231801 = -100						; size = 4
$T231792 = -96						; size = 4
$T231788 = -92						; size = 4
$T231787 = -88						; size = 4
$T231729 = -28						; size = 4
$T231720 = -24						; size = 4
$T231711 = -20						; size = 4
$T231702 = -16						; size = 4
_iPlotDistance$ = -12					; size = 4
_iPathLength$ = -8					; size = 4
_pPathfinderNode$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
_target$ = 12						; size = 4
?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z PROC ; CvMilitaryAI::ShouldAttackBySea, COMDAT
; _this$ = ecx

; 1181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1182 : 	CvAStarNode* pPathfinderNode;
; 1183 : 	int iPathLength = 0;

	mov	DWORD PTR _iPathLength$[ebp], 0

; 1184 : 	int iPlotDistance = plotDistance(target.m_pMusterCity->getX(), target.m_pMusterCity->getY(), target.m_pTargetCity->getX(), target.m_pTargetCity->getY());

	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T231702[ebp], edx
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T231711[ebp], edx
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T231720[ebp], edx
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T231729[ebp], edx
	mov	eax, DWORD PTR $T231702[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231711[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231720[ebp]
	push	edx
	mov	eax, DWORD PTR $T231729[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$[ebp], eax

; 1185 : 
; 1186 : 	// Can embark
; 1187 : 	if(GET_TEAM(m_pPlayer->getTeam()).canEmbark())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231787[ebp], edx
	mov	eax, DWORD PTR $T231787[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231788[ebp], eax
	mov	edx, DWORD PTR $T231788[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231792[ebp], edx
	mov	ecx, DWORD PTR $T231792[ebp]
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark
	movzx	eax, al
	test	eax, eax
	je	$LN74@ShouldAtta

; 1188 : 	{
; 1189 : 		// On different landmasses?
; 1190 : 		if(target.m_pMusterCity->getArea() != target.m_pTargetCity->getArea())

	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	esi, eax
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	esi, eax
	je	SHORT $LN68@ShouldAtta

; 1191 : 		{
; 1192 : 			target.m_bAttackBySea = true;

	mov	eax, DWORD PTR _target$[ebp]
	mov	BYTE PTR [eax+20], 1

; 1193 : 			target.m_iPathLength = iPlotDistance;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR _iPlotDistance$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1194 : 			return;

	jmp	$LN10@ShouldAtta

; 1195 : 		}
; 1196 : 
; 1197 : 		// No step path between muster point and target?
; 1198 : 		if(!GC.getStepFinder().DoesPathExist(m_pPlayer->GetID(), eEnemy, target.m_pMusterCity->plot(), target.m_pTargetCity->plot()))

$LN68@ShouldAtta:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T231801[ebp], edx
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	mov	eax, DWORD PTR $T231801[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@ShouldAtta

; 1199 : 		{
; 1200 : 			target.m_bAttackBySea = true;

	mov	edx, DWORD PTR _target$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1201 : 			target.m_iPathLength = iPlotDistance;

	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR _iPlotDistance$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1202 : 			return;

	jmp	$LN10@ShouldAtta
$LN7@ShouldAtta:

; 1203 : 		}
; 1204 : 
; 1205 : 		// Land path is over twice as long as direct path
; 1206 : 		pPathfinderNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T231805[ebp], eax
	mov	edx, DWORD PTR $T231805[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], eax

; 1207 : 		if(pPathfinderNode != NULL)

	cmp	DWORD PTR _pPathfinderNode$[ebp], 0
	je	SHORT $LN6@ShouldAtta

; 1208 : 		{
; 1209 : 			iPathLength = pPathfinderNode->m_iData1;

	mov	ecx, DWORD PTR _pPathfinderNode$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _iPathLength$[ebp], edx

; 1210 : 			if(iPathLength > (2 * iPlotDistance))

	mov	eax, DWORD PTR _iPlotDistance$[ebp]
	shl	eax, 1
	cmp	DWORD PTR _iPathLength$[ebp], eax
	jle	SHORT $LN6@ShouldAtta

; 1211 : 			{
; 1212 : 				target.m_bAttackBySea = true;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 1213 : 				target.m_iPathLength = iPlotDistance;

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR _iPlotDistance$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1214 : 				return;

	jmp	$LN10@ShouldAtta
$LN6@ShouldAtta:

; 1215 : 			}
; 1216 : 		}
; 1217 : 	}
; 1218 : 
; 1219 : 	// Can't embark yet
; 1220 : 	else

	jmp	SHORT $LN4@ShouldAtta

; 1221 : 	{
; 1222 : 		if(!GC.getStepFinder().DoesPathExist(m_pPlayer->GetID(), eEnemy, target.m_pMusterCity->plot(), target.m_pTargetCity->plot()))

$LN74@ShouldAtta:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T231814[ebp], eax
	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	eax, DWORD PTR _eEnemy$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231814[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@ShouldAtta

; 1223 : 		{
; 1224 : 			target.m_iPathLength = -1;  // Call off attack, no path

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax+16], -1

; 1225 : 			return;

	jmp	SHORT $LN10@ShouldAtta

; 1226 : 		}
; 1227 : 
; 1228 : 		else

	jmp	SHORT $LN4@ShouldAtta
$LN3@ShouldAtta:

; 1229 : 		{
; 1230 : 			pPathfinderNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T231818[ebp], eax
	mov	ecx, DWORD PTR $T231818[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], edx

; 1231 : 			if(pPathfinderNode != NULL)

	cmp	DWORD PTR _pPathfinderNode$[ebp], 0
	je	SHORT $LN4@ShouldAtta

; 1232 : 			{
; 1233 : 				iPathLength = pPathfinderNode->m_iData1;

	mov	eax, DWORD PTR _pPathfinderNode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iPathLength$[ebp], ecx
$LN4@ShouldAtta:

; 1234 : 			}
; 1235 : 		}
; 1236 : 	}
; 1237 : 
; 1238 : 	target.m_bAttackBySea = false;

	mov	edx, DWORD PTR _target$[ebp]
	mov	BYTE PTR [edx+20], 0

; 1239 : 	target.m_iPathLength = iPathLength;

	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR _iPathLength$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN10@ShouldAtta:

; 1240 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z ENDP ; CvMilitaryAI::ShouldAttackBySea
_TEXT	ENDS
PUBLIC	?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z ; CvMilitaryAI::EvaluateMilitaryApproaches
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?IsCityAlreadyTargeted@CvPlayer@@QBE_NPAVCvCity@@W4DomainTypes@@HH@Z:PROC ; CvPlayer::IsCityAlreadyTargeted
EXTRN	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ:PROC ; CvCity::getOriginalOwner
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ:PROC	; CvCity::IsRouteToCapitalConnected
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?CanAirlift@CvCity@@QBE_NXZ:PROC		; CvCity::CanAirlift
; Function compile flags: /Odtp
;	COMDAT ?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z
_TEXT	SEGMENT
tv173 = -100						; size = 4
tv168 = -96						; size = 4
tv165 = -92						; size = 4
tv249 = -88						; size = 4
tv142 = -84						; size = 4
_this$ = -80						; size = 4
$T231876 = -76						; size = 4
$T231869 = -72						; size = 4
$T231865 = -68						; size = 4
$T231856 = -64						; size = 4
$T231850 = -60						; size = 4
$T231841 = -56						; size = 4
$T231832 = -52						; size = 4
$T231825 = -48						; size = 4
$T231824 = -44						; size = 4
$T231823 = -40						; size = 4
$T231822 = -36						; size = 4
$T231821 = -32						; size = 4
_iFriendlyStrength$ = -28				; size = 4
_iApproachMultiplier$ = -24				; size = 4
_iRatio$ = -20						; size = 4
_uliRtnValue$ = -16					; size = 4
_eApproaches$ = -12					; size = 4
_iEconomicValue$ = -8					; size = 4
_iEnemyStrength$ = -4					; size = 4
_target$ = 8						; size = 4
_eAIOperationType$ = 12					; size = 4
?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z PROC ; CvMilitaryAI::ScoreTarget, COMDAT
; _this$ = ecx

; 1244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 1245 : 	unsigned long int uliRtnValue = 1;  // Start with a high base number since divide into it later

	mov	DWORD PTR _uliRtnValue$[ebp], 1

; 1246 : 
; 1247 : 	// Take into account distance to target (and use higher multipliers for land paths)
; 1248 : 	if(!target.m_bAttackBySea)

	mov	eax, DWORD PTR _target$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $LN29@ScoreTarge

; 1249 : 	{
; 1250 : 		if(target.m_iPathLength < 10)

	mov	edx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [edx+16], 10			; 0000000aH
	jge	SHORT $LN28@ScoreTarge

; 1251 : 		{
; 1252 : 			uliRtnValue *= 16;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	shl	eax, 4
	mov	DWORD PTR _uliRtnValue$[ebp], eax
	jmp	SHORT $LN27@ScoreTarge
$LN28@ScoreTarge:

; 1253 : 		}
; 1254 : 		else if(target.m_iPathLength < 15)

	mov	ecx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [ecx+16], 15			; 0000000fH
	jge	SHORT $LN26@ScoreTarge

; 1255 : 		{
; 1256 : 			uliRtnValue *= 8;

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	shl	edx, 3
	mov	DWORD PTR _uliRtnValue$[ebp], edx
	jmp	SHORT $LN27@ScoreTarge
$LN26@ScoreTarge:

; 1257 : 		}
; 1258 : 		else if(target.m_iPathLength < 20)

	mov	eax, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [eax+16], 20			; 00000014H
	jge	SHORT $LN24@ScoreTarge

; 1259 : 		{
; 1260 : 			uliRtnValue *= 4;

	mov	ecx, DWORD PTR _uliRtnValue$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _uliRtnValue$[ebp], ecx

; 1261 : 		}
; 1262 : 		else

	jmp	SHORT $LN27@ScoreTarge
$LN24@ScoreTarge:

; 1263 : 		{
; 1264 : 			uliRtnValue *= 2;

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _uliRtnValue$[ebp], edx
$LN27@ScoreTarge:

; 1265 : 		}
; 1266 : 
; 1267 : 		// Double if we can assemble troops in muster city with airlifts
; 1268 : 		if (target.m_pMusterCity->CanAirlift())

	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?CanAirlift@CvCity@@QBE_NXZ		; CvCity::CanAirlift
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@ScoreTarge

; 1269 : 		{
; 1270 : 			uliRtnValue *= 2;

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _uliRtnValue$[ebp], edx
$LN22@ScoreTarge:

; 1271 : 		}
; 1272 : 	}
; 1273 : 	else

	jmp	SHORT $LN21@ScoreTarge
$LN29@ScoreTarge:

; 1274 : 	{
; 1275 : 		if(target.m_iPathLength < 12)

	mov	eax, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [eax+16], 12			; 0000000cH
	jge	SHORT $LN20@ScoreTarge

; 1276 : 		{
; 1277 : 			uliRtnValue *= 5;

	mov	ecx, DWORD PTR _uliRtnValue$[ebp]
	imul	ecx, 5
	mov	DWORD PTR _uliRtnValue$[ebp], ecx
	jmp	SHORT $LN19@ScoreTarge
$LN20@ScoreTarge:

; 1278 : 		}
; 1279 : 		else if(target.m_iPathLength < 20)

	mov	edx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [edx+16], 20			; 00000014H
	jge	SHORT $LN18@ScoreTarge

; 1280 : 		{
; 1281 : 			uliRtnValue *= 3;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	imul	eax, 3
	mov	DWORD PTR _uliRtnValue$[ebp], eax
	jmp	SHORT $LN19@ScoreTarge
$LN18@ScoreTarge:

; 1282 : 		}
; 1283 : 		else if(target.m_iPathLength < 30)

	mov	ecx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [ecx+16], 30			; 0000001eH
	jge	SHORT $LN19@ScoreTarge

; 1284 : 		{
; 1285 : 			uliRtnValue *= 2;

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _uliRtnValue$[ebp], edx
$LN19@ScoreTarge:

; 1286 : 		}
; 1287 : 
; 1288 : 		// If coming over sea, inland cities are trickier
; 1289 : 		if(!target.m_pTargetCity->plot()->isCoastalLand())

	push	-1
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@ScoreTarge

; 1290 : 		{
; 1291 : 			uliRtnValue /= 2;

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	shr	edx, 1
	mov	DWORD PTR _uliRtnValue$[ebp], edx
$LN21@ScoreTarge:

; 1292 : 		}
; 1293 : 	}
; 1294 : 
; 1295 : 	// Is this a sneak attack?  If so distance is REALLY important (want to target spaces on edge of empire)
; 1296 : 	// So let's cube what we have so far
; 1297 : 	if (eAIOperationType == AI_OPERATION_SNEAK_CITY_ATTACK || eAIOperationType == AI_OPERATION_NAVAL_SNEAK_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 6
	je	SHORT $LN13@ScoreTarge
	cmp	DWORD PTR _eAIOperationType$[ebp], 14	; 0000000eH
	jne	SHORT $LN14@ScoreTarge
$LN13@ScoreTarge:

; 1298 : 	{
; 1299 : 		uliRtnValue = uliRtnValue * uliRtnValue * uliRtnValue;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	imul	eax, DWORD PTR _uliRtnValue$[ebp]
	imul	eax, DWORD PTR _uliRtnValue$[ebp]
	mov	DWORD PTR _uliRtnValue$[ebp], eax
$LN14@ScoreTarge:

; 1300 : 	}
; 1301 : 
; 1302 : 	CityAttackApproaches eApproaches;
; 1303 : 	int iApproachMultiplier = 0;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 0

; 1304 : 	eApproaches = EvaluateMilitaryApproaches(target.m_pTargetCity, true /* Assume units coming by sea can disembark */, target.m_bAttackBySea);

	mov	ecx, DWORD PTR _target$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	push	1
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z ; CvMilitaryAI::EvaluateMilitaryApproaches
	mov	DWORD PTR _eApproaches$[ebp], eax

; 1305 : 	switch(eApproaches)

	mov	edx, DWORD PTR _eApproaches$[ebp]
	mov	DWORD PTR tv142[ebp], edx
	cmp	DWORD PTR tv142[ebp], 5
	ja	SHORT $LN11@ScoreTarge
	mov	eax, DWORD PTR tv142[ebp]
	jmp	DWORD PTR $LN56@ScoreTarge[eax*4]
$LN10@ScoreTarge:

; 1306 : 	{
; 1307 : 	case ATTACK_APPROACH_UNRESTRICTED:
; 1308 : 		iApproachMultiplier = 10;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 10 ; 0000000aH

; 1309 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN9@ScoreTarge:

; 1310 : 
; 1311 : 	case ATTACK_APPROACH_OPEN:
; 1312 : 		iApproachMultiplier = 8;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 8

; 1313 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN8@ScoreTarge:

; 1314 : 
; 1315 : 	case ATTACK_APPROACH_NEUTRAL:
; 1316 : 		iApproachMultiplier = 4;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 4

; 1317 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN7@ScoreTarge:

; 1318 : 
; 1319 : 	case ATTACK_APPROACH_LIMITED:
; 1320 : 		iApproachMultiplier = 2;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 2

; 1321 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN6@ScoreTarge:

; 1322 : 
; 1323 : 	case ATTACK_APPROACH_RESTRICTED:
; 1324 : 		iApproachMultiplier = 1;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 1

; 1325 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN5@ScoreTarge:

; 1326 : 
; 1327 : 	case ATTACK_APPROACH_NONE:
; 1328 : 		iApproachMultiplier = 0;

	mov	DWORD PTR _iApproachMultiplier$[ebp], 0
$LN11@ScoreTarge:

; 1329 : 		break;
; 1330 : 	}
; 1331 : 
; 1332 : 	uliRtnValue *= iApproachMultiplier;

	mov	ecx, DWORD PTR _uliRtnValue$[ebp]
	imul	ecx, DWORD PTR _iApproachMultiplier$[ebp]
	mov	DWORD PTR _uliRtnValue$[ebp], ecx

; 1333 : 
; 1334 : 	// should probably give a bonus if these cities are adjacent
; 1335 : 
; 1336 : 	// Don't want to start at a city that isn't connected to our capital
; 1337 : 	if (!target.m_pMusterCity->IsRouteToCapitalConnected() && !target.m_pMusterCity->isCapital())

	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ ; CvCity::IsRouteToCapitalConnected
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@ScoreTarge
	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@ScoreTarge

; 1338 : 	{
; 1339 : 		uliRtnValue /= 4;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	shr	eax, 2
	mov	DWORD PTR _uliRtnValue$[ebp], eax
$LN4@ScoreTarge:

; 1340 : 	}
; 1341 : 
; 1342 : 	// this won't work if we are "just checking" as the zone are only built for actual war war opponents
; 1343 : 	// TODO come up with a better way to do this that is always correct
; 1344 : 
; 1345 : 	int iFriendlyStrength = target.iMusterNearbyUnitPower;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _iFriendlyStrength$[ebp], edx

; 1346 : 	int iEnemyStrength = target.iTargetNearbyUnitPower + (target.m_pTargetCity->getStrengthValue() / 50);

	push	0
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	edx, DWORD PTR _target$[ebp]
	add	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _iEnemyStrength$[ebp], eax

; 1347 : 	iFriendlyStrength = max(1, iFriendlyStrength);

	mov	DWORD PTR $T231821[ebp], 1
	mov	eax, DWORD PTR $T231821[ebp]
	cmp	eax, DWORD PTR _iFriendlyStrength$[ebp]
	jge	SHORT $LN34@ScoreTarge
	lea	ecx, DWORD PTR _iFriendlyStrength$[ebp]
	mov	DWORD PTR tv249[ebp], ecx
	jmp	SHORT $LN35@ScoreTarge
$LN34@ScoreTarge:
	lea	edx, DWORD PTR $T231821[ebp]
	mov	DWORD PTR tv249[ebp], edx
$LN35@ScoreTarge:
	mov	eax, DWORD PTR tv249[ebp]
	mov	DWORD PTR $T231832[ebp], eax
	mov	ecx, DWORD PTR $T231832[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iFriendlyStrength$[ebp], edx

; 1348 : 	iEnemyStrength = max(1, iEnemyStrength);

	mov	DWORD PTR $T231822[ebp], 1
	mov	eax, DWORD PTR $T231822[ebp]
	cmp	eax, DWORD PTR _iEnemyStrength$[ebp]
	jge	SHORT $LN38@ScoreTarge
	lea	ecx, DWORD PTR _iEnemyStrength$[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	jmp	SHORT $LN39@ScoreTarge
$LN38@ScoreTarge:
	lea	edx, DWORD PTR $T231822[ebp]
	mov	DWORD PTR tv165[ebp], edx
$LN39@ScoreTarge:
	mov	eax, DWORD PTR tv165[ebp]
	mov	DWORD PTR $T231841[ebp], eax
	mov	ecx, DWORD PTR $T231841[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iEnemyStrength$[ebp], edx

; 1349 : 	int iRatio = 1;

	mov	DWORD PTR _iRatio$[ebp], 1

; 1350 : 	iRatio = (iFriendlyStrength * 100) / iEnemyStrength;

	mov	eax, DWORD PTR _iFriendlyStrength$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iEnemyStrength$[ebp]
	mov	DWORD PTR _iRatio$[ebp], eax

; 1351 : 	iRatio = min(1000, iRatio);

	mov	DWORD PTR $T231823[ebp], 1000		; 000003e8H
	mov	eax, DWORD PTR _iRatio$[ebp]
	cmp	eax, DWORD PTR $T231823[ebp]
	jge	SHORT $LN42@ScoreTarge
	lea	ecx, DWORD PTR _iRatio$[ebp]
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN43@ScoreTarge
$LN42@ScoreTarge:
	lea	edx, DWORD PTR $T231823[ebp]
	mov	DWORD PTR tv168[ebp], edx
$LN43@ScoreTarge:
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T231850[ebp], eax
	mov	ecx, DWORD PTR $T231850[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], edx

; 1352 : 	uliRtnValue *= iRatio;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	imul	eax, DWORD PTR _iRatio$[ebp]
	mov	DWORD PTR _uliRtnValue$[ebp], eax

; 1353 : 
; 1354 : 	if (target.m_pTargetCity->IsOriginalCapital())

	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN48@ScoreTarge

; 1355 : 	{
; 1356 : 		uliRtnValue *= GC.getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2204
	mov	DWORD PTR $T231856[ebp], eax
	mov	ecx, DWORD PTR _uliRtnValue$[ebp]
	imul	ecx, DWORD PTR $T231856[ebp]
	mov	DWORD PTR _uliRtnValue$[ebp], ecx

; 1357 : 		uliRtnValue /= 100;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	DWORD PTR _uliRtnValue$[ebp], eax

; 1358 : 	}
; 1359 : 
; 1360 : 	if (target.m_pTargetCity->getOriginalOwner() == m_pPlayer->GetID())

$LN48@ScoreTarge:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T231865[ebp], ecx
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	cmp	eax, DWORD PTR $T231865[ebp]
	jne	SHORT $LN2@ScoreTarge

; 1361 : 	{
; 1362 : 		uliRtnValue *= GC.getAI_MILITARY_RECAPTURING_OWN_CITY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2200
	mov	DWORD PTR $T231869[ebp], eax
	mov	ecx, DWORD PTR _uliRtnValue$[ebp]
	imul	ecx, DWORD PTR $T231869[ebp]
	mov	DWORD PTR _uliRtnValue$[ebp], ecx

; 1363 : 		uliRtnValue /= 100;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	DWORD PTR _uliRtnValue$[ebp], eax
$LN2@ScoreTarge:

; 1364 : 	}
; 1365 : 
; 1366 : 	// Don't want it to already be targeted by an operation that's not well on its way
; 1367 : 	if(m_pPlayer->IsCityAlreadyTargeted(target.m_pTargetCity, NO_DOMAIN, 50))

	push	-1
	push	50					; 00000032H
	push	-1
	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?IsCityAlreadyTargeted@CvPlayer@@QBE_NPAVCvCity@@W4DomainTypes@@HH@Z ; CvPlayer::IsCityAlreadyTargeted
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@ScoreTarge

; 1368 : 	{
; 1369 : 		uliRtnValue /= 10;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _uliRtnValue$[ebp], eax
$LN1@ScoreTarge:

; 1370 : 	}
; 1371 : 
; 1372 : 	uliRtnValue /= 1000;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR _uliRtnValue$[ebp], eax

; 1373 : 
; 1374 : 	// Economic value of target
; 1375 : 	unsigned long int iEconomicValue = 1 + (target.m_pTargetCity->getPopulation() / 3);

	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cdq
	mov	ecx, 3
	idiv	ecx
	add	eax, 1
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1376 : 	// TODO: unhardcode this
; 1377 : 	// filter out all but the most productive
; 1378 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_FOOD, false) / 10;

	push	0
	push	0
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	eax, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1379 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_PRODUCTION, false) / 10;

	push	0
	push	1
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	eax, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1380 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_SCIENCE, false) / 10;

	push	0
	push	3
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	eax, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1381 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_GOLD, false) / 10;

	push	0
	push	2
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	eax, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1382 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_CULTURE, false) / 10;

	push	0
	push	4
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	eax, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1383 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_FAITH, false) / 10;

	push	0
	push	5
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	eax, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _iEconomicValue$[ebp], eax

; 1384 : 	uliRtnValue *= iEconomicValue;

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	imul	edx, DWORD PTR _iEconomicValue$[ebp]
	mov	DWORD PTR _uliRtnValue$[ebp], edx

; 1385 : 
; 1386 : 	uliRtnValue /= 10;

	mov	eax, DWORD PTR _uliRtnValue$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _uliRtnValue$[ebp], eax

; 1387 : 
; 1388 : 	return min(10000000, (int)uliRtnValue & 0x7fffffff);

	mov	edx, DWORD PTR _uliRtnValue$[ebp]
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR $T231824[ebp], edx
	mov	DWORD PTR $T231825[ebp], 10000000	; 00989680H
	mov	eax, DWORD PTR $T231824[ebp]
	cmp	eax, DWORD PTR $T231825[ebp]
	jge	SHORT $LN54@ScoreTarge
	lea	ecx, DWORD PTR $T231824[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	jmp	SHORT $LN55@ScoreTarge
$LN54@ScoreTarge:
	lea	edx, DWORD PTR $T231825[ebp]
	mov	DWORD PTR tv173[ebp], edx
$LN55@ScoreTarge:
	mov	eax, DWORD PTR tv173[ebp]
	mov	DWORD PTR $T231876[ebp], eax
	mov	ecx, DWORD PTR $T231876[ebp]
	mov	eax, DWORD PTR [ecx]

; 1389 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN56@ScoreTarge:
	DD	$LN5@ScoreTarge
	DD	$LN6@ScoreTarge
	DD	$LN7@ScoreTarge
	DD	$LN8@ScoreTarge
	DD	$LN9@ScoreTarge
	DD	$LN10@ScoreTarge
?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ENDP ; CvMilitaryAI::ScoreTarget
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
; Function compile flags: /Odtp
;	COMDAT ?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z
_TEXT	SEGMENT
tv136 = -112						; size = 4
_this$ = -108						; size = 4
$T231899 = -24						; size = 4
$T231890 = -20						; size = 4
_iI$225852 = -16					; size = 4
_eRtnValue$ = -12					; size = 4
_iNumBlocked$ = -8					; size = 4
_pLoopPlot$ = -4					; size = 4
_pCity$ = 8						; size = 4
_bAttackByLand$ = 12					; size = 1
_bAttackBySea$ = 16					; size = 1
?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z PROC ; CvMilitaryAI::EvaluateMilitaryApproaches, COMDAT
; _this$ = ecx

; 1393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 1394 : 	CvPlot* pLoopPlot;
; 1395 : 	CityAttackApproaches eRtnValue = ATTACK_APPROACH_UNRESTRICTED;

	mov	DWORD PTR _eRtnValue$[ebp], 5

; 1396 : 	int iNumBlocked = 0;

	mov	DWORD PTR _iNumBlocked$[ebp], 0

; 1397 : 
; 1398 : 	// Look at each of the six plots around the city
; 1399 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$225852[ebp], 0
	jmp	SHORT $LN22@EvaluateMi
$LN21@EvaluateMi:
	mov	eax, DWORD PTR _iI$225852[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225852[ebp], eax
$LN22@EvaluateMi:
	cmp	DWORD PTR _iI$225852[ebp], 6
	jge	$LN20@EvaluateMi

; 1400 : 	{
; 1401 : 		pLoopPlot = plotDirection(pCity->getX(), pCity->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T231890[ebp], edx
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231899[ebp], ecx
	mov	edx, DWORD PTR _iI$225852[ebp]
	push	edx
	mov	eax, DWORD PTR $T231890[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231899[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1402 : 
; 1403 : 		// Blocked if edge of map
; 1404 : 		if(pLoopPlot == NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	jne	SHORT $LN19@EvaluateMi

; 1405 : 		{
; 1406 : 			iNumBlocked++;

	mov	edx, DWORD PTR _iNumBlocked$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumBlocked$[ebp], edx

; 1407 : 		}
; 1408 : 		else

	jmp	$LN18@EvaluateMi
$LN19@EvaluateMi:

; 1409 : 		{
; 1410 : 			// For now, assume no one coming in over a lake
; 1411 : 			if(pLoopPlot->isLake())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN109@EvaluateMi

; 1412 : 			{
; 1413 : 				iNumBlocked++;

	mov	ecx, DWORD PTR _iNumBlocked$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumBlocked$[ebp], ecx
	jmp	$LN18@EvaluateMi

; 1414 : 			}
; 1415 : 			// Coast but attack is not by sea?
; 1416 : 			else if(pLoopPlot->isWater() && !bAttackBySea)

$LN109@EvaluateMi:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN111@EvaluateMi
	movzx	eax, BYTE PTR _bAttackBySea$[ebp]
	test	eax, eax
	jne	SHORT $LN111@EvaluateMi

; 1417 : 			{
; 1418 : 				iNumBlocked++;

	mov	ecx, DWORD PTR _iNumBlocked$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumBlocked$[ebp], ecx
	jmp	SHORT $LN18@EvaluateMi

; 1419 : 			}
; 1420 : 			// Land
; 1421 : 			else if(!pLoopPlot->isWater())

$LN111@EvaluateMi:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN18@EvaluateMi

; 1422 : 			{
; 1423 : 				if(!bAttackByLand)

	movzx	eax, BYTE PTR _bAttackByLand$[ebp]
	test	eax, eax
	jne	SHORT $LN113@EvaluateMi

; 1424 : 				{
; 1425 : 					iNumBlocked++;

	mov	ecx, DWORD PTR _iNumBlocked$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumBlocked$[ebp], ecx

; 1426 : 				}
; 1427 : 				else

	jmp	SHORT $LN18@EvaluateMi

; 1428 : 				{
; 1429 : 					if(pLoopPlot->isImpassable() || pLoopPlot->isMountain())

$LN113@EvaluateMi:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@EvaluateMi
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@EvaluateMi
$LN9@EvaluateMi:

; 1430 : 					{
; 1431 : 						iNumBlocked++;

	mov	edx, DWORD PTR _iNumBlocked$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumBlocked$[ebp], edx
$LN18@EvaluateMi:

; 1432 : 					}
; 1433 : 				}
; 1434 : 			}
; 1435 : 		}
; 1436 : 	}

	jmp	$LN21@EvaluateMi
$LN20@EvaluateMi:

; 1437 : 
; 1438 : 	switch(iNumBlocked)

	mov	eax, DWORD PTR _iNumBlocked$[ebp]
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 6
	ja	SHORT $LN7@EvaluateMi
	mov	ecx, DWORD PTR tv136[ebp]
	jmp	DWORD PTR $LN117@EvaluateMi[ecx*4]
$LN6@EvaluateMi:

; 1439 : 	{
; 1440 : 	case 0:
; 1441 : 		eRtnValue = ATTACK_APPROACH_UNRESTRICTED;

	mov	DWORD PTR _eRtnValue$[ebp], 5

; 1442 : 		break;

	jmp	SHORT $LN7@EvaluateMi
$LN5@EvaluateMi:

; 1443 : 	case 1:
; 1444 : 	case 2:
; 1445 : 		eRtnValue = ATTACK_APPROACH_OPEN;

	mov	DWORD PTR _eRtnValue$[ebp], 4

; 1446 : 		break;

	jmp	SHORT $LN7@EvaluateMi
$LN4@EvaluateMi:

; 1447 : 	case 3:
; 1448 : 		eRtnValue = ATTACK_APPROACH_NEUTRAL;

	mov	DWORD PTR _eRtnValue$[ebp], 3

; 1449 : 		break;

	jmp	SHORT $LN7@EvaluateMi
$LN3@EvaluateMi:

; 1450 : 	case 4:
; 1451 : 		eRtnValue = ATTACK_APPROACH_LIMITED;

	mov	DWORD PTR _eRtnValue$[ebp], 2

; 1452 : 		break;

	jmp	SHORT $LN7@EvaluateMi
$LN2@EvaluateMi:

; 1453 : 	case 5:
; 1454 : 		eRtnValue = ATTACK_APPROACH_RESTRICTED;

	mov	DWORD PTR _eRtnValue$[ebp], 1

; 1455 : 		break;

	jmp	SHORT $LN7@EvaluateMi
$LN1@EvaluateMi:

; 1456 : 	case 6:
; 1457 : 		eRtnValue = ATTACK_APPROACH_NONE;

	mov	DWORD PTR _eRtnValue$[ebp], 0
$LN7@EvaluateMi:

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[ebp]

; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN117@EvaluateMi:
	DD	$LN6@EvaluateMi
	DD	$LN5@EvaluateMi
	DD	$LN5@EvaluateMi
	DD	$LN4@EvaluateMi
	DD	$LN3@EvaluateMi
	DD	$LN2@EvaluateMi
	DD	$LN1@EvaluateMi
?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z ENDP ; CvMilitaryAI::EvaluateMilitaryApproaches
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T232299 = -80						; size = 4
$T232254 = -76						; size = 4
$T232241 = -72						; size = 4
$T232237 = -68						; size = 4
$T232223 = -64						; size = 4
$T232219 = -57						; size = 1
$T232208 = -56						; size = 4
$T232204 = -49						; size = 1
_iMapY$232263 = -48					; size = 4
_iMapX$232262 = -44					; size = 4
$T232197 = -40						; size = 4
$T232173 = -36						; size = 4
$T232136 = -32						; size = 4
$T232124 = -28						; size = 4
$T232120 = -21						; size = 1
$T232109 = -20						; size = 4
$T232105 = -13						; size = 1
_iMapY$232172 = -12					; size = 4
_iMapX$232171 = -8					; size = 4
$T232098 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232098[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T232173[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T232098[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T232105[ebp], dl
	mov	eax, DWORD PTR $T232098[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232109[ebp], ecx
	movzx	edx, BYTE PTR $T232105[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T232109[ebp]
	add	edx, DWORD PTR $T232109[ebp]
	mov	DWORD PTR _iMapX$232171[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T232109[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T232109[ebp]
	mov	DWORD PTR _iMapX$232171[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$232171[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T232098[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T232120[ebp], al
	mov	ecx, DWORD PTR $T232098[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T232124[ebp], edx
	movzx	eax, BYTE PTR $T232120[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T232124[ebp]
	add	edx, DWORD PTR $T232124[ebp]
	mov	DWORD PTR _iMapY$232172[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T232124[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T232124[ebp]
	mov	DWORD PTR _iMapY$232172[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$232172[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$232172[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$232171[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232098[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T232098[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T232136[ebp], eax
	mov	ecx, DWORD PTR _iMapY$232172[ebp]
	imul	ecx, DWORD PTR $T232136[ebp]
	add	ecx, DWORD PTR _iMapX$232171[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T232098[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T232173[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T232173[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232197[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T232299[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T232197[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T232204[ebp], dl
	mov	eax, DWORD PTR $T232197[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232208[ebp], ecx
	movzx	edx, BYTE PTR $T232204[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T232208[ebp]
	add	edx, DWORD PTR $T232208[ebp]
	mov	DWORD PTR _iMapX$232262[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T232208[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T232208[ebp]
	mov	DWORD PTR _iMapX$232262[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$232262[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T232197[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T232219[ebp], al
	mov	ecx, DWORD PTR $T232197[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T232223[ebp], edx
	movzx	eax, BYTE PTR $T232219[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T232223[ebp]
	add	edx, DWORD PTR $T232223[ebp]
	mov	DWORD PTR _iMapY$232263[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T232223[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T232223[ebp]
	mov	DWORD PTR _iMapY$232263[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$232263[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$232262[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T232197[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232237[ebp], ecx
	mov	edx, DWORD PTR _iMapX$232262[ebp]
	cmp	edx, DWORD PTR $T232237[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$232263[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T232197[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T232241[ebp], ecx
	mov	edx, DWORD PTR _iMapY$232263[ebp]
	cmp	edx, DWORD PTR $T232241[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T232197[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232254[ebp], ecx
	mov	edx, DWORD PTR _iMapY$232263[ebp]
	imul	edx, DWORD PTR $T232254[ebp]
	add	edx, DWORD PTR _iMapX$232262[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T232197[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T232299[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T232299[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetNearestCoastalCity
EXTRN	?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z:PROC	; OnSameBodyOfWater
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -152						; size = 4
$T232366 = -68						; size = 4
$T232357 = -64						; size = 4
$T232348 = -60						; size = 4
$T232339 = -56						; size = 4
$T232330 = -52						; size = 4
_uiOffset$232328 = -48					; size = 4
$T232319 = -44						; size = 4
$T232318 = -40						; size = 4
$T232309 = -36						; size = 4
$T232305 = -32						; size = 4
_iDistance$225897 = -28					; size = 4
_iEnemyLoop$ = -24					; size = 4
_iBestDistance$ = -20					; size = 4
_pBestCoastalCity$ = -16				; size = 4
_pEnemyCity$ = -12					; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eEnemy$ = 8						; size = 4
?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetNearestCoastalCity, COMDAT
; _this$ = ecx

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	DWORD PTR _this$[ebp], ecx

; 1467 : 	CvCity* pBestCoastalCity = NULL;

	mov	DWORD PTR _pBestCoastalCity$[ebp], 0

; 1468 : 	CvCity* pLoopCity, *pEnemyCity;
; 1469 : 	int iLoop, iEnemyLoop;
; 1470 : 	int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$[ebp], 2147483647 ; 7fffffffH

; 1471 : 
; 1472 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN10@GetNearest
$LN9@GetNearest:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN10@GetNearest:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN8@GetNearest

; 1473 : 	{
; 1474 : 		if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@GetNearest

; 1475 : 		{
; 1476 : 			for(pEnemyCity = GET_PLAYER(eEnemy).firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = GET_PLAYER(eEnemy).nextCity(&iEnemyLoop))

	mov	edx, DWORD PTR _eEnemy$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232305[ebp], edx
	push	0
	lea	eax, DWORD PTR _iEnemyLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232305[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pEnemyCity$[ebp], eax
	jmp	SHORT $LN6@GetNearest
$LN5@GetNearest:
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232309[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232309[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pEnemyCity$[ebp], eax
$LN6@GetNearest:
	cmp	DWORD PTR _pEnemyCity$[ebp], 0
	je	$LN7@GetNearest

; 1477 : 			{
; 1478 : 				// Check all revealed enemy cities
; 1479 : 				if(pEnemyCity->isCoastal() && pEnemyCity->plot()->isRevealed(m_pPlayer->getTeam()))

	push	-1
	mov	ecx, DWORD PTR _pEnemyCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	$LN3@GetNearest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T232318[ebp], edx
	mov	eax, DWORD PTR $T232318[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232319[ebp], eax
	mov	ecx, DWORD PTR _pEnemyCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T232330[ebp], eax
	mov	edx, DWORD PTR $T232319[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$232328[ebp], edx
	mov	eax, DWORD PTR _uiOffset$232328[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T232319[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$232328[ebp]
	mov	ecx, DWORD PTR $T232330[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@GetNearest

; 1480 : 				{
; 1481 : 					// On same body of water?
; 1482 : 					if(OnSameBodyOfWater(pLoopCity, pEnemyCity))

	mov	ecx, DWORD PTR _pEnemyCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	push	edx
	call	?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z	; OnSameBodyOfWater
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetNearest

; 1483 : 					{
; 1484 : 						int iDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pEnemyCity->getX(), pEnemyCity->getY());

	mov	ecx, DWORD PTR _pEnemyCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T232339[ebp], edx
	mov	eax, DWORD PTR _pEnemyCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T232348[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T232357[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T232366[ebp], edx
	mov	eax, DWORD PTR $T232339[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232348[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232357[ebp]
	push	edx
	mov	eax, DWORD PTR $T232366[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225897[ebp], eax

; 1485 : 						if(iDistance < iBestDistance)

	mov	ecx, DWORD PTR _iDistance$225897[ebp]
	cmp	ecx, DWORD PTR _iBestDistance$[ebp]
	jge	SHORT $LN3@GetNearest

; 1486 : 						{
; 1487 : 							iBestDistance = iDistance;

	mov	edx, DWORD PTR _iDistance$225897[ebp]
	mov	DWORD PTR _iBestDistance$[ebp], edx

; 1488 : 							pBestCoastalCity = pLoopCity;

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestCoastalCity$[ebp], eax
$LN3@GetNearest:

; 1489 : 						}
; 1490 : 					}
; 1491 : 				}
; 1492 : 			}

	jmp	$LN5@GetNearest
$LN7@GetNearest:

; 1493 : 		}
; 1494 : 	}

	jmp	$LN9@GetNearest
$LN8@GetNearest:

; 1495 : 
; 1496 : 	return pBestCoastalCity;

	mov	eax, DWORD PTR _pBestCoastalCity$[ebp]

; 1497 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetNearestCoastalCity
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?GetFirstUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetFirstUnitID
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z$0
__ehfuncinfo$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv175 = -256						; size = 4
tv174 = -252						; size = 4
_this$ = -248						; size = 4
$T232689 = -176						; size = 4
$T232680 = -172						; size = 4
$T232676 = -168						; size = 4
$T232667 = -164						; size = 4
$T232663 = -160						; size = 4
$T232659 = -156						; size = 4
$T232655 = -152						; size = 4
$T232485 = -68						; size = 4
$T232481 = -64						; size = 4
$T232477 = -60						; size = 4
$T232456 = -56						; size = 4
$T232455 = -52						; size = 4
$T232454 = -48						; size = 4
_iDistance$225919 = -44					; size = 4
_pAdjacentPlot$225913 = -40				; size = 4
_iDirectionLoop$225909 = -36				; size = 4
_iBestDistance$ = -32					; size = 4
_pCoastalPlot$ = -28					; size = 4
_pInitialUnit$ = -24					; size = 8
_iUnitID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_pArmy$ = 12						; size = 4
?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z PROC ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget, COMDAT
; _this$ = ecx

; 1500 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 	CvPlot *pCoastalPlot = NULL;

	mov	DWORD PTR _pCoastalPlot$[ebp], 0

; 1502 : 	UnitHandle pInitialUnit;

	mov	DWORD PTR _pInitialUnit$[ebp], 0
	mov	BYTE PTR _pInitialUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1503 : 	int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$[ebp], 2147483647 ; 7fffffffH

; 1504 : 	int iUnitID = -1;

	mov	DWORD PTR _iUnitID$[ebp], -1

; 1505 : 	if (pArmy)

	cmp	DWORD PTR _pArmy$[ebp], 0
	je	SHORT $LN9@GetCoastal

; 1506 : 	{
; 1507 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 1508 : 		pInitialUnit = m_pPlayer->getUnit(iUnitID);

	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T232477[ebp], eax
	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	je	SHORT $LN17@GetCoastal
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@GetCoastal:
	mov	edx, DWORD PTR $T232477[ebp]
	mov	DWORD PTR _pInitialUnit$[ebp], edx
	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	je	SHORT $LN9@GetCoastal
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@GetCoastal:

; 1509 : 	}
; 1510 : 
; 1511 : 	// Find a coastal water tile adjacent to enemy city
; 1512 : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$225909[ebp], 0
	jmp	SHORT $LN8@GetCoastal
$LN7@GetCoastal:
	mov	eax, DWORD PTR _iDirectionLoop$225909[ebp]
	add	eax, 1
	mov	DWORD PTR _iDirectionLoop$225909[ebp], eax
$LN8@GetCoastal:
	cmp	DWORD PTR _iDirectionLoop$225909[ebp], 6
	jge	$LN6@GetCoastal

; 1513 : 	{
; 1514 : 		CvPlot* pAdjacentPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T232481[ebp], edx
	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T232485[ebp], ecx
	mov	edx, DWORD PTR _iDirectionLoop$225909[ebp]
	push	edx
	mov	eax, DWORD PTR $T232481[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232485[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$225913[ebp], eax

; 1515 : 		if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	cmp	DWORD PTR _pAdjacentPlot$225913[ebp], 0
	je	$LN5@GetCoastal
	mov	edx, DWORD PTR _pAdjacentPlot$225913[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN5@GetCoastal
	mov	ecx, DWORD PTR _pAdjacentPlot$225913[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	eax, al
	test	eax, eax
	je	$LN5@GetCoastal

; 1516 : 		{
; 1517 : 			// Check for path if we have a unit, otherwise don't worry about it
; 1518 : 			if(pInitialUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN4@GetCoastal

; 1519 : 			{
; 1520 : 				if (TurnsToReachTarget(pInitialUnit, pAdjacentPlot, false /*bReusePaths*/, true /*bIgnoreUnits*/, true /*bIgnoreStacking*/) < MAX_INT)

	push	1
	push	1
	push	0
	mov	eax, DWORD PTR _pAdjacentPlot$225913[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T232454[ebp], esp
	mov	DWORD PTR $T232655[ebp], ecx
	mov	edx, DWORD PTR $T232655[ebp]
	mov	eax, DWORD PTR _pInitialUnit$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T232655[ebp]
	mov	dl, BYTE PTR _pInitialUnit$[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T232655[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN97@GetCoastal
	mov	ecx, DWORD PTR $T232655[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN97@GetCoastal:
	mov	edx, DWORD PTR $T232655[ebp]
	mov	DWORD PTR tv174[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv175[ebp], eax
	cmp	DWORD PTR tv175[ebp], 2147483647	; 7fffffffH
	jge	$LN3@GetCoastal

; 1521 : 				{
; 1522 : 					int iDistance = plotDistance(pInitialUnit->getX(), pInitialUnit->getY(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T232659[ebp], ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T232663[ebp], eax
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	mov	DWORD PTR $T232667[ebp], ecx
	mov	edx, DWORD PTR $T232667[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T232676[ebp], eax
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	mov	DWORD PTR $T232680[ebp], ecx
	mov	edx, DWORD PTR $T232680[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T232689[ebp], eax
	mov	ecx, DWORD PTR $T232659[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232663[ebp]
	push	edx
	mov	eax, DWORD PTR $T232676[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232689[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225919[ebp], eax

; 1523 : 					if (iDistance < iBestDistance)

	mov	edx, DWORD PTR _iDistance$225919[ebp]
	cmp	edx, DWORD PTR _iBestDistance$[ebp]
	jge	SHORT $LN3@GetCoastal

; 1524 : 					{
; 1525 : 						iBestDistance = iDistance;

	mov	eax, DWORD PTR _iDistance$225919[ebp]
	mov	DWORD PTR _iBestDistance$[ebp], eax

; 1526 : 						pCoastalPlot = pAdjacentPlot;

	mov	ecx, DWORD PTR _pAdjacentPlot$225913[ebp]
	mov	DWORD PTR _pCoastalPlot$[ebp], ecx
$LN3@GetCoastal:

; 1527 : 					}
; 1528 : 				}
; 1529 : 			}
; 1530 : 			else

	jmp	SHORT $LN5@GetCoastal
$LN4@GetCoastal:

; 1531 : 			{
; 1532 : 				return pAdjacentPlot;

	mov	edx, DWORD PTR _pAdjacentPlot$225913[ebp]
	mov	DWORD PTR $T232455[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	je	SHORT $LN158@GetCoastal
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN158@GetCoastal:
	mov	eax, DWORD PTR $T232455[ebp]
	jmp	SHORT $LN10@GetCoastal
$LN5@GetCoastal:

; 1533 : 			}
; 1534 : 		}
; 1535 : 	}

	jmp	$LN7@GetCoastal
$LN6@GetCoastal:

; 1536 : 
; 1537 : 	return pCoastalPlot;

	mov	eax, DWORD PTR _pCoastalPlot$[ebp]
	mov	DWORD PTR $T232456[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	je	SHORT $LN163@GetCoastal
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN163@GetCoastal:
	mov	eax, DWORD PTR $T232456[ebp]
$LN10@GetCoastal:

; 1538 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _pInitialUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ENDP ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
PUBLIC	?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ; CvMilitaryAI::GetHighestThreat
EXTRN	?GetMilitaryThreat@CvDiplomacyAI@@QBE?AW4ThreatTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMilitaryThreat
EXTRN	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::IsPlayerValid
; Function compile flags: /Odtp
;	COMDAT ?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T232785 = -20						; size = 4
_iPlayerLoop$225930 = -16				; size = 4
_eMilitaryThreatType$ = -12				; size = 4
_eLoopPlayer$ = -8					; size = 4
_eHighestThreat$ = -4					; size = 4
?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ PROC ; CvMilitaryAI::GetHighestThreat, COMDAT
; _this$ = ecx

; 1544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1545 : 	ThreatTypes eHighestThreat = THREAT_NONE;

	mov	DWORD PTR _eHighestThreat$[ebp], 0

; 1546 : 	ThreatTypes eMilitaryThreatType;
; 1547 : 
; 1548 : 	PlayerTypes eLoopPlayer;
; 1549 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225930[ebp], 0
	jmp	SHORT $LN5@GetHighest
$LN4@GetHighest:
	mov	eax, DWORD PTR _iPlayerLoop$225930[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$225930[ebp], eax
$LN5@GetHighest:
	cmp	DWORD PTR _iPlayerLoop$225930[ebp], 22	; 00000016H
	jge	SHORT $LN3@GetHighest

; 1550 : 	{
; 1551 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$225930[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 1552 : 
; 1553 : 		// Is this a player we have relations with?
; 1554 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pDiplomacyAI->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232785[ebp], ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	edx, DWORD PTR $T232785[ebp]
	je	SHORT $LN2@GetHighest
	push	0
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetHighest

; 1555 : 		{
; 1556 : 			eMilitaryThreatType = m_pDiplomacyAI->GetMilitaryThreat(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetMilitaryThreat@CvDiplomacyAI@@QBE?AW4ThreatTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMilitaryThreat
	mov	DWORD PTR _eMilitaryThreatType$[ebp], eax

; 1557 : 			if((int)eMilitaryThreatType > (int)eHighestThreat)

	mov	edx, DWORD PTR _eMilitaryThreatType$[ebp]
	cmp	edx, DWORD PTR _eHighestThreat$[ebp]
	jle	SHORT $LN2@GetHighest

; 1558 : 			{
; 1559 : 				eHighestThreat = eMilitaryThreatType;

	mov	eax, DWORD PTR _eMilitaryThreatType$[ebp]
	mov	DWORD PTR _eHighestThreat$[ebp], eax
$LN2@GetHighest:

; 1560 : 			}
; 1561 : 		}
; 1562 : 	}

	jmp	SHORT $LN4@GetHighest
$LN3@GetHighest:

; 1563 : 	return eHighestThreat;

	mov	eax, DWORD PTR _eHighestThreat$[ebp]

; 1564 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ENDP ; CvMilitaryAI::GetHighestThreat
_TEXT	ENDS
PUBLIC	?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ	; CvMilitaryAI::GetBarbarianThreatTotal
; Function compile flags: /Odtp
;	COMDAT ?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T232795 = -12						; size = 4
$T232791 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ PROC	; CvMilitaryAI::GetBarbarianThreatTotal, COMDAT
; _this$ = ecx

; 1568 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1569 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 1570 : 
; 1571 : 	ScanForBarbarians();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::ScanForBarbarians

; 1572 : 
; 1573 : 	// Major threat for each camp seen
; 1574 : 	iRtnValue += GC.getAI_MILITARY_THREAT_WEIGHT_MAJOR() * m_iBarbarianCampCount;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	mov	DWORD PTR $T232791[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T232791[ebp]
	imul	edx, DWORD PTR [ecx+88]
	add	edx, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], edx

; 1575 : 
; 1576 : 	// One minor threat for every X barbarians
; 1577 : #ifdef AUI_MILITARY_FIX_BARBARIAN_THREAT
; 1578 : 	iRtnValue += m_iVisibleBarbarianCount * GC.getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT();
; 1579 : #else
; 1580 : 	iRtnValue += m_iVisibleBarbarianCount / GC.getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2192
	mov	DWORD PTR $T232795[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+92]
	cdq
	idiv	DWORD PTR $T232795[ebp]
	add	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax

; 1581 : #endif
; 1582 : 
; 1583 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ ENDP	; CvMilitaryAI::GetBarbarianThreatTotal
_TEXT	ENDS
PUBLIC	?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ; CvMilitaryAI::GetThreatWeight
; Function compile flags: /Odtp
;	COMDAT ?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z
_TEXT	SEGMENT
tv64 = -12						; size = 4
_this$ = -8						; size = 4
_iRtnValue$ = -4					; size = 4
_eThreat$ = 8						; size = 4
?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z PROC ; CvMilitaryAI::GetThreatWeight, COMDAT
; _this$ = ecx

; 1588 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1589 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 1590 : 
; 1591 : 	switch(eThreat)

	mov	eax, DWORD PTR _eThreat$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	SHORT $LN5@GetThreatW
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN17@GetThreatW[edx*4]
$LN4@GetThreatW:

; 1592 : 	{
; 1593 : 	case THREAT_MINOR:
; 1594 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_MINOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2164
	mov	DWORD PTR _iRtnValue$[ebp], eax

; 1595 : 		break;

	jmp	SHORT $LN5@GetThreatW
$LN3@GetThreatW:

; 1596 : 	case THREAT_MAJOR:
; 1597 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_MAJOR();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	mov	DWORD PTR _iRtnValue$[ebp], ecx

; 1598 : 		break;

	jmp	SHORT $LN5@GetThreatW
$LN2@GetThreatW:

; 1599 : 	case THREAT_SEVERE:
; 1600 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_SEVERE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2172
	mov	DWORD PTR _iRtnValue$[ebp], edx

; 1601 : 		break;

	jmp	SHORT $LN5@GetThreatW
$LN1@GetThreatW:

; 1602 : 	case THREAT_CRITICAL:
; 1603 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_CRITICAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2176
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN5@GetThreatW:

; 1604 : 		break;
; 1605 : 	}
; 1606 : 
; 1607 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 1608 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN17@GetThreatW:
	DD	$LN4@GetThreatW
	DD	$LN3@GetThreatW
	DD	$LN2@GetThreatW
	DD	$LN1@GetThreatW
?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ENDP ; CvMilitaryAI::GetThreatWeight
_TEXT	ENDS
PUBLIC	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ	; CvMilitaryAI::GetNumberCivsAtWarWith
EXTRN	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarState
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
; Function compile flags: /Odtp
;	COMDAT ?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T232821 = -20						; size = 4
_iPlayerLoop$225962 = -16				; size = 4
_iRtnValue$ = -12					; size = 4
_eLoopPlayer$ = -8					; size = 4
_eWarState$ = -4					; size = 4
?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ PROC	; CvMilitaryAI::GetNumberCivsAtWarWith, COMDAT
; _this$ = ecx

; 1612 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 	PlayerTypes eLoopPlayer;
; 1614 : 	WarStateTypes eWarState;
; 1615 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 1616 : 
; 1617 : 	// Let's figure out if we're at war
; 1618 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225962[ebp], 0
	jmp	SHORT $LN5@GetNumberC
$LN4@GetNumberC:
	mov	eax, DWORD PTR _iPlayerLoop$225962[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$225962[ebp], eax
$LN5@GetNumberC:
	cmp	DWORD PTR _iPlayerLoop$225962[ebp], 22	; 00000016H
	jge	SHORT $LN3@GetNumberC

; 1619 : 	{
; 1620 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$225962[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 1621 : 
; 1622 : 		// Is this a player we have relations with?
; 1623 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232821[ebp], ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	edx, DWORD PTR $T232821[ebp]
	je	SHORT $LN2@GetNumberC
	push	0
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetNumberC

; 1624 : 		{
; 1625 : 			eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState
	mov	DWORD PTR _eWarState$[ebp], eax

; 1626 : 			if(eWarState != NO_WAR_STATE_TYPE)

	cmp	DWORD PTR _eWarState$[ebp], -1
	je	SHORT $LN2@GetNumberC

; 1627 : 			{
; 1628 : 				iRtnValue++;

	mov	edx, DWORD PTR _iRtnValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _iRtnValue$[ebp], edx
$LN2@GetNumberC:

; 1629 : 			}
; 1630 : 		}
; 1631 : 	}

	jmp	SHORT $LN4@GetNumberC
$LN3@GetNumberC:

; 1632 : 
; 1633 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 1634 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ENDP	; CvMilitaryAI::GetNumberCivsAtWarWith
_TEXT	ENDS
PUBLIC	??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
PUBLIC	?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy
PUBLIC	??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
PUBLIC	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z$0
__ehfuncinfo$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T232860 = -88						; size = 4
$T232853 = -84						; size = 4
$T232825 = -64						; size = 4
$T232824 = -60						; size = 4
_ui$226140 = -56					; size = 4
_bCityAlreadyExamined$226139 = -49			; size = 1
_iThreatValue$226146 = -48				; size = 4
_iLoopCity$226135 = -44					; size = 4
_iHighestThreatValue$226133 = -40			; size = 4
_pCity$226132 = -36					; size = 4
_pLoopCity$226134 = -32					; size = 4
_iCycle$226128 = -28					; size = 4
_m_apCities$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
_iOrder$ = 8						; size = 4
?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z PROC ; CvMilitaryAI::GetMostThreatenedCity, COMDAT
; _this$ = ecx

; 1638 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1639 : 	// slewis - this is slow, but I did it quickly!
; 1640 : 
; 1641 : 	FFastVector<CvCity*> m_apCities;

	push	0
	lea	ecx, DWORD PTR _m_apCities$[ebp]
	call	??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1642 : 	m_apCities.push_back_copy(NULL, iOrder + 1);

	mov	DWORD PTR $T232824[ebp], 0
	mov	eax, DWORD PTR _iOrder$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T232824[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_apCities$[ebp]
	call	?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy

; 1643 : 
; 1644 : 	for(int iCycle = 0; iCycle < iOrder + 1; iCycle++)

	mov	DWORD PTR _iCycle$226128[ebp], 0
	jmp	SHORT $LN15@GetMostThr
$LN14@GetMostThr:
	mov	edx, DWORD PTR _iCycle$226128[ebp]
	add	edx, 1
	mov	DWORD PTR _iCycle$226128[ebp], edx
$LN15@GetMostThr:
	mov	eax, DWORD PTR _iOrder$[ebp]
	add	eax, 1
	cmp	DWORD PTR _iCycle$226128[ebp], eax
	jge	$LN47@GetMostThr

; 1645 : 	{
; 1646 : 		CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$226132[ebp], 0

; 1647 : 		int iHighestThreatValue = 0;

	mov	DWORD PTR _iHighestThreatValue$226133[ebp], 0

; 1648 : 
; 1649 : 		CvCity* pLoopCity;
; 1650 : 		int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$226135[ebp], 0

; 1651 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	ecx, DWORD PTR _iLoopCity$226135[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226134[ebp], eax
	jmp	SHORT $LN12@GetMostThr
$LN11@GetMostThr:
	push	0
	lea	eax, DWORD PTR _iLoopCity$226135[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226134[ebp], eax
$LN12@GetMostThr:
	cmp	DWORD PTR _pLoopCity$226134[ebp], 0
	je	$LN10@GetMostThr

; 1652 : 		{
; 1653 : 			bool bCityAlreadyExamined = false;

	mov	BYTE PTR _bCityAlreadyExamined$226139[ebp], 0

; 1654 : 			for(uint ui = 0; ui < m_apCities.size(); ui++)

	mov	DWORD PTR _ui$226140[ebp], 0
	jmp	SHORT $LN9@GetMostThr
$LN8@GetMostThr:
	mov	edx, DWORD PTR _ui$226140[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$226140[ebp], edx
$LN9@GetMostThr:
	mov	eax, DWORD PTR _m_apCities$[ebp+4]
	mov	DWORD PTR $T232853[ebp], eax
	mov	ecx, DWORD PTR _ui$226140[ebp]
	cmp	ecx, DWORD PTR $T232853[ebp]
	jae	SHORT $LN7@GetMostThr

; 1655 : 			{
; 1656 : 				if(pLoopCity == m_apCities[ui])

	mov	edx, DWORD PTR _ui$226140[ebp]
	mov	eax, DWORD PTR _m_apCities$[ebp]
	mov	ecx, DWORD PTR _pLoopCity$226134[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4]
	jne	SHORT $LN6@GetMostThr

; 1657 : 				{
; 1658 : 					bCityAlreadyExamined = true;

	mov	BYTE PTR _bCityAlreadyExamined$226139[ebp], 1

; 1659 : 					break;

	jmp	SHORT $LN7@GetMostThr
$LN6@GetMostThr:

; 1660 : 				}
; 1661 : 			}

	jmp	SHORT $LN8@GetMostThr
$LN7@GetMostThr:

; 1662 : 			if(bCityAlreadyExamined)

	movzx	edx, BYTE PTR _bCityAlreadyExamined$226139[ebp]
	test	edx, edx
	je	SHORT $LN5@GetMostThr

; 1663 : 			{
; 1664 : 				continue;

	jmp	SHORT $LN11@GetMostThr
$LN5@GetMostThr:

; 1665 : 			}
; 1666 : 
; 1667 : 			int iThreatValue = pLoopCity->getThreatValue();

	mov	ecx, DWORD PTR _pLoopCity$226134[ebp]
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	mov	DWORD PTR _iThreatValue$226146[ebp], eax

; 1668 : 			iThreatValue = iThreatValue * pLoopCity->getPopulation();

	mov	ecx, DWORD PTR _pLoopCity$226134[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, DWORD PTR _iThreatValue$226146[ebp]
	mov	DWORD PTR _iThreatValue$226146[ebp], eax

; 1669 : 
; 1670 : 			if(pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$226134[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetMostThr

; 1671 : 			{
; 1672 : 				iThreatValue = (iThreatValue * GC.getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL()) / 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2188
	mov	DWORD PTR $T232860[ebp], ecx
	mov	eax, DWORD PTR _iThreatValue$226146[ebp]
	imul	eax, DWORD PTR $T232860[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iThreatValue$226146[ebp], eax
$LN4@GetMostThr:

; 1673 : 			}
; 1674 : 
; 1675 : 			if(iThreatValue > iHighestThreatValue)

	mov	edx, DWORD PTR _iThreatValue$226146[ebp]
	cmp	edx, DWORD PTR _iHighestThreatValue$226133[ebp]
	jle	SHORT $LN3@GetMostThr

; 1676 : 			{
; 1677 : 				pCity = pLoopCity;

	mov	eax, DWORD PTR _pLoopCity$226134[ebp]
	mov	DWORD PTR _pCity$226132[ebp], eax

; 1678 : 				iHighestThreatValue = iThreatValue;

	mov	ecx, DWORD PTR _iThreatValue$226146[ebp]
	mov	DWORD PTR _iHighestThreatValue$226133[ebp], ecx
$LN3@GetMostThr:

; 1679 : 			}
; 1680 : 		}

	jmp	$LN11@GetMostThr
$LN10@GetMostThr:

; 1681 : 
; 1682 : 		if(pCity)

	cmp	DWORD PTR _pCity$226132[ebp], 0
	je	SHORT $LN2@GetMostThr

; 1683 : 		{
; 1684 : 			m_apCities[iCycle] = pCity;

	mov	edx, DWORD PTR _iCycle$226128[ebp]
	mov	eax, DWORD PTR _m_apCities$[ebp]
	mov	ecx, DWORD PTR _pCity$226132[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1685 : 		}
; 1686 : 		else

	jmp	SHORT $LN1@GetMostThr
$LN2@GetMostThr:

; 1687 : 		{
; 1688 : 			// we didn't find a city, so bail
; 1689 : 			break;

	jmp	SHORT $LN47@GetMostThr
$LN1@GetMostThr:

; 1690 : 		}
; 1691 : 	}

	jmp	$LN14@GetMostThr

; 1692 : 
; 1693 : 	return m_apCities[iOrder];

$LN47@GetMostThr:
	mov	edx, DWORD PTR _iOrder$[ebp]
	mov	eax, DWORD PTR _m_apCities$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T232825[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_apCities$[ebp]
	call	??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
	mov	eax, DWORD PTR $T232825[ebp]

; 1694 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z$0:
	lea	ecx, DWORD PTR _m_apCities$[ebp]
	jmp	??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
__ehhandler$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ENDP ; CvMilitaryAI::GetMostThreatenedCity
PUBLIC	?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize
; Function compile flags: /Odtp
;	COMDAT ?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ PROC ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize, COMDAT
; _this$ = ecx

; 1698 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1699 : 	if(m_iRecommendedMilitarySize <= 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jg	SHORT $LN2@GetPercent

; 1700 : 	{
; 1701 : 		return 100;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN3@GetPercent

; 1702 : 	}
; 1703 : 	else

	jmp	SHORT $LN3@GetPercent
$LN2@GetPercent:

; 1704 : 	{
; 1705 : 		return m_iNumLandUnits * 100 / m_iRecommendedMilitarySize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+52]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+96]
$LN3@GetPercent:

; 1706 : 	}
; 1707 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ ENDP ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize
_TEXT	ENDS
PUBLIC	??_C@_06DAGDBLPI@?0?5Land?$AA@			; `string'
PUBLIC	??_C@_05BENAEHHE@?0?5Sea?$AA@			; `string'
PUBLIC	??_C@_0CJ@OEPBOLDK@Target?3?5?$CFs?0?5Muster?3?5?$CFs?0?5?$CFd?0?5Dist@ ; `string'
PUBLIC	??0CvMilitaryTarget@@QAE@XZ			; CvMilitaryTarget::CvMilitaryTarget
PUBLIC	??_C@_0BE@FFIDIIGN@City?5State?5Attack?0?5?$AA@	; `string'
PUBLIC	??_C@_0BE@BJKNLDOP@Pure?5Naval?5Attack?0?5?$AA@	; `string'
PUBLIC	??_C@_0P@MABHLFCM@Sneak?5Attack?0?5?$AA@	; `string'
PUBLIC	??_C@_0P@MDDHKLMB@Basic?5Attack?0?5?$AA@	; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_06DAGDBLPI@?0?5Land?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06DAGDBLPI@?0?5Land?$AA@ DB ', Land', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BENAEHHE@?0?5Sea?$AA@
CONST	SEGMENT
??_C@_05BENAEHHE@?0?5Sea?$AA@ DB ', Sea', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OEPBOLDK@Target?3?5?$CFs?0?5Muster?3?5?$CFs?0?5?$CFd?0?5Dist@
CONST	SEGMENT
??_C@_0CJ@OEPBOLDK@Target?3?5?$CFs?0?5Muster?3?5?$CFs?0?5?$CFd?0?5Dist@ DB 'T'
	DB	'arget: %s, Muster: %s, %d, Distance: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FFIDIIGN@City?5State?5Attack?0?5?$AA@
CONST	SEGMENT
??_C@_0BE@FFIDIIGN@City?5State?5Attack?0?5?$AA@ DB 'City State Attack, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BJKNLDOP@Pure?5Naval?5Attack?0?5?$AA@
CONST	SEGMENT
??_C@_0BE@BJKNLDOP@Pure?5Naval?5Attack?0?5?$AA@ DB 'Pure Naval Attack, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MABHLFCM@Sneak?5Attack?0?5?$AA@
CONST	SEGMENT
??_C@_0P@MABHLFCM@Sneak?5Attack?0?5?$AA@ DB 'Sneak Attack, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDDHKLMB@Basic?5Attack?0?5?$AA@
CONST	SEGMENT
??_C@_0P@MDDHKLMB@Basic?5Attack?0?5?$AA@ DB 'Basic Attack, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
CONST	SEGMENT
??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@ DB 'OperationalAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@
CONST	SEGMENT
??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@ DB 'OperationalAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
_TEXT	SEGMENT
tv74 = -472						; size = 4
tv317 = -468						; size = 4
tv328 = -464						; size = 4
tv305 = -460						; size = 4
tv339 = -456						; size = 4
tv149 = -452						; size = 4
tv350 = -448						; size = 4
tv301 = -444						; size = 4
tv361 = -440						; size = 4
_this$ = -436						; size = 4
$T233028 = -432						; size = 4
$T233024 = -428						; size = 4
$T233012 = -424						; size = 4
$T233008 = -420						; size = 4
$T233007 = -416						; size = 4
_elem$233003 = -412					; size = 28
$T232977 = -384						; size = 4
$T232972 = -380						; size = 4
$T232968 = -376						; size = 4
$T232964 = -372						; size = 4
$T232955 = -368						; size = 4
$T232951 = -364						; size = 4
$T232914 = -360						; size = 28
$T232913 = -332						; size = 28
$T232912 = -304						; size = 28
$T232911 = -276						; size = 28
$T232910 = -248						; size = 28
$T232909 = -220						; size = 28
_target$226195 = -192					; size = 24
_iWeight$226196 = -168					; size = 4
_iI$226191 = -164					; size = 4
_strOutBuf$226165 = -160				; size = 28
_playerName$226168 = -132				; size = 28
_strLogName$226169 = -104				; size = 28
_pLog$226170 = -76					; size = 4
_strTemp$226167 = -72					; size = 28
_strBaseString$226166 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eAIOperationType$ = 8					; size = 4
_eEnemy$ = 12						; size = 4
_weightedTargetList$ = 16				; size = 4
?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z PROC ; CvMilitaryAI::LogAttackTargets, COMDAT
; _this$ = ecx

; 1711 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 460				; 000001ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1712 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN15@LogAttackT
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@LogAttackT

; 1713 : 	{
; 1714 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1715 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1716 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226167[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1717 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226168[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1718 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1719 : 
; 1720 : 		// Find the name of this civ
; 1721 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T232951[ebp], eax
	cmp	DWORD PTR $T232951[ebp], 0
	je	SHORT $LN44@LogAttackT
	mov	eax, DWORD PTR $T232951[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226168[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN45@LogAttackT
$LN44@LogAttackT:
	lea	ecx, DWORD PTR _playerName$226168[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN45@LogAttackT:

; 1722 : 
; 1723 : 		// Open the log file
; 1724 : 		FILogFile* pLog;
; 1725 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN13@LogAttackT

; 1726 : 		{
; 1727 : 			strLogName = "OperationalAILog_" + playerName + ".csv";

	lea	edx, DWORD PTR _playerName$226168[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@
	lea	eax, DWORD PTR $T232909[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv361[ebp], eax
	mov	ecx, DWORD PTR tv361[ebp]
	mov	DWORD PTR tv301[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv301[ebp]
	push	edx
	lea	eax, DWORD PTR $T232910[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv350[ebp], eax
	mov	ecx, DWORD PTR tv350[ebp]
	mov	DWORD PTR $T232955[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T232955[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232910[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T232909[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1728 : 		}
; 1729 : 		else

	jmp	SHORT $LN12@LogAttackT
$LN13@LogAttackT:

; 1730 : 		{
; 1731 : 			strLogName = "OperationalAILog.csv";

	mov	edx, OFFSET ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN50@LogAttackT
	push	OFFSET ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN12@LogAttackT
$LN50@LogAttackT:
	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN12@LogAttackT:

; 1732 : 		}
; 1733 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv149[ebp], eax
	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232964[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T232964[ebp]
	push	eax
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv149[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226170[ebp], eax

; 1734 : 
; 1735 : 		// Get the leading info for this line
; 1736 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232968[ebp], ecx
	mov	ecx, DWORD PTR $T232968[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226166[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1737 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226168[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232911[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv339[ebp], eax
	mov	edx, DWORD PTR tv339[ebp]
	mov	DWORD PTR tv305[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR tv305[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T232911[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1738 : 		if(eAIOperationType == AI_OPERATION_BASIC_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 2
	jne	SHORT $LN11@LogAttackT

; 1739 : 		{
; 1740 : 			strBaseString += "Basic Attack, ";

	push	OFFSET ??_C@_0P@MDDHKLMB@Basic?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN10@LogAttackT
$LN11@LogAttackT:

; 1741 : 		}
; 1742 : 		else if(eAIOperationType == AI_OPERATION_SNEAK_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 6
	jne	SHORT $LN9@LogAttackT

; 1743 : 		{
; 1744 : 			strBaseString += "Sneak Attack, ";

	push	OFFSET ??_C@_0P@MABHLFCM@Sneak?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN10@LogAttackT
$LN9@LogAttackT:

; 1745 : 		}
; 1746 : 		else if(eAIOperationType == AI_OPERATION_PURE_NAVAL_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 18	; 00000012H
	jne	SHORT $LN7@LogAttackT

; 1747 : 		{
; 1748 : 			strBaseString += "Pure Naval Attack, ";

	push	OFFSET ??_C@_0BE@BJKNLDOP@Pure?5Naval?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1749 : 		}
; 1750 : 		else

	jmp	SHORT $LN10@LogAttackT
$LN7@LogAttackT:

; 1751 : 		{
; 1752 : 			strBaseString += "City State Attack, ";

	push	OFFSET ??_C@_0BE@FFIDIIGN@City?5State?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN10@LogAttackT:

; 1753 : 		}
; 1754 : 		strBaseString += GET_PLAYER(eEnemy).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eEnemy$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232972[ebp], ecx
	mov	ecx, DWORD PTR $T232972[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1755 : 		strBaseString += ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1756 : 
; 1757 : 		// Dump out the weight of each buildable item
; 1758 : 		for(int iI = 0; iI < weightedTargetList.size(); iI++)

	mov	DWORD PTR _iI$226191[ebp], 0
	jmp	SHORT $LN5@LogAttackT
$LN4@LogAttackT:
	mov	edx, DWORD PTR _iI$226191[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$226191[ebp], edx
$LN5@LogAttackT:
	mov	eax, DWORD PTR _weightedTargetList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232977[ebp], ecx
	mov	edx, DWORD PTR _iI$226191[ebp]
	cmp	edx, DWORD PTR $T232977[ebp]
	jge	$LN3@LogAttackT

; 1759 : 		{
; 1760 : 			CvMilitaryTarget target = weightedTargetList.GetElement(iI);

	mov	eax, DWORD PTR _iI$226191[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _weightedTargetList$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _target$226195[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _target$226195[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _target$226195[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _target$226195[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _target$226195[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR _target$226195[ebp+20], ecx

; 1761 : 			int iWeight = weightedTargetList.GetWeight(iI);

	lea	ecx, DWORD PTR _elem$233003[ebp]
	call	??0CvMilitaryTarget@@QAE@XZ		; CvMilitaryTarget::CvMilitaryTarget
	mov	DWORD PTR _elem$233003[ebp+24], 0
	mov	edx, DWORD PTR _iI$226191[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _weightedTargetList$[ebp]
	mov	esi, DWORD PTR [eax]
	add	esi, edx
	mov	ecx, 7
	lea	edi, DWORD PTR _elem$233003[ebp]
	rep movsd
	mov	ecx, DWORD PTR _elem$233003[ebp+24]
	mov	DWORD PTR _iWeight$226196[ebp], ecx

; 1762 : 			strTemp.Format("Target: %s, Muster: %s, %d, Distance: %d", target.m_pTargetCity->getName().GetCString(), target.m_pMusterCity->getName().GetCString(), iWeight, target.m_iPathLength);

	lea	edx, DWORD PTR $T232912[ebp]
	push	edx
	mov	ecx, DWORD PTR _target$226195[ebp+4]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv328[ebp], eax
	mov	eax, DWORD PTR tv328[ebp]
	mov	DWORD PTR $T233007[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T232913[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$226195[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv317[ebp], eax
	mov	edx, DWORD PTR tv317[ebp]
	mov	DWORD PTR $T233012[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T233007[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233008[ebp], eax
	mov	eax, DWORD PTR _target$226195[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _iWeight$226196[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233008[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233012[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CJ@OEPBOLDK@Target?3?5?$CFs?0?5Muster?3?5?$CFs?0?5?$CFd?0?5Dist@
	lea	eax, DWORD PTR _strTemp$226167[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T232913[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T232912[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1763 : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$226167[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$226166[ebp]
	push	edx
	lea	eax, DWORD PTR $T232914[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T233024[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T233024[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T232914[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1764 : 			if(target.m_bAttackBySea)

	movzx	edx, BYTE PTR _target$226195[ebp+20]
	test	edx, edx
	je	SHORT $LN2@LogAttackT

; 1765 : 			{
; 1766 : 				strOutBuf += ", Sea";

	push	OFFSET ??_C@_05BENAEHHE@?0?5Sea?$AA@
	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1767 : 			}
; 1768 : 			else

	jmp	SHORT $LN1@LogAttackT
$LN2@LogAttackT:

; 1769 : 			{
; 1770 : 				strOutBuf += ", Land";

	push	OFFSET ??_C@_06DAGDBLPI@?0?5Land?$AA@
	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@LogAttackT:

; 1771 : 			}
; 1772 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233028[ebp], eax
	mov	eax, DWORD PTR $T233028[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226170[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226170[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1773 : 		}

	jmp	$LN4@LogAttackT
$LN3@LogAttackT:

; 1774 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226168[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226167[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN15@LogAttackT:

; 1775 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226165[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226166[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$226167[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$3:
	lea	ecx, DWORD PTR _playerName$226168[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$4:
	lea	ecx, DWORD PTR _strLogName$226169[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$5:
	lea	ecx, DWORD PTR $T232909[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$6:
	lea	ecx, DWORD PTR $T232910[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$7:
	lea	ecx, DWORD PTR $T232911[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$8:
	lea	ecx, DWORD PTR $T232912[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$9:
	lea	ecx, DWORD PTR $T232913[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$10:
	lea	ecx, DWORD PTR $T232914[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ENDP ; CvMilitaryAI::LogAttackTargets
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.h
;	COMDAT ??0CvMilitaryTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvMilitaryTarget@@QAE@XZ PROC			; CvMilitaryTarget::CvMilitaryTarget, COMDAT
; _this$ = ecx

; 130  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], 0

; 131  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvMilitaryTarget@@QAE@XZ ENDP			; CvMilitaryTarget::CvMilitaryTarget
_TEXT	ENDS
PUBLIC	??_C@_0BH@JNLPFNBD@CHOSEN?3?5?$CFs?0?5Muster?3?5?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BH@JNLPFNBD@CHOSEN?3?5?$CFs?0?5Muster?3?5?$CFs?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BH@JNLPFNBD@CHOSEN?3?5?$CFs?0?5Muster?3?5?$CFs?$AA@ DB 'CHOSEN: %s'
	DB	', Muster: %s', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
_TEXT	SEGMENT
tv74 = -408						; size = 4
tv306 = -404						; size = 4
tv317 = -400						; size = 4
tv294 = -396						; size = 4
tv328 = -392						; size = 4
tv149 = -388						; size = 4
tv339 = -384						; size = 4
tv290 = -380						; size = 4
tv350 = -376						; size = 4
_this$ = -372						; size = 4
$T233148 = -368						; size = 4
$T233144 = -364						; size = 4
$T233132 = -360						; size = 4
$T233128 = -356						; size = 4
$T233127 = -352						; size = 4
$T233123 = -348						; size = 4
$T233119 = -344						; size = 4
$T233115 = -340						; size = 4
$T233106 = -336						; size = 4
$T233102 = -332						; size = 4
$T233065 = -328						; size = 28
$T233064 = -300						; size = 28
$T233063 = -272						; size = 28
$T233062 = -244						; size = 28
$T233061 = -216						; size = 28
$T233060 = -188						; size = 28
_strOutBuf$226212 = -160				; size = 28
_playerName$226215 = -132				; size = 28
_strLogName$226216 = -104				; size = 28
_pLog$226217 = -76					; size = 4
_strTemp$226214 = -72					; size = 28
_strBaseString$226213 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eAIOperationType$ = 8					; size = 4
_eEnemy$ = 12						; size = 4
_target$ = 16						; size = 4
?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z PROC ; CvMilitaryAI::LogChosenTarget, COMDAT
; _this$ = ecx

; 1779 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 396				; 0000018cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1780 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN12@LogChosenT
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@LogChosenT

; 1781 : 	{
; 1782 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1783 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1784 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226214[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1785 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226215[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1786 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1787 : 
; 1788 : 		// Find the name of this civ and city
; 1789 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233102[ebp], eax
	cmp	DWORD PTR $T233102[ebp], 0
	je	SHORT $LN41@LogChosenT
	mov	eax, DWORD PTR $T233102[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226215[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN42@LogChosenT
$LN41@LogChosenT:
	lea	ecx, DWORD PTR _playerName$226215[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN42@LogChosenT:

; 1790 : 
; 1791 : 		// Open the log file
; 1792 : 		FILogFile* pLog;
; 1793 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@LogChosenT

; 1794 : 		{
; 1795 : 			strLogName = "OperationalAILog_" + playerName + ".csv";

	lea	edx, DWORD PTR _playerName$226215[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@
	lea	eax, DWORD PTR $T233060[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv350[ebp], eax
	mov	ecx, DWORD PTR tv350[ebp]
	mov	DWORD PTR tv290[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv290[ebp]
	push	edx
	lea	eax, DWORD PTR $T233061[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv339[ebp], eax
	mov	ecx, DWORD PTR tv339[ebp]
	mov	DWORD PTR $T233106[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T233106[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233061[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233060[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1796 : 		}
; 1797 : 		else

	jmp	SHORT $LN9@LogChosenT
$LN10@LogChosenT:

; 1798 : 		{
; 1799 : 			strLogName = "OperationalAILog.csv";

	mov	edx, OFFSET ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN47@LogChosenT
	push	OFFSET ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN9@LogChosenT
$LN47@LogChosenT:
	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN9@LogChosenT:

; 1800 : 		}
; 1801 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv149[ebp], eax
	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233115[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T233115[ebp]
	push	eax
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv149[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226217[ebp], eax

; 1802 : 
; 1803 : 		// Get the leading info for this line
; 1804 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233119[ebp], ecx
	mov	ecx, DWORD PTR $T233119[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226213[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1805 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226215[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233062[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv328[ebp], eax
	mov	edx, DWORD PTR tv328[ebp]
	mov	DWORD PTR tv294[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR tv294[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233062[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1806 : 		if(eAIOperationType == AI_OPERATION_BASIC_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 2
	jne	SHORT $LN8@LogChosenT

; 1807 : 		{
; 1808 : 			strBaseString += "Basic Attack, ";

	push	OFFSET ??_C@_0P@MDDHKLMB@Basic?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN7@LogChosenT
$LN8@LogChosenT:

; 1809 : 		}
; 1810 : 		else if(eAIOperationType == AI_OPERATION_SNEAK_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 6
	jne	SHORT $LN6@LogChosenT

; 1811 : 		{
; 1812 : 			strBaseString += "Sneak Attack, ";

	push	OFFSET ??_C@_0P@MABHLFCM@Sneak?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN7@LogChosenT
$LN6@LogChosenT:

; 1813 : 		}
; 1814 : 		else if(eAIOperationType == AI_OPERATION_PURE_NAVAL_CITY_ATTACK)

	cmp	DWORD PTR _eAIOperationType$[ebp], 18	; 00000012H
	jne	SHORT $LN4@LogChosenT

; 1815 : 		{
; 1816 : 			strBaseString += "Pure Naval Attack, ";

	push	OFFSET ??_C@_0BE@BJKNLDOP@Pure?5Naval?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1817 : 		}
; 1818 : 		else

	jmp	SHORT $LN7@LogChosenT
$LN4@LogChosenT:

; 1819 : 		{
; 1820 : 			strBaseString += "City State Attack, ";

	push	OFFSET ??_C@_0BE@FFIDIIGN@City?5State?5Attack?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN7@LogChosenT:

; 1821 : 		}
; 1822 : 		strBaseString += GET_PLAYER(eEnemy).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eEnemy$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233123[ebp], ecx
	mov	ecx, DWORD PTR $T233123[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1823 : 		strBaseString += ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1824 : 
; 1825 : 		strTemp.Format("CHOSEN: %s, Muster: %s", target.m_pTargetCity->getName().GetCString(), target.m_pMusterCity->getName().GetCString());

	lea	edx, DWORD PTR $T233063[ebp]
	push	edx
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv317[ebp], eax
	mov	ecx, DWORD PTR tv317[ebp]
	mov	DWORD PTR $T233127[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	edx, DWORD PTR $T233064[ebp]
	push	edx
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv306[ebp], eax
	mov	ecx, DWORD PTR tv306[ebp]
	mov	DWORD PTR $T233132[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T233127[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233128[ebp], eax
	mov	edx, DWORD PTR $T233128[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233132[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BH@JNLPFNBD@CHOSEN?3?5?$CFs?0?5Muster?3?5?$CFs?$AA@
	lea	eax, DWORD PTR _strTemp$226214[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T233064[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233063[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1826 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$226214[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$226213[ebp]
	push	edx
	lea	eax, DWORD PTR $T233065[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T233144[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T233144[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233065[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1827 : 		if(target.m_bAttackBySea)

	mov	edx, DWORD PTR _target$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	test	eax, eax
	je	SHORT $LN2@LogChosenT

; 1828 : 		{
; 1829 : 			strOutBuf += ", Sea";

	push	OFFSET ??_C@_05BENAEHHE@?0?5Sea?$AA@
	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1830 : 		}
; 1831 : 		else

	jmp	SHORT $LN1@LogChosenT
$LN2@LogChosenT:

; 1832 : 		{
; 1833 : 			strOutBuf += ", Land";

	push	OFFSET ??_C@_06DAGDBLPI@?0?5Land?$AA@
	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@LogChosenT:

; 1834 : 		}
; 1835 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233148[ebp], eax
	mov	ecx, DWORD PTR $T233148[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226217[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226217[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 1836 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226215[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226214[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@LogChosenT:

; 1837 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226212[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226213[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$226214[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$3:
	lea	ecx, DWORD PTR _playerName$226215[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$4:
	lea	ecx, DWORD PTR _strLogName$226216[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$5:
	lea	ecx, DWORD PTR $T233060[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$6:
	lea	ecx, DWORD PTR $T233061[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$7:
	lea	ecx, DWORD PTR $T233062[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$8:
	lea	ecx, DWORD PTR $T233063[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$9:
	lea	ecx, DWORD PTR $T233064[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$10:
	lea	ecx, DWORD PTR $T233065[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-400]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ENDP ; CvMilitaryAI::LogChosenTarget
PUBLIC	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage
PUBLIC	??_C@_0BE@KEMLDCGE@Declared?5War?5on?3?5?$CFs?$AA@ ; `string'
PUBLIC	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
PUBLIC	__$ArrayPad$
PUBLIC	?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z ; CvMilitaryAI::LogDeclarationOfWar
;	COMDAT ??_C@_0BE@KEMLDCGE@Declared?5War?5on?3?5?$CFs?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BE@KEMLDCGE@Declared?5War?5on?3?5?$CFs?$AA@ DB 'Declared War on: %'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv243 = -300						; size = 4
tv213 = -296						; size = 4
tv254 = -292						; size = 4
tv265 = -288						; size = 4
tv137 = -284						; size = 4
_this$ = -280						; size = 4
$T233248 = -276						; size = 4
$T233244 = -272						; size = 4
$T233237 = -268						; size = 4
$T233229 = -264						; size = 4
$T233228 = -260						; size = 4
$T233224 = -256						; size = 4
$T233218 = -252						; size = 4
$T233214 = -248						; size = 4
$T233180 = -244						; size = 28
$T233179 = -216						; size = 28
$T233178 = -188						; size = 28
_strOutBuf$226240 = -160				; size = 28
_playerName$226243 = -132				; size = 28
_opponentName$226242 = -104				; size = 28
_pLog$226245 = -76					; size = 4
_strTemp$226244 = -72					; size = 28
_strBaseString$226241 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eOpponent$ = 8						; size = 4
?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMilitaryAI::LogDeclarationOfWar, COMDAT
; _this$ = ecx

; 1841 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1842 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogDeclara
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogDeclara

; 1843 : 	{
; 1844 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226240[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1845 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226241[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1846 : 		CvString opponentName;

	lea	ecx, DWORD PTR _opponentName$226242[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1847 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226243[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1848 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226244[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1849 : 		FILogFile* pLog;
; 1850 : 
; 1851 : 		// Open the right file
; 1852 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233214[ebp], eax
	cmp	DWORD PTR $T233214[ebp], 0
	je	SHORT $LN28@LogDeclara
	mov	edx, DWORD PTR $T233214[ebp]
	push	edx
	lea	ecx, DWORD PTR _playerName$226243[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogDeclara
$LN28@LogDeclara:
	lea	ecx, DWORD PTR _playerName$226243[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogDeclara:

; 1853 : 		opponentName = GET_PLAYER(eOpponent).getCivilizationShortDescription();

	mov	eax, DWORD PTR _eOpponent$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233218[ebp], eax
	mov	ecx, DWORD PTR $T233218[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233224[ebp], eax
	cmp	DWORD PTR $T233224[ebp], 0
	je	SHORT $LN34@LogDeclara
	mov	ecx, DWORD PTR $T233224[ebp]
	push	ecx
	lea	ecx, DWORD PTR _opponentName$226242[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@LogDeclara
$LN34@LogDeclara:
	lea	ecx, DWORD PTR _opponentName$226242[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@LogDeclara:

; 1854 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv137[ebp], eax
	push	0
	lea	edx, DWORD PTR _playerName$226243[ebp]
	push	edx
	lea	eax, DWORD PTR $T233178[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv265[ebp], eax
	mov	ecx, DWORD PTR tv265[ebp]
	mov	DWORD PTR $T233228[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T233228[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233229[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T233229[ebp]
	push	edx
	mov	eax, DWORD PTR tv137[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226245[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233178[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1855 : 
; 1856 : 		// Get the leading info for this line
; 1857 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233237[ebp], ecx
	mov	ecx, DWORD PTR $T233237[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226241[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1858 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226243[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233179[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv254[ebp], eax
	mov	edx, DWORD PTR tv254[ebp]
	mov	DWORD PTR tv213[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR tv213[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226241[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233179[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1859 : 
; 1860 : 		// Strategy Info
; 1861 : 		strTemp.Format("Declared War on: %s", opponentName.GetCString());

	lea	ecx, DWORD PTR _opponentName$226242[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BE@KEMLDCGE@Declared?5War?5on?3?5?$CFs?$AA@
	lea	ecx, DWORD PTR _strTemp$226244[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1862 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$226244[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$226241[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233180[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv243[ebp], eax
	mov	edx, DWORD PTR tv243[ebp]
	mov	DWORD PTR $T233244[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233244[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226240[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233180[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1863 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226240[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233248[ebp], eax
	mov	eax, DWORD PTR $T233248[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226245[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226245[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1864 : 
; 1865 : 		LogMilitarySummaryMessage(strTemp);

	lea	edx, DWORD PTR _strTemp$226244[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1866 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$226244[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226243[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _opponentName$226242[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226241[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226240[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogDeclara:

; 1867 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226240[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226241[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _opponentName$226242[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$226243[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$226244[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T233178[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T233179[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T233180[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::LogDeclarationOfWar
PUBLIC	??_C@_0L@DIEIBNHI@DESTROYED?$CB?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ	; CvMilitaryAI::LogCivilizationDestroyed
;	COMDAT ??_C@_0L@DIEIBNHI@DESTROYED?$CB?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0L@DIEIBNHI@DESTROYED?$CB?$AA@ DB 'DESTROYED!', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
tv215 = -264						; size = 4
tv196 = -260						; size = 4
tv226 = -256						; size = 4
tv237 = -252						; size = 4
tv92 = -248						; size = 4
_this$ = -244						; size = 4
$T233330 = -240						; size = 4
$T233326 = -236						; size = 4
$T233322 = -232						; size = 4
$T233314 = -228						; size = 4
$T233313 = -224						; size = 4
$T233309 = -220						; size = 4
$T233280 = -216						; size = 28
$T233279 = -188						; size = 28
$T233278 = -160						; size = 28
_strOutBuf$226254 = -132				; size = 28
_playerName$226256 = -104				; size = 28
_pLog$226258 = -76					; size = 4
_strTemp$226257 = -72					; size = 28
_strBaseString$226255 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ PROC	; CvMilitaryAI::LogCivilizationDestroyed, COMDAT
; _this$ = ecx

; 1871 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1872 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogCiviliz
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogCiviliz

; 1873 : 	{
; 1874 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226254[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1875 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226255[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1876 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226256[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1877 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226257[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1878 : 		FILogFile* pLog;
; 1879 : 
; 1880 : 		// Open the right file
; 1881 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233309[ebp], eax
	cmp	DWORD PTR $T233309[ebp], 0
	je	SHORT $LN24@LogCiviliz
	mov	edx, DWORD PTR $T233309[ebp]
	push	edx
	lea	ecx, DWORD PTR _playerName$226256[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@LogCiviliz
$LN24@LogCiviliz:
	lea	ecx, DWORD PTR _playerName$226256[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@LogCiviliz:

; 1882 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv92[ebp], eax
	push	0
	lea	eax, DWORD PTR _playerName$226256[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233278[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv237[ebp], eax
	mov	edx, DWORD PTR tv237[ebp]
	mov	DWORD PTR $T233313[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T233313[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233314[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T233314[ebp]
	push	eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226258[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233278[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1883 : 
; 1884 : 		// Get the leading info for this line
; 1885 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233322[ebp], ecx
	mov	ecx, DWORD PTR $T233322[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226255[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1886 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226256[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233279[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv226[ebp], eax
	mov	edx, DWORD PTR tv226[ebp]
	mov	DWORD PTR tv196[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR tv196[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226255[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233279[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1887 : 
; 1888 : 		// Strategy Info
; 1889 : 		strTemp.Format("DESTROYED!");

	push	OFFSET ??_C@_0L@DIEIBNHI@DESTROYED?$CB?$AA@
	lea	ecx, DWORD PTR _strTemp$226257[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 1890 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$226257[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$226255[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233280[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR tv215[ebp]
	mov	DWORD PTR $T233326[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T233326[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226254[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233280[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1891 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226254[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233330[ebp], eax
	mov	eax, DWORD PTR $T233330[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226258[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226258[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1892 : 
; 1893 : 		LogMilitarySummaryMessage(strTemp);

	lea	edx, DWORD PTR _strTemp$226257[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1894 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$226257[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _playerName$226256[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226255[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226254[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogCiviliz:

; 1895 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$226254[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$226255[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _playerName$226256[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp$226257[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T233278[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T233279[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T233280[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ ENDP	; CvMilitaryAI::LogCivilizationDestroyed
PUBLIC	??_C@_06GNPEEHKO@From?3?5?$AA@			; `string'
PUBLIC	??_C@_0L@JMBKINMH@Captured?3?5?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::LogCityCaptured
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
;	COMDAT ??_C@_06GNPEEHKO@From?3?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06GNPEEHKO@From?3?5?$AA@ DB 'From: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JMBKINMH@Captured?3?5?$AA@
CONST	SEGMENT
??_C@_0L@JMBKINMH@Captured?3?5?$AA@ DB 'Captured: ', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv74 = -472						; size = 4
tv261 = -468						; size = 4
tv269 = -464						; size = 4
tv280 = -460						; size = 4
tv257 = -456						; size = 4
tv291 = -452						; size = 4
tv255 = -448						; size = 4
tv302 = -444						; size = 4
tv313 = -440						; size = 4
tv147 = -436						; size = 4
tv324 = -432						; size = 4
_this$ = -428						; size = 4
$T233448 = -424						; size = 4
$T233444 = -420						; size = 4
$T233440 = -416						; size = 4
$T233436 = -412						; size = 4
$T233428 = -408						; size = 4
$T233427 = -404						; size = 4
$T233419 = -400						; size = 4
$T233415 = -396						; size = 4
$T233409 = -392						; size = 4
$T233405 = -388						; size = 4
$T233362 = -384						; size = 28
$T233361 = -356						; size = 28
$T233360 = -328						; size = 28
$T233359 = -300						; size = 28
$T233358 = -272						; size = 28
$T233357 = -244						; size = 28
$T233356 = -216						; size = 28
_strOutBuf$226269 = -188				; size = 28
_strPlayerName$226271 = -160				; size = 28
_strCityName$226273 = -132				; size = 28
_pLog$226275 = -104					; size = 4
_strOldOwnerName$226272 = -100				; size = 28
_strTemp$226274 = -72					; size = 28
_strBaseString$226270 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_eOldOwner$ = 12					; size = 4
?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::LogCityCaptured, COMDAT
; _this$ = ecx

; 1899 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 460				; 000001ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1900 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogCityCap
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogCityCap

; 1901 : 	{
; 1902 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226269[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1903 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226270[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1904 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226271[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1905 : 		CvString strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$226272[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1906 : 		CvString strCityName;

	lea	ecx, DWORD PTR _strCityName$226273[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1907 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226274[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1908 : 		FILogFile* pLog;
; 1909 : 
; 1910 : 		// Open the right file
; 1911 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233405[ebp], eax
	cmp	DWORD PTR $T233405[ebp], 0
	je	SHORT $LN36@LogCityCap
	mov	edx, DWORD PTR $T233405[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$226271[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@LogCityCap
$LN36@LogCityCap:
	lea	ecx, DWORD PTR _strPlayerName$226271[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@LogCityCap:

; 1912 : 		strOldOwnerName = GET_PLAYER(eOldOwner).getCivilizationShortDescription();

	mov	eax, DWORD PTR _eOldOwner$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233409[ebp], eax
	mov	ecx, DWORD PTR $T233409[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233415[ebp], eax
	cmp	DWORD PTR $T233415[ebp], 0
	je	SHORT $LN42@LogCityCap
	mov	ecx, DWORD PTR $T233415[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOldOwnerName$226272[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@LogCityCap
$LN42@LogCityCap:
	lea	ecx, DWORD PTR _strOldOwnerName$226272[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@LogCityCap:

; 1913 : 		strCityName = pCity->getName();

	lea	edx, DWORD PTR $T233356[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv324[ebp], eax
	mov	eax, DWORD PTR tv324[ebp]
	mov	DWORD PTR $T233419[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T233419[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strCityName$226273[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233356[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1914 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv147[ebp], eax
	push	0
	lea	edx, DWORD PTR _strPlayerName$226271[ebp]
	push	edx
	lea	eax, DWORD PTR $T233357[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv313[ebp], eax
	mov	ecx, DWORD PTR tv313[ebp]
	mov	DWORD PTR $T233427[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233427[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233428[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T233428[ebp]
	push	edx
	mov	eax, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv147[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226275[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233357[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1915 : 
; 1916 : 		// Get the leading info for this line
; 1917 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233436[ebp], ecx
	mov	ecx, DWORD PTR $T233436[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226270[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1918 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _strPlayerName$226271[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233358[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv302[ebp], eax
	mov	edx, DWORD PTR tv302[ebp]
	mov	DWORD PTR tv255[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR tv255[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226270[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233358[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1919 : 
; 1920 : 		// Strategy Info
; 1921 : 		strTemp = "Captured: " + strCityName + ", ";

	lea	ecx, DWORD PTR _strCityName$226273[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@JMBKINMH@Captured?3?5?$AA@
	lea	edx, DWORD PTR $T233359[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv291[ebp], eax
	mov	eax, DWORD PTR tv291[ebp]
	mov	DWORD PTR tv257[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv257[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233360[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv280[ebp], eax
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T233440[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T233440[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$226274[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T233360[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233359[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1922 : 		strTemp += "From: " + strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$226272[ebp]
	push	ecx
	push	OFFSET ??_C@_06GNPEEHKO@From?3?5?$AA@
	lea	edx, DWORD PTR $T233361[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv269[ebp], eax
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR tv261[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR tv261[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226274[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233361[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1923 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$226274[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$226270[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233362[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T233444[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T233444[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226269[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233362[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1924 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226269[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233448[ebp], eax
	mov	eax, DWORD PTR $T233448[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226275[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226275[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1925 : 
; 1926 : 		LogMilitarySummaryMessage(strTemp);

	lea	edx, DWORD PTR _strTemp$226274[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1927 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strTemp$226274[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strCityName$226273[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strOldOwnerName$226272[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strPlayerName$226271[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226270[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226269[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogCityCap:

; 1928 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226269[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226270[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$226271[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strOldOwnerName$226272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strCityName$226273[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR _strTemp$226274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T233356[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T233357[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8:
	lea	ecx, DWORD PTR $T233358[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9:
	lea	ecx, DWORD PTR $T233359[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10:
	lea	ecx, DWORD PTR $T233360[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11:
	lea	ecx, DWORD PTR $T233361[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12:
	lea	ecx, DWORD PTR $T233362[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-464]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::LogCityCaptured
PUBLIC	??_C@_07FDEIGBFG@Razed?3?5?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::LogCityRazed
;	COMDAT ??_C@_07FDEIGBFG@Razed?3?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_07FDEIGBFG@Razed?3?5?$AA@ DB 'Razed: ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv74 = -472						; size = 4
tv261 = -468						; size = 4
tv269 = -464						; size = 4
tv280 = -460						; size = 4
tv257 = -456						; size = 4
tv291 = -452						; size = 4
tv255 = -448						; size = 4
tv302 = -444						; size = 4
tv313 = -440						; size = 4
tv147 = -436						; size = 4
tv324 = -432						; size = 4
_this$ = -428						; size = 4
$T233574 = -424						; size = 4
$T233570 = -420						; size = 4
$T233566 = -416						; size = 4
$T233562 = -412						; size = 4
$T233554 = -408						; size = 4
$T233553 = -404						; size = 4
$T233545 = -400						; size = 4
$T233541 = -396						; size = 4
$T233535 = -392						; size = 4
$T233531 = -388						; size = 4
$T233488 = -384						; size = 28
$T233487 = -356						; size = 28
$T233486 = -328						; size = 28
$T233485 = -300						; size = 28
$T233484 = -272						; size = 28
$T233483 = -244						; size = 28
$T233482 = -216						; size = 28
_strOutBuf$226291 = -188				; size = 28
_strPlayerName$226293 = -160				; size = 28
_strCityName$226295 = -132				; size = 28
_pLog$226297 = -104					; size = 4
_strOldOwnerName$226294 = -100				; size = 28
_strTemp$226296 = -72					; size = 28
_strBaseString$226292 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_eOldOwner$ = 12					; size = 4
?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::LogCityRazed, COMDAT
; _this$ = ecx

; 1932 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 460				; 000001ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1933 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogCityRaz
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogCityRaz

; 1934 : 	{
; 1935 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226291[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1936 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226292[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1937 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226293[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1938 : 		CvString strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$226294[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1939 : 		CvString strCityName;

	lea	ecx, DWORD PTR _strCityName$226295[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1940 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226296[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1941 : 		FILogFile* pLog;
; 1942 : 
; 1943 : 		// Open the right file
; 1944 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233531[ebp], eax
	cmp	DWORD PTR $T233531[ebp], 0
	je	SHORT $LN36@LogCityRaz
	mov	edx, DWORD PTR $T233531[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$226293[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@LogCityRaz
$LN36@LogCityRaz:
	lea	ecx, DWORD PTR _strPlayerName$226293[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@LogCityRaz:

; 1945 : 		strOldOwnerName = GET_PLAYER(eOldOwner).getCivilizationShortDescription();

	mov	eax, DWORD PTR _eOldOwner$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233535[ebp], eax
	mov	ecx, DWORD PTR $T233535[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233541[ebp], eax
	cmp	DWORD PTR $T233541[ebp], 0
	je	SHORT $LN42@LogCityRaz
	mov	ecx, DWORD PTR $T233541[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOldOwnerName$226294[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@LogCityRaz
$LN42@LogCityRaz:
	lea	ecx, DWORD PTR _strOldOwnerName$226294[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@LogCityRaz:

; 1946 : 		strCityName = pCity->getName();

	lea	edx, DWORD PTR $T233482[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv324[ebp], eax
	mov	eax, DWORD PTR tv324[ebp]
	mov	DWORD PTR $T233545[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T233545[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strCityName$226295[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233482[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1947 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv147[ebp], eax
	push	0
	lea	edx, DWORD PTR _strPlayerName$226293[ebp]
	push	edx
	lea	eax, DWORD PTR $T233483[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv313[ebp], eax
	mov	ecx, DWORD PTR tv313[ebp]
	mov	DWORD PTR $T233553[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233553[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233554[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T233554[ebp]
	push	edx
	mov	eax, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv147[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226297[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233483[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1948 : 
; 1949 : 		// Get the leading info for this line
; 1950 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233562[ebp], ecx
	mov	ecx, DWORD PTR $T233562[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226292[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1951 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _strPlayerName$226293[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233484[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv302[ebp], eax
	mov	edx, DWORD PTR tv302[ebp]
	mov	DWORD PTR tv255[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR tv255[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226292[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233484[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1952 : 
; 1953 : 		// Strategy Info
; 1954 : 		strTemp = "Razed: " + strCityName + ", ";

	lea	ecx, DWORD PTR _strCityName$226295[ebp]
	push	ecx
	push	OFFSET ??_C@_07FDEIGBFG@Razed?3?5?$AA@
	lea	edx, DWORD PTR $T233485[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv291[ebp], eax
	mov	eax, DWORD PTR tv291[ebp]
	mov	DWORD PTR tv257[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv257[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233486[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv280[ebp], eax
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T233566[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T233566[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$226296[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T233486[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233485[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1955 : 		strTemp += "From: " + strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$226294[ebp]
	push	ecx
	push	OFFSET ??_C@_06GNPEEHKO@From?3?5?$AA@
	lea	edx, DWORD PTR $T233487[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv269[ebp], eax
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR tv261[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR tv261[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226296[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233487[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1956 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$226296[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$226292[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233488[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T233570[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T233570[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226291[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233488[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1957 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226291[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233574[ebp], eax
	mov	eax, DWORD PTR $T233574[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226297[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226297[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1958 : 
; 1959 : 		LogMilitarySummaryMessage(strTemp);

	lea	edx, DWORD PTR _strTemp$226296[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1960 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strTemp$226296[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strCityName$226295[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strOldOwnerName$226294[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strPlayerName$226293[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226292[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226291[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogCityRaz:

; 1961 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226291[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226292[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$226293[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strOldOwnerName$226294[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strCityName$226295[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR _strTemp$226296[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T233482[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T233483[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8:
	lea	ecx, DWORD PTR $T233484[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9:
	lea	ecx, DWORD PTR $T233485[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10:
	lea	ecx, DWORD PTR $T233486[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11:
	lea	ecx, DWORD PTR $T233487[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12:
	lea	ecx, DWORD PTR $T233488[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-464]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::LogCityRazed
PUBLIC	??_C@_0BE@IJHOHFMB@Made?5peace?5with?3?5?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z	; CvMilitaryAI::LogPeace
;	COMDAT ??_C@_0BE@IJHOHFMB@Made?5peace?5with?3?5?$CFs?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BE@IJHOHFMB@Made?5peace?5with?3?5?$CFs?$AA@ DB 'Made peace with: %'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv243 = -300						; size = 4
tv213 = -296						; size = 4
tv254 = -292						; size = 4
tv265 = -288						; size = 4
tv137 = -284						; size = 4
_this$ = -280						; size = 4
$T233678 = -276						; size = 4
$T233674 = -272						; size = 4
$T233667 = -268						; size = 4
$T233659 = -264						; size = 4
$T233658 = -260						; size = 4
$T233654 = -256						; size = 4
$T233648 = -252						; size = 4
$T233644 = -248						; size = 4
$T233610 = -244						; size = 28
$T233609 = -216						; size = 28
$T233608 = -188						; size = 28
_strOutBuf$226311 = -160				; size = 28
_strOpponentName$226313 = -132				; size = 28
_strPlayerName$226314 = -104				; size = 28
_pLog$226316 = -76					; size = 4
_strTemp$226315 = -72					; size = 28
_strBaseString$226312 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eOpponent$ = 8						; size = 4
?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z PROC	; CvMilitaryAI::LogPeace, COMDAT
; _this$ = ecx

; 1965 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1966 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogPeace
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogPeace

; 1967 : 	{
; 1968 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226311[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1969 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226312[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1970 : 		CvString strOpponentName;

	lea	ecx, DWORD PTR _strOpponentName$226313[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1971 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226314[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1972 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226315[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1973 : 		FILogFile* pLog;
; 1974 : 
; 1975 : 		// Open the right file
; 1976 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233644[ebp], eax
	cmp	DWORD PTR $T233644[ebp], 0
	je	SHORT $LN28@LogPeace
	mov	edx, DWORD PTR $T233644[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$226314[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogPeace
$LN28@LogPeace:
	lea	ecx, DWORD PTR _strPlayerName$226314[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogPeace:

; 1977 : 		strOpponentName = GET_PLAYER(eOpponent).getCivilizationShortDescription();

	mov	eax, DWORD PTR _eOpponent$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233648[ebp], eax
	mov	ecx, DWORD PTR $T233648[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233654[ebp], eax
	cmp	DWORD PTR $T233654[ebp], 0
	je	SHORT $LN34@LogPeace
	mov	ecx, DWORD PTR $T233654[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOpponentName$226313[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@LogPeace
$LN34@LogPeace:
	lea	ecx, DWORD PTR _strOpponentName$226313[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@LogPeace:

; 1978 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv137[ebp], eax
	push	0
	lea	edx, DWORD PTR _strPlayerName$226314[ebp]
	push	edx
	lea	eax, DWORD PTR $T233608[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv265[ebp], eax
	mov	ecx, DWORD PTR tv265[ebp]
	mov	DWORD PTR $T233658[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T233658[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233659[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T233659[ebp]
	push	edx
	mov	eax, DWORD PTR tv137[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226316[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233608[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1979 : 
; 1980 : 		// Get the leading info for this line
; 1981 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233667[ebp], ecx
	mov	ecx, DWORD PTR $T233667[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226312[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1982 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _strPlayerName$226314[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233609[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv254[ebp], eax
	mov	edx, DWORD PTR tv254[ebp]
	mov	DWORD PTR tv213[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR tv213[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226312[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233609[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1983 : 
; 1984 : 		// Strategy Info
; 1985 : 		strTemp.Format("Made peace with: %s", strOpponentName.GetCString());

	lea	ecx, DWORD PTR _strOpponentName$226313[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BE@IJHOHFMB@Made?5peace?5with?3?5?$CFs?$AA@
	lea	ecx, DWORD PTR _strTemp$226315[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1986 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$226315[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$226312[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233610[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv243[ebp], eax
	mov	edx, DWORD PTR tv243[ebp]
	mov	DWORD PTR $T233674[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233674[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226311[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233610[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1987 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226311[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233678[ebp], eax
	mov	eax, DWORD PTR $T233678[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226316[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226316[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1988 : 
; 1989 : 		LogMilitarySummaryMessage(strTemp);

	lea	edx, DWORD PTR _strTemp$226315[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1990 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$226315[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strPlayerName$226314[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strOpponentName$226313[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226312[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226311[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogPeace:

; 1991 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226311[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226312[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strOpponentName$226313[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$226314[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$226315[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T233608[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T233609[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T233610[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z ENDP	; CvMilitaryAI::LogPeace
PUBLIC	??_C@_0BO@BCHGLDCF@Made?5peace?5with?5team?3?5?$CFd?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z	; CvMilitaryAI::LogPeace
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
;	COMDAT ??_C@_0BO@BCHGLDCF@Made?5peace?5with?5team?3?5?$CFd?5?$CI?$CFs?$CJ?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BO@BCHGLDCF@Made?5peace?5with?5team?3?5?$CFd?5?$CI?$CFs?$CJ?$AA@ DB 'M'
	DB	'ade peace with team: %d (%s)', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv266 = -304						; size = 4
tv236 = -300						; size = 4
tv277 = -296						; size = 4
tv288 = -292						; size = 4
tv95 = -288						; size = 4
_this$ = -284						; size = 4
$T233791 = -280						; size = 4
$T233787 = -276						; size = 4
$T233769 = -269						; size = 1
$T233757 = -268						; size = 4
$T233749 = -264						; size = 4
$T233748 = -260						; size = 4
$T233744 = -256						; size = 4
$T233710 = -252						; size = 28
$T233709 = -224						; size = 28
$T233708 = -196						; size = 28
_kPlayer$226338 = -168					; size = 4
_iPlayer$226334 = -164					; size = 4
_strOutBuf$226326 = -160				; size = 28
_strOpponentName$226328 = -132				; size = 28
_strPlayerName$226329 = -104				; size = 28
_pLog$226331 = -76					; size = 4
_strTemp$226330 = -72					; size = 28
_strBaseString$226327 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eOpponentTeam$ = 8					; size = 4
?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z PROC	; CvMilitaryAI::LogPeace, COMDAT
; _this$ = ecx

; 1995 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1996 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogPeace@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@LogPeace@2

; 1997 : 	{
; 1998 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226326[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1999 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226327[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2000 : 		CvString strOpponentName;

	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2001 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226329[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2002 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226330[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2003 : 		FILogFile* pLog;
; 2004 : 
; 2005 : 		// Open the right file
; 2006 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233744[ebp], eax
	cmp	DWORD PTR $T233744[ebp], 0
	je	SHORT $LN33@LogPeace@2
	mov	edx, DWORD PTR $T233744[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$226329[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN34@LogPeace@2
$LN33@LogPeace@2:
	lea	ecx, DWORD PTR _strPlayerName$226329[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN34@LogPeace@2:

; 2007 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	push	0
	lea	eax, DWORD PTR _strPlayerName$226329[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233708[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv288[ebp], eax
	mov	edx, DWORD PTR tv288[ebp]
	mov	DWORD PTR $T233748[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T233748[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233749[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T233749[ebp]
	push	eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226331[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233708[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2008 : 
; 2009 : 		// Get the leading info for this line
; 2010 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233757[ebp], ecx
	mov	ecx, DWORD PTR $T233757[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226327[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2011 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _strPlayerName$226329[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233709[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv277[ebp], eax
	mov	edx, DWORD PTR tv277[ebp]
	mov	DWORD PTR tv236[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR tv236[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226327[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233709[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2012 : 
; 2013 : 		// Collect the names of the players on the team
; 2014 : 		for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	DWORD PTR _iPlayer$226334[ebp], 0
	jmp	SHORT $LN5@LogPeace@2
$LN4@LogPeace@2:
	mov	ecx, DWORD PTR _iPlayer$226334[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayer$226334[ebp], ecx
$LN5@LogPeace@2:
	cmp	DWORD PTR _iPlayer$226334[ebp], 64	; 00000040H
	jge	$LN55@LogPeace@2

; 2015 : 		{
; 2016 : 			CvPlayer& kPlayer = GET_PLAYER((PlayerTypes) iPlayer);

	mov	edx, DWORD PTR _iPlayer$226334[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226338[ebp], edx

; 2017 : 			if(kPlayer.isAlive() && kPlayer.getTeam() == eOpponentTeam)

	mov	eax, DWORD PTR _kPlayer$226338[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T233769[ebp], cl
	movzx	edx, BYTE PTR $T233769[ebp]
	test	edx, edx
	je	SHORT $LN2@LogPeace@2
	mov	eax, DWORD PTR _kPlayer$226338[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eOpponentTeam$[ebp]
	jne	SHORT $LN2@LogPeace@2

; 2018 : 			{
; 2019 : 				if(strOpponentName.GetLength() != 0)

	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	je	SHORT $LN1@LogPeace@2

; 2020 : 					strOpponentName += ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@LogPeace@2:

; 2021 : 
; 2022 : 				strOpponentName += kPlayer.getCivilizationShortDescription();

	mov	ecx, DWORD PTR _kPlayer$226338[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@LogPeace@2:

; 2023 : 			}
; 2024 : 		}

	jmp	$LN4@LogPeace@2

; 2025 : 		// Strategy Info
; 2026 : 		strTemp.Format("Made peace with team: %d (%s)", (int)eOpponentTeam, strOpponentName.GetCString());

$LN55@LogPeace@2:
	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	edx, DWORD PTR _eOpponentTeam$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@BCHGLDCF@Made?5peace?5with?5team?3?5?$CFd?5?$CI?$CFs?$CJ?$AA@
	lea	eax, DWORD PTR _strTemp$226330[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2027 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$226330[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$226327[ebp]
	push	edx
	lea	eax, DWORD PTR $T233710[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv266[ebp], eax
	mov	ecx, DWORD PTR tv266[ebp]
	mov	DWORD PTR $T233787[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233787[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226326[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233710[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2028 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226326[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233791[ebp], eax
	mov	edx, DWORD PTR $T233791[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$226331[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$226331[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 2029 : 
; 2030 : 		LogMilitarySummaryMessage(strTemp);

	lea	ecx, DWORD PTR _strTemp$226330[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 2031 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$226330[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strPlayerName$226329[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226327[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226326[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogPeace@2:

; 2032 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226326[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226327[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$2:
	lea	ecx, DWORD PTR _strOpponentName$226328[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$226329[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$226330[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$5:
	lea	ecx, DWORD PTR $T233708[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$6:
	lea	ecx, DWORD PTR $T233709[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$7:
	lea	ecx, DWORD PTR $T233710[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z ENDP	; CvMilitaryAI::LogPeace
PUBLIC	??_C@_0CE@EDMLPMBB@Num?5Naval?5Units?3?5?$CFd?0?5In?5Armies?5?$CF@ ; `string'
PUBLIC	??_C@_0DB@JIKILAFA@Num?5Land?5Units?3?5?$CFd?0?5In?5Armies?5?$CFd@ ; `string'
PUBLIC	??_C@_0BD@FAOKJKAN@by?5DoDeficit?$CI?$CJ?0?5?0?5?$AA@ ; `string'
PUBLIC	??_C@_0BN@MLLFFMID@Scrapping?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvMilitaryAI::LogDeficitScrapUnit
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
;	COMDAT ??_C@_0CE@EDMLPMBB@Num?5Naval?5Units?3?5?$CFd?0?5In?5Armies?5?$CF@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0CE@EDMLPMBB@Num?5Naval?5Units?3?5?$CFd?0?5In?5Armies?5?$CF@ DB 'Nu'
	DB	'm Naval Units: %d, In Armies %d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JIKILAFA@Num?5Land?5Units?3?5?$CFd?0?5In?5Armies?5?$CFd@
CONST	SEGMENT
??_C@_0DB@JIKILAFA@Num?5Land?5Units?3?5?$CFd?0?5In?5Armies?5?$CFd@ DB 'Nu'
	DB	'm Land Units: %d, In Armies %d, Rec Size: %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FAOKJKAN@by?5DoDeficit?$CI?$CJ?0?5?0?5?$AA@
CONST	SEGMENT
??_C@_0BD@FAOKJKAN@by?5DoDeficit?$CI?$CJ?0?5?0?5?$AA@ DB 'by DoDeficit(),'
	DB	' , ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MLLFFMID@Scrapping?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5?$AA@
CONST	SEGMENT
??_C@_0BN@MLLFFMID@Scrapping?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5?$AA@ DB 'S'
	DB	'crapping %s, X: %d, Y: %d, ', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv240 = -228						; size = 4
tv258 = -224						; size = 4
tv269 = -220						; size = 4
tv88 = -216						; size = 4
_this$ = -212						; size = 4
$T233901 = -208						; size = 4
$T233897 = -204						; size = 4
$T233893 = -200						; size = 4
$T233889 = -196						; size = 4
$T233885 = -192						; size = 4
$T233876 = -188						; size = 4
$T233872 = -184						; size = 4
$T233863 = -180						; size = 4
$T233859 = -176						; size = 4
$T233851 = -172						; size = 4
$T233850 = -168						; size = 4
$T233846 = -164						; size = 4
$T233822 = -160						; size = 28
$T233821 = -132						; size = 28
_strOutBuf$226350 = -104				; size = 28
_playerName$226352 = -76				; size = 28
_pLog$226353 = -48					; size = 4
_strTemp$226351 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvMilitaryAI::LogDeficitScrapUnit, COMDAT
; _this$ = ecx

; 2037 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2038 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@LogDeficit
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@LogDeficit

; 2039 : 	{
; 2040 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2041 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226351[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2042 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226352[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2043 : 		FILogFile* pLog;
; 2044 : 
; 2045 : 		// Open the right file
; 2046 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233846[ebp], eax
	cmp	DWORD PTR $T233846[ebp], 0
	je	SHORT $LN22@LogDeficit
	mov	eax, DWORD PTR $T233846[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226352[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@LogDeficit
$LN22@LogDeficit:
	lea	ecx, DWORD PTR _playerName$226352[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@LogDeficit:

; 2047 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv88[ebp], eax
	push	0
	lea	ecx, DWORD PTR _playerName$226352[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233821[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv269[ebp], eax
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR $T233850[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T233850[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233851[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T233851[ebp]
	push	ecx
	mov	edx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$226353[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233821[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2048 : 
; 2049 : 		strOutBuf.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233859[ebp], eax
	mov	ecx, DWORD PTR $T233859[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2050 : 		strOutBuf += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$226352[ebp]
	push	edx
	lea	eax, DWORD PTR $T233822[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv258[ebp], eax
	mov	ecx, DWORD PTR tv258[ebp]
	mov	DWORD PTR tv240[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv240[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233822[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2051 : 		strTemp.Format("Scrapping %s, X: %d, Y: %d, ", pUnit->getUnitInfo().GetDescription(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T233863[ebp], eax
	mov	ecx, DWORD PTR $T233863[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T233872[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T233876[ebp], eax
	mov	ecx, DWORD PTR $T233876[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T233885[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T233889[ebp], eax
	mov	ecx, DWORD PTR $T233889[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T233893[ebp], eax
	mov	ecx, DWORD PTR $T233872[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233885[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233893[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BN@MLLFFMID@Scrapping?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5?$AA@
	lea	eax, DWORD PTR _strTemp$226351[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2052 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$226351[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2053 : 		strOutBuf += "by DoDeficit(), , ";   //extra space so format is consistent with LogScrapUnit()

	push	OFFSET ??_C@_0BD@FAOKJKAN@by?5DoDeficit?$CI?$CJ?0?5?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2054 : 		if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T233897[ebp], edx
	mov	ecx, DWORD PTR $T233897[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN2@LogDeficit

; 2055 : 		{
; 2056 : 			strTemp.Format("Num Land Units: %d, In Armies %d, Rec Size: %d, ", m_iNumLandUnits, m_iNumLandUnitsInArmies, m_iRecommendedMilitarySize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET ??_C@_0DB@JIKILAFA@Num?5Land?5Units?3?5?$CFd?0?5In?5Armies?5?$CFd@
	lea	eax, DWORD PTR _strTemp$226351[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2057 : 		}
; 2058 : 		else

	jmp	SHORT $LN1@LogDeficit
$LN2@LogDeficit:

; 2059 : 		{
; 2060 : 			strTemp.Format("Num Naval Units: %d, In Armies %d, ", m_iNumNavalUnits, m_iNumNavalUnitsInArmies);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	push	OFFSET ??_C@_0CE@EDMLPMBB@Num?5Naval?5Units?3?5?$CFd?0?5In?5Armies?5?$CF@
	lea	edx, DWORD PTR _strTemp$226351[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN1@LogDeficit:

; 2061 : 		}
; 2062 : 		strOutBuf += strTemp;

	lea	eax, DWORD PTR _strTemp$226351[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2063 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233901[ebp], eax
	mov	ecx, DWORD PTR $T233901[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226353[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226353[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 2064 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226352[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226351[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@LogDeficit:

; 2065 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN4@LogDeficit
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@LogDeficit:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$226350[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$226351[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _playerName$226352[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$4:
	lea	ecx, DWORD PTR $T233821[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$5:
	lea	ecx, DWORD PTR $T233822[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvMilitaryAI::LogDeficitScrapUnit
PUBLIC	??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ ; `string'
PUBLIC	__real@3ecccccd
PUBLIC	__real@42c80000
PUBLIC	??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@		; `string'
PUBLIC	??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@		; `string'
PUBLIC	??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@ ; `string'
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
EXTRN	?getExtraIntercept@CvUnit@@QBEHXZ:PROC		; CvUnit::getExtraIntercept
EXTRN	?IsCanAttackRanged@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttackRanged
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ DB 'AIGRANDSTRATEGY_CONQ'
	DB	'UEST', 00H					; `string'
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
CONST	SEGMENT
??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@ DB 'FLAVOR_DEFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
CONST	SEGMENT
??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@ DB 'FLAVOR_OFFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@
CONST	SEGMENT
??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@ DB 'ECONOMICAISTRATE'
	DB	'GY_NAVAL_MAP', 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?UpdateBaseData@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
tv280 = -128						; size = 4
tv270 = -124						; size = 4
tv262 = -120						; size = 4
tv321 = -116						; size = 4
_this$ = -112						; size = 4
$T233988 = -108						; size = 4
$T233979 = -104						; size = 4
$T233972 = -100						; size = 4
$T233969 = -96						; size = 4
$T233960 = -92						; size = 4
$T233953 = -88						; size = 4
$T233952 = -84						; size = 4
$T233948 = -80						; size = 4
$T233944 = -76						; size = 4
$T233940 = -72						; size = 4
$T233936 = -68						; size = 4
$T233935 = -64						; size = 4
$T233934 = -60						; size = 4
$T233933 = -56						; size = 4
$T233932 = -52						; size = 4
$T233931 = -48						; size = 4
_bConquestGrandStrategy$226412 = -41			; size = 1
_eConquestGrandStrategy$226413 = -40			; size = 4
_iNumUnitsWanted$ = -36					; size = 4
_iFlavorOffense$ = -32					; size = 4
_eStrategyNavalMap$ = -28				; size = 4
_pLoopUnit$ = -24					; size = 4
_fMultiplier$ = -20					; size = 4
_bNavalMap$ = -13					; size = 1
_iFlavorDefense$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_iDifficulty$ = -4					; size = 4
?UpdateBaseData@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateBaseData, COMDAT
; _this$ = ecx

; 2071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 2072 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateBaseData, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2073 : 
; 2074 : 	// Count how many Military Units I have right now
; 2075 : 	CvUnit* pLoopUnit;
; 2076 : 	int iLoop;
; 2077 : 
; 2078 : 	m_iNumLandUnits = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2079 : 	m_iNumRangedLandUnits = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2080 : 	m_iNumMobileLandUnits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 0

; 2081 : 	m_iNumAirUnits = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 2082 : 	m_iNumAntiAirUnits = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 2083 : 	m_iNumMeleeLandUnits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 2084 : 	m_iNumNavalUnits = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 2085 : 	m_iNumLandUnitsInArmies = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 2086 : 	m_iNumNavalUnitsInArmies = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 0

; 2087 : 
; 2088 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN24@UpdateBase
$LN23@UpdateBase:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN24@UpdateBase:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN22@UpdateBase

; 2089 : 	{
; 2090 : 		// Don't count civilians or exploration units
; 2091 : 		if(pLoopUnit->IsCanAttack() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@UpdateBase
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN8@UpdateBase
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN8@UpdateBase

; 2092 : 		{
; 2093 : 			if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN20@UpdateBase

; 2094 : 			{
; 2095 : 				m_iNumLandUnits++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 2096 : 
; 2097 : 				if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN19@UpdateBase

; 2098 : 				{
; 2099 : 					m_iNumLandUnitsInArmies++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], eax
$LN19@UpdateBase:

; 2100 : 				}
; 2101 : 
; 2102 : 				if(pLoopUnit->IsCanAttackRanged())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@UpdateBase

; 2103 : 				{
; 2104 : 					m_iNumRangedLandUnits++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], ecx
	jmp	SHORT $LN13@UpdateBase
$LN18@UpdateBase:

; 2105 : 				}
; 2106 : 				else if(pLoopUnit->getExtraIntercept() > 0)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getExtraIntercept@CvUnit@@QBEHXZ	; CvUnit::getExtraIntercept
	test	eax, eax
	jle	SHORT $LN16@UpdateBase

; 2107 : 				{
; 2108 : 					// I'm an anti-air unit
; 2109 : 					m_iNumAntiAirUnits++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], ecx
	jmp	SHORT $LN13@UpdateBase
$LN16@UpdateBase:

; 2110 : 				}
; 2111 : 				else if(pLoopUnit->getUnitInfo().GetMoves() > 2)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves
	cmp	eax, 2
	jle	SHORT $LN14@UpdateBase

; 2112 : 				{
; 2113 : 					m_iNumMobileLandUnits++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], ecx

; 2114 : 				}
; 2115 : 				else

	jmp	SHORT $LN13@UpdateBase
$LN14@UpdateBase:

; 2116 : 				{
; 2117 : 					m_iNumMeleeLandUnits++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], ecx
$LN13@UpdateBase:

; 2118 : 				}

	jmp	SHORT $LN8@UpdateBase
$LN20@UpdateBase:

; 2119 : 			}
; 2120 : 			else if(pLoopUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN11@UpdateBase

; 2121 : 			{
; 2122 : 				m_iNumNavalUnits++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 2123 : 
; 2124 : 				if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN10@UpdateBase

; 2125 : 				{
; 2126 : 					m_iNumNavalUnitsInArmies++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN10@UpdateBase:

; 2127 : 				}
; 2128 : 			}

	jmp	SHORT $LN8@UpdateBase
$LN11@UpdateBase:

; 2129 : 			else if(pLoopUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN8@UpdateBase

; 2130 : 			{
; 2131 : 				m_iNumAirUnits++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN8@UpdateBase:

; 2132 : 			}
; 2133 : 		}
; 2134 : 	}

	jmp	$LN23@UpdateBase
$LN22@UpdateBase:

; 2135 : 
; 2136 : 	float fMultiplier;
; 2137 : 	int iNumUnitsWanted = 0;

	mov	DWORD PTR _iNumUnitsWanted$[ebp], 0

; 2138 : 	bool bNavalMap = false;

	mov	BYTE PTR _bNavalMap$[ebp], 0

; 2139 : 	EconomicAIStrategyTypes eStrategyNavalMap = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NAVAL_MAP");

	push	0
	push	OFFSET ??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyNavalMap$[ebp], eax

; 2140 : 	if (m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyNavalMap))

	mov	eax, DWORD PTR _eStrategyNavalMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@UpdateBase

; 2141 : 	{
; 2142 : 		bNavalMap = true;

	mov	BYTE PTR _bNavalMap$[ebp], 1
$LN7@UpdateBase:

; 2143 : 	}
; 2144 : 	int iFlavorOffense = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));

	push	0
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorOffense$[ebp], eax

; 2145 : 	int iFlavorDefense = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DEFENSE"));

	push	0
	push	OFFSET ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorDefense$[ebp], eax

; 2146 : 
; 2147 : 	// Scale up or down based on true threat level and a bit by flavors (multiplier should range from about 0.5 to about 1.5)
; 2148 : 	fMultiplier = (float)0.40 + (((float)(m_pPlayer->GetMilitaryAI()->GetHighestThreat() + iFlavorOffense + iFlavorDefense)) / (float)100.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ; CvMilitaryAI::GetHighestThreat
	add	eax, DWORD PTR _iFlavorOffense$[ebp]
	add	eax, DWORD PTR _iFlavorDefense$[ebp]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR _fMultiplier$[ebp], xmm0

; 2149 : 
; 2150 : 	// first get the number of defenders that we think we need
; 2151 : 
; 2152 : 	// Start with 3, to protect the capital
; 2153 : 	iNumUnitsWanted = GC.getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2180
	mov	DWORD PTR $T233940[ebp], eax
	mov	ecx, DWORD PTR $T233940[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], ecx

; 2154 : 
; 2155 : 	// 1 Unit per City & 1 per Settler
; 2156 : 	iNumUnitsWanted += (int)(m_pPlayer->getNumCities() * /*1.0*/ GC.getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY());

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8104
	movss	DWORD PTR $T233944[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR $T233944[ebp]
	cvttss2si eax, xmm0
	add	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax

; 2157 : 	iNumUnitsWanted += m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	add	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax

; 2158 : 
; 2159 : 	m_iMandatoryReserveSize = (int)((float)iNumUnitsWanted * fMultiplier);

	cvtsi2ss xmm0, DWORD PTR _iNumUnitsWanted$[ebp]
	mulss	xmm0, DWORD PTR _fMultiplier$[ebp]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], edx

; 2160 : 
; 2161 : 	// add in a few for the difficulty level (all above Chieftain are boosted)
; 2162 : 	int iDifficulty = max(0,GC.getGame().getHandicapInfo().GetID() - 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233948[ebp], ecx
	mov	ecx, DWORD PTR $T233948[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T233952[ebp], eax
	mov	edx, DWORD PTR $T233952[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233953[ebp], eax
	mov	ecx, DWORD PTR $T233953[ebp]
	sub	ecx, 1
	mov	DWORD PTR $T233931[ebp], ecx
	mov	DWORD PTR $T233932[ebp], 0
	mov	edx, DWORD PTR $T233932[ebp]
	cmp	edx, DWORD PTR $T233931[ebp]
	jge	SHORT $LN37@UpdateBase
	lea	eax, DWORD PTR $T233931[ebp]
	mov	DWORD PTR tv321[ebp], eax
	jmp	SHORT $LN38@UpdateBase
$LN37@UpdateBase:
	lea	ecx, DWORD PTR $T233932[ebp]
	mov	DWORD PTR tv321[ebp], ecx
$LN38@UpdateBase:
	mov	edx, DWORD PTR tv321[ebp]
	mov	DWORD PTR $T233960[ebp], edx
	mov	eax, DWORD PTR $T233960[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iDifficulty$[ebp], ecx

; 2163 : 	m_iMandatoryReserveSize += iDifficulty;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	add	eax, DWORD PTR _iDifficulty$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], eax

; 2164 : 
; 2165 : 	m_iMandatoryReserveSize = max(1,m_iMandatoryReserveSize);

	mov	DWORD PTR $T233933[ebp], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR $T233972[ebp], edx
	mov	eax, DWORD PTR $T233972[ebp]
	mov	ecx, DWORD PTR $T233933[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN41@UpdateBase
	mov	edx, DWORD PTR $T233972[ebp]
	mov	DWORD PTR tv262[ebp], edx
	jmp	SHORT $LN42@UpdateBase
$LN41@UpdateBase:
	lea	eax, DWORD PTR $T233933[ebp]
	mov	DWORD PTR tv262[ebp], eax
$LN42@UpdateBase:
	mov	ecx, DWORD PTR tv262[ebp]
	mov	DWORD PTR $T233969[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T233969[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+100], ecx

; 2166 : 
; 2167 : 	// now we add in the strike forces we think we will need
; 2168 : 	if(m_pPlayer->isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@UpdateBase

; 2169 : 	{
; 2170 : 		m_iMandatoryReserveSize = max(1,m_iMandatoryReserveSize/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+100]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T233934[ebp], eax
	mov	DWORD PTR $T233935[ebp], 1
	mov	edx, DWORD PTR $T233935[ebp]
	cmp	edx, DWORD PTR $T233934[ebp]
	jge	SHORT $LN45@UpdateBase
	lea	eax, DWORD PTR $T233934[ebp]
	mov	DWORD PTR tv270[ebp], eax
	jmp	SHORT $LN46@UpdateBase
$LN45@UpdateBase:
	lea	ecx, DWORD PTR $T233935[ebp]
	mov	DWORD PTR tv270[ebp], ecx
$LN46@UpdateBase:
	mov	edx, DWORD PTR tv270[ebp]
	mov	DWORD PTR $T233979[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T233979[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+100], edx

; 2171 : 		iNumUnitsWanted = 0;

	mov	DWORD PTR _iNumUnitsWanted$[ebp], 0

; 2172 : 	}
; 2173 : 	else

	jmp	$LN5@UpdateBase
$LN6@UpdateBase:

; 2174 : 	{
; 2175 : 		iNumUnitsWanted = 7; // size of a basic attack

	mov	DWORD PTR _iNumUnitsWanted$[ebp], 7

; 2176 : 
; 2177 : 		// if we are going for conquest we want at least one more task force
; 2178 : 		bool bConquestGrandStrategy = false;

	mov	BYTE PTR _bConquestGrandStrategy$226412[ebp], 0

; 2179 : 		AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eConquestGrandStrategy$226413[ebp], eax

; 2180 : 		if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eConquestGrandStrategy$226413[ebp], -1
	je	SHORT $LN3@UpdateBase

; 2181 : 		{
; 2182 : 			if(m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eConquestGrandStrategy$226413[ebp]
	jne	SHORT $LN3@UpdateBase

; 2183 : 			{
; 2184 : 				bConquestGrandStrategy = true;

	mov	BYTE PTR _bConquestGrandStrategy$226412[ebp], 1
$LN3@UpdateBase:

; 2185 : 			}
; 2186 : 		}
; 2187 : 		if(bConquestGrandStrategy)

	movzx	ecx, BYTE PTR _bConquestGrandStrategy$226412[ebp]
	test	ecx, ecx
	je	SHORT $LN2@UpdateBase

; 2188 : 		{
; 2189 : 			iNumUnitsWanted *= 2;

	mov	edx, DWORD PTR _iNumUnitsWanted$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iNumUnitsWanted$[ebp], edx
$LN2@UpdateBase:

; 2190 : 		}
; 2191 : 
; 2192 : 		// add in a few more if the player is bold
; 2193 : 		iNumUnitsWanted += m_pPlayer->GetDiplomacyAI()->GetBoldness();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	add	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax

; 2194 : 
; 2195 : 		// add in more if we are playing on a high difficulty
; 2196 : 		iNumUnitsWanted += iDifficulty;

	mov	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	add	ecx, DWORD PTR _iDifficulty$[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], ecx

; 2197 : 
; 2198 : 		iNumUnitsWanted = (int)((float)iNumUnitsWanted * fMultiplier);

	cvtsi2ss xmm0, DWORD PTR _iNumUnitsWanted$[ebp]
	mulss	xmm0, DWORD PTR _fMultiplier$[ebp]
	cvttss2si edx, xmm0
	mov	DWORD PTR _iNumUnitsWanted$[ebp], edx

; 2199 : 
; 2200 : 		iNumUnitsWanted = max(1,iNumUnitsWanted);

	mov	DWORD PTR $T233936[ebp], 1
	mov	eax, DWORD PTR $T233936[ebp]
	cmp	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	jge	SHORT $LN49@UpdateBase
	lea	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	DWORD PTR tv280[ebp], ecx
	jmp	SHORT $LN50@UpdateBase
$LN49@UpdateBase:
	lea	edx, DWORD PTR $T233936[ebp]
	mov	DWORD PTR tv280[ebp], edx
$LN50@UpdateBase:
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T233988[ebp], eax
	mov	ecx, DWORD PTR $T233988[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], edx
$LN5@UpdateBase:

; 2201 : 	}
; 2202 : 
; 2203 : 	if (bNavalMap)

	movzx	eax, BYTE PTR _bNavalMap$[ebp]
	test	eax, eax
	je	SHORT $LN1@UpdateBase

; 2204 : 	{
; 2205 : 		iNumUnitsWanted *= 2;

	mov	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _iNumUnitsWanted$[ebp], ecx

; 2206 : 		iNumUnitsWanted /= 3;

	mov	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax

; 2207 : 		m_iMandatoryReserveSize *= 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], eax

; 2208 : 		m_iMandatoryReserveSize /= 3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], eax
$LN1@UpdateBase:

; 2209 : 	}
; 2210 : 
; 2211 : 	m_iRecommendedMilitarySize = m_iMandatoryReserveSize + iNumUnitsWanted;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	add	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 2212 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateBaseData@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateBaseData
_TEXT	ENDS
PUBLIC	?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ; MilitaryAIHelpers::ComputeRecommendedNavySize
; Function compile flags: /Odtp
;	COMDAT ?UpdateDefenseState@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_iLandUnitsNotInArmies$ = -12				; size = 4
_iNavySize$ = -8					; size = 4
_iNavalUnitsNotInArmies$ = -4				; size = 4
?UpdateDefenseState@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateDefenseState, COMDAT
; _this$ = ecx

; 2216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2217 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateDefenseState, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2218 : 
; 2219 : 	int iLandUnitsNotInArmies;
; 2220 : 	int iNavalUnitsNotInArmies;
; 2221 : 
; 2222 : 	// Derive data we'll need
; 2223 : 	iLandUnitsNotInArmies = m_iNumLandUnits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _iLandUnitsNotInArmies$[ebp], ecx

; 2224 : 	iNavalUnitsNotInArmies = m_iNumNavalUnits;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR _iNavalUnitsNotInArmies$[ebp], eax

; 2225 : 
; 2226 : 	if(iLandUnitsNotInArmies < m_iMandatoryReserveSize)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iLandUnitsNotInArmies$[ebp]
	cmp	edx, DWORD PTR [ecx+100]
	jge	SHORT $LN12@UpdateDefe

; 2227 : 	{
; 2228 : 		m_eLandDefenseState = DEFENSE_STATE_CRITICAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 3
	jmp	SHORT $LN11@UpdateDefe
$LN12@UpdateDefe:

; 2229 : 	}
; 2230 : 	else if(iLandUnitsNotInArmies < m_iRecommendedMilitarySize)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iLandUnitsNotInArmies$[ebp]
	cmp	edx, DWORD PTR [ecx+96]
	jge	SHORT $LN10@UpdateDefe

; 2231 : 	{
; 2232 : 		m_eLandDefenseState = DEFENSE_STATE_NEEDED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 2
	jmp	SHORT $LN11@UpdateDefe
$LN10@UpdateDefe:

; 2233 : 	}
; 2234 : 	else if(iLandUnitsNotInArmies < m_iRecommendedMilitarySize * 5 / 4)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+96]
	imul	eax, 5
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	DWORD PTR _iLandUnitsNotInArmies$[ebp], eax
	jge	SHORT $LN8@UpdateDefe

; 2235 : 	{
; 2236 : 		m_eLandDefenseState = DEFENSE_STATE_NEUTRAL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 2237 : 	}
; 2238 : 	else

	jmp	SHORT $LN11@UpdateDefe
$LN8@UpdateDefe:

; 2239 : 	{
; 2240 : 		m_eLandDefenseState = DEFENSE_STATE_ENOUGH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0
$LN11@UpdateDefe:

; 2241 : 	}
; 2242 : 
; 2243 : 	int iNavySize = MilitaryAIHelpers::ComputeRecommendedNavySize(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ; MilitaryAIHelpers::ComputeRecommendedNavySize
	add	esp, 4
	mov	DWORD PTR _iNavySize$[ebp], eax

; 2244 : 
; 2245 : 	if(iNavalUnitsNotInArmies <= (iNavySize / 2))

	mov	eax, DWORD PTR _iNavySize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _iNavalUnitsNotInArmies$[ebp], eax
	jg	SHORT $LN6@UpdateDefe

; 2246 : 	{
; 2247 : 		m_eNavalDefenseState = DEFENSE_STATE_CRITICAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 3
	jmp	SHORT $LN13@UpdateDefe
$LN6@UpdateDefe:

; 2248 : 	}
; 2249 : 	else if(iNavalUnitsNotInArmies <= iNavySize)

	mov	ecx, DWORD PTR _iNavalUnitsNotInArmies$[ebp]
	cmp	ecx, DWORD PTR _iNavySize$[ebp]
	jg	SHORT $LN4@UpdateDefe

; 2250 : 	{
; 2251 : 		m_eNavalDefenseState = DEFENSE_STATE_NEEDED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 2
	jmp	SHORT $LN13@UpdateDefe
$LN4@UpdateDefe:

; 2252 : 	}
; 2253 : 	else if(iNavalUnitsNotInArmies <= iNavySize * 5 / 4)

	mov	eax, DWORD PTR _iNavySize$[ebp]
	imul	eax, 5
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	DWORD PTR _iNavalUnitsNotInArmies$[ebp], eax
	jg	SHORT $LN2@UpdateDefe

; 2254 : 	{
; 2255 : 		m_eNavalDefenseState = DEFENSE_STATE_NEUTRAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 1

; 2256 : 	}
; 2257 : 	else

	jmp	SHORT $LN13@UpdateDefe
$LN2@UpdateDefe:

; 2258 : 	{
; 2259 : 		m_eNavalDefenseState = DEFENSE_STATE_ENOUGH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 0
$LN13@UpdateDefe:

; 2260 : 	}
; 2261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateDefenseState@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateDefenseState
_TEXT	ENDS
EXTRN	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z:PROC ; CvPlot::plotCount
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
; Function compile flags: /Odtp
;	COMDAT ?ScanForBarbarians@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T234155 = -149						; size = 1
$T234076 = -76						; size = 4
$T234067 = -72						; size = 4
$T234058 = -68						; size = 4
$T234054 = -64						; size = 4
$T234050 = -60						; size = 4
$T234041 = -56						; size = 4
$T234037 = -52						; size = 4
_uiOffset$234032 = -48					; size = 4
$T234020 = -44						; size = 4
$T234016 = -40						; size = 4
$T234012 = -36						; size = 4
$T234008 = -32						; size = 4
_iDist$226463 = -28					; size = 4
_iCityLoop$226457 = -24					; size = 4
_iTolerableDistance$226456 = -20			; size = 4
_pLoopCity$226458 = -16					; size = 4
_pPlot$ = -12						; size = 4
_iPlotLoop$ = -8					; size = 4
_eTeam$ = -4						; size = 4
?ScanForBarbarians@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::ScanForBarbarians, COMDAT
; _this$ = ecx

; 2265 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 2266 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("ScanForBarbarians, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2267 : 
; 2268 : #ifdef AUI_WARNING_FIXES
; 2269 : 	uint iPlotLoop;
; 2270 : #else
; 2271 : 	int iPlotLoop;
; 2272 : #endif
; 2273 : 	CvPlot* pPlot;
; 2274 : 
; 2275 : 	m_iBarbarianCampCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 2276 : 	m_iVisibleBarbarianCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 2277 : 
; 2278 : 	TeamTypes eTeam = m_pPlayer->getTeam();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234008[ebp], eax
	mov	ecx, DWORD PTR $T234008[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 2279 : 
; 2280 : 	// Look at revealed Barbarian camps and visible units
; 2281 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN14@ScanForBar
$LN13@ScanForBar:
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoop$[ebp], eax
$LN14@ScanForBar:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234012[ebp], ecx
	mov	edx, DWORD PTR $T234012[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T234016[ebp], eax
	mov	ecx, DWORD PTR _iPlotLoop$[ebp]
	cmp	ecx, DWORD PTR $T234016[ebp]
	jge	$LN15@ScanForBar

; 2282 : 	{
; 2283 : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234020[ebp], edx
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T234020[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$[ebp], eax

; 2284 : 
; 2285 : 		if(pPlot->isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$234032[ebp], edx
	mov	eax, DWORD PTR _uiOffset$234032[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$234032[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN11@ScanForBar

; 2286 : 		{
; 2287 : 			if(pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T234037[ebp], ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T234037[ebp]
	jne	$LN11@ScanForBar

; 2288 : 			{
; 2289 : 				m_iBarbarianCampCount++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 2290 : 
; 2291 : 				// Count it as 10 camps if sitting inside our territory, that is annoying!
; 2292 : 				if(pPlot->getOwner() == m_pPlayer->GetID())

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T234041[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T234050[ebp], eax
	mov	ecx, DWORD PTR $T234041[ebp]
	cmp	ecx, DWORD PTR $T234050[ebp]
	jne	SHORT $LN9@ScanForBar

; 2293 : 				{
; 2294 : 					m_iBarbarianCampCount += 9;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	add	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 2295 : 				}
; 2296 : 
; 2297 : 				// See how close it is to each of our cities, if less than 10 tiles, treat it as 5 camps
; 2298 : 				else

	jmp	$LN11@ScanForBar
$LN9@ScanForBar:

; 2299 : 				{
; 2300 : 					int iTolerableDistance = 10;

	mov	DWORD PTR _iTolerableDistance$226456[ebp], 10 ; 0000000aH

; 2301 : 					int iCityLoop;
; 2302 : 					CvCity *pLoopCity;
; 2303 : 					for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	edx, DWORD PTR _iCityLoop$226457[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226458[ebp], eax
	jmp	SHORT $LN7@ScanForBar
$LN6@ScanForBar:
	push	0
	lea	ecx, DWORD PTR _iCityLoop$226457[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226458[ebp], eax
$LN7@ScanForBar:
	cmp	DWORD PTR _pLoopCity$226458[ebp], 0
	je	SHORT $LN11@ScanForBar

; 2304 : 					{
; 2305 : 						if (pLoopCity)

	cmp	DWORD PTR _pLoopCity$226458[ebp], 0
	je	SHORT $LN4@ScanForBar

; 2306 : 						{
; 2307 : 							int iDist = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T234054[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T234058[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$226458[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T234067[ebp], edx
	mov	eax, DWORD PTR _pLoopCity$226458[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T234076[ebp], ecx
	mov	edx, DWORD PTR $T234054[ebp]
	push	edx
	mov	eax, DWORD PTR $T234058[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234067[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234076[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDist$226463[ebp], eax

; 2308 : 							if (iDist < iTolerableDistance)

	mov	eax, DWORD PTR _iDist$226463[ebp]
	cmp	eax, DWORD PTR _iTolerableDistance$226456[ebp]
	jge	SHORT $LN4@ScanForBar

; 2309 : 							{
; 2310 : 								m_iBarbarianCampCount += 4;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], edx

; 2311 : 								break;

	jmp	SHORT $LN11@ScanForBar
$LN4@ScanForBar:

; 2312 : 							}
; 2313 : 						}
; 2314 : 					}

	jmp	$LN6@ScanForBar
$LN11@ScanForBar:

; 2315 : 				}
; 2316 : 			}
; 2317 : 		}
; 2318 : 
; 2319 : 		if(pPlot->isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN102@ScanForBar
	mov	BYTE PTR $T234155[ebp], 0
	jmp	SHORT $LN100@ScanForBar
$LN102@ScanForBar:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T234155[ebp], dl
$LN100@ScanForBar:
	movzx	eax, BYTE PTR $T234155[ebp]
	test	eax, eax
	je	SHORT $LN2@ScanForBar

; 2320 : 		{
; 2321 : 			if(pPlot->plotCount(NULL, -1, -1, BARBARIAN_PLAYER, BARBARIAN_TEAM))

	push	-1
	push	-1
	push	0
	push	63					; 0000003fH
	push	63					; 0000003fH
	push	-1
	push	-1
	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
	test	eax, eax
	je	SHORT $LN2@ScanForBar

; 2322 : 			{
; 2323 : 				m_iVisibleBarbarianCount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], edx
$LN2@ScanForBar:

; 2324 : 			}
; 2325 : 		}

	jmp	$LN13@ScanForBar
$LN15@ScanForBar:

; 2326 : 	}
; 2327 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScanForBarbarians@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::ScanForBarbarians
_TEXT	ENDS
PUBLIC	?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatDecrease
PUBLIC	?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatIncrease
; Function compile flags: /Odtp
;	COMDAT ?UpdateThreats@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T234166 = -16						; size = 4
_iPlayerLoop$226475 = -12				; size = 4
_eMilitaryThreatType$ = -8				; size = 4
_eLoopPlayer$ = -4					; size = 4
?UpdateThreats@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateThreats, COMDAT
; _this$ = ecx

; 2331 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2332 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateThreats, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2333 : 
; 2334 : 	ThreatTypes eMilitaryThreatType;
; 2335 : 
; 2336 : 	PlayerTypes eLoopPlayer;
; 2337 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226475[ebp], 0
	jmp	SHORT $LN7@UpdateThre
$LN6@UpdateThre:
	mov	eax, DWORD PTR _iPlayerLoop$226475[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$226475[ebp], eax
$LN7@UpdateThre:
	cmp	DWORD PTR _iPlayerLoop$226475[ebp], 22	; 00000016H
	jge	$LN8@UpdateThre

; 2338 : 	{
; 2339 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$226475[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 2340 : 
; 2341 : 		// Is this a player we have relations with?
; 2342 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pDiplomacyAI->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T234166[ebp], ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	edx, DWORD PTR $T234166[ebp]
	je	$LN4@UpdateThre
	push	0
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@UpdateThre

; 2343 : 		{
; 2344 : 			eMilitaryThreatType = m_pDiplomacyAI->GetMilitaryThreat(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetMilitaryThreat@CvDiplomacyAI@@QBE?AW4ThreatTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMilitaryThreat
	mov	DWORD PTR _eMilitaryThreatType$[ebp], eax

; 2345 : 			if(eMilitaryThreatType != m_paeLastTurnMilitaryThreat[eLoopPlayer])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	mov	edx, DWORD PTR _eMilitaryThreatType$[ebp]
	cmp	edx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN4@UpdateThre

; 2346 : 			{
; 2347 : 				// Change in threat level
; 2348 : 				if(eMilitaryThreatType > m_paeLastTurnMilitaryThreat[eLoopPlayer])

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	mov	eax, DWORD PTR _eMilitaryThreatType$[ebp]
	cmp	eax, DWORD PTR [ecx+edx*4]
	jle	SHORT $LN2@UpdateThre

; 2349 : 				{
; 2350 : 					ThreatIncrease(eMilitaryThreatType, (ThreatTypes)m_paeLastTurnMilitaryThreat[eLoopPlayer]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _eMilitaryThreatType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatIncrease

; 2351 : 				}
; 2352 : 				else

	jmp	SHORT $LN1@UpdateThre
$LN2@UpdateThre:

; 2353 : 				{
; 2354 : 					ThreatDecrease(eMilitaryThreatType, (ThreatTypes)m_paeLastTurnMilitaryThreat[eLoopPlayer]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _eMilitaryThreatType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatDecrease
$LN1@UpdateThre:

; 2355 : 				}
; 2356 : 
; 2357 : 				// Save off new value
; 2358 : 				m_paeLastTurnMilitaryThreat[eLoopPlayer] = eMilitaryThreatType;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	mov	edx, DWORD PTR _eMilitaryThreatType$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$LN4@UpdateThre:

; 2359 : 			}
; 2360 : 		}

	jmp	$LN6@UpdateThre
$LN8@UpdateThre:

; 2361 : 	}
; 2362 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateThreats@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateThreats
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eNewThreat$ = 8					; size = 4
_eOldThreat$ = 12					; size = 4
?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z PROC ; CvMilitaryAI::ThreatIncrease, COMDAT
; _this$ = ecx

; 2366 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2367 : 	// Subtract off old threat
; 2368 : 	m_iTotalThreatWeight -= GetThreatWeight(eOldThreat);

	mov	eax, DWORD PTR _eOldThreat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ; CvMilitaryAI::GetThreatWeight
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx

; 2369 : 
; 2370 : 	// Add on new threat
; 2371 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

	mov	ecx, DWORD PTR _eNewThreat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ; CvMilitaryAI::GetThreatWeight
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2372 : 
; 2373 : 	// FUTURE: Add anything else we'd like to do to individually handle new threats from a single power
; 2374 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ENDP ; CvMilitaryAI::ThreatIncrease
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eNewThreat$ = 8					; size = 4
_eOldThreat$ = 12					; size = 4
?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z PROC ; CvMilitaryAI::ThreatDecrease, COMDAT
; _this$ = ecx

; 2378 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2379 : 	// Subtract off old threat
; 2380 : 	m_iTotalThreatWeight -= GetThreatWeight(eOldThreat);

	mov	eax, DWORD PTR _eOldThreat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ; CvMilitaryAI::GetThreatWeight
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx

; 2381 : 
; 2382 : 	// Add on new threat
; 2383 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

	mov	ecx, DWORD PTR _eNewThreat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ; CvMilitaryAI::GetThreatWeight
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2384 : 
; 2385 : 	// FUTURE: Add anything else we'd like to do to individually handle diminishing threats from a single power
; 2386 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ENDP ; CvMilitaryAI::ThreatDecrease
_TEXT	ENDS
PUBLIC	?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::WarStateChange
; Function compile flags: /Odtp
;	COMDAT ?UpdateWars@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T234181 = -16						; size = 4
_iPlayerLoop$226502 = -12				; size = 4
_eLoopPlayer$ = -8					; size = 4
_eWarState$ = -4					; size = 4
?UpdateWars@CvMilitaryAI@@AAEXXZ PROC			; CvMilitaryAI::UpdateWars, COMDAT
; _this$ = ecx

; 2390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2391 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateWars, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2392 : 
; 2393 : 	WarStateTypes eWarState;
; 2394 : 
; 2395 : 	PlayerTypes eLoopPlayer;
; 2396 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226502[ebp], 0
	jmp	SHORT $LN5@UpdateWars
$LN4@UpdateWars:
	mov	eax, DWORD PTR _iPlayerLoop$226502[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$226502[ebp], eax
$LN5@UpdateWars:
	cmp	DWORD PTR _iPlayerLoop$226502[ebp], 22	; 00000016H
	jge	$LN6@UpdateWars

; 2397 : 	{
; 2398 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$226502[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 2399 : 
; 2400 : 		// Is this a player we have relations with?
; 2401 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pDiplomacyAI->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T234181[ebp], ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	edx, DWORD PTR $T234181[ebp]
	je	SHORT $LN2@UpdateWars
	push	0
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@UpdateWars

; 2402 : 		{
; 2403 : 			eWarState = m_pDiplomacyAI->GetWarState(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState
	mov	DWORD PTR _eWarState$[ebp], eax

; 2404 : 			if(eWarState != m_paeLastTurnWarState[eLoopPlayer])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	mov	edx, DWORD PTR _eWarState$[ebp]
	cmp	edx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN2@UpdateWars

; 2405 : 			{
; 2406 : 				WarStateChange(eLoopPlayer, eWarState, (WarStateTypes)m_paeLastTurnWarState[eLoopPlayer]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _eWarState$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::WarStateChange

; 2407 : 
; 2408 : 				// Save off new value
; 2409 : 				m_paeLastTurnWarState[eLoopPlayer] = eWarState;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	mov	eax, DWORD PTR _eWarState$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN2@UpdateWars:

; 2410 : 			}
; 2411 : 		}

	jmp	$LN4@UpdateWars
$LN6@UpdateWars:

; 2412 : 	}
; 2413 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateWars@CvMilitaryAI@@AAEXXZ ENDP			; CvMilitaryAI::UpdateWars
_TEXT	ENDS
PUBLIC	?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::LogWarStateChange
; Function compile flags: /Odtp
;	COMDAT ?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_eNewWarState$ = 12					; size = 4
_eOldWarState$ = 16					; size = 4
?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z PROC ; CvMilitaryAI::WarStateChange, COMDAT
; _this$ = ecx

; 2417 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2418 : 	LogWarStateChange(ePlayer, eNewWarState, eOldWarState);

	mov	eax, DWORD PTR _eOldWarState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eNewWarState$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::LogWarStateChange

; 2419 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ENDP ; CvMilitaryAI::WarStateChange
_TEXT	ENDS
PUBLIC	??_C@_0BM@GDBDHKME@MilitaryStrategyCanActivate?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers
PUBLIC	??_C@_0CE@NIBBOHNC@MILITARYAISTRATEGY_NEED_AIR_CARR@ ; `string'
PUBLIC	?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits
PUBLIC	??_C@_0CC@ELNMLHCP@MILITARYAISTRATEGY_ENOUGH_ANTIAI@ ; `string'
PUBLIC	?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits
PUBLIC	??_C@_0CA@PDDGGKAO@MILITARYAISTRATEGY_NEED_ANTIAIR?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedANuke
PUBLIC	??_C@_0BN@NGMNKOEM@MILITARYAISTRATEGY_NEED_NUKE?$AA@ ; `string'
PUBLIC	?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits
PUBLIC	??_C@_0BO@KHLAAIEO@MILITARYAISTRATEGY_ENOUGH_AIR?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits
PUBLIC	??_C@_0BM@MLOEPCOF@MILITARYAISTRATEGY_NEED_AIR?$AA@ ; `string'
PUBLIC	?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits
PUBLIC	??_C@_0CB@BKDHFPFB@MILITARYAISTRATEGY_ENOUGH_MOBILE@ ; `string'
PUBLIC	?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits
PUBLIC	??_C@_0BP@ENEPHBGG@MILITARYAISTRATEGY_NEED_MOBILE?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack
PUBLIC	??_C@_0CF@DDNAOBGI@MILITARYAISTRATEGY_NEED_RANGED_E@ ; `string'
PUBLIC	?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits
PUBLIC	??_C@_0CB@ICEOECPK@MILITARYAISTRATEGY_ENOUGH_RANGED@ ; `string'
PUBLIC	?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits
PUBLIC	??_C@_0BP@NFDGGMMN@MILITARYAISTRATEGY_NEED_RANGED?$AA@ ; `string'
PUBLIC	?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_LosingWars
PUBLIC	??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@ ; `string'
PUBLIC	?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WinningWars
PUBLIC	??_C@_0CA@NOLAFEEE@MILITARYAISTRATEGY_WINNING_WARS?$AA@ ; `string'
PUBLIC	?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians
PUBLIC	??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@ ; `string'
PUBLIC	?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical
PUBLIC	??_C@_0CN@GKMGLOHH@MILITARYAISTRATEGY_MINOR_CIV_THR@ ; `string'
PUBLIC	?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated
PUBLIC	??_C@_0CN@MIOLCJKI@MILITARYAISTRATEGY_MINOR_CIV_THR@ ; `string'
PUBLIC	?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense
PUBLIC	??_C@_0CN@PNLKDPJO@MILITARYAISTRATEGY_MINOR_CIV_GEN@ ; `string'
PUBLIC	?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_AtWar
PUBLIC	??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@ ; `string'
PUBLIC	?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WarMobilization
PUBLIC	??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@ ; `string'
PUBLIC	?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical
PUBLIC	??_C@_0CN@NADDHBK@MILITARYAISTRATEGY_NEED_NAVAL_UN@ ; `string'
PUBLIC	?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits
PUBLIC	??_C@_0CE@CPIEOHHN@MILITARYAISTRATEGY_NEED_NAVAL_UN@ ; `string'
PUBLIC	?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits
PUBLIC	??_C@_0CG@NDHAKJJN@MILITARYAISTRATEGY_ENOUGH_NAVAL_@ ; `string'
PUBLIC	?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical
PUBLIC	??_C@_0CL@CKCIKBIK@MILITARYAISTRATEGY_EMPIRE_DEFENS@ ; `string'
PUBLIC	?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense
PUBLIC	??_C@_0CC@KNPAEDG@MILITARYAISTRATEGY_EMPIRE_DEFENS@ ; `string'
PUBLIC	?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits
PUBLIC	??_C@_0CJ@ECLOIKB@MILITARYAISTRATEGY_ENOUGH_MILITA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z:PROC ; CvCitySpecializationAI::SetSpecializationsDirty
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z:PROC ; CvFlavorManager::ChangeFlavors
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
;	COMDAT ??_C@_0BM@GDBDHKME@MilitaryStrategyCanActivate?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BM@GDBDHKME@MilitaryStrategyCanActivate?$AA@ DB 'MilitaryStrategyC'
	DB	'anActivate', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NIBBOHNC@MILITARYAISTRATEGY_NEED_AIR_CARR@
CONST	SEGMENT
??_C@_0CE@NIBBOHNC@MILITARYAISTRATEGY_NEED_AIR_CARR@ DB 'MILITARYAISTRATE'
	DB	'GY_NEED_AIR_CARRIER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ELNMLHCP@MILITARYAISTRATEGY_ENOUGH_ANTIAI@
CONST	SEGMENT
??_C@_0CC@ELNMLHCP@MILITARYAISTRATEGY_ENOUGH_ANTIAI@ DB 'MILITARYAISTRATE'
	DB	'GY_ENOUGH_ANTIAIR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PDDGGKAO@MILITARYAISTRATEGY_NEED_ANTIAIR?$AA@
CONST	SEGMENT
??_C@_0CA@PDDGGKAO@MILITARYAISTRATEGY_NEED_ANTIAIR?$AA@ DB 'MILITARYAISTR'
	DB	'ATEGY_NEED_ANTIAIR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NGMNKOEM@MILITARYAISTRATEGY_NEED_NUKE?$AA@
CONST	SEGMENT
??_C@_0BN@NGMNKOEM@MILITARYAISTRATEGY_NEED_NUKE?$AA@ DB 'MILITARYAISTRATE'
	DB	'GY_NEED_NUKE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KHLAAIEO@MILITARYAISTRATEGY_ENOUGH_AIR?$AA@
CONST	SEGMENT
??_C@_0BO@KHLAAIEO@MILITARYAISTRATEGY_ENOUGH_AIR?$AA@ DB 'MILITARYAISTRAT'
	DB	'EGY_ENOUGH_AIR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MLOEPCOF@MILITARYAISTRATEGY_NEED_AIR?$AA@
CONST	SEGMENT
??_C@_0BM@MLOEPCOF@MILITARYAISTRATEGY_NEED_AIR?$AA@ DB 'MILITARYAISTRATEG'
	DB	'Y_NEED_AIR', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKDHFPFB@MILITARYAISTRATEGY_ENOUGH_MOBILE@
CONST	SEGMENT
??_C@_0CB@BKDHFPFB@MILITARYAISTRATEGY_ENOUGH_MOBILE@ DB 'MILITARYAISTRATE'
	DB	'GY_ENOUGH_MOBILE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ENEPHBGG@MILITARYAISTRATEGY_NEED_MOBILE?$AA@
CONST	SEGMENT
??_C@_0BP@ENEPHBGG@MILITARYAISTRATEGY_NEED_MOBILE?$AA@ DB 'MILITARYAISTRA'
	DB	'TEGY_NEED_MOBILE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DDNAOBGI@MILITARYAISTRATEGY_NEED_RANGED_E@
CONST	SEGMENT
??_C@_0CF@DDNAOBGI@MILITARYAISTRATEGY_NEED_RANGED_E@ DB 'MILITARYAISTRATE'
	DB	'GY_NEED_RANGED_EARLY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ICEOECPK@MILITARYAISTRATEGY_ENOUGH_RANGED@
CONST	SEGMENT
??_C@_0CB@ICEOECPK@MILITARYAISTRATEGY_ENOUGH_RANGED@ DB 'MILITARYAISTRATE'
	DB	'GY_ENOUGH_RANGED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NFDGGMMN@MILITARYAISTRATEGY_NEED_RANGED?$AA@
CONST	SEGMENT
??_C@_0BP@NFDGGMMN@MILITARYAISTRATEGY_NEED_RANGED?$AA@ DB 'MILITARYAISTRA'
	DB	'TEGY_NEED_RANGED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@
CONST	SEGMENT
??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@ DB 'MILITARYAISTRA'
	DB	'TEGY_LOSING_WARS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NOLAFEEE@MILITARYAISTRATEGY_WINNING_WARS?$AA@
CONST	SEGMENT
??_C@_0CA@NOLAFEEE@MILITARYAISTRATEGY_WINNING_WARS?$AA@ DB 'MILITARYAISTR'
	DB	'ATEGY_WINNING_WARS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@
CONST	SEGMENT
??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@ DB 'MILITARYAISTRATE'
	DB	'GY_ERADICATE_BARBARIANS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GKMGLOHH@MILITARYAISTRATEGY_MINOR_CIV_THR@
CONST	SEGMENT
??_C@_0CN@GKMGLOHH@MILITARYAISTRATEGY_MINOR_CIV_THR@ DB 'MILITARYAISTRATE'
	DB	'GY_MINOR_CIV_THREAT_CRITICAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MIOLCJKI@MILITARYAISTRATEGY_MINOR_CIV_THR@
CONST	SEGMENT
??_C@_0CN@MIOLCJKI@MILITARYAISTRATEGY_MINOR_CIV_THR@ DB 'MILITARYAISTRATE'
	DB	'GY_MINOR_CIV_THREAT_ELEVATED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PNLKDPJO@MILITARYAISTRATEGY_MINOR_CIV_GEN@
CONST	SEGMENT
??_C@_0CN@PNLKDPJO@MILITARYAISTRATEGY_MINOR_CIV_GEN@ DB 'MILITARYAISTRATE'
	DB	'GY_MINOR_CIV_GENERAL_DEFENSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
CONST	SEGMENT
??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@ DB 'MILITARYAISTRATEGY_A'
	DB	'T_WAR', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
CONST	SEGMENT
??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@ DB 'MILITARYAISTRATE'
	DB	'GY_WAR_MOBILIZATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NADDHBK@MILITARYAISTRATEGY_NEED_NAVAL_UN@
CONST	SEGMENT
??_C@_0CN@NADDHBK@MILITARYAISTRATEGY_NEED_NAVAL_UN@ DB 'MILITARYAISTRATEG'
	DB	'Y_NEED_NAVAL_UNITS_CRITICAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CPIEOHHN@MILITARYAISTRATEGY_NEED_NAVAL_UN@
CONST	SEGMENT
??_C@_0CE@CPIEOHHN@MILITARYAISTRATEGY_NEED_NAVAL_UN@ DB 'MILITARYAISTRATE'
	DB	'GY_NEED_NAVAL_UNITS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NDHAKJJN@MILITARYAISTRATEGY_ENOUGH_NAVAL_@
CONST	SEGMENT
??_C@_0CG@NDHAKJJN@MILITARYAISTRATEGY_ENOUGH_NAVAL_@ DB 'MILITARYAISTRATE'
	DB	'GY_ENOUGH_NAVAL_UNITS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CKCIKBIK@MILITARYAISTRATEGY_EMPIRE_DEFENS@
CONST	SEGMENT
??_C@_0CL@CKCIKBIK@MILITARYAISTRATEGY_EMPIRE_DEFENS@ DB 'MILITARYAISTRATE'
	DB	'GY_EMPIRE_DEFENSE_CRITICAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KNPAEDG@MILITARYAISTRATEGY_EMPIRE_DEFENS@
CONST	SEGMENT
??_C@_0CC@KNPAEDG@MILITARYAISTRATEGY_EMPIRE_DEFENS@ DB 'MILITARYAISTRATEG'
	DB	'Y_EMPIRE_DEFENSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ECLOIKB@MILITARYAISTRATEGY_ENOUGH_MILITA@
CONST	SEGMENT
??_C@_0CJ@ECLOIKB@MILITARYAISTRATEGY_ENOUGH_MILITA@ DB 'MILITARYAISTRATEG'
	DB	'Y_ENOUGH_MILITARY_UNITS', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$1
__ehfuncinfo$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
tv585 = -176						; size = 4
tv578 = -172						; size = 4
tv565 = -168						; size = 4
tv748 = -164						; size = 4
_this$ = -160						; size = 4
$T234297 = -156						; size = 4
$T234293 = -152						; size = 4
$T234289 = -148						; size = 4
$T234285 = -144						; size = 4
$T234277 = -140						; size = 4
$T234273 = -136						; size = 4
$T234258 = -132						; size = 4
$T234246 = -128						; size = 4
$T234242 = -124						; size = 4
$T234238 = -120						; size = 4
$T234237 = -116						; size = 4
$T234228 = -112						; size = 4
$T234224 = -108						; size = 4
$T234220 = -104						; size = 4
$T234216 = -100						; size = 4
$T234212 = -96						; size = 4
$T234211 = -92						; size = 4
$T234202 = -88						; size = 4
$T234198 = -84						; size = 4
$T234197 = -80						; size = 4
_iFlavorLoop$226645 = -76				; size = 4
_bResult$226631 = -69					; size = 1
_args$226630 = -68					; size = 4
_strStrategyName$226550 = -64				; size = 28
__$ArrayPad$ = -36					; size = 4
_pkScriptSystem$226628 = -32				; size = 4
_bAdoptOrEndStrategy$226635 = -28			; size = 1
_bStrategyShouldBeActive$226546 = -27			; size = 1
_bTestStrategyEnd$226538 = -26				; size = 1
_bTestStrategyStart$226530 = -25			; size = 1
_eStrategy$226524 = -24					; size = 4
_pStrategy$226526 = -20					; size = 4
_iStrategiesLoop$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ PROC	; CvMilitaryAI::UpdateMilitaryStrategies, COMDAT
; _this$ = ecx

; 2423 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2424 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateMilitaryStrategies, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2425 : 
; 2426 : 	int iStrategiesLoop = 0;

	mov	DWORD PTR _iStrategiesLoop$[ebp], 0

; 2427 : 
; 2428 : 	// Loop through all strategies
; 2429 : 	for(iStrategiesLoop = 0; iStrategiesLoop < GetMilitaryAIStrategies()->GetNumMilitaryAIStrategies(); iStrategiesLoop++)

	mov	DWORD PTR _iStrategiesLoop$[ebp], 0
	jmp	SHORT $LN99@UpdateMili
$LN98@UpdateMili:
	mov	eax, DWORD PTR _iStrategiesLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iStrategiesLoop$[ebp], eax
$LN99@UpdateMili:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
	mov	ecx, eax
	call	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
	cmp	DWORD PTR _iStrategiesLoop$[ebp], eax
	jge	$LN100@UpdateMili

; 2430 : 	{
; 2431 : 		MilitaryAIStrategyTypes eStrategy = (MilitaryAIStrategyTypes) iStrategiesLoop;

	mov	ecx, DWORD PTR _iStrategiesLoop$[ebp]
	mov	DWORD PTR _eStrategy$226524[ebp], ecx

; 2432 : 		CvMilitaryAIStrategyXMLEntry* pStrategy = GetMilitaryAIStrategies()->GetEntry(iStrategiesLoop);

	mov	edx, DWORD PTR _iStrategiesLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ; CvMilitaryAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$226526[ebp], eax

; 2433 : 
; 2434 : 		if(pStrategy == NULL)	// Can have holes in the list

	cmp	DWORD PTR _pStrategy$226526[ebp], 0
	jne	SHORT $LN96@UpdateMili

; 2435 : 			continue;

	jmp	SHORT $LN98@UpdateMili
$LN96@UpdateMili:

; 2436 : 
; 2437 : 		// Minor Civs can't run some Strategies
; 2438 : 		if(GetPlayer()->isMinorCiv() && pStrategy->IsNoMinorCivs())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN95@UpdateMili
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN95@UpdateMili

; 2439 : 			continue;

	jmp	SHORT $LN98@UpdateMili
$LN95@UpdateMili:

; 2440 : 
; 2441 : 		// Some strategies ONLY for Minor Civs
; 2442 : 		if(!GetPlayer()->isMinorCiv() && pStrategy->IsOnlyMinorCivs())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN94@UpdateMili
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN94@UpdateMili

; 2443 : 			continue;

	jmp	$LN98@UpdateMili
$LN94@UpdateMili:

; 2444 : 
; 2445 : 		bool bTestStrategyStart = true;

	mov	BYTE PTR _bTestStrategyStart$226530[ebp], 1

; 2446 : 
; 2447 : 		// Do we already have this Strategy adopted?
; 2448 : 		if(IsUsingStrategy(eStrategy))

	mov	ecx, DWORD PTR _eStrategy$226524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN93@UpdateMili

; 2449 : 			bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$226530[ebp], 0

; 2450 : 
; 2451 : 		else

	jmp	$LN92@UpdateMili
$LN93@UpdateMili:

; 2452 : 		{
; 2453 : 			// Has the prereq Tech necessary?
; 2454 : 			if(pStrategy->GetTechPrereq() != NO_TECH && !GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechPrereq()))

	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq
	cmp	eax, -1
	je	SHORT $LN91@UpdateMili
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	DWORD PTR $T234197[ebp], eax
	mov	eax, DWORD PTR $T234197[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234198[ebp], eax
	mov	edx, DWORD PTR $T234198[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234202[ebp], edx
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq
	push	eax
	mov	ecx, DWORD PTR $T234202[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN91@UpdateMili

; 2455 : 			{
; 2456 : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$226530[ebp], 0
$LN91@UpdateMili:

; 2457 : 			}
; 2458 : 
; 2459 : 			// Has the Tech which obsoletes this Strategy?
; 2460 : 			if(bTestStrategyStart && pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	movzx	ecx, BYTE PTR _bTestStrategyStart$226530[ebp]
	test	ecx, ecx
	je	SHORT $LN90@UpdateMili
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
	cmp	eax, -1
	je	SHORT $LN90@UpdateMili
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	DWORD PTR $T234211[ebp], eax
	mov	edx, DWORD PTR $T234211[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234212[ebp], eax
	mov	ecx, DWORD PTR $T234212[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234216[ebp], ecx
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T234216[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN90@UpdateMili

; 2461 : 			{
; 2462 : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$226530[ebp], 0
$LN90@UpdateMili:

; 2463 : 			}
; 2464 : 
; 2465 : 			// Not time to check this yet?
; 2466 : 			if(GC.getGame().getGameTurn() < pStrategy->GetFirstTurnExecuted())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234220[ebp], eax
	mov	ecx, DWORD PTR $T234220[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted
	cmp	esi, eax
	jge	SHORT $LN92@UpdateMili

; 2467 : 			{
; 2468 : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$226530[ebp], 0
$LN92@UpdateMili:

; 2469 : 			}
; 2470 : 		}
; 2471 : 
; 2472 : 		bool bTestStrategyEnd = false;

	mov	BYTE PTR _bTestStrategyEnd$226538[ebp], 0

; 2473 : 
; 2474 : 		// Strategy is active, check to see if we should even try to disable it
; 2475 : 		if(IsUsingStrategy(eStrategy))

	mov	ecx, DWORD PTR _eStrategy$226524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	$LN88@UpdateMili

; 2476 : 		{
; 2477 : 			if(pStrategy->GetCheckTriggerTurnCount() > 0)

	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount
	test	eax, eax
	jle	SHORT $LN87@UpdateMili

; 2478 : 			{
; 2479 : 				// Is it a turn where we want to check to see if this Strategy is maintained?
; 2480 : 				if((GC.getGame().getGameTurn() - GetTurnStrategyAdopted(eStrategy)) % pStrategy->GetCheckTriggerTurnCount() == 0)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234224[ebp], eax
	mov	ecx, DWORD PTR $T234224[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _eStrategy$226524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::GetTurnStrategyAdopted
	sub	esi, eax
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN87@UpdateMili

; 2481 : 					bTestStrategyEnd = true;

	mov	BYTE PTR _bTestStrategyEnd$226538[ebp], 1
$LN87@UpdateMili:

; 2482 : 			}
; 2483 : 
; 2484 : 			if(bTestStrategyEnd && pStrategy->GetMinimumNumTurnsExecuted() > 0)

	movzx	edx, BYTE PTR _bTestStrategyEnd$226538[ebp]
	test	edx, edx
	je	SHORT $LN88@UpdateMili
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
	test	eax, eax
	jle	SHORT $LN88@UpdateMili

; 2485 : 			{
; 2486 : 				// Has the minimum # of turns passed for this Strategy?
; 2487 : 				if(GC.getGame().getGameTurn() < GetTurnStrategyAdopted(eStrategy) + pStrategy->GetMinimumNumTurnsExecuted())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234228[ebp], eax
	mov	ecx, DWORD PTR $T234228[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _eStrategy$226524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::GetTurnStrategyAdopted
	mov	edi, eax
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
	add	edi, eax
	cmp	esi, edi
	jge	SHORT $LN88@UpdateMili

; 2488 : 					bTestStrategyEnd = false;

	mov	BYTE PTR _bTestStrategyEnd$226538[ebp], 0
$LN88@UpdateMili:

; 2489 : 			}
; 2490 : 		}
; 2491 : 
; 2492 : 		// Check Strategy Triggers
; 2493 : 		// Functionality and existence of specific Strategies is hardcoded here, but data is stored in XML so it's easier to modify
; 2494 : 
; 2495 : 		if(bTestStrategyStart || bTestStrategyEnd)

	movzx	edx, BYTE PTR _bTestStrategyStart$226530[ebp]
	test	edx, edx
	jne	SHORT $LN82@UpdateMili
	movzx	eax, BYTE PTR _bTestStrategyEnd$226538[ebp]
	test	eax, eax
	je	$LN83@UpdateMili
$LN82@UpdateMili:

; 2496 : 		{
; 2497 : 			bool bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], 0

; 2498 : 
; 2499 : 			// Has the Tech which obsoletes this Strategy? If so, Strategy should be deactivated regardless of other factors
; 2500 : 			if(pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
	cmp	eax, -1
	je	SHORT $LN81@UpdateMili
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	DWORD PTR $T234237[ebp], eax
	mov	ecx, DWORD PTR $T234237[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234238[ebp], eax
	mov	eax, DWORD PTR $T234238[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234242[ebp], eax
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T234242[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN81@UpdateMili

; 2501 : 			{
; 2502 : 				bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], 0

; 2503 : 			}
; 2504 : 
; 2505 : 			// Strategy isn't obsolete, so test triggers as normal
; 2506 : 			else

	jmp	$LN80@UpdateMili
$LN81@UpdateMili:

; 2507 : 			{
; 2508 : 				CvString strStrategyName = (CvString) pStrategy->GetType();

	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234246[ebp], eax
	cmp	DWORD PTR $T234246[ebp], 0
	je	SHORT $LN132@UpdateMili
	mov	edx, DWORD PTR $T234246[ebp]
	mov	DWORD PTR tv748[ebp], edx
	jmp	SHORT $LN133@UpdateMili
$LN132@UpdateMili:
	mov	DWORD PTR tv748[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN133@UpdateMili:
	mov	eax, DWORD PTR tv748[ebp]
	push	eax
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2509 : 
; 2510 : 				// Check all of the Strategy Triggers
; 2511 : 				if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_MILITARY_UNITS")

	push	OFFSET ??_C@_0CJ@ECLOIKB@MILITARYAISTRATEGY_ENOUGH_MILITA@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN79@UpdateMili

; 2512 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN79@UpdateMili:

; 2513 : 				else if(strStrategyName == "MILITARYAISTRATEGY_EMPIRE_DEFENSE")

	push	OFFSET ??_C@_0CC@KNPAEDG@MILITARYAISTRATEGY_EMPIRE_DEFENS@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN77@UpdateMili

; 2514 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EmpireDefense(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN77@UpdateMili:

; 2515 : 				else if(strStrategyName == "MILITARYAISTRATEGY_EMPIRE_DEFENSE_CRITICAL")

	push	OFFSET ??_C@_0CL@CKCIKBIK@MILITARYAISTRATEGY_EMPIRE_DEFENS@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN75@UpdateMili

; 2516 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN75@UpdateMili:

; 2517 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_NAVAL_UNITS")

	push	OFFSET ??_C@_0CG@NDHAKJJN@MILITARYAISTRATEGY_ENOUGH_NAVAL_@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN73@UpdateMili

; 2518 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN73@UpdateMili:

; 2519 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_NAVAL_UNITS")

	push	OFFSET ??_C@_0CE@CPIEOHHN@MILITARYAISTRATEGY_NEED_NAVAL_UN@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@UpdateMili

; 2520 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN71@UpdateMili:

; 2521 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_NAVAL_UNITS_CRITICAL")

	push	OFFSET ??_C@_0CN@NADDHBK@MILITARYAISTRATEGY_NEED_NAVAL_UN@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN69@UpdateMili

; 2522 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN69@UpdateMili:

; 2523 : 				else if(strStrategyName == "MILITARYAISTRATEGY_WAR_MOBILIZATION")

	push	OFFSET ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN67@UpdateMili

; 2524 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_WarMobilization(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$226524[ebp]
	push	edx
	call	?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WarMobilization
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN67@UpdateMili:

; 2525 : 				else if(strStrategyName == "MILITARYAISTRATEGY_AT_WAR")

	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN65@UpdateMili

; 2526 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_AtWar(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_AtWar
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN65@UpdateMili:

; 2527 : 				else if(strStrategyName == "MILITARYAISTRATEGY_MINOR_CIV_GENERAL_DEFENSE")

	push	OFFSET ??_C@_0CN@PNLKDPJO@MILITARYAISTRATEGY_MINOR_CIV_GEN@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN63@UpdateMili

; 2528 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense();

	call	?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN63@UpdateMili:

; 2529 : 				else if(strStrategyName == "MILITARYAISTRATEGY_MINOR_CIV_THREAT_ELEVATED")

	push	OFFSET ??_C@_0CN@MIOLCJKI@MILITARYAISTRATEGY_MINOR_CIV_THR@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN61@UpdateMili

; 2530 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN61@UpdateMili:

; 2531 : 				else if(strStrategyName == "MILITARYAISTRATEGY_MINOR_CIV_THREAT_CRITICAL")

	push	OFFSET ??_C@_0CN@GKMGLOHH@MILITARYAISTRATEGY_MINOR_CIV_THR@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN59@UpdateMili

; 2532 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN59@UpdateMili:

; 2533 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ERADICATE_BARBARIANS")

	push	OFFSET ??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@UpdateMili

; 2534 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians(eStrategy, m_pPlayer, m_iBarbarianCampCount, m_iVisibleBarbarianCount);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$226524[ebp]
	push	ecx
	call	?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians
	add	esp, 16					; 00000010H
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN57@UpdateMili:

; 2535 : 				else if(strStrategyName == "MILITARYAISTRATEGY_WINNING_WARS")

	push	OFFSET ??_C@_0CA@NOLAFEEE@MILITARYAISTRATEGY_WINNING_WARS?$AA@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN55@UpdateMili

; 2536 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_WinningWars(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WinningWars
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN55@UpdateMili:

; 2537 : 				else if(strStrategyName == "MILITARYAISTRATEGY_LOSING_WARS")

	push	OFFSET ??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN53@UpdateMili

; 2538 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_LosingWars(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_LosingWars
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN53@UpdateMili:

; 2539 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_RANGED")

	push	OFFSET ??_C@_0BP@NFDGGMMN@MILITARYAISTRATEGY_NEED_RANGED?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN51@UpdateMili

; 2540 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits(m_pPlayer, m_iNumRangedLandUnits, m_iNumMeleeLandUnits);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN51@UpdateMili:

; 2541 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_RANGED")

	push	OFFSET ??_C@_0CB@ICEOECPK@MILITARYAISTRATEGY_ENOUGH_RANGED@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN49@UpdateMili

; 2542 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits(m_pPlayer, m_iNumRangedLandUnits, m_iNumMeleeLandUnits);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN49@UpdateMili:

; 2543 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_RANGED_EARLY")

	push	OFFSET ??_C@_0CF@DDNAOBGI@MILITARYAISTRATEGY_NEED_RANGED_E@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN47@UpdateMili

; 2544 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN47@UpdateMili:

; 2545 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_MOBILE")

	push	OFFSET ??_C@_0BP@ENEPHBGG@MILITARYAISTRATEGY_NEED_MOBILE?$AA@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN45@UpdateMili

; 2546 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits(m_pPlayer, m_iNumMobileLandUnits, m_iNumMeleeLandUnits);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN45@UpdateMili:

; 2547 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_MOBILE")

	push	OFFSET ??_C@_0CB@BKDHFPFB@MILITARYAISTRATEGY_ENOUGH_MOBILE@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN43@UpdateMili

; 2548 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits(m_pPlayer, m_iNumMobileLandUnits, m_iNumMeleeLandUnits);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN43@UpdateMili:

; 2549 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_AIR")

	push	OFFSET ??_C@_0BM@MLOEPCOF@MILITARYAISTRATEGY_NEED_AIR?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN41@UpdateMili

; 2550 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedAirUnits(m_pPlayer, m_iNumAirUnits, m_iNumMeleeLandUnits);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN41@UpdateMili:

; 2551 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_AIR")

	push	OFFSET ??_C@_0BO@KHLAAIEO@MILITARYAISTRATEGY_ENOUGH_AIR?$AA@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN39@UpdateMili

; 2552 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits(m_pPlayer, m_iNumAirUnits, m_iNumMeleeLandUnits);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN39@UpdateMili:

; 2553 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_NUKE")

	push	OFFSET ??_C@_0BN@NGMNKOEM@MILITARYAISTRATEGY_NEED_NUKE?$AA@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN37@UpdateMili

; 2554 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedANuke(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedANuke
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	$LN78@UpdateMili
$LN37@UpdateMili:

; 2555 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_ANTIAIR")

	push	OFFSET ??_C@_0CA@PDDGGKAO@MILITARYAISTRATEGY_NEED_ANTIAIR?$AA@
	lea	eax, DWORD PTR _strStrategyName$226550[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@UpdateMili

; 2556 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits(m_pPlayer, m_iNumAntiAirUnits, m_iNumMeleeLandUnits);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	SHORT $LN78@UpdateMili
$LN35@UpdateMili:

; 2557 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_ANTIAIR")

	push	OFFSET ??_C@_0CC@ELNMLHCP@MILITARYAISTRATEGY_ENOUGH_ANTIAI@
	lea	edx, DWORD PTR _strStrategyName$226550[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@UpdateMili

; 2558 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits(m_pPlayer, m_iNumAntiAirUnits, m_iNumMeleeLandUnits);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al
	jmp	SHORT $LN78@UpdateMili
$LN33@UpdateMili:

; 2559 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_AIR_CARRIER")

	push	OFFSET ??_C@_0CE@NIBBOHNC@MILITARYAISTRATEGY_NEED_AIR_CARR@
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN31@UpdateMili

; 2560 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], al

; 2561 : 
; 2562 : 				// Never found it?  Assume it is scenario-specific and should be on unless disabled by Lua hook
; 2563 : 				else

	jmp	SHORT $LN78@UpdateMili
$LN31@UpdateMili:

; 2564 : 				{
; 2565 : 					bStrategyShouldBeActive = true;

	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], 1
$LN78@UpdateMili:

; 2566 : 				}
; 2567 : 
; 2568 : 				// Check Lua hook
; 2569 : 				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T234258[ebp]
	mov	DWORD PTR tv565[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv565[ebp], eax
	mov	ecx, DWORD PTR tv565[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv565[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226628[ebp], eax

; 2570 : 				if(pkScriptSystem && bStrategyShouldBeActive)

	cmp	DWORD PTR _pkScriptSystem$226628[ebp], 0
	je	$LN29@UpdateMili
	movzx	ecx, BYTE PTR _bStrategyShouldBeActive$226546[ebp]
	test	ecx, ecx
	je	$LN29@UpdateMili

; 2571 : 				{
; 2572 : 					CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226630[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2573 : 					args->Push(iStrategiesLoop);

	mov	edx, DWORD PTR _args$226630[ebp]
	mov	DWORD PTR tv578[ebp], edx
	mov	eax, DWORD PTR _iStrategiesLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv578[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv578[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2574 : 					args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _args$226630[ebp]
	mov	DWORD PTR tv585[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T234273[ebp], ecx
	mov	edx, DWORD PTR $T234273[ebp]
	push	edx
	mov	eax, DWORD PTR tv585[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv585[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2575 : 
; 2576 : 					// Attempt to execute the game events.
; 2577 : 					// Will return false if there are no registered listeners.
; 2578 : 					bool bResult = false;

	mov	BYTE PTR _bResult$226631[ebp], 0

; 2579 : 					if(LuaSupport::CallTestAll(pkScriptSystem, "MilitaryStrategyCanActivate", args.get(), bResult))

	mov	ecx, DWORD PTR _args$226630[ebp]
	mov	DWORD PTR $T234277[ebp], ecx
	lea	edx, DWORD PTR _bResult$226631[ebp]
	push	edx
	mov	eax, DWORD PTR $T234277[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@GDBDHKME@MilitaryStrategyCanActivate?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$226628[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@UpdateMili

; 2580 : 					{
; 2581 : 						// Check the result.
; 2582 : 						if(bResult == false)

	movzx	eax, BYTE PTR _bResult$226631[ebp]
	test	eax, eax
	jne	SHORT $LN28@UpdateMili

; 2583 : 						{
; 2584 : 							bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$226546[ebp], 0
$LN28@UpdateMili:

; 2585 : 						}
; 2586 : 					}
; 2587 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$226630[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN29@UpdateMili:

; 2588 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN80@UpdateMili:

; 2589 : 
; 2590 : 			// This variable keeps track of whether or not we should be doing something (i.e. Strategy is active now but should be turned off, OR Strategy is inactive and should be enabled)
; 2591 : 			bool bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$226635[ebp], 0

; 2592 : 
; 2593 : 			// Strategy should be on, and if it's not, turn it on
; 2594 : 			if(bStrategyShouldBeActive)

	movzx	ecx, BYTE PTR _bStrategyShouldBeActive$226546[ebp]
	test	ecx, ecx
	je	SHORT $LN26@UpdateMili

; 2595 : 			{
; 2596 : 				if(bTestStrategyStart)

	movzx	edx, BYTE PTR _bTestStrategyStart$226530[ebp]
	test	edx, edx
	je	SHORT $LN25@UpdateMili

; 2597 : 					bAdoptOrEndStrategy = true;

	mov	BYTE PTR _bAdoptOrEndStrategy$226635[ebp], 1
	jmp	SHORT $LN24@UpdateMili
$LN25@UpdateMili:

; 2598 : 				else if(bTestStrategyEnd)

	movzx	eax, BYTE PTR _bTestStrategyEnd$226538[ebp]
	test	eax, eax
	je	SHORT $LN24@UpdateMili

; 2599 : 					bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$226635[ebp], 0
$LN24@UpdateMili:

; 2600 : 			}
; 2601 : 			// Strategy should be off, and if it's not, turn it off
; 2602 : 			else

	jmp	SHORT $LN22@UpdateMili
$LN26@UpdateMili:

; 2603 : 			{
; 2604 : 				if(bTestStrategyStart)

	movzx	ecx, BYTE PTR _bTestStrategyStart$226530[ebp]
	test	ecx, ecx
	je	SHORT $LN21@UpdateMili

; 2605 : 					bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$226635[ebp], 0
	jmp	SHORT $LN22@UpdateMili
$LN21@UpdateMili:

; 2606 : 				else if(bTestStrategyEnd)

	movzx	edx, BYTE PTR _bTestStrategyEnd$226538[ebp]
	test	edx, edx
	je	SHORT $LN22@UpdateMili

; 2607 : 					bAdoptOrEndStrategy = true;

	mov	BYTE PTR _bAdoptOrEndStrategy$226635[ebp], 1
$LN22@UpdateMili:

; 2608 : 			}
; 2609 : 
; 2610 : 			// Flavor propagation
; 2611 : 			if(bAdoptOrEndStrategy)

	movzx	eax, BYTE PTR _bAdoptOrEndStrategy$226635[ebp]
	test	eax, eax
	je	$LN83@UpdateMili

; 2612 : 			{
; 2613 : 				int iFlavorLoop;
; 2614 : 
; 2615 : 				// We should adopt this Strategy
; 2616 : 				if(bTestStrategyStart)

	movzx	ecx, BYTE PTR _bTestStrategyStart$226530[ebp]
	test	ecx, ecx
	je	$LN17@UpdateMili

; 2617 : 				{
; 2618 : 					SetUsingStrategy(eStrategy, true);

	push	1
	mov	edx, DWORD PTR _eStrategy$226524[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::SetUsingStrategy

; 2619 : 
; 2620 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226645[ebp], 0
	jmp	SHORT $LN16@UpdateMili
$LN15@UpdateMili:
	mov	eax, DWORD PTR _iFlavorLoop$226645[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$226645[ebp], eax
$LN16@UpdateMili:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T234285[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$226645[ebp]
	cmp	edx, DWORD PTR $T234285[ebp]
	jge	SHORT $LN14@UpdateMili

; 2621 : 					{
; 2622 : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$226645[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2623 : 					}

	jmp	SHORT $LN15@UpdateMili
$LN14@UpdateMili:

; 2624 : 
; 2625 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2626 : 
; 2627 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226645[ebp], 0
	jmp	SHORT $LN13@UpdateMili
$LN12@UpdateMili:
	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$226645[ebp], ecx
$LN13@UpdateMili:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T234289[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$226645[ebp]
	cmp	eax, DWORD PTR $T234289[ebp]
	jge	SHORT $LN11@UpdateMili

; 2628 : 					{
; 2629 : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _iFlavorLoop$226645[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2630 : 					}

	jmp	SHORT $LN12@UpdateMili
$LN11@UpdateMili:

; 2631 : 
; 2632 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2633 : 
; 2634 : 					if(pStrategy->RequiresCitySpecializationUpdate())

	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@UpdateMili

; 2635 : 						GetPlayer()->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_STRATEGY_NOW_ON);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty
$LN10@UpdateMili:

; 2636 : 				}

	jmp	$LN83@UpdateMili
$LN17@UpdateMili:

; 2637 : 				// End the Strategy
; 2638 : 				else if(bTestStrategyEnd)

	movzx	eax, BYTE PTR _bTestStrategyEnd$226538[ebp]
	test	eax, eax
	je	$LN83@UpdateMili

; 2639 : 				{
; 2640 : 					SetUsingStrategy(eStrategy, false);

	push	0
	mov	ecx, DWORD PTR _eStrategy$226524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::SetUsingStrategy

; 2641 : 
; 2642 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226645[ebp], 0
	jmp	SHORT $LN7@UpdateMili
$LN6@UpdateMili:
	mov	edx, DWORD PTR _iFlavorLoop$226645[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavorLoop$226645[ebp], edx
$LN7@UpdateMili:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T234293[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	cmp	ecx, DWORD PTR $T234293[ebp]
	jge	SHORT $LN5@UpdateMili

; 2643 : 					{
; 2644 : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	edx, DWORD PTR _iFlavorLoop$226645[ebp]
	push	edx
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2645 : 					}

	jmp	SHORT $LN6@UpdateMili
$LN5@UpdateMili:

; 2646 : 
; 2647 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2648 : 
; 2649 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226645[ebp], 0
	jmp	SHORT $LN4@UpdateMili
$LN3@UpdateMili:
	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$226645[ebp], ecx
$LN4@UpdateMili:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T234297[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$226645[ebp]
	cmp	eax, DWORD PTR $T234297[ebp]
	jge	SHORT $LN2@UpdateMili

; 2650 : 					{
; 2651 : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$226645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
	neg	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _iFlavorLoop$226645[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2652 : 					}

	jmp	SHORT $LN3@UpdateMili
$LN2@UpdateMili:

; 2653 : 
; 2654 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2655 : 
; 2656 : 					if(pStrategy->RequiresCitySpecializationUpdate())

	mov	ecx, DWORD PTR _pStrategy$226526[ebp]
	call	?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN83@UpdateMili

; 2657 : 						GetPlayer()->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_STRATEGY_NOW_OFF);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty
$LN83@UpdateMili:

; 2658 : 				}
; 2659 : 			}
; 2660 : 		}

	jmp	$LN98@UpdateMili
$LN100@UpdateMili:

; 2661 : 	}
; 2662 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strStrategyName$226550[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _args$226630[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ ENDP	; CvMilitaryAI::UpdateMilitaryStrategies
PUBLIC	?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight
PUBLIC	??_C@_0CB@FELPDINN@Choosing?5attack?5target?5by?5weight@ ; `string'
PUBLIC	??_C@_0CL@FLANLLLE@Second?5roll?5to?5see?5if?5we?8re?5goin@ ; `string'
PUBLIC	??_C@_0CE@DNNNLBDB@Roll?5to?5see?5if?5we?8re?5going?5to?5nu@ ; `string'
PUBLIC	??_C@_0BA@FMBAEGJO@FLAVOR_USE_NUKE?$AA@		; `string'
EXTRN	?GetPlayerTargetValue@CvDiplomacyAI@@QBE?AW4TargetValueTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetPlayerTargetValue
EXTRN	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs
EXTRN	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarProjection
EXTRN	?GetLastWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetLastWarProjection
EXTRN	?GetNumTimesNuked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetNumTimesNuked
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ:PROC ; CvAIOperation::GetEnemy
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isForcePeace
EXTRN	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ:PROC ; CvUnit::GetOriginalOwner
;	COMDAT ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
_BSS	SEGMENT
?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A DB 04610H DUP (?) ; `CvMilitaryAI::UpdateOperations'::`166'::weightedTargetList
_BSS	ENDS
;	COMDAT ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA
_BSS	SEGMENT
?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA DD 01H DUP (?) ; `CvMilitaryAI::UpdateOperations'::`166'::$S2
_BSS	ENDS
;	COMDAT ??_C@_0CB@FELPDINN@Choosing?5attack?5target?5by?5weight@
CONST	SEGMENT
??_C@_0CB@FELPDINN@Choosing?5attack?5target?5by?5weight@ DB 'Choosing att'
	DB	'ack target by weight', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FLANLLLE@Second?5roll?5to?5see?5if?5we?8re?5goin@
CONST	SEGMENT
??_C@_0CL@FLANLLLE@Second?5roll?5to?5see?5if?5we?8re?5goin@ DB 'Second ro'
	DB	'll to see if we''re going to nuke!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DNNNLBDB@Roll?5to?5see?5if?5we?8re?5going?5to?5nu@
CONST	SEGMENT
??_C@_0CE@DNNNLBDB@Roll?5to?5see?5if?5we?8re?5going?5to?5nu@ DB 'Roll to '
	DB	'see if we''re going to nuke!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMBAEGJO@FLAVOR_USE_NUKE?$AA@
CONST	SEGMENT
??_C@_0BA@FMBAEGJO@FLAVOR_USE_NUKE?$AA@ DB 'FLAVOR_USE_NUKE', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateOperations@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateOperations@CvMilitaryAI@@AAEXXZ$0
__ehfuncinfo$?UpdateOperations@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateOperations@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateOperations@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
tv792 = -680						; size = 4
tv339 = -676						; size = 4
tv263 = -672						; size = 4
tv247 = -668						; size = 4
tv231 = -664						; size = 4
tv215 = -660						; size = 4
tv199 = -656						; size = 4
tv176 = -652						; size = 4
_this$ = -648						; size = 4
$T234799 = -644						; size = 4
$T234795 = -640						; size = 4
$T234786 = -636						; size = 4
$T234720 = -540						; size = 4
$T234704 = -536						; size = 4
$T234659 = -532						; size = 4
$T234652 = -528						; size = 4
_elem$234673 = -524					; size = 28
_i$234669 = -496					; size = 4
_rtnValue$234668 = -492					; size = 4
$T234647 = -488						; size = 4
$T234630 = -484						; size = 4
$T234552 = -408						; size = 4
$T234543 = -404						; size = 4
$T234513 = -364						; size = 4
$T234508 = -360						; size = 4
$T234504 = -356						; size = 4
$T234503 = -352						; size = 4
$T234499 = -348						; size = 4
$T234491 = -344						; size = 4
$T234483 = -340						; size = 4
$T234479 = -336						; size = 4
_i$234466 = -332					; size = 4
$T234424 = -320						; size = 4
$T234420 = -316						; size = 4
$T234416 = -312						; size = 4
$T234412 = -308						; size = 4
$T234403 = -304						; size = 4
$T234399 = -300						; size = 4
$T234398 = -296						; size = 4
$T234389 = -292						; size = 4
$T234380 = -288						; size = 4
$T234376 = -284						; size = 4
$T234367 = -280						; size = 4
$T234363 = -276						; size = 4
$T234359 = -272						; size = 4
$T234358 = -268						; size = 4
$T234349 = -264						; size = 4
$T234340 = -260						; size = 4
$T234336 = -256						; size = 4
$T234327 = -252						; size = 4
$T234315 = -248						; size = 4
$T234314 = -244						; size = 4
$T234309 = -240						; size = 8
$T234306 = -232						; size = 24
_bHasOperationUnderway$226833 = -205			; size = 1
_fcn$226822 = -204					; size = 8
_chosenTarget$226824 = -196				; size = 24
_iNumUnitsWillingBuild$226811 = -172			; size = 4
_eMilitaryStrength$226801 = -168			; size = 4
_target$226807 = -164					; size = 24
_iAdjustedByTargetValueScore$226819 = -140		; size = 4
_eTargetType$226802 = -136				; size = 4
_bRequestAttack$226800 = -129				; size = 1
_iScore$226808 = -128					; size = 4
_iRoll2$226779 = -124					; size = 4
_iRoll$226777 = -120					; size = 4
_iFlavorNuke$226774 = -116				; size = 4
_bRollForNuke$226767 = -109				; size = 1
_eCurrentWarProjection$226769 = -108			; size = 4
_eLastWarProjection$226768 = -104			; size = 4
_bLaunchNuke$226761 = -97				; size = 1
_pLoopCity$226745 = -96					; size = 4
_iLoop$226746 = -92					; size = 4
_bFoundOneToDelete$226700 = -87				; size = 1
_bFoundOneToDelete$226694 = -86				; size = 1
_bWillingToAcceptRisk$ = -85				; size = 1
_pOperation$ = -84					; size = 4
_iMaxOperations$ = -80					; size = 4
_iPlayerLoop$ = -76					; size = 4
_eBuildCriticalDefenses$ = -72				; size = 4
_iNumBombard$ = -68					; size = 4
_iNumRequiredSlots$ = -64				; size = 4
_iLandReservesUsed$ = -60				; size = 4
_eLoopPlayer$ = -56					; size = 4
_eStrategyBarbs$ = -52					; size = 4
_pLoopUnit$ = -48					; size = 4
_eStrategyFightAWar$ = -44				; size = 4
_iNumSuperiority$ = -40					; size = 4
_eWarState$ = -36					; size = 4
_iFlavorNaval$ = -32					; size = 4
_iFilledSlots$ = -28					; size = 4
_BarbPlayer$ = -24					; size = 4
_iBarbLoop$ = -20					; size = 4
_iOperationID$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?UpdateOperations@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateOperations, COMDAT
; _this$ = ecx

; 2666 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateOperations@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 668				; 0000029cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2667 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateOperations, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2668 : 
; 2669 : 	int iOperationID;
; 2670 : 	int iNumRequiredSlots;
; 2671 : 	int iLandReservesUsed;
; 2672 : 	int iFilledSlots;
; 2673 : 
; 2674 : 	int iPlayerLoop;
; 2675 : 	PlayerTypes eLoopPlayer;
; 2676 : 	WarStateTypes eWarState;
; 2677 : 	CvAIOperation* pOperation;
; 2678 : 
; 2679 : 	MilitaryAIStrategyTypes eStrategyBarbs = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_ERADICATE_BARBARIANS");

	push	0
	push	OFFSET ??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyBarbs$[ebp], eax

; 2680 : 	MilitaryAIStrategyTypes eStrategyFightAWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyFightAWar$[ebp], eax

; 2681 : 	MilitaryAIStrategyTypes eBuildCriticalDefenses = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_EMPIRE_DEFENSE_CRITICAL");

	push	0
	push	OFFSET ??_C@_0CL@CKCIKBIK@MILITARYAISTRATEGY_EMPIRE_DEFENS@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eBuildCriticalDefenses$[ebp], eax

; 2682 : 
; 2683 : 	// SEE IF THERE ARE OPERATIONS THAT NEED TO BE ABORTED
; 2684 : 
; 2685 : 	// Are we willing to risk pressing forward vs. barbarians?
; 2686 : 	bool bWillingToAcceptRisk = (m_iTotalThreatWeight / 2) < GetBarbarianThreatTotal();

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ ; CvMilitaryAI::GetBarbarianThreatTotal
	xor	ecx, ecx
	cmp	esi, eax
	setl	cl
	mov	BYTE PTR _bWillingToAcceptRisk$[ebp], cl

; 2687 : 	if(m_pPlayer->GetPlayerTraits()->GetLandBarbarianConversionPercent() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T234314[ebp], eax
	mov	eax, DWORD PTR $T234314[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T234315[ebp], ecx
	cmp	DWORD PTR $T234315[ebp], 0
	jle	SHORT $LN122@UpdateOper

; 2688 : 	{
; 2689 : 		bWillingToAcceptRisk = true;

	mov	BYTE PTR _bWillingToAcceptRisk$[ebp], 1

; 2690 : 	}
; 2691 : 
; 2692 : 	// if they have one of our civilians
; 2693 : 	CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

$LN122@UpdateOper:
	mov	edx, 63					; 0000003fH
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _BarbPlayer$[ebp], edx

; 2694 : 	CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 2695 : 	int iBarbLoop;
; 2696 : 	for (pLoopUnit = BarbPlayer.firstUnit(&iBarbLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iBarbLoop))

	push	0
	lea	eax, DWORD PTR _iBarbLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _BarbPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN113@UpdateOper
$LN112@UpdateOper:
	push	0
	lea	ecx, DWORD PTR _iBarbLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _BarbPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN113@UpdateOper:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN111@UpdateOper

; 2697 : 	{
; 2698 : 		if (pLoopUnit->GetOriginalOwner() == m_pPlayer->GetID() && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T234327[ebp], ecx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	cmp	eax, DWORD PTR $T234327[ebp]
	jne	SHORT $LN110@UpdateOper
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	SHORT $LN109@UpdateOper
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN110@UpdateOper
$LN109@UpdateOper:

; 2699 : 		{
; 2700 : 			bWillingToAcceptRisk = true;

	mov	BYTE PTR _bWillingToAcceptRisk$[ebp], 1

; 2701 : 			break;

	jmp	SHORT $LN111@UpdateOper
$LN110@UpdateOper:

; 2702 : 		}
; 2703 : 	}

	jmp	SHORT $LN112@UpdateOper
$LN111@UpdateOper:

; 2704 : 
; 2705 : 	//
; 2706 : 	// Operations vs. Barbarians
; 2707 : 	//
; 2708 : 	// If have aborted the eradicate barbarian strategy or if the threat level from civs is significantly higher than from barbs, we better abort all of them
; 2709 : 	if(!IsUsingStrategy(eStrategyBarbs) || IsUsingStrategy(eStrategyFightAWar) || !bWillingToAcceptRisk)

	mov	edx, DWORD PTR _eStrategyBarbs$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN107@UpdateOper
	mov	ecx, DWORD PTR _eStrategyFightAWar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN107@UpdateOper
	movzx	eax, BYTE PTR _bWillingToAcceptRisk$[ebp]
	test	eax, eax
	jne	SHORT $LN108@UpdateOper
$LN107@UpdateOper:

; 2710 : 	{
; 2711 : 		bool bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226694[ebp], 1
$LN106@UpdateOper:

; 2712 : 		while(bFoundOneToDelete)

	movzx	ecx, BYTE PTR _bFoundOneToDelete$226694[ebp]
	test	ecx, ecx
	je	SHORT $LN108@UpdateOper

; 2713 : 		{
; 2714 : 			bFoundOneToDelete = false;

	mov	BYTE PTR _bFoundOneToDelete$226694[ebp], 0

; 2715 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_DESTROY_BARBARIAN_CAMP, &iOperationID))

	push	0
	push	-1
	lea	edx, DWORD PTR _iOperationID$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN104@UpdateOper

; 2716 : 			{
; 2717 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR _iOperationID$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR tv176[ebp], eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR tv176[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv176[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 2718 : 				bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226694[ebp], 1
$LN104@UpdateOper:

; 2719 : 			}
; 2720 : 		}

	jmp	SHORT $LN106@UpdateOper
$LN108@UpdateOper:

; 2721 : 	}
; 2722 : 
; 2723 : 	//
; 2724 : 	// Operation vs. Other Civs
; 2725 : 	//
; 2726 : 	// Are our wars over?
; 2727 : 	if(!IsUsingStrategy(eStrategyFightAWar))

	mov	ecx, DWORD PTR _eStrategyFightAWar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	jne	$LN103@UpdateOper

; 2728 : 	{
; 2729 : 		bool bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 1
$LN102@UpdateOper:

; 2730 : 		while(bFoundOneToDelete)

	movzx	eax, BYTE PTR _bFoundOneToDelete$226700[ebp]
	test	eax, eax
	je	$LN101@UpdateOper

; 2731 : 		{
; 2732 : 			bFoundOneToDelete = false;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 0

; 2733 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN100@UpdateOper

; 2734 : 			{
; 2735 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR tv199[ebp], eax
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv199[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv199[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 2736 : 				bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 1
$LN100@UpdateOper:

; 2737 : 			}
; 2738 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_PILLAGE_ENEMY, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN99@UpdateOper

; 2739 : 			{
; 2740 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR tv215[ebp], eax
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv215[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 2741 : 				bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 1
$LN99@UpdateOper:

; 2742 : 			}
; 2743 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_RAPID_RESPONSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN98@UpdateOper

; 2744 : 			{
; 2745 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR tv231[ebp], eax
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv231[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv231[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 2746 : 				bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 1
$LN98@UpdateOper:

; 2747 : 			}
; 2748 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN97@UpdateOper

; 2749 : 			{
; 2750 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR tv247[ebp], eax
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv247[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv247[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 2751 : 				bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 1
$LN97@UpdateOper:

; 2752 : 			}
; 2753 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN96@UpdateOper

; 2754 : 			{
; 2755 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR tv263[ebp], eax
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv263[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv263[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 2756 : 				bFoundOneToDelete = true;

	mov	BYTE PTR _bFoundOneToDelete$226700[ebp], 1
$LN96@UpdateOper:

; 2757 : 			}
; 2758 : 		}

	jmp	$LN102@UpdateOper
$LN101@UpdateOper:

; 2759 : 	}
; 2760 : 
; 2761 : 	else

	jmp	$LN95@UpdateOper
$LN103@UpdateOper:

; 2762 : 	{
; 2763 : 		// Are any of our strategies inappropriate given the type of war we are fighting
; 2764 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN94@UpdateOper
$LN93@UpdateOper:
	mov	ecx, DWORD PTR _iPlayerLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], ecx
$LN94@UpdateOper:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN92@UpdateOper

; 2765 : 		{
; 2766 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], edx

; 2767 : 
; 2768 : 			// Is this a player we have relations with?
; 2769 : 			if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T234336[ebp], edx
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	cmp	eax, DWORD PTR $T234336[ebp]
	je	$LN91@UpdateOper
	push	0
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	eax, al
	test	eax, eax
	je	$LN91@UpdateOper

; 2770 : 			{
; 2771 : 				// If we've made peace with this player, abort all operations related to him
; 2772 : 				// slewis - added the check for STATE_ALL_WARS_LOSING so that if the player is losing all wars, that they will cancel scheduled attacks
; 2773 : 				if(GET_TEAM(m_pPlayer->getTeam()).isForcePeace(GET_PLAYER(eLoopPlayer).getTeam()) || m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234340[ebp], ecx
	mov	edx, DWORD PTR $T234340[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234349[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T234358[ebp], edx
	mov	eax, DWORD PTR $T234358[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234359[ebp], eax
	mov	edx, DWORD PTR $T234359[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234363[ebp], edx
	mov	eax, DWORD PTR $T234349[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234363[ebp]
	call	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isForcePeace
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN89@UpdateOper
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	$LN90@UpdateOper
$LN89@UpdateOper:

; 2774 : 				{
; 2775 : 					pOperation = GetSneakAttackOperation(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetSneakAttackOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2776 : 					if(pOperation)

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN88@UpdateOper

; 2777 : 					{
; 2778 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN88@UpdateOper:

; 2779 : 					}
; 2780 : 					pOperation = GetBasicAttackOperation(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetBasicAttackOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2781 : 					if(pOperation)

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN87@UpdateOper

; 2782 : 					{
; 2783 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax+80]
	call	edx
$LN87@UpdateOper:

; 2784 : 					}
; 2785 : 					pOperation = GetShowOfForceOperation(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetShowOfForceOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2786 : 					if(pOperation)

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN86@UpdateOper

; 2787 : 					{
; 2788 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN86@UpdateOper:

; 2789 : 					}
; 2790 : 					pOperation = GetPureNavalAttackOperation(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetPureNavalAttackOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2791 : 					if(pOperation)

	cmp	DWORD PTR _pOperation$[ebp], 0
	je	SHORT $LN90@UpdateOper

; 2792 : 					{
; 2793 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax+80]
	call	edx
$LN90@UpdateOper:

; 2794 : 					}
; 2795 : 				}
; 2796 : 
; 2797 : 				eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState
	mov	DWORD PTR _eWarState$[ebp], eax

; 2798 : 				switch(eWarState)

	mov	edx, DWORD PTR _eWarState$[ebp]
	mov	DWORD PTR tv339[ebp], edx
	cmp	DWORD PTR tv339[ebp], 5
	ja	$LN91@UpdateOper
	mov	eax, DWORD PTR tv339[ebp]
	jmp	DWORD PTR $LN395@UpdateOper[eax*4]
$LN82@UpdateOper:

; 2799 : 				{
; 2800 : 					// If we are dominant, shouldn't be running a defensive strategy
; 2801 : 				case WAR_STATE_NEARLY_WON:
; 2802 : 				case WAR_STATE_OFFENSIVE:
; 2803 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_RAPID_RESPONSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN81@UpdateOper

; 2804 : 					{
; 2805 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2806 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN81@UpdateOper

; 2807 : 						{
; 2808 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN81@UpdateOper:

; 2809 : 						}
; 2810 : 					}
; 2811 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN79@UpdateOper

; 2812 : 					{
; 2813 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2814 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN79@UpdateOper

; 2815 : 						{
; 2816 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN79@UpdateOper:

; 2817 : 						}
; 2818 : 					}
; 2819 : 					break;

	jmp	$LN91@UpdateOper
$LN77@UpdateOper:

; 2820 : 
; 2821 : 					// If we are losing, make sure attacks are not running
; 2822 : 				case WAR_STATE_DEFENSIVE:
; 2823 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN76@UpdateOper

; 2824 : 					{
; 2825 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2826 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN76@UpdateOper

; 2827 : 						{
; 2828 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN76@UpdateOper:

; 2829 : 						}
; 2830 : 					}
; 2831 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_PILLAGE_ENEMY, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN74@UpdateOper

; 2832 : 					{
; 2833 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2834 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN74@UpdateOper

; 2835 : 						{
; 2836 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN74@UpdateOper:

; 2837 : 						}
; 2838 : 					}
; 2839 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN72@UpdateOper

; 2840 : 					{
; 2841 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2842 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN72@UpdateOper

; 2843 : 						{
; 2844 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN72@UpdateOper:

; 2845 : 						}
; 2846 : 					}
; 2847 : 					break;

	jmp	$LN91@UpdateOper
$LN70@UpdateOper:

; 2848 : 
; 2849 : 					// If nearly defeated, call off all operations in enemy territory
; 2850 : 				case WAR_STATE_NEARLY_DEFEATED:
; 2851 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@UpdateOper

; 2852 : 					{
; 2853 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2854 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN69@UpdateOper

; 2855 : 						{
; 2856 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN69@UpdateOper:

; 2857 : 						}
; 2858 : 					}
; 2859 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_PILLAGE_ENEMY, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN67@UpdateOper

; 2860 : 					{
; 2861 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2862 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN67@UpdateOper

; 2863 : 						{
; 2864 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN67@UpdateOper:

; 2865 : 						}
; 2866 : 					}
; 2867 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN91@UpdateOper

; 2868 : 					{
; 2869 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2870 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, DWORD PTR _pOperation$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, DWORD PTR _eLoopPlayer$[ebp]
	jne	SHORT $LN91@UpdateOper

; 2871 : 						{
; 2872 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN91@UpdateOper:

; 2873 : 						}
; 2874 : 					}
; 2875 : 					break;
; 2876 : 
; 2877 : 				case WAR_STATE_CALM:
; 2878 : 				case WAR_STATE_STALEMATE:
; 2879 : 				default:
; 2880 : 					break;
; 2881 : 				}
; 2882 : 			}
; 2883 : 		}

	jmp	$LN93@UpdateOper
$LN92@UpdateOper:

; 2884 : 
; 2885 : 		// Are there city defense operations for cities that no longer need defending?
; 2886 : 		CvCity* pLoopCity;
; 2887 : 		int iLoop;
; 2888 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$226746[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226745[ebp], eax
	jmp	SHORT $LN62@UpdateOper
$LN61@UpdateOper:
	push	0
	lea	eax, DWORD PTR _iLoop$226746[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226745[ebp], eax
$LN62@UpdateOper:
	cmp	DWORD PTR _pLoopCity$226745[ebp], 0
	je	SHORT $LN60@UpdateOper

; 2889 : 		{
; 2890 : 			if(pLoopCity->getThreatValue() == 0)

	mov	ecx, DWORD PTR _pLoopCity$226745[ebp]
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	test	eax, eax
	jne	SHORT $LN59@UpdateOper

; 2891 : 			{
; 2892 : 				if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID, NO_PLAYER, pLoopCity->plot()))

	mov	ecx, DWORD PTR _pLoopCity$226745[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	push	-1
	lea	edx, DWORD PTR _iOperationID$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN59@UpdateOper

; 2893 : 				{
; 2894 : 					pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2895 : 					pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN59@UpdateOper:

; 2896 : 				}
; 2897 : 			}
; 2898 : 		}

	jmp	SHORT $LN61@UpdateOper
$LN60@UpdateOper:

; 2899 : 
; 2900 : 		// Are we running a rapid response tactic and the overall threat level is very low?
; 2901 : 		if(m_iTotalThreatWeight <= GC.getAI_MILITARY_THREAT_WEIGHT_MAJOR())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	mov	DWORD PTR $T234367[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	eax, DWORD PTR $T234367[ebp]
	jg	SHORT $LN95@UpdateOper

; 2902 : 		{
; 2903 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_RAPID_RESPONSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN95@UpdateOper

; 2904 : 			{
; 2905 : 				pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pOperation$[ebp], eax

; 2906 : 				pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOperation$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN95@UpdateOper:

; 2907 : 			}
; 2908 : 		}
; 2909 : 	}
; 2910 : 
; 2911 : 	// SEE WHAT OPERATIONS WE SHOULD ADD
; 2912 : 	//
; 2913 : 	// Operation vs. Barbarians
; 2914 : 	//
; 2915 : 	// If running the eradicate barbarian strategy, the threat is low (no higher than 1 major threat), we're not at war, /*and we have enough units*/, then launch a new operation.
; 2916 : 	// Which one is based on whether or not we saw any barbarian camps
; 2917 : 	if(IsUsingStrategy(eStrategyBarbs) && !IsUsingStrategy(eStrategyFightAWar) && !IsUsingStrategy(eBuildCriticalDefenses) && !m_pPlayer->haveAIOperationOfType(AI_OPERATION_DESTROY_BARBARIAN_CAMP)
; 2918 : 	        && bWillingToAcceptRisk)

	mov	ecx, DWORD PTR _eStrategyBarbs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN55@UpdateOper
	mov	eax, DWORD PTR _eStrategyFightAWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN55@UpdateOper
	mov	edx, DWORD PTR _eBuildCriticalDefenses$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN55@UpdateOper
	push	0
	push	-1
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN55@UpdateOper
	movzx	eax, BYTE PTR _bWillingToAcceptRisk$[ebp]
	test	eax, eax
	je	SHORT $LN55@UpdateOper

; 2919 : 	{
; 2920 : 		// We should have AI build for this
; 2921 : 		m_pPlayer->addAIOperation(AI_OPERATION_DESTROY_BARBARIAN_CAMP);

	push	0
	push	0
	push	-1
	push	-1
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN55@UpdateOper:

; 2922 : 	}
; 2923 : 
; 2924 : 	//
; 2925 : 	// Operation vs. Other Civs
; 2926 : 	//
; 2927 : 	// If at war, consider launching an operation
; 2928 : 	if(IsUsingStrategy(eStrategyFightAWar))

	mov	edx, DWORD PTR _eStrategyFightAWar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	$LN54@UpdateOper

; 2929 : 	{
; 2930 : 		// check nuke launches
; 2931 : 		// Loop through each enemy
; 2932 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN53@UpdateOper
$LN52@UpdateOper:
	mov	ecx, DWORD PTR _iPlayerLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], ecx
$LN53@UpdateOper:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN51@UpdateOper

; 2933 : 		{
; 2934 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], edx

; 2935 : 
; 2936 : 			// Is this a player we have relations with?
; 2937 : 			if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T234376[ebp], edx
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	cmp	eax, DWORD PTR $T234376[ebp]
	je	$LN50@UpdateOper
	push	0
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	eax, al
	test	eax, eax
	je	$LN50@UpdateOper

; 2938 : 			{
; 2939 : 				bool bLaunchNuke = false;

	mov	BYTE PTR _bLaunchNuke$226761[ebp], 0

; 2940 : 				// only evaluate nukes when we have nukes and we've declared war on someone
; 2941 : 				if (m_pPlayer->getNumNukeUnits() > 0 && GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam())) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jle	$LN49@UpdateOper
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234380[ebp], edx
	mov	eax, DWORD PTR $T234380[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234389[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234398[ebp], eax
	mov	ecx, DWORD PTR $T234398[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234399[ebp], eax
	mov	eax, DWORD PTR $T234399[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234403[ebp], eax
	mov	ecx, DWORD PTR $T234389[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234403[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	$LN49@UpdateOper

; 2942 : 				{
; 2943 : 					// they nuked us, so we can nuke them.
; 2944 : 					if (m_pPlayer->GetDiplomacyAI()->GetNumTimesNuked(eLoopPlayer) > 0)

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumTimesNuked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumTimesNuked
	test	eax, eax
	jle	SHORT $LN164@UpdateOper

; 2945 : 					{	
; 2946 : 						bLaunchNuke = true;

	mov	BYTE PTR _bLaunchNuke$226761[ebp], 1
	jmp	$LN49@UpdateOper

; 2947 : 					}
; 2948 : 					// if we already nuked them, uhhh, keep it up!
; 2949 : 					else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTimesNuked(m_pPlayer->GetID()) > 0)

$LN164@UpdateOper:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T234412[ebp], ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234416[ebp], edx
	mov	eax, DWORD PTR $T234412[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234416[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumTimesNuked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumTimesNuked
	test	eax, eax
	jle	SHORT $LN46@UpdateOper

; 2950 : 					{
; 2951 : 						bLaunchNuke = true;

	mov	BYTE PTR _bLaunchNuke$226761[ebp], 1

; 2952 : 					}
; 2953 : 					else 

	jmp	$LN49@UpdateOper
$LN46@UpdateOper:

; 2954 : 					{
; 2955 : 						bool bRollForNuke = false;

	mov	BYTE PTR _bRollForNuke$226767[ebp], 0

; 2956 : 						WarProjectionTypes eLastWarProjection = m_pPlayer->GetDiplomacyAI()->GetLastWarProjection(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetLastWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetLastWarProjection
	mov	DWORD PTR _eLastWarProjection$226768[ebp], eax

; 2957 : 						WarProjectionTypes eCurrentWarProjection = m_pPlayer->GetDiplomacyAI()->GetWarProjection(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection
	mov	DWORD PTR _eCurrentWarProjection$226769[ebp], eax

; 2958 : 						if (eCurrentWarProjection == WAR_PROJECTION_DESTRUCTION)

	cmp	DWORD PTR _eCurrentWarProjection$226769[ebp], 0
	jne	SHORT $LN44@UpdateOper

; 2959 : 						{
; 2960 : 							// roll every turn
; 2961 : 							bRollForNuke = true;

	mov	BYTE PTR _bRollForNuke$226767[ebp], 1

; 2962 : 						}
; 2963 : 						else if (eCurrentWarProjection != WAR_PROJECTION_UNKNOWN && eCurrentWarProjection != NO_WAR_PROJECTION_TYPE && 

	jmp	SHORT $LN43@UpdateOper
$LN44@UpdateOper:

; 2964 : 							eLastWarProjection != WAR_PROJECTION_UNKNOWN && eLastWarProjection != NO_WAR_PROJECTION_TYPE && 
; 2965 : 							eCurrentWarProjection < eLastWarProjection)

	cmp	DWORD PTR _eCurrentWarProjection$226769[ebp], 3
	je	SHORT $LN43@UpdateOper
	cmp	DWORD PTR _eCurrentWarProjection$226769[ebp], -1
	je	SHORT $LN43@UpdateOper
	cmp	DWORD PTR _eLastWarProjection$226768[ebp], 3
	je	SHORT $LN43@UpdateOper
	cmp	DWORD PTR _eLastWarProjection$226768[ebp], -1
	je	SHORT $LN43@UpdateOper
	mov	edx, DWORD PTR _eCurrentWarProjection$226769[ebp]
	cmp	edx, DWORD PTR _eLastWarProjection$226768[ebp]
	jge	SHORT $LN43@UpdateOper

; 2966 : 						{
; 2967 : 							// roll for nukes!
; 2968 : 							bRollForNuke = true;

	mov	BYTE PTR _bRollForNuke$226767[ebp], 1
$LN43@UpdateOper:

; 2969 : 						}
; 2970 : 
; 2971 : 						if (bRollForNuke)

	movzx	eax, BYTE PTR _bRollForNuke$226767[ebp]
	test	eax, eax
	je	SHORT $LN49@UpdateOper

; 2972 : 						{
; 2973 : 							int iFlavorNuke = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_USE_NUKE"));

	push	0
	push	OFFSET ??_C@_0BA@FMBAEGJO@FLAVOR_USE_NUKE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorNuke$226774[ebp], eax

; 2974 : 							int iRoll  = GC.getGame().getJonRandNum(10, "Roll to see if we're going to nuke!");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234420[ebp], edx
	push	OFFSET ??_C@_0CE@DNNNLBDB@Roll?5to?5see?5if?5we?8re?5going?5to?5nu@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T234420[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iRoll$226777[ebp], eax

; 2975 : 							int iRoll2 = GC.getGame().getJonRandNum(10, "Second roll to see if we're going to nuke!");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234424[ebp], eax
	push	OFFSET ??_C@_0CL@FLANLLLE@Second?5roll?5to?5see?5if?5we?8re?5goin@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T234424[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iRoll2$226779[ebp], eax

; 2976 : 							if (iRoll < iFlavorNuke && iRoll2 < iFlavorNuke)

	mov	ecx, DWORD PTR _iRoll$226777[ebp]
	cmp	ecx, DWORD PTR _iFlavorNuke$226774[ebp]
	jge	SHORT $LN49@UpdateOper
	mov	edx, DWORD PTR _iRoll2$226779[ebp]
	cmp	edx, DWORD PTR _iFlavorNuke$226774[ebp]
	jge	SHORT $LN49@UpdateOper

; 2977 : 							{
; 2978 : 								bLaunchNuke = true;

	mov	BYTE PTR _bLaunchNuke$226761[ebp], 1
$LN49@UpdateOper:

; 2979 : 							}
; 2980 : 						}
; 2981 : 					}
; 2982 : 				}
; 2983 : 
; 2984 : 				if (bLaunchNuke)

	movzx	eax, BYTE PTR _bLaunchNuke$226761[ebp]
	test	eax, eax
	je	SHORT $LN50@UpdateOper

; 2985 : 				{
; 2986 : 					RequestNukeAttack(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestNukeAttack
$LN50@UpdateOper:

; 2987 : 				}
; 2988 : 
; 2989 : 			}
; 2990 : 		}

	jmp	$LN52@UpdateOper
$LN51@UpdateOper:

; 2991 : 
; 2992 : 		// if we're not considered to be losing all wars, then consider launching operations against other civs
; 2993 : 		if (m_pPlayer->GetDiplomacyAI()->GetStateAllWars() != STATE_ALL_WARS_LOSING)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	je	$LN38@UpdateOper

; 2994 : 		{
; 2995 : 			static CvWeightedVector<CvMilitaryTarget, SAFE_ESTIMATE_NUM_CITIES* 10, true> weightedTargetList;

	mov	eax, DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA
	and	eax, 1
	jne	SHORT $LN37@UpdateOper
	mov	ecx, DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
	push	OFFSET ??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ ; `CvMilitaryAI::UpdateOperations'::`166'::`dynamic atexit destructor for 'weightedTargetList''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN37@UpdateOper:

; 2996 : 			weightedTargetList.clear();

	xor	edx, edx
	je	SHORT $LN192@UpdateOper
	mov	DWORD PTR _i$234466[ebp], 0
	jmp	SHORT $LN190@UpdateOper
$LN189@UpdateOper:
	mov	eax, DWORD PTR _i$234466[ebp]
	add	eax, 1
	mov	DWORD PTR _i$234466[ebp], eax
$LN190@UpdateOper:
	mov	ecx, DWORD PTR _i$234466[ebp]
	cmp	ecx, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	jae	SHORT $LN192@UpdateOper
	jmp	SHORT $LN189@UpdateOper
$LN192@UpdateOper:
	mov	DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, 0

; 2997 : 
; 2998 : 			// make list of scores for each player
; 2999 : 			for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN36@UpdateOper
$LN35@UpdateOper:
	mov	edx, DWORD PTR _iPlayerLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], edx
$LN36@UpdateOper:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN34@UpdateOper

; 3000 : 			{
; 3001 : 				eLoopPlayer = (PlayerTypes)iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], eax

; 3002 : 				if (eLoopPlayer == m_pPlayer->GetID() || !m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T234479[ebp], eax
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	ecx, DWORD PTR $T234479[ebp]
	je	SHORT $LN32@UpdateOper
	push	0
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN33@UpdateOper
$LN32@UpdateOper:

; 3003 : 				{
; 3004 : 					continue;

	jmp	SHORT $LN35@UpdateOper
$LN33@UpdateOper:

; 3005 : 				}
; 3006 : 
; 3007 : 				eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState
	mov	DWORD PTR _eWarState$[ebp], eax

; 3008 : 
; 3009 : 				// if we're not at war
; 3010 : 				if (eWarState == NO_WAR_STATE_TYPE)

	cmp	DWORD PTR _eWarState$[ebp], -1
	jne	SHORT $LN31@UpdateOper

; 3011 : 				{
; 3012 : 					continue;

	jmp	SHORT $LN35@UpdateOper
$LN31@UpdateOper:

; 3013 : 				}
; 3014 : 
; 3015 : 				// don't declare any operations if we are in a defensive or nearly defeated state
; 3016 : 				if (eWarState == WAR_STATE_DEFENSIVE || eWarState == WAR_STATE_NEARLY_DEFEATED)

	cmp	DWORD PTR _eWarState$[ebp], 1
	je	SHORT $LN29@UpdateOper
	cmp	DWORD PTR _eWarState$[ebp], 0
	jne	SHORT $LN30@UpdateOper
$LN29@UpdateOper:

; 3017 : 				{
; 3018 : 					continue;

	jmp	$LN35@UpdateOper
$LN30@UpdateOper:

; 3019 : 				}
; 3020 : 
; 3021 : 				bool bRequestAttack = false;

	mov	BYTE PTR _bRequestAttack$226800[ebp], 0

; 3022 : 
; 3023 : 				StrengthTypes eMilitaryStrength = m_pPlayer->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs
	mov	DWORD PTR _eMilitaryStrength$226801[ebp], eax

; 3024 : 				TargetValueTypes eTargetType = NO_TARGET_VALUE;

	mov	DWORD PTR _eTargetType$226802[ebp], -1

; 3025 : 
; 3026 : 				if(eMilitaryStrength <= STRENGTH_AVERAGE || (GC.getAI_MILITARY_IGNORE_BAD_ODDS() == 1))

	cmp	DWORD PTR _eMilitaryStrength$226801[ebp], 3
	jle	SHORT $LN27@UpdateOper
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2196
	mov	DWORD PTR $T234483[ebp], eax
	cmp	DWORD PTR $T234483[ebp], 1
	jne	SHORT $LN28@UpdateOper
$LN27@UpdateOper:

; 3027 : 				{
; 3028 : 					eTargetType = m_pPlayer->GetDiplomacyAI()->GetPlayerTargetValue(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPlayerTargetValue@CvDiplomacyAI@@QBE?AW4TargetValueTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetPlayerTargetValue
	mov	DWORD PTR _eTargetType$226802[ebp], eax

; 3029 : 					if(eTargetType > TARGET_VALUE_IMPOSSIBLE)

	cmp	DWORD PTR _eTargetType$226802[ebp], 0
	jle	SHORT $LN28@UpdateOper

; 3030 : 					{
; 3031 : 						bRequestAttack = true;

	mov	BYTE PTR _bRequestAttack$226800[ebp], 1
$LN28@UpdateOper:

; 3032 : 					}
; 3033 : 				}
; 3034 : 
; 3035 : 				if (!bRequestAttack)

	movzx	eax, BYTE PTR _bRequestAttack$226800[ebp]
	test	eax, eax
	jne	SHORT $LN25@UpdateOper

; 3036 : 				{
; 3037 : 					continue;

	jmp	$LN35@UpdateOper
$LN25@UpdateOper:

; 3038 : 				}
; 3039 : 
; 3040 : 				CvMilitaryTarget target;

	mov	DWORD PTR _target$226807[ebp], 0
	mov	DWORD PTR _target$226807[ebp+4], 0
	mov	DWORD PTR _target$226807[ebp+8], 0
	mov	DWORD PTR _target$226807[ebp+12], 0
	mov	DWORD PTR _target$226807[ebp+16], 0
	mov	BYTE PTR _target$226807[ebp+20], 0

; 3041 : 				int iScore;
; 3042 : 				target = FindBestAttackTarget(AI_OPERATION_BASIC_CITY_ATTACK, eLoopPlayer, &iScore);

	lea	ecx, DWORD PTR _iScore$226808[ebp]
	push	ecx
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	push	2
	lea	eax, DWORD PTR $T234306[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _target$226807[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$226807[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$226807[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$226807[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$226807[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _target$226807[ebp+20], edx

; 3043 : 				if(target.m_pTargetCity)

	cmp	DWORD PTR _target$226807[ebp], 0
	je	$LN24@UpdateOper

; 3044 : 				{
; 3045 : 					int iNumUnitsWillingBuild = 1;

	mov	DWORD PTR _iNumUnitsWillingBuild$226811[ebp], 1

; 3046 : 					if(target.m_bAttackBySea)

	movzx	eax, BYTE PTR _target$226807[ebp+20]
	test	eax, eax
	je	SHORT $LN23@UpdateOper

; 3047 : 					{
; 3048 : 						iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_INVASION, true, &iNumRequiredSlots, &iLandReservesUsed);

	lea	ecx, DWORD PTR _iLandReservesUsed$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 3049 : 						if((iNumRequiredSlots - iFilledSlots) > iNumUnitsWillingBuild || iLandReservesUsed > GetLandReservesAvailable())

	mov	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	sub	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumUnitsWillingBuild$226811[ebp]
	jg	SHORT $LN21@UpdateOper
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T234491[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	sub	ecx, DWORD PTR [eax+72]
	sub	ecx, DWORD PTR $T234491[ebp]
	cmp	DWORD PTR _iLandReservesUsed$[ebp], ecx
	jle	SHORT $LN22@UpdateOper
$LN21@UpdateOper:

; 3050 : 						{
; 3051 : 							continue;

	jmp	$LN35@UpdateOper
$LN22@UpdateOper:

; 3052 : 						}
; 3053 : 					}
; 3054 : 					else

	jmp	$LN20@UpdateOper
$LN23@UpdateOper:

; 3055 : 					{
; 3056 : 						iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE, false, &iNumRequiredSlots, &iLandReservesUsed);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234499[ebp], edx
	mov	ecx, DWORD PTR $T234499[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T234503[ebp], eax
	mov	eax, DWORD PTR $T234503[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234504[ebp], ecx
	cmp	DWORD PTR $T234504[ebp], 4
	jle	SHORT $LN117@UpdateOper
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234508[ebp], edx
	mov	ecx, DWORD PTR $T234508[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN117@UpdateOper
	mov	DWORD PTR tv792[ebp], 18		; 00000012H
	jmp	SHORT $LN118@UpdateOper
$LN117@UpdateOper:
	mov	DWORD PTR tv792[ebp], 0
$LN118@UpdateOper:
	lea	eax, DWORD PTR _iLandReservesUsed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv792[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 3057 : 						if((iNumRequiredSlots - iFilledSlots) > iNumUnitsWillingBuild || iLandReservesUsed > GetLandReservesAvailable())

	mov	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	sub	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumUnitsWillingBuild$226811[ebp]
	jg	SHORT $LN18@UpdateOper
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T234513[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	sub	ecx, DWORD PTR [eax+72]
	sub	ecx, DWORD PTR $T234513[ebp]
	cmp	DWORD PTR _iLandReservesUsed$[ebp], ecx
	jle	SHORT $LN20@UpdateOper
$LN18@UpdateOper:

; 3058 : 						{
; 3059 : 							continue;

	jmp	$LN35@UpdateOper
$LN20@UpdateOper:

; 3060 : 						}
; 3061 : 					}
; 3062 : 				}
; 3063 : 				else

	jmp	SHORT $LN17@UpdateOper
$LN24@UpdateOper:

; 3064 : 				{
; 3065 : 					continue;

	jmp	$LN35@UpdateOper
$LN17@UpdateOper:

; 3066 : 				}
; 3067 : 
; 3068 : 				// add logic in here for current war state
; 3069 : 				int iAdjustedByTargetValueScore = iScore * eTargetType;

	mov	edx, DWORD PTR _iScore$226808[ebp]
	imul	edx, DWORD PTR _eTargetType$226802[ebp]
	mov	DWORD PTR _iAdjustedByTargetValueScore$226819[ebp], edx

; 3070 : 				weightedTargetList.push_back(target, iAdjustedByTargetValueScore);

	mov	eax, DWORD PTR _iAdjustedByTargetValueScore$226819[ebp]
	push	eax
	lea	ecx, DWORD PTR _target$226807[ebp]
	push	ecx
	mov	ecx, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back

; 3071 : 			}

	jmp	$LN35@UpdateOper
$LN34@UpdateOper:

; 3072 : 
; 3073 : 			// roll from list of players
; 3074 : 			// make sure the list has something in it
; 3075 : 			if(weightedTargetList.size() != 0)

	mov	edx, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR $T234543[ebp], edx
	cmp	DWORD PTR $T234543[ebp], 0
	je	$LN38@UpdateOper

; 3076 : 			{
; 3077 : 				weightedTargetList.SortItems();

	mov	eax, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T234552[ebp], eax
	mov	ecx, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T234630[ebp], ecx
	mov	eax, DWORD PTR $T234552[ebp]
	sub	eax, DWORD PTR $T234630[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR $T234552[ebp]
	push	edx
	mov	eax, DWORD PTR $T234630[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3078 : 				LogAttackTargets(AI_OPERATION_BASIC_CITY_ATTACK, m_pPlayer->GetID(), weightedTargetList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T234647[ebp], eax
	push	OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	ecx, DWORD PTR $T234647[ebp]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; CvMilitaryAI::LogAttackTargets

; 3079 : 
; 3080 : 				if(weightedTargetList.GetTotalWeight() > 0)

	mov	DWORD PTR _rtnValue$234668[ebp], 0
	mov	DWORD PTR _i$234669[ebp], 0
	jmp	SHORT $LN326@UpdateOper
$LN325@UpdateOper:
	mov	edx, DWORD PTR _i$234669[ebp]
	add	edx, 1
	mov	DWORD PTR _i$234669[ebp], edx
$LN326@UpdateOper:
	mov	eax, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR $T234652[ebp], eax
	mov	ecx, DWORD PTR _i$234669[ebp]
	cmp	ecx, DWORD PTR $T234652[ebp]
	jae	SHORT $LN327@UpdateOper
	mov	edx, DWORD PTR _i$234669[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR $T234659[ebp], edx
	mov	eax, DWORD PTR $T234659[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$234673[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$234673[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$234673[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$234673[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _elem$234673[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _elem$234673[ebp+20], edx
	mov	eax, DWORD PTR $T234659[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _elem$234673[ebp+24], ecx
	mov	edx, DWORD PTR _rtnValue$234668[ebp]
	add	edx, DWORD PTR _elem$234673[ebp+24]
	mov	DWORD PTR _rtnValue$234668[ebp], edx
	jmp	$LN325@UpdateOper
$LN327@UpdateOper:
	cmp	DWORD PTR _rtnValue$234668[ebp], 0
	jle	$LN38@UpdateOper

; 3081 : 				{
; 3082 : 					RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$226822[ebp], 0
	mov	DWORD PTR _fcn$226822[ebp+4], 0
	mov	DWORD PTR _fcn$226822[ebp], 0
	mov	DWORD PTR _fcn$226822[ebp+4], 0

; 3083 : 					fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234704[ebp], eax
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	ecx, DWORD PTR $T234704[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234309[ebp]
	push	edx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T234720[ebp], eax
	mov	eax, DWORD PTR $T234720[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fcn$226822[ebp+4], ecx
	mov	edx, DWORD PTR $T234720[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _fcn$226822[ebp], eax

; 3084 : 					CvMilitaryTarget chosenTarget = weightedTargetList.ChooseByWeight(&fcn, "Choosing attack target by weight");

	push	OFFSET ??_C@_0CB@FELPDINN@Choosing?5attack?5target?5by?5weight@
	lea	ecx, DWORD PTR _fcn$226822[ebp]
	push	ecx
	lea	edx, DWORD PTR _chosenTarget$226824[ebp]
	push	edx
	mov	ecx, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight

; 3085 : 
; 3086 : 					// declare that attack
; 3087 : 					RequestSpecificAttack(chosenTarget, 1);

	push	1
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	ecx, DWORD PTR _chosenTarget$226824[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _chosenTarget$226824[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _chosenTarget$226824[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _chosenTarget$226824[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _chosenTarget$226824[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _chosenTarget$226824[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ; CvMilitaryAI::RequestSpecificAttack

; 3088 : 
; 3089 : 					LogChosenTarget(AI_OPERATION_BASIC_CITY_ATTACK, m_pPlayer->GetID(), chosenTarget);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T234786[ebp], edx
	lea	eax, DWORD PTR _chosenTarget$226824[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234786[ebp]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::LogChosenTarget
$LN38@UpdateOper:

; 3090 : 				}
; 3091 : 			}
; 3092 : 
; 3093 : 			/*
; 3094 : 			for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 3095 : 			{
; 3096 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3097 : 
; 3098 : 				// Is this a player we have relations with?
; 3099 : 				if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
; 3100 : 				{
; 3101 : 					eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);
; 3102 : 
; 3103 : 					switch(eWarState)
; 3104 : 					{
; 3105 : 						// If roughly equal in number, let's try to annoy him with raids
; 3106 : 					case WAR_STATE_STALEMATE:
; 3107 : 						//iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_FAST_PILLAGERS, false, &iNumRequiredSlots, &iLandReservesUsed);
; 3108 : 
; 3109 : 						//// Not willing to build units to get this off the ground
; 3110 : 						//if(iFilledSlots >= iNumRequiredSlots && iLandReservesUsed <= GetLandReservesAvailable())
; 3111 : 						//{
; 3112 : 						//	m_pPlayer->addAIOperation(AI_OPERATION_PILLAGE_ENEMY, eLoopPlayer);
; 3113 : 						//}
; 3114 : 						//break;
; 3115 : 
; 3116 : 						// If we are dominant, time to take down one of his cities
; 3117 : 					case WAR_STATE_NEARLY_WON:
; 3118 : 					case WAR_STATE_OFFENSIVE:
; 3119 : 						RequestBasicAttack(eLoopPlayer, 1);
; 3120 : 						break;
; 3121 : 
; 3122 : 						// No one near the other, let's look at a strength comparison before deciding what to do
; 3123 : 					case WAR_STATE_CALM:
; 3124 : 						{
; 3125 : 							bool bRequestAttack = false;
; 3126 : 
; 3127 : 							// slewis - add callbacks here to see if we need to attack anyways
; 3128 : 							StrengthTypes eMilitaryStrength = m_pPlayer->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer);
; 3129 : 
; 3130 : 							bool bAttackAnyway = true;
; 3131 : 
; 3132 : 							if(eMilitaryStrength <= STRENGTH_AVERAGE || bAttackAnyway)
; 3133 : 							{
; 3134 : 								TargetValueTypes eTargetType = m_pPlayer->GetDiplomacyAI()->GetPlayerTargetValue(eLoopPlayer);
; 3135 : 								if(eTargetType > TARGET_VALUE_IMPOSSIBLE)
; 3136 : 								{
; 3137 : 									bRequestAttack = true;
; 3138 : 								}
; 3139 : 							}
; 3140 : 
; 3141 : 							if(bRequestAttack)
; 3142 : 							{
; 3143 : 								RequestBasicAttack(eLoopPlayer, 1);
; 3144 : 							}
; 3145 : 							//else
; 3146 : 							//{
; 3147 : 							//	iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_FAST_PILLAGERS, false, &iNumRequiredSlots, &iLandReservesUsed);
; 3148 : 
; 3149 : 							//	// Not willing to build units to get this off the ground
; 3150 : 							//	if(iFilledSlots >= iNumRequiredSlots && iLandReservesUsed <= GetLandReservesAvailable())
; 3151 : 							//	{
; 3152 : 							//		m_pPlayer->addAIOperation(AI_OPERATION_PILLAGE_ENEMY, eLoopPlayer);
; 3153 : 							//	}
; 3154 : 							//}
; 3155 : 						}
; 3156 : 
; 3157 : 					case WAR_STATE_DEFENSIVE:
; 3158 : 					case WAR_STATE_NEARLY_DEFEATED:
; 3159 : 						{
; 3160 : 							//CvCity *pThreatenedCity;
; 3161 : 							//int iOperationID;
; 3162 : 
; 3163 : 							//// Start by seeing if we have a city that needs defense
; 3164 : 							//for (int iI = 0; iI < m_pPlayer->getNumCities(); iI++)
; 3165 : 							//{
; 3166 : 							//	pThreatenedCity = GetMostThreatenedCity(iI);
; 3167 : 							//	if (pThreatenedCity == NULL)
; 3168 : 							//	{
; 3169 : 							//		break;
; 3170 : 							//	}
; 3171 : 
; 3172 : 							//	// Do we already have an operation protecting this city?
; 3173 : 							//	if (!m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID, NO_PLAYER, pThreatenedCity->plot()))
; 3174 : 							//	{
; 3175 : 							//		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_CLOSE_CITY_DEFENSE, false, &iNumRequiredSlots);
; 3176 : 
; 3177 : 							//		// Not willing to build units to get this off the ground
; 3178 : 							//		if (iFilledSlots >= iNumRequiredSlots)
; 3179 : 							//		{
; 3180 : 							//			m_pPlayer->addAIOperation(AI_OPERATION_CITY_CLOSE_DEFENSE, eLoopPlayer);
; 3181 : 							//		}
; 3182 : 							//	}
; 3183 : 							//}
; 3184 : 
; 3185 : 							//// With any extra defensive bandwidth let's add rapid response forces
; 3186 : 							//iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_RAPID_RESPONSE_FORCE, false, &iNumRequiredSlots);
; 3187 : 
; 3188 : 							//// Not willing to build units to get this off the ground
; 3189 : 							//if (iFilledSlots >= iNumRequiredSlots)
; 3190 : 							//{
; 3191 : 							//	m_pPlayer->addAIOperation(AI_OPERATION_RAPID_RESPONSE, eLoopPlayer);
; 3192 : 							//}
; 3193 : 						}
; 3194 : 						break;
; 3195 : 
; 3196 : 					default:
; 3197 : 						break;
; 3198 : 					}
; 3199 : 				}
; 3200 : 			}*/
; 3201 : 		}
; 3202 : 	
; 3203 : 		// naval attack
; 3204 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN14@UpdateOper
$LN13@UpdateOper:
	mov	edx, DWORD PTR _iPlayerLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], edx
$LN14@UpdateOper:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN54@UpdateOper

; 3205 : 		{
; 3206 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], eax

; 3207 : 			// Is this a player we have relations with?
; 3208 : 			if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T234795[ebp], eax
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	ecx, DWORD PTR $T234795[ebp]
	je	SHORT $LN11@UpdateOper
	push	0
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@UpdateOper

; 3209 : 			{
; 3210 : 				eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState
	mov	DWORD PTR _eWarState$[ebp], eax

; 3211 : 
; 3212 : 				// if we're not at war
; 3213 : 				if (eWarState == NO_WAR_STATE_TYPE)

	cmp	DWORD PTR _eWarState$[ebp], -1
	jne	SHORT $LN10@UpdateOper

; 3214 : 				{
; 3215 : 					continue;

	jmp	SHORT $LN13@UpdateOper
$LN10@UpdateOper:

; 3216 : 				}
; 3217 : 
; 3218 : 				// Naval operations as part of a war effort, but only one at a time
; 3219 : 				bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, &iOperationID, NO_PLAYER);

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	push	18					; 00000012H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$226833[ebp], al

; 3220 : 				if (!bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$226833[ebp]
	test	eax, eax
	jne	SHORT $LN11@UpdateOper

; 3221 : 				{
; 3222 : 					RequestPureNavalAttack(eLoopPlayer, 1);

	push	1
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ; CvMilitaryAI::RequestPureNavalAttack
$LN11@UpdateOper:

; 3223 : 				}
; 3224 : 			}
; 3225 : 		}

	jmp	$LN13@UpdateOper
$LN54@UpdateOper:

; 3226 : 	}
; 3227 : 
; 3228 : 	//
; 3229 : 	// Naval operations (vs. opportunity targets)
; 3230 : 	//
; 3231 : 	// Total number of these operations can't exceed (FLAVOR_NAVAL / 2)
; 3232 : 	int iFlavorNaval = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL"));

	push	0
	push	OFFSET ??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iFlavorNaval$[ebp], eax

; 3233 : 	int iNumSuperiority = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_SUPERIORITY);

	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType
	mov	DWORD PTR _iNumSuperiority$[ebp], eax

; 3234 : 	int iNumBombard = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_BOMBARDMENT);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType
	mov	DWORD PTR _iNumBombard$[ebp], eax

; 3235 : 	int iMaxOperations = iFlavorNaval / 2;

	mov	eax, DWORD PTR _iFlavorNaval$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iMaxOperations$[ebp], eax

; 3236 : 	if(GC.getMap().GetAIMapHint() & 1)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234799[ebp], edx
	mov	ecx, DWORD PTR $T234799[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	je	SHORT $LN8@UpdateOper

; 3237 : 	{
; 3238 : 		iMaxOperations *= 2;

	mov	eax, DWORD PTR _iMaxOperations$[ebp]
	shl	eax, 1
	mov	DWORD PTR _iMaxOperations$[ebp], eax
$LN8@UpdateOper:

; 3239 : 	}
; 3240 : 
; 3241 : 	if((iNumSuperiority + iNumBombard) <= iMaxOperations)

	mov	ecx, DWORD PTR _iNumSuperiority$[ebp]
	add	ecx, DWORD PTR _iNumBombard$[ebp]
	cmp	ecx, DWORD PTR _iMaxOperations$[ebp]
	jg	$LN115@UpdateOper

; 3242 : 	{
; 3243 : 		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_SQUADRON, true, &iNumRequiredSlots);

	push	0
	lea	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	edx
	push	1
	push	9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 3244 : 
; 3245 : 		// Not willing to build units to get this off the ground
; 3246 : 		if(iFilledSlots >= iNumRequiredSlots)

	mov	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	jl	SHORT $LN6@UpdateOper

; 3247 : 		{
; 3248 : 			// If I have a colonization operation underway, start up naval superiority as extra escorts
; 3249 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_QUICK_COLONIZE, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@UpdateOper

; 3250 : 			{
; 3251 : 				m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SUPERIORITY, NO_PLAYER);

	push	0
	push	0
	push	-1
	push	-1
	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	jmp	$LN115@UpdateOper

; 3252 : 				return;

	jmp	SHORT $LN6@UpdateOper
$LN5@UpdateOper:

; 3253 : 			}
; 3254 : 			else if (IsUsingStrategy(eStrategyFightAWar))

	mov	ecx, DWORD PTR _eStrategyFightAWar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@UpdateOper

; 3255 : 			{
; 3256 : 				m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SUPERIORITY, NO_PLAYER);

	push	0
	push	0
	push	-1
	push	-1
	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 3257 : 				return;

	jmp	SHORT $LN115@UpdateOper
$LN6@UpdateOper:

; 3258 : 			}
; 3259 : 		}
; 3260 : 
; 3261 : 		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_BOMBARDMENT, true, &iNumRequiredSlots);

	push	0
	lea	ecx, DWORD PTR _iNumRequiredSlots$[ebp]
	push	ecx
	push	1
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 3262 : 
; 3263 : 		// Not willing to build units to get this off the ground
; 3264 : 		if(iFilledSlots >= iNumRequiredSlots)

	mov	ecx, DWORD PTR _iFilledSlots$[ebp]
	cmp	ecx, DWORD PTR _iNumRequiredSlots$[ebp]
	jl	SHORT $LN115@UpdateOper

; 3265 : 		{
; 3266 : 			// If fighting off barbarians, start naval bombardment, but only if don't have one
; 3267 : 			if(iNumBombard == 0 && IsUsingStrategy(eStrategyBarbs))

	cmp	DWORD PTR _iNumBombard$[ebp], 0
	jne	SHORT $LN115@UpdateOper
	mov	edx, DWORD PTR _eStrategyBarbs$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN115@UpdateOper

; 3268 : 			{
; 3269 : 				m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_BOMBARDMENT, NO_PLAYER);

	push	0
	push	0
	push	-1
	push	-1
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN115@UpdateOper:

; 3270 : 				return;
; 3271 : 			}
; 3272 : 		}
; 3273 : 	}
; 3274 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN395@UpdateOper:
	DD	$LN70@UpdateOper
	DD	$LN77@UpdateOper
	DD	$LN91@UpdateOper
	DD	$LN91@UpdateOper
	DD	$LN82@UpdateOper
	DD	$LN82@UpdateOper
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateOperations@CvMilitaryAI@@AAEXXZ$0:
	mov	eax, DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA, eax
	ret	0
__ehhandler$?UpdateOperations@CvMilitaryAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-676]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateOperations@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateOperations@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateOperations
; Function compile flags: /Odtp
;	COMDAT ??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ
text$yd	SEGMENT
??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ PROC ; `CvMilitaryAI::UpdateOperations'::`166'::`dynamic atexit destructor for 'weightedTargetList'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ ENDP ; `CvMilitaryAI::UpdateOperations'::`166'::`dynamic atexit destructor for 'weightedTargetList''
text$yd	ENDS
EXTRN	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ:PROC ; CvPlayer::getNextAIOperation
EXTRN	?BuyFinalUnit@CvAIOperation@@QAE_NXZ:PROC	; CvAIOperation::BuyFinalUnit
EXTRN	?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ:PROC ; CvAIOperation::HasOneMoreSlotToFill
EXTRN	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ:PROC ; CvPlayer::getFirstAIOperation
; Function compile flags: /Odtp
;	COMDAT ?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nextOp$ = -8						; size = 4
_eStrategyAtWar$ = -4					; size = 4
?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ PROC	; CvMilitaryAI::MakeEmergencyPurchases, COMDAT
; _this$ = ecx

; 3279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3280 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("MakeEmergencyPurchases, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3281 : 
; 3282 : 	CvAIOperation* nextOp;
; 3283 : 
; 3284 : 	// Are we winning all the wars we are in?
; 3285 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 3286 : 	if(!IsUsingStrategy(eStrategyAtWar) || m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	eax, DWORD PTR _eStrategyAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@MakeEmerge
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN7@MakeEmerge
$LN5@MakeEmerge:

; 3287 : 	{
; 3288 : 		// Is there an operation waiting for one more unit?
; 3289 : 		nextOp = m_pPlayer->getFirstAIOperation();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getFirstAIOperation
	mov	DWORD PTR _nextOp$[ebp], eax
$LN4@MakeEmerge:

; 3290 : 		while(nextOp != NULL)

	cmp	DWORD PTR _nextOp$[ebp], 0
	je	SHORT $LN7@MakeEmerge

; 3291 : 		{
; 3292 : 			if(nextOp->HasOneMoreSlotToFill())

	mov	ecx, DWORD PTR _nextOp$[ebp]
	call	?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ ; CvAIOperation::HasOneMoreSlotToFill
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@MakeEmerge

; 3293 : 			{
; 3294 : 				// Can we buy a unit to fill that slot?
; 3295 : 				if(nextOp->BuyFinalUnit())

	mov	ecx, DWORD PTR _nextOp$[ebp]
	call	?BuyFinalUnit@CvAIOperation@@QAE_NXZ	; CvAIOperation::BuyFinalUnit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@MakeEmerge

; 3296 : 				{
; 3297 : 					break;

	jmp	SHORT $LN7@MakeEmerge
$LN2@MakeEmerge:

; 3298 : 				}
; 3299 : 			}
; 3300 : 			nextOp = m_pPlayer->getNextAIOperation();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getNextAIOperation
	mov	DWORD PTR _nextOp$[ebp], eax

; 3301 : 		}

	jmp	SHORT $LN4@MakeEmerge
$LN7@MakeEmerge:

; 3302 : 	}
; 3303 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ ENDP	; CvMilitaryAI::MakeEmergencyPurchases
_TEXT	ENDS
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Odtp
;	COMDAT ?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T234847 = -28						; size = 4
_iCityLoop$226883 = -24					; size = 4
_pLoopCity$226882 = -20					; size = 4
_bNeedNaval$226879 = -13				; size = 1
_pCity$226877 = -12					; size = 4
_pUnit$ = -8						; size = 4
_eStrategyAtWar$ = -4					; size = 4
?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ PROC	; CvMilitaryAI::MakeOffensivePurchases, COMDAT
; _this$ = ecx

; 3307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3308 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("MakeOffensivePurchases, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3309 : 
; 3310 : 	CvUnit *pUnit;
; 3311 : 
; 3312 : 	if (m_pPlayer->isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@MakeOffens

; 3313 : 	{
; 3314 : 		return;

	jmp	$LN22@MakeOffens
$LN21@MakeOffens:

; 3315 : 	}
; 3316 : 
; 3317 : 	// Are we winning all the wars we are in?
; 3318 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 3319 : 	if(!IsUsingStrategy(eStrategyAtWar) || m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	edx, DWORD PTR _eStrategyAtWar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@MakeOffens
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	$LN22@MakeOffens
$LN19@MakeOffens:

; 3320 : 	{
; 3321 : 		// Do we have a high offensive personality flavor and our military could be larger?
; 3322 : 		if (m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE")) >= 7 &&
; 3323 : 			(GetPercentOfRecommendedMilitarySize() < 100 || m_eNavalDefenseState > DEFENSE_STATE_ENOUGH))

	push	0
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	cmp	eax, 7
	jl	$LN22@MakeOffens
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN17@MakeOffens
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jle	$LN22@MakeOffens
$LN17@MakeOffens:

; 3324 : 		{
; 3325 : 			// Do we have operations running (if so let them recruit the units)?
; 3326 : 			if (GetArmyBeingBuilt() == NO_ARMY_TYPE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T234847[ebp], edx
	cmp	DWORD PTR $T234847[ebp], -1
	jne	$LN22@MakeOffens

; 3327 : 			{
; 3328 : 				CvCity *pCity = m_pPlayer->getCapitalCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCity$226877[ebp], eax

; 3329 : 				if (pCity == NULL)

	cmp	DWORD PTR _pCity$226877[ebp], 0
	jne	SHORT $LN15@MakeOffens

; 3330 : 				{
; 3331 : 					return;

	jmp	$LN22@MakeOffens
$LN15@MakeOffens:

; 3332 : 				}
; 3333 : 
; 3334 : 				// Do we need naval units most?
; 3335 : 				bool bNeedNaval = m_eNavalDefenseState > m_eLandDefenseState;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+116]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+112]
	setg	cl
	mov	BYTE PTR _bNeedNaval$226879[ebp], cl

; 3336 : 				if (bNeedNaval)

	movzx	edx, BYTE PTR _bNeedNaval$226879[ebp]
	test	edx, edx
	je	SHORT $LN14@MakeOffens

; 3337 : 				{
; 3338 : 					// Get a different city if capital is not coastal
; 3339 : 					if (!pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$226877[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@MakeOffens

; 3340 : 					{
; 3341 : 						CvCity* pLoopCity;
; 3342 : 						int iCityLoop;
; 3343 : 						bNeedNaval = false;

	mov	BYTE PTR _bNeedNaval$226879[ebp], 0

; 3344 : 						for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL && !bNeedNaval; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$226883[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226882[ebp], eax
	jmp	SHORT $LN12@MakeOffens
$LN11@MakeOffens:
	push	0
	lea	eax, DWORD PTR _iCityLoop$226883[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226882[ebp], eax
$LN12@MakeOffens:
	cmp	DWORD PTR _pLoopCity$226882[ebp], 0
	je	SHORT $LN14@MakeOffens
	movzx	edx, BYTE PTR _bNeedNaval$226879[ebp]
	test	edx, edx
	jne	SHORT $LN14@MakeOffens

; 3345 : 						{
; 3346 : 							if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pLoopCity$226882[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@MakeOffens

; 3347 : 							{
; 3348 : 								bNeedNaval = true;

	mov	BYTE PTR _bNeedNaval$226879[ebp], 1

; 3349 : 								pCity = pLoopCity;

	mov	ecx, DWORD PTR _pLoopCity$226882[ebp]
	mov	DWORD PTR _pCity$226877[ebp], ecx
$LN9@MakeOffens:

; 3350 : 							}
; 3351 : 						}

	jmp	SHORT $LN11@MakeOffens
$LN14@MakeOffens:

; 3352 : 					}
; 3353 : 				}
; 3354 : 
; 3355 : 				if (bNeedNaval)

	movzx	edx, BYTE PTR _bNeedNaval$226879[ebp]
	test	edx, edx
	je	SHORT $LN8@MakeOffens

; 3356 : 				{
; 3357 : 					pUnit = BuyEmergencyUnit(UNITAI_ASSAULT_SEA, pCity);

	mov	eax, DWORD PTR _pCity$226877[ebp]
	push	eax
	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax

; 3358 : 					if (!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN7@MakeOffens

; 3359 : 					{
; 3360 : 						pUnit = BuyEmergencyUnit(UNITAI_ATTACK_SEA, pCity);

	mov	ecx, DWORD PTR _pCity$226877[ebp]
	push	ecx
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax
$LN7@MakeOffens:

; 3361 : 					}
; 3362 : 				}
; 3363 : 				else

	jmp	SHORT $LN22@MakeOffens
$LN8@MakeOffens:

; 3364 : 				{
; 3365 : 					if (m_iNumMeleeLandUnits <= m_iNumRangedLandUnits)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+64]
	cmp	ecx, DWORD PTR [eax+56]
	jg	SHORT $LN5@MakeOffens

; 3366 : 					{
; 3367 : 						pUnit = BuyEmergencyUnit(UNITAI_FAST_ATTACK, pCity);

	mov	edx, DWORD PTR _pCity$226877[ebp]
	push	edx
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax

; 3368 : 						if (!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN4@MakeOffens

; 3369 : 						{
; 3370 : 							pUnit = BuyEmergencyUnit(UNITAI_ATTACK, pCity);

	mov	eax, DWORD PTR _pCity$226877[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax

; 3371 : 							if (!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN4@MakeOffens

; 3372 : 							{
; 3373 : 								pUnit = BuyEmergencyUnit(UNITAI_DEFENSE, pCity);

	mov	ecx, DWORD PTR _pCity$226877[ebp]
	push	ecx
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax
$LN4@MakeOffens:

; 3374 : 							}
; 3375 : 						}
; 3376 : 					}
; 3377 : 					else

	jmp	SHORT $LN22@MakeOffens
$LN5@MakeOffens:

; 3378 : 					{
; 3379 : 						pUnit = BuyEmergencyUnit(UNITAI_CITY_BOMBARD, pCity);

	mov	edx, DWORD PTR _pCity$226877[ebp]
	push	edx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax

; 3380 : 						if (!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN22@MakeOffens

; 3381 : 						{
; 3382 : 							pUnit = BuyEmergencyUnit(UNITAI_RANGED, pCity);

	mov	eax, DWORD PTR _pCity$226877[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$[ebp], eax
$LN22@MakeOffens:

; 3383 : 						}
; 3384 : 					}
; 3385 : 				}
; 3386 : 			}
; 3387 : 		}
; 3388 : 	}
; 3389 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ ENDP	; CvMilitaryAI::MakeOffensivePurchases
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?RequestImprovements@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestImprovements@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::RequestImprovements, COMDAT
; _this$ = ecx

; 3392 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3393 : 
; 3394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RequestImprovements@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::RequestImprovements
_TEXT	ENDS
PUBLIC	?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ; CvMilitaryAI::LogScrapUnit
PUBLIC	?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ; CvMilitaryAI::FindBestUnitToScrap
PUBLIC	??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@ ; `string'
EXTRN	?scrap@CvUnit@@QAEXXZ:PROC			; CvUnit::scrap
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
;	COMDAT ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@ DB 'ECONOMICAISTRA'
	DB	'TEGY_LOSING_MONEY', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$3
__ehfuncinfo$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
tv246 = -140						; size = 4
tv242 = -136						; size = 4
tv269 = -132						; size = 4
tv66 = -128						; size = 4
tv131 = -124						; size = 4
tv88 = -120						; size = 4
_this$ = -116						; size = 4
$T235004 = -112						; size = 4
$T234988 = -108						; size = 4
$T234963 = -104						; size = 4
$T234937 = -100						; size = 4
$T234918 = -96						; size = 4
$T234911 = -92						; size = 4
$T234859 = -88						; size = 4
$T234858 = -84						; size = 4
$T234857 = -80						; size = 8
$T234856 = -72						; size = 8
$T234853 = -64						; size = 4
$T234852 = -60						; size = 4
_pNavalUnit$ = -56					; size = 8
_bInDeficit$ = -46					; size = 1
_bConquestGrandStrategy$ = -45				; size = 1
_eConquestGrandStrategy$ = -44				; size = 4
_iNavalScore$ = -40					; size = 4
_pLandUnit$ = -36					; size = 8
_eStrategyLosingMoney$ = -28				; size = 4
_iLandScore$ = -24					; size = 4
_iGoldSpentOnUnits$ = -20				; size = 4
_iAverageGoldPerUnit$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::DisbandObsoleteUnits, COMDAT
; _this$ = ecx

; 3398 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3399 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("DisbandObsoleteUnits, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3400 : 
; 3401 : 	bool bInDeficit = false;

	mov	BYTE PTR _bInDeficit$[ebp], 0

; 3402 : 	bool bConquestGrandStrategy = false;

	mov	BYTE PTR _bConquestGrandStrategy$[ebp], 0

; 3403 : 	UnitHandle pNavalUnit;

	mov	DWORD PTR _pNavalUnit$[ebp], 0
	mov	BYTE PTR _pNavalUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3404 : 	UnitHandle pLandUnit;

	mov	DWORD PTR _pLandUnit$[ebp], 0
	mov	BYTE PTR _pLandUnit$[ebp+4], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3405 : 	int iNavalScore = MAX_INT;

	mov	DWORD PTR _iNavalScore$[ebp], 2147483647 ; 7fffffffH

; 3406 : 	int iLandScore = MAX_INT;

	mov	DWORD PTR _iLandScore$[ebp], 2147483647	; 7fffffffH

; 3407 : 
; 3408 : 	// Don't do this if at war
; 3409 : 	if(GetNumberCivsAtWarWith() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberCivsAtWarWith
	test	eax, eax
	jle	SHORT $LN14@DisbandObs

; 3410 : 	{
; 3411 : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pLandUnit$[ebp], 0
	je	SHORT $LN30@DisbandObs
	mov	ecx, DWORD PTR _pLandUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@DisbandObs:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pNavalUnit$[ebp], 0
	je	SHORT $LN35@DisbandObs
	mov	ecx, DWORD PTR _pNavalUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN35@DisbandObs:
	jmp	$LN15@DisbandObs
$LN14@DisbandObs:

; 3412 : 	}
; 3413 : 
; 3414 : 	// Don't do this if we're a minor civ
; 3415 : 	if(m_pPlayer->isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@DisbandObs

; 3416 : 	{
; 3417 : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pLandUnit$[ebp], 0
	je	SHORT $LN40@DisbandObs
	mov	ecx, DWORD PTR _pLandUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN40@DisbandObs:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pNavalUnit$[ebp], 0
	je	SHORT $LN45@DisbandObs
	mov	ecx, DWORD PTR _pNavalUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN45@DisbandObs:
	jmp	$LN15@DisbandObs
$LN13@DisbandObs:

; 3418 : 	}
; 3419 : 
; 3420 : 	// Are we running at a deficit?
; 3421 : 	EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");

	push	0
	push	OFFSET ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyLosingMoney$[ebp], eax

; 3422 : 	bInDeficit = m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	edx, DWORD PTR _eStrategyLosingMoney$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	mov	BYTE PTR _bInDeficit$[ebp], al

; 3423 : 
; 3424 : 	int iGoldSpentOnUnits = m_pPlayer->GetTreasury()->GetExpensePerTurnUnitMaintenance();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR $T234911[ebp], eax
	mov	edx, DWORD PTR $T234911[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iGoldSpentOnUnits$[ebp], eax

; 3425 : 	int iAverageGoldPerUnit = iGoldSpentOnUnits / (max(1,m_pPlayer->getNumUnits()));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits
	mov	DWORD PTR $T234852[ebp], eax
	mov	DWORD PTR $T234853[ebp], 1
	mov	edx, DWORD PTR $T234853[ebp]
	cmp	edx, DWORD PTR $T234852[ebp]
	jge	SHORT $LN53@DisbandObs
	lea	eax, DWORD PTR $T234852[ebp]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN54@DisbandObs
$LN53@DisbandObs:
	lea	ecx, DWORD PTR $T234853[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$LN54@DisbandObs:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T234918[ebp], edx
	mov	ecx, DWORD PTR $T234918[ebp]
	mov	eax, DWORD PTR _iGoldSpentOnUnits$[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iAverageGoldPerUnit$[ebp], eax

; 3426 : 
; 3427 : 	// if our units maintenance cost is high we may want to scrap some obsolete stuff
; 3428 : 	bInDeficit = bInDeficit || iAverageGoldPerUnit > 5;

	movzx	edx, BYTE PTR _bInDeficit$[ebp]
	test	edx, edx
	jne	SHORT $LN17@DisbandObs
	cmp	DWORD PTR _iAverageGoldPerUnit$[ebp], 5
	jg	SHORT $LN17@DisbandObs
	mov	DWORD PTR tv131[ebp], 0
	jmp	SHORT $LN18@DisbandObs
$LN17@DisbandObs:
	mov	DWORD PTR tv131[ebp], 1
$LN18@DisbandObs:
	mov	al, BYTE PTR tv131[ebp]
	mov	BYTE PTR _bInDeficit$[ebp], al

; 3429 : 
; 3430 : 	// Are we running anything other than the Conquest Grand Strategy?
; 3431 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eConquestGrandStrategy$[ebp], eax

; 3432 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eConquestGrandStrategy$[ebp], -1
	je	SHORT $LN12@DisbandObs

; 3433 : 	{
; 3434 : 		if(m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eConquestGrandStrategy$[ebp]
	jne	SHORT $LN12@DisbandObs

; 3435 : 		{
; 3436 : 			bConquestGrandStrategy = true;

	mov	BYTE PTR _bConquestGrandStrategy$[ebp], 1
$LN12@DisbandObs:

; 3437 : 		}
; 3438 : 	}
; 3439 : 
; 3440 : 	// Look for obsolete land units if in deficit or have sufficient units
; 3441 : 	if(bInDeficit || (m_eLandDefenseState <= DEFENSE_STATE_NEUTRAL && !bConquestGrandStrategy))

	movzx	edx, BYTE PTR _bInDeficit$[ebp]
	test	edx, edx
	jne	SHORT $LN9@DisbandObs
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 1
	jg	SHORT $LN10@DisbandObs
	movzx	ecx, BYTE PTR _bConquestGrandStrategy$[ebp]
	test	ecx, ecx
	jne	SHORT $LN10@DisbandObs
$LN9@DisbandObs:

; 3442 : 	{
; 3443 : 		pLandUnit = FindBestUnitToScrap(true /*bLand*/, false /*bDeficitForcedDisband*/, iLandScore);

	lea	edx, DWORD PTR _iLandScore$[ebp]
	push	edx
	push	0
	push	1
	lea	eax, DWORD PTR $T234856[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ; CvMilitaryAI::FindBestUnitToScrap
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T234937[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T234937[ebp]
	lea	eax, DWORD PTR _pLandUnit$[ebp]
	cmp	edx, eax
	je	SHORT $LN58@DisbandObs
	cmp	DWORD PTR _pLandUnit$[ebp], 0
	je	SHORT $LN56@DisbandObs
	mov	ecx, DWORD PTR _pLandUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN56@DisbandObs:
	mov	ecx, DWORD PTR $T234937[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pLandUnit$[ebp], edx
	cmp	DWORD PTR _pLandUnit$[ebp], 0
	je	SHORT $LN58@DisbandObs
	mov	ecx, DWORD PTR _pLandUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN58@DisbandObs:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T234856[ebp], 0
	je	SHORT $LN10@DisbandObs
	mov	ecx, DWORD PTR $T234856[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@DisbandObs:

; 3444 : 	}
; 3445 : 
; 3446 : 	// Look for obsolete naval units if in deficit or have sufficient units
; 3447 : 	if(bInDeficit || (m_eNavalDefenseState <= DEFENSE_STATE_NEUTRAL && !bConquestGrandStrategy))

	movzx	eax, BYTE PTR _bInDeficit$[ebp]
	test	eax, eax
	jne	SHORT $LN7@DisbandObs
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 1
	jg	SHORT $LN8@DisbandObs
	movzx	edx, BYTE PTR _bConquestGrandStrategy$[ebp]
	test	edx, edx
	jne	SHORT $LN8@DisbandObs
$LN7@DisbandObs:

; 3448 : 	{
; 3449 : 		pNavalUnit = FindBestUnitToScrap(false/*bNaval*/, false /*bDeficitForcedDisband*/, iNavalScore);

	lea	eax, DWORD PTR _iNavalScore$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR $T234857[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ; CvMilitaryAI::FindBestUnitToScrap
	mov	DWORD PTR tv269[ebp], eax
	mov	edx, DWORD PTR tv269[ebp]
	mov	DWORD PTR $T234963[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR $T234963[ebp]
	lea	ecx, DWORD PTR _pNavalUnit$[ebp]
	cmp	eax, ecx
	je	SHORT $LN72@DisbandObs
	cmp	DWORD PTR _pNavalUnit$[ebp], 0
	je	SHORT $LN70@DisbandObs
	mov	ecx, DWORD PTR _pNavalUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN70@DisbandObs:
	mov	edx, DWORD PTR $T234963[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pNavalUnit$[ebp], eax
	cmp	DWORD PTR _pNavalUnit$[ebp], 0
	je	SHORT $LN72@DisbandObs
	mov	ecx, DWORD PTR _pNavalUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN72@DisbandObs:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T234857[ebp], 0
	je	SHORT $LN8@DisbandObs
	mov	ecx, DWORD PTR $T234857[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN8@DisbandObs:

; 3450 : 	}
; 3451 : 
; 3452 : 	if(iLandScore < MAX_INT && (m_eLandDefenseState <= m_eNavalDefenseState || iLandScore <= iNavalScore))

	cmp	DWORD PTR _iLandScore$[ebp], 2147483647	; 7fffffffH
	jge	SHORT $LN6@DisbandObs
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+112]
	cmp	eax, DWORD PTR [edx+116]
	jle	SHORT $LN83@DisbandObs
	mov	ecx, DWORD PTR _iLandScore$[ebp]
	cmp	ecx, DWORD PTR _iNavalScore$[ebp]
	jg	SHORT $LN6@DisbandObs

; 3453 : 	{
; 3454 : 		if(pLandUnit)

$LN83@DisbandObs:
	xor	edx, edx
	cmp	DWORD PTR _pLandUnit$[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@DisbandObs

; 3455 : 		{
; 3456 : 			pLandUnit->scrap();

	mov	ecx, DWORD PTR _pLandUnit$[ebp]
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 3457 : 			LogScrapUnit(pLandUnit, bInDeficit, bConquestGrandStrategy);

	movzx	ecx, BYTE PTR _bConquestGrandStrategy$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bInDeficit$[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T234858[ebp], esp
	mov	DWORD PTR $T234988[ebp], eax
	mov	ecx, DWORD PTR $T234988[ebp]
	mov	edx, DWORD PTR _pLandUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T234988[ebp]
	mov	cl, BYTE PTR _pLandUnit$[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T234988[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN88@DisbandObs
	mov	eax, DWORD PTR $T234988[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN88@DisbandObs:
	mov	ecx, DWORD PTR $T234988[ebp]
	mov	DWORD PTR tv242[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ; CvMilitaryAI::LogScrapUnit
$LN4@DisbandObs:

; 3458 : 		}
; 3459 : 	}

	jmp	SHORT $LN3@DisbandObs
$LN6@DisbandObs:

; 3460 : 	else if(iNavalScore < MAX_INT)

	cmp	DWORD PTR _iNavalScore$[ebp], 2147483647 ; 7fffffffH
	jge	SHORT $LN3@DisbandObs

; 3461 : 	{
; 3462 : 		if(pNavalUnit)

	xor	edx, edx
	cmp	DWORD PTR _pNavalUnit$[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@DisbandObs

; 3463 : 		{
; 3464 : 			pNavalUnit->scrap();

	mov	ecx, DWORD PTR _pNavalUnit$[ebp]
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 3465 : 			LogScrapUnit(pNavalUnit, bInDeficit, bConquestGrandStrategy);

	movzx	ecx, BYTE PTR _bConquestGrandStrategy$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bInDeficit$[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T234859[ebp], esp
	mov	DWORD PTR $T235004[ebp], eax
	mov	ecx, DWORD PTR $T235004[ebp]
	mov	edx, DWORD PTR _pNavalUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T235004[ebp]
	mov	cl, BYTE PTR _pNavalUnit$[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T235004[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN97@DisbandObs
	mov	eax, DWORD PTR $T235004[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN97@DisbandObs:
	mov	ecx, DWORD PTR $T235004[ebp]
	mov	DWORD PTR tv246[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ; CvMilitaryAI::LogScrapUnit
$LN3@DisbandObs:

; 3466 : 		}
; 3467 : 	}
; 3468 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pLandUnit$[ebp], 0
	je	SHORT $LN102@DisbandObs
	mov	ecx, DWORD PTR _pLandUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN102@DisbandObs:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pNavalUnit$[ebp], 0
	je	SHORT $LN15@DisbandObs
	mov	ecx, DWORD PTR _pNavalUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@DisbandObs:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pNavalUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pLandUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR $T234856[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T234857[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::DisbandObsoleteUnits
; Function compile flags: /Odtp
;	COMDAT ?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T235035 = -28						; size = 4
$T235034 = -24						; size = 4
_iNumRequiredSlots$ = -20				; size = 4
_iLandReservesUsed$ = -16				; size = 4
_bRequiresNavalMoves$ = -10				; size = 1
_bHasOperationUnderway$ = -9				; size = 1
_iFilledSlots$ = -8					; size = 4
_iOperationID$ = -4					; size = 4
_eFormation$ = 8					; size = 4
_eOperationType$ = 12					; size = 4
?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z PROC ; CvMilitaryAI::IsAttackReady, COMDAT
; _this$ = ecx

; 3472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3473 : 	int iOperationID;
; 3474 : 
; 3475 : 	// Do we already have an operation of this type that is building units?
; 3476 : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(eOperationType, &iOperationID, NO_PLAYER);

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOperationType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	BYTE PTR _bHasOperationUnderway$[ebp], al

; 3477 : 	if (bHasOperationUnderway)

	movzx	eax, BYTE PTR _bHasOperationUnderway$[ebp]
	test	eax, eax
	je	SHORT $LN6@IsAttackRe

; 3478 : 	{
; 3479 : 		if (m_pPlayer->getAIOperation(iOperationID)->GetOperationState() != AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	ecx, DWORD PTR _iOperationID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR $T235034[ebp], eax
	mov	eax, DWORD PTR $T235034[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T235035[ebp], ecx
	cmp	DWORD PTR $T235035[ebp], 1
	je	SHORT $LN6@IsAttackRe

; 3480 : 		{
; 3481 : 			return false;

	xor	al, al
	jmp	SHORT $LN7@IsAttackRe
$LN6@IsAttackRe:

; 3482 : 		}
; 3483 : 	}
; 3484 : 
; 3485 : 	int iNumRequiredSlots = 0;

	mov	DWORD PTR _iNumRequiredSlots$[ebp], 0

; 3486 : 	int iLandReservesUsed = 0;

	mov	DWORD PTR _iLandReservesUsed$[ebp], 0

; 3487 : 	int iFilledSlots = 0;

	mov	DWORD PTR _iFilledSlots$[ebp], 0

; 3488 : 
; 3489 : 	bool bRequiresNavalMoves = false;

	mov	BYTE PTR _bRequiresNavalMoves$[ebp], 0

; 3490 : 	if(eFormation == MUFORMATION_NAVAL_INVASION || eFormation == MUFORMATION_NAVAL_SQUADRON || eFormation == MUFORMATION_CITY_STATE_INVASION || eFormation == MUFORMATION_PURE_NAVAL_CITY_ATTACK)

	cmp	DWORD PTR _eFormation$[ebp], 12		; 0000000cH
	je	SHORT $LN3@IsAttackRe
	cmp	DWORD PTR _eFormation$[ebp], 9
	je	SHORT $LN3@IsAttackRe
	cmp	DWORD PTR _eFormation$[ebp], 13		; 0000000dH
	je	SHORT $LN3@IsAttackRe
	cmp	DWORD PTR _eFormation$[ebp], 17		; 00000011H
	jne	SHORT $LN4@IsAttackRe
$LN3@IsAttackRe:

; 3491 : 	{
; 3492 : 		bRequiresNavalMoves = true;

	mov	BYTE PTR _bRequiresNavalMoves$[ebp], 1
$LN4@IsAttackRe:

; 3493 : 	}
; 3494 : 
; 3495 : 	iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, eFormation, bRequiresNavalMoves, &iNumRequiredSlots, &iLandReservesUsed);

	lea	edx, DWORD PTR _iLandReservesUsed$[ebp]
	push	edx
	lea	eax, DWORD PTR _iNumRequiredSlots$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bRequiresNavalMoves$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eFormation$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	mov	DWORD PTR _iFilledSlots$[ebp], eax

; 3496 : 	if(iFilledSlots >= iNumRequiredSlots)

	mov	edx, DWORD PTR _iFilledSlots$[ebp]
	cmp	edx, DWORD PTR _iNumRequiredSlots$[ebp]
	jl	SHORT $LN2@IsAttackRe

; 3497 : 	{
; 3498 : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@IsAttackRe

; 3499 : 	}
; 3500 : 	else

	jmp	SHORT $LN7@IsAttackRe
$LN2@IsAttackRe:

; 3501 : 	{
; 3502 : 		return false;

	xor	al, al
$LN7@IsAttackRe:

; 3503 : 	}
; 3504 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ENDP ; CvMilitaryAI::IsAttackReady
_TEXT	ENDS
PUBLIC	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
EXTRN	?canScrap@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::canScrap
EXTRN	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceTotal
EXTRN	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z:PROC ; CvUnitEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ:PROC ; CvUnit::GetUpgradeUnitType
EXTRN	?GetPower@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetPower
EXTRN	?GetObsoleteTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetObsoleteTech
EXTRN	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvPlayer::canTrain
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z$0
__ehfuncinfo$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T235066 = -80						; size = 4
$T235062 = -76						; size = 4
$T235061 = -72						; size = 4
$T235040 = -68						; size = 4
_iNumResourceNeeded$226994 = -64			; size = 4
_eResource$226992 = -60					; size = 4
_iResourceLoop$226988 = -56				; size = 4
_pUpgradeUnitInfo$226986 = -52				; size = 4
_pUnitInfo$226978 = -48					; size = 4
_eUpgradeUnit$226984 = -44				; size = 4
_bSkipThisOne$226968 = -37				; size = 1
_pBestUnit$ = -36					; size = 8
_pLoopUnit$ = -28					; size = 4
_iBestScore$ = -24					; size = 4
_iUnitLoop$ = -20					; size = 4
_iScore$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_bLand$ = 12						; size = 1
_bDeficitForcedDisband$ = 16				; size = 1
_iReturnedScore$ = 20					; size = 4
?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z PROC ; CvMilitaryAI::FindBestUnitToScrap, COMDAT
; _this$ = ecx

; 3508 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T235040[ebp], 0

; 3509 : 	CvUnit* pLoopUnit;
; 3510 : 	int iUnitLoop;
; 3511 : 	UnitHandle pBestUnit;

	mov	DWORD PTR _pBestUnit$[ebp], 0
	mov	BYTE PTR _pBestUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3512 : 	int iScore;
; 3513 : 	int iBestScore = MAX_INT;

	mov	DWORD PTR _iBestScore$[ebp], 2147483647	; 7fffffffH

; 3514 : 
; 3515 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN27@FindBestUn
$LN26@FindBestUn:
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN27@FindBestUn:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN25@FindBestUn

; 3516 : 	{
; 3517 : 		bool bSkipThisOne = false;

	mov	BYTE PTR _bSkipThisOne$226968[ebp], 0

; 3518 : 
; 3519 : 		if(!pLoopUnit->IsCombatUnit())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@FindBestUn

; 3520 : 		{
; 3521 : 			continue;

	jmp	SHORT $LN26@FindBestUn
$LN24@FindBestUn:

; 3522 : 		}
; 3523 : 
; 3524 : 		if(bLand && pLoopUnit->getDomainType() != DOMAIN_LAND)

	movzx	ecx, BYTE PTR _bLand$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@FindBestUn
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	je	SHORT $LN23@FindBestUn

; 3525 : 		{
; 3526 : 			continue;

	jmp	SHORT $LN26@FindBestUn
$LN23@FindBestUn:

; 3527 : 		}
; 3528 : 
; 3529 : 		if(!bLand && pLoopUnit->getDomainType() != DOMAIN_SEA)

	movzx	edx, BYTE PTR _bLand$[ebp]
	test	edx, edx
	jne	SHORT $LN22@FindBestUn
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN22@FindBestUn

; 3530 : 		{
; 3531 : 			continue;

	jmp	SHORT $LN26@FindBestUn
$LN22@FindBestUn:

; 3532 : 		}
; 3533 : 
; 3534 : 		// Following checks are for the case where the AI is trying to decide if it is a good idea to disband this unit (as opposed to when the game is FORCING the player to disband one)
; 3535 : 		if(!bDeficitForcedDisband)

	movzx	eax, BYTE PTR _bDeficitForcedDisband$[ebp]
	test	eax, eax
	jne	$LN21@FindBestUn

; 3536 : 		{
; 3537 : 			if(bLand && m_eLandDefenseState == DEFENSE_STATE_CRITICAL)

	movzx	ecx, BYTE PTR _bLand$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@FindBestUn
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+112], 3
	jne	SHORT $LN20@FindBestUn
	jmp	$LN26@FindBestUn

; 3538 : 			{
; 3539 : 				continue;

	jmp	SHORT $LN19@FindBestUn
$LN20@FindBestUn:

; 3540 : 			}
; 3541 : 			else if(!bLand && m_eNavalDefenseState == DEFENSE_STATE_CRITICAL)

	movzx	eax, BYTE PTR _bLand$[ebp]
	test	eax, eax
	jne	SHORT $LN19@FindBestUn
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 3
	jne	SHORT $LN19@FindBestUn

; 3542 : 			{
; 3543 : 				continue;

	jmp	$LN26@FindBestUn
$LN19@FindBestUn:

; 3544 : 			}
; 3545 : 
; 3546 : 			// Is it in an army?
; 3547 : 			if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN17@FindBestUn

; 3548 : 			{
; 3549 : 				continue;

	jmp	$LN26@FindBestUn
$LN17@FindBestUn:

; 3550 : 			}
; 3551 : 
; 3552 : 			// Can I still build this unit? If so too new to scrap
; 3553 : 			if(bLand && m_pPlayer->canTrain(pLoopUnit->getUnitType(), false /*bContinue*/, false /*bTestVisible*/, true /*bIgnoreCost*/))

	movzx	edx, BYTE PTR _bLand$[ebp]
	test	edx, edx
	je	SHORT $LN16@FindBestUn
	push	0
	push	0
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvPlayer::canTrain
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@FindBestUn

; 3554 : 			{
; 3555 : 				continue;

	jmp	$LN26@FindBestUn
$LN16@FindBestUn:

; 3556 : 			}
; 3557 : 
; 3558 : 			// Is this a unit who has an obsolete tech that I have researched?
; 3559 : 			CvUnitEntry& pUnitInfo = pLoopUnit->getUnitInfo();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR _pUnitInfo$226978[ebp], eax

; 3560 : 			if((TechTypes)pUnitInfo.GetObsoleteTech() == NO_TECH)

	mov	ecx, DWORD PTR _pUnitInfo$226978[ebp]
	call	?GetObsoleteTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetObsoleteTech
	cmp	eax, -1
	jne	SHORT $LN15@FindBestUn

; 3561 : 			{
; 3562 : 				continue;

	jmp	$LN26@FindBestUn
$LN15@FindBestUn:

; 3563 : 			}
; 3564 : 
; 3565 : 			if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T235061[ebp], eax
	mov	ecx, DWORD PTR $T235061[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235062[ebp], eax
	mov	eax, DWORD PTR $T235062[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235066[ebp], eax
	mov	ecx, DWORD PTR _pUnitInfo$226978[ebp]
	call	?GetObsoleteTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetObsoleteTech
	push	eax
	mov	ecx, DWORD PTR $T235066[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN14@FindBestUn

; 3566 : 			{
; 3567 : 				continue;

	jmp	$LN26@FindBestUn
$LN14@FindBestUn:

; 3568 : 			}
; 3569 : 
; 3570 : 			// Is this unit's INTRINSIC power less than half that of the best unit I can build for this domain?
; 3571 : 			if((pLoopUnit->getUnitInfo().GetPower() * 2) >= GetPowerOfStrongestBuildableUnit(pLoopUnit->getDomainType()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	mov	esi, eax
	shl	esi, 1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
	cmp	esi, eax
	jl	SHORT $LN13@FindBestUn

; 3572 : 			{
; 3573 : 				continue;

	jmp	$LN26@FindBestUn
$LN13@FindBestUn:

; 3574 : 			}
; 3575 : 
; 3576 : 			// Does this unit's upgrade require a resource?
; 3577 : 			UnitTypes eUpgradeUnit = pLoopUnit->GetUpgradeUnitType();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ ; CvUnit::GetUpgradeUnitType
	mov	DWORD PTR _eUpgradeUnit$226984[ebp], eax

; 3578 : 			if(eUpgradeUnit != NO_UNIT)

	cmp	DWORD PTR _eUpgradeUnit$226984[ebp], -1
	je	$LN21@FindBestUn

; 3579 : 			{
; 3580 : 				CvUnitEntry* pUpgradeUnitInfo = GC.GetGameUnits()->GetEntry(eUpgradeUnit);

	mov	edx, DWORD PTR _eUpgradeUnit$226984[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pUpgradeUnitInfo$226986[ebp], eax

; 3581 : 				if(pUpgradeUnitInfo != NULL)

	cmp	DWORD PTR _pUpgradeUnitInfo$226986[ebp], 0
	je	$LN21@FindBestUn

; 3582 : 				{
; 3583 : #ifdef AUI_WARNING_FIXES
; 3584 : 					for(uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bSkipThisOne; iResourceLoop++)
; 3585 : #else
; 3586 : 					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bSkipThisOne; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$226988[ebp], 0
	jmp	SHORT $LN10@FindBestUn
$LN9@FindBestUn:
	mov	eax, DWORD PTR _iResourceLoop$226988[ebp]
	add	eax, 1
	mov	DWORD PTR _iResourceLoop$226988[ebp], eax
$LN10@FindBestUn:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$226988[ebp], eax
	jge	SHORT $LN21@FindBestUn
	movzx	ecx, BYTE PTR _bSkipThisOne$226968[ebp]
	test	ecx, ecx
	jne	SHORT $LN21@FindBestUn

; 3587 : #endif
; 3588 : 					{
; 3589 : 						ResourceTypes eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$226988[ebp]
	mov	DWORD PTR _eResource$226992[ebp], edx

; 3590 : 						int iNumResourceNeeded = pUpgradeUnitInfo->GetResourceQuantityRequirement(eResource);

	mov	eax, DWORD PTR _eResource$226992[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUpgradeUnitInfo$226986[ebp]
	call	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement
	mov	DWORD PTR _iNumResourceNeeded$226994[ebp], eax

; 3591 : 
; 3592 : 						if(iNumResourceNeeded > 0)

	cmp	DWORD PTR _iNumResourceNeeded$226994[ebp], 0
	jle	SHORT $LN7@FindBestUn

; 3593 : 						{
; 3594 : 							if(m_pPlayer->getNumResourceTotal(eResource) > 0)

	push	1
	mov	ecx, DWORD PTR _eResource$226992[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jle	SHORT $LN7@FindBestUn

; 3595 : 							{
; 3596 : 								if(bLand && m_eLandDefenseState > DEFENSE_STATE_NEUTRAL)

	movzx	eax, BYTE PTR _bLand$[ebp]
	test	eax, eax
	je	SHORT $LN5@FindBestUn
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+112], 1
	jle	SHORT $LN5@FindBestUn

; 3597 : 								{
; 3598 : 									bSkipThisOne  = true;    // We'll wait and try to upgrade this one, our unit count isn't that bad

	mov	BYTE PTR _bSkipThisOne$226968[ebp], 1
	jmp	SHORT $LN7@FindBestUn
$LN5@FindBestUn:

; 3599 : 								}
; 3600 : 								else if(!bLand && m_eNavalDefenseState > DEFENSE_STATE_NEUTRAL)

	movzx	edx, BYTE PTR _bLand$[ebp]
	test	edx, edx
	jne	SHORT $LN7@FindBestUn
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 1
	jle	SHORT $LN7@FindBestUn

; 3601 : 								{
; 3602 : 									bSkipThisOne  = true;    // We'll wait and try to upgrade this one, our unit count isn't that bad

	mov	BYTE PTR _bSkipThisOne$226968[ebp], 1
$LN7@FindBestUn:

; 3603 : 								}
; 3604 : 							}
; 3605 : 						}
; 3606 : 					}

	jmp	SHORT $LN9@FindBestUn
$LN21@FindBestUn:

; 3607 : 				}
; 3608 : 			}
; 3609 : 		}
; 3610 : 
; 3611 : 		// Can I scrap this unit?
; 3612 : 		if(!bSkipThisOne && pLoopUnit->canScrap())

	movzx	ecx, BYTE PTR _bSkipThisOne$226968[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@FindBestUn
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canScrap@CvUnit@@QBE_N_N@Z		; CvUnit::canScrap
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@FindBestUn

; 3613 : 		{
; 3614 : 			iScore = pLoopUnit->GetPower();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	mov	DWORD PTR _iScore$[ebp], eax

; 3615 : 
; 3616 : 			if(iScore < iBestScore)

	mov	eax, DWORD PTR _iScore$[ebp]
	cmp	eax, DWORD PTR _iBestScore$[ebp]
	jge	SHORT $LN2@FindBestUn

; 3617 : 			{
; 3618 : 				iBestScore = iScore;

	mov	ecx, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iBestScore$[ebp], ecx

; 3619 : 				iReturnedScore = iBestScore;

	mov	edx, DWORD PTR _iReturnedScore$[ebp]
	mov	eax, DWORD PTR _iBestScore$[ebp]
	mov	DWORD PTR [edx], eax

; 3620 : 				pBestUnit = pLoopUnit;

	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN46@FindBestUn
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@FindBestUn:
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pBestUnit$[ebp], ecx
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN2@FindBestUn
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FindBestUn:

; 3621 : 			}
; 3622 : 		}
; 3623 : 	}

	jmp	$LN26@FindBestUn
$LN25@FindBestUn:

; 3624 : 
; 3625 : 	return pBestUnit;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _pBestUnit$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	dl, BYTE PTR _pBestUnit$[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN54@FindBestUn
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN54@FindBestUn:
	mov	edx, DWORD PTR $T235040[ebp]
	or	edx, 1
	mov	DWORD PTR $T235040[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN59@FindBestUn
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@FindBestUn:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3626 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z$0:
	lea	ecx, DWORD PTR _pBestUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z$1:
	mov	eax, DWORD PTR $T235040[ebp]
	and	eax, 1
	je	$LN32@FindBestUn
	and	DWORD PTR $T235040[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN32@FindBestUn:
	ret	0
__ehhandler$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ENDP ; CvMilitaryAI::FindBestUnitToScrap
PUBLIC	?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ; MilitaryAIHelpers::FirstSlotCityCanFill
PUBLIC	?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z ; CvMilitaryAI::GetUnitForArmy
; Function compile flags: /Odtp
;	COMDAT ?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
tv85 = -36						; size = 4
_this$ = -32						; size = 4
$T235122 = -28						; size = 4
$T235118 = -24						; size = 4
$T235117 = -20						; size = 4
$T235113 = -16						; size = 4
_eFormation$ = -12					; size = 4
_eUnitAIType$ = -8					; size = 4
_eType$ = -4						; size = 4
_pCity$ = 8						; size = 4
?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z PROC ; CvMilitaryAI::GetUnitForArmy, COMDAT
; _this$ = ecx

; 3630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3631 : 	if(m_eArmyTypeBeingBuilt == NO_ARMY_TYPE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], -1
	jne	SHORT $LN4@GetUnitFor

; 3632 : 	{
; 3633 : 		return NO_UNIT;

	or	eax, -1
	jmp	$LN5@GetUnitFor
$LN4@GetUnitFor:

; 3634 : 	}
; 3635 : 
; 3636 : 	// Look for required units first
; 3637 : 	MultiunitFormationTypes eFormation;
; 3638 : 	if(m_eArmyTypeBeingBuilt == ARMY_TYPE_NAVAL_INVASION)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], 1
	jne	SHORT $LN3@GetUnitFor

; 3639 : 	{
; 3640 : 		eFormation = MUFORMATION_NAVAL_INVASION;

	mov	DWORD PTR _eFormation$[ebp], 12		; 0000000cH

; 3641 : 	}
; 3642 : 	else

	jmp	SHORT $LN2@GetUnitFor
$LN3@GetUnitFor:

; 3643 : 	{
; 3644 : 		eFormation = (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235113[ebp], edx
	mov	ecx, DWORD PTR $T235113[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T235117[ebp], eax
	mov	eax, DWORD PTR $T235117[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235118[ebp], ecx
	cmp	DWORD PTR $T235118[ebp], 4
	jle	SHORT $LN7@GetUnitFor
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235122[ebp], edx
	mov	ecx, DWORD PTR $T235122[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN7@GetUnitFor
	mov	DWORD PTR tv85[ebp], 18			; 00000012H
	jmp	SHORT $LN8@GetUnitFor
$LN7@GetUnitFor:
	mov	DWORD PTR tv85[ebp], 0
$LN8@GetUnitFor:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _eFormation$[ebp], eax
$LN2@GetUnitFor:

; 3645 : 	}
; 3646 : 	UnitAITypes eUnitAIType = MilitaryAIHelpers::FirstSlotCityCanFill(m_pPlayer, eFormation, (m_eArmyTypeBeingBuilt == ARMY_TYPE_NAVAL_INVASION), pCity->isCoastal(), false /*bSecondaryUnit*/);

	push	0
	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 1
	sete	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _eFormation$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ; MilitaryAIHelpers::FirstSlotCityCanFill
	add	esp, 20					; 00000014H
	mov	DWORD PTR _eUnitAIType$[ebp], eax

; 3647 : 	UnitTypes eType = pCity->GetCityStrategyAI()->GetUnitProductionAI()->RecommendUnit(eUnitAIType);

	mov	edx, DWORD PTR _eUnitAIType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
	mov	ecx, eax
	call	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit
	mov	DWORD PTR _eType$[ebp], eax

; 3648 : 	if(eType == NO_UNIT)

	cmp	DWORD PTR _eType$[ebp], -1
	jne	SHORT $LN1@GetUnitFor

; 3649 : 	{
; 3650 : 		eUnitAIType = MilitaryAIHelpers::FirstSlotCityCanFill(m_pPlayer, eFormation, (m_eArmyTypeBeingBuilt == ARMY_TYPE_NAVAL_INVASION), pCity->isCoastal(), true /*bSecondaryUnit*/);

	push	1
	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], 1
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR _eFormation$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ; MilitaryAIHelpers::FirstSlotCityCanFill
	add	esp, 20					; 00000014H
	mov	DWORD PTR _eUnitAIType$[ebp], eax

; 3651 : 		eType = pCity->GetCityStrategyAI()->GetUnitProductionAI()->RecommendUnit(eUnitAIType);

	mov	ecx, DWORD PTR _eUnitAIType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
	mov	ecx, eax
	call	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit
	mov	DWORD PTR _eType$[ebp], eax
$LN1@GetUnitFor:

; 3652 : 	}
; 3653 : 	return eType;

	mov	eax, DWORD PTR _eType$[ebp]
$LN5@GetUnitFor:

; 3654 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z ENDP ; CvMilitaryAI::GetUnitForArmy
_TEXT	ENDS
PUBLIC	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ; CvMilitaryAI::GetBestAirSweepTarget
PUBLIC	?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ; CvMilitaryAI::GetNumEnemyAirUnitsInRange
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ; CvMilitaryAI::WillAirUnitRebase
EXTRN	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z:PROC ; CvUnit::canLoadUnit
EXTRN	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canRebaseAt
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?canAirSweep@CvUnit@@QBE_NXZ:PROC		; CvUnit::canAirSweep
EXTRN	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canAirPatrol
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
EXTRN	?getTransportUnit@CvUnit@@QAEPAV1@XZ:PROC	; CvUnit::getTransportUnit
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Odtp
;	COMDAT ?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T235175 = -100						; size = 4
$T235171 = -96						; size = 4
$T235167 = -92						; size = 4
$T235163 = -88						; size = 4
$T235159 = -84						; size = 4
$T235155 = -80						; size = 4
$T235151 = -76						; size = 4
$T235147 = -72						; size = 4
$T235143 = -68						; size = 4
_pTarget$227055 = -52					; size = 4
_pLoopUnitPlot$227045 = -48				; size = 4
_pLoopUnit$227041 = -44					; size = 4
_pLoopUnitPlot$227036 = -40				; size = 4
_pLoopUnit$227032 = -36					; size = 4
_iNumNearbyEnemyAirUnits$227028 = -32			; size = 4
_pCarrier$227023 = -28					; size = 4
_iLoopCity$ = -24					; size = 4
_pUnitPlot$ = -20					; size = 4
_pBestPlot$ = -16					; size = 4
_iLoopUnit$ = -12					; size = 4
_bNeedsToMove$ = -5					; size = 1
_pLoopCity$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z PROC ; CvMilitaryAI::WillAirUnitRebase, COMDAT
; _this$ = ecx

; 3658 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3659 : 	CvPlot* pUnitPlot = pUnit->plot();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$[ebp], eax

; 3660 : 
; 3661 : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 3662 : 
; 3663 : 	// Is this unit in a base in danger?
; 3664 : 	bool bNeedsToMove = false;

	mov	BYTE PTR _bNeedsToMove$[ebp], 0

; 3665 : 	if (pUnitPlot->isCity())

	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@WillAirUni

; 3666 : 	{
; 3667 : 		if (pUnitPlot->getPlotCity()->getDamage() > (pUnitPlot->getPlotCity()->GetMaxHitPoints() / 5))

	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	esi, eax
	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cdq
	mov	ecx, 5
	idiv	ecx
	cmp	esi, eax
	jle	SHORT $LN27@WillAirUni

; 3668 : 		{
; 3669 : 			bNeedsToMove = true;

	mov	BYTE PTR _bNeedsToMove$[ebp], 1
$LN27@WillAirUni:

; 3670 : 		}
; 3671 : 	}
; 3672 : 	else

	jmp	SHORT $LN26@WillAirUni
$LN28@WillAirUni:

; 3673 : 	{
; 3674 : 		CvUnit *pCarrier = pUnit->getTransportUnit();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTransportUnit@CvUnit@@QAEPAV1@XZ	; CvUnit::getTransportUnit
	mov	DWORD PTR _pCarrier$227023[ebp], eax

; 3675 : 		if (pCarrier)

	cmp	DWORD PTR _pCarrier$227023[ebp], 0
	je	SHORT $LN26@WillAirUni

; 3676 : 		{
; 3677 : 			if (pCarrier->getDamage() > (GC.getMAX_HIT_POINTS() / 5))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T235143[ebp], edx
	mov	ecx, DWORD PTR _pCarrier$227023[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, DWORD PTR $T235143[ebp]
	cdq
	mov	esi, 5
	idiv	esi
	cmp	ecx, eax
	jle	SHORT $LN26@WillAirUni

; 3678 : 			{
; 3679 : 				bNeedsToMove = true;

	mov	BYTE PTR _bNeedsToMove$[ebp], 1
$LN26@WillAirUni:

; 3680 : 			}
; 3681 : 		}
; 3682 : 	}
; 3683 : 
; 3684 : 	// Is this a fighter that doesn't have any useful missions nearby
; 3685 : 	if (pUnit->canAirPatrol(NULL) || pUnit->canAirSweep())

	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirPatrol
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN22@WillAirUni
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canAirSweep@CvUnit@@QBE_NXZ		; CvUnit::canAirSweep
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@WillAirUni
$LN22@WillAirUni:

; 3686 : 	{
; 3687 : 		int iNumNearbyEnemyAirUnits = GetNumEnemyAirUnitsInRange(pUnitPlot, pUnit->GetRange(), true /*bCountFighters*/, true /*bCountBombers*/);

	push	1
	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	push	eax
	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ; CvMilitaryAI::GetNumEnemyAirUnitsInRange
	mov	DWORD PTR _iNumNearbyEnemyAirUnits$227028[ebp], eax

; 3688 : 		if (iNumNearbyEnemyAirUnits == 0 && !GetBestAirSweepTarget(pUnit))

	cmp	DWORD PTR _iNumNearbyEnemyAirUnits$227028[ebp], 0
	jne	SHORT $LN23@WillAirUni
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ; CvMilitaryAI::GetBestAirSweepTarget
	test	eax, eax
	jne	SHORT $LN23@WillAirUni

; 3689 : 		{
; 3690 : 			bNeedsToMove = true;

	mov	BYTE PTR _bNeedsToMove$[ebp], 1
$LN23@WillAirUni:

; 3691 : 		}
; 3692 : 	}
; 3693 : 
; 3694 : 	if (!bNeedsToMove)

	movzx	eax, BYTE PTR _bNeedsToMove$[ebp]
	test	eax, eax
	jne	SHORT $LN20@WillAirUni

; 3695 : 	{
; 3696 : 		return false;

	xor	al, al
	jmp	$LN29@WillAirUni
$LN20@WillAirUni:

; 3697 : 	}
; 3698 : 
; 3699 : 	// first look for open carrier slots in carriers within operations
; 3700 : 	int iLoopUnit = 0;

	mov	DWORD PTR _iLoopUnit$[ebp], 0

; 3701 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$227032[ebp], eax
	jmp	SHORT $LN19@WillAirUni
$LN18@WillAirUni:
	push	0
	lea	eax, DWORD PTR _iLoopUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$227032[ebp], eax
$LN19@WillAirUni:
	cmp	DWORD PTR _pLoopUnit$227032[ebp], 0
	je	$LN17@WillAirUni

; 3702 : 	{
; 3703 : 		CvPlot* pLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$227032[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pLoopUnitPlot$227036[ebp], eax

; 3704 : 
; 3705 : 		if(pLoopUnit->getDamage() > (GC.getMAX_HIT_POINTS() / 5))  // this might not be a good place to land

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T235147[ebp], edx
	mov	ecx, DWORD PTR _pLoopUnit$227032[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, DWORD PTR $T235147[ebp]
	cdq
	mov	esi, 5
	idiv	esi
	cmp	ecx, eax
	jle	SHORT $LN16@WillAirUni

; 3706 : 		{
; 3707 : 			continue;

	jmp	SHORT $LN18@WillAirUni
$LN16@WillAirUni:

; 3708 : 		}
; 3709 : 
; 3710 : 		if (pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$227032[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN15@WillAirUni

; 3711 : 		{
; 3712 : 			continue;

	jmp	SHORT $LN18@WillAirUni
$LN15@WillAirUni:

; 3713 : 		}
; 3714 : 
; 3715 : 		if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pLoopUnitPlot->getX(),pLoopUnitPlot->getY()))

	mov	edx, DWORD PTR _pBestPlot$[ebp]
	cmp	edx, DWORD PTR _pUnitPlot$[ebp]
	je	SHORT $LN14@WillAirUni
	mov	eax, DWORD PTR _pLoopUnitPlot$227036[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235151[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnitPlot$227036[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235155[ebp], eax
	mov	ecx, DWORD PTR $T235151[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235155[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnitPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN14@WillAirUni

; 3716 : 		{
; 3717 : 			continue;

	jmp	$LN18@WillAirUni
$LN14@WillAirUni:

; 3718 : 		}
; 3719 : 
; 3720 : 		if(!pUnit->canLoadUnit(*pLoopUnit, *pLoopUnitPlot))

	mov	edx, DWORD PTR _pLoopUnitPlot$227036[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$227032[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z ; CvUnit::canLoadUnit
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@WillAirUni

; 3721 : 		{
; 3722 : 			continue;

	jmp	$LN18@WillAirUni
$LN13@WillAirUni:

; 3723 : 		}
; 3724 : 		
; 3725 : 		// Found somewhere to rebase to
; 3726 : 		return true;

	mov	al, 1
	jmp	$LN29@WillAirUni

; 3727 : 	}

	jmp	$LN18@WillAirUni
$LN17@WillAirUni:

; 3728 : 
; 3729 : 	// then look for open carrier slots in carriers NOT in operations
; 3730 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	edx, DWORD PTR _iLoopUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$227041[ebp], eax
	jmp	SHORT $LN12@WillAirUni
$LN11@WillAirUni:
	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$227041[ebp], eax
$LN12@WillAirUni:
	cmp	DWORD PTR _pLoopUnit$227041[ebp], 0
	je	$LN10@WillAirUni

; 3731 : 	{
; 3732 : 		CvPlot* pLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$227041[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pLoopUnitPlot$227045[ebp], eax

; 3733 : 
; 3734 : 		if(pLoopUnit->getDamage() > (GC.getMAX_HIT_POINTS() / 5))  // this might not be a good place to land

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T235159[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$227041[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, DWORD PTR $T235159[ebp]
	cdq
	mov	esi, 5
	idiv	esi
	cmp	ecx, eax
	jle	SHORT $LN9@WillAirUni

; 3735 : 		{
; 3736 : 			continue;

	jmp	SHORT $LN11@WillAirUni
$LN9@WillAirUni:

; 3737 : 		}
; 3738 : 
; 3739 : 		if (pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$227041[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN8@WillAirUni

; 3740 : 		{
; 3741 : 			continue;

	jmp	SHORT $LN11@WillAirUni
$LN8@WillAirUni:

; 3742 : 		}
; 3743 : 
; 3744 : 		if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pLoopUnitPlot->getX(),pLoopUnitPlot->getY()))

	mov	edx, DWORD PTR _pBestPlot$[ebp]
	cmp	edx, DWORD PTR _pUnitPlot$[ebp]
	je	SHORT $LN7@WillAirUni
	mov	eax, DWORD PTR _pLoopUnitPlot$227045[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235163[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnitPlot$227045[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235167[ebp], eax
	mov	ecx, DWORD PTR $T235163[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235167[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnitPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@WillAirUni

; 3745 : 		{
; 3746 : 			continue;

	jmp	$LN11@WillAirUni
$LN7@WillAirUni:

; 3747 : 		}
; 3748 : 
; 3749 : 		if(!pUnit->canLoadUnit(*pLoopUnit, *pLoopUnitPlot))

	mov	edx, DWORD PTR _pLoopUnitPlot$227045[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$227041[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z ; CvUnit::canLoadUnit
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@WillAirUni

; 3750 : 		{
; 3751 : 			continue;

	jmp	$LN11@WillAirUni
$LN6@WillAirUni:

; 3752 : 		}
; 3753 : 
; 3754 : 		// Found somewhere to rebase to
; 3755 : 		return true;

	mov	al, 1
	jmp	$LN29@WillAirUni

; 3756 : 	}

	jmp	$LN11@WillAirUni
$LN10@WillAirUni:

; 3757 : 
; 3758 : 	CvCity* pLoopCity;
; 3759 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 3760 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN5@WillAirUni
$LN4@WillAirUni:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN5@WillAirUni:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN3@WillAirUni

; 3761 : 	{
; 3762 : 		CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pTarget$227055[ebp], eax

; 3763 : 
; 3764 : #ifdef AUI_WARNING_FIXES
; 3765 : 		if (!pTarget)
; 3766 : 			continue;
; 3767 : #endif
; 3768 : 
; 3769 : 		if(pLoopCity->getDamage() > (pLoopCity->GetMaxHitPoints() / 5))

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cdq
	mov	ecx, 5
	idiv	ecx
	cmp	esi, eax
	jle	SHORT $LN2@WillAirUni

; 3770 : 		{
; 3771 : 			continue;

	jmp	SHORT $LN4@WillAirUni
$LN2@WillAirUni:

; 3772 : 		}
; 3773 : 
; 3774 : 		if (pTarget != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pTarget->getX(),pTarget->getY()))

	mov	edx, DWORD PTR _pTarget$227055[ebp]
	cmp	edx, DWORD PTR _pUnitPlot$[ebp]
	je	SHORT $LN1@WillAirUni
	mov	eax, DWORD PTR _pTarget$227055[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235171[ebp], ecx
	mov	edx, DWORD PTR _pTarget$227055[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235175[ebp], eax
	mov	ecx, DWORD PTR $T235171[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235175[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnitPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@WillAirUni

; 3775 : 		{
; 3776 : 			continue;

	jmp	SHORT $LN4@WillAirUni
$LN1@WillAirUni:

; 3777 : 		}
; 3778 : 
; 3779 : 		// Found somewhere to rebase to
; 3780 : 		return true;

	mov	al, 1
	jmp	SHORT $LN29@WillAirUni

; 3781 : 	}

	jmp	$LN4@WillAirUni
$LN3@WillAirUni:

; 3782 : 
; 3783 : 	return false;

	xor	al, al
$LN29@WillAirUni:

; 3784 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ENDP ; CvMilitaryAI::WillAirUnitRebase
_TEXT	ENDS
EXTRN	?canAirDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canAirDefend
EXTRN	?IsAirSweepCapable@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAirSweepCapable
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
; Function compile flags: /Odtp
;	COMDAT ?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z
_TEXT	SEGMENT
_this$ = -144						; size = 4
$T235252 = -60						; size = 4
$T235248 = -56						; size = 4
$T235244 = -52						; size = 4
$T235235 = -48						; size = 4
$T235226 = -44						; size = 4
$T235217 = -40						; size = 4
$T235216 = -36						; size = 4
$T235207 = -32						; size = 4
$T235198 = -28						; size = 4
$T235189 = -21						; size = 1
_pLoopUnit$227075 = -20					; size = 4
_iLoopUnit$227074 = -16					; size = 4
_kPlayer$227070 = -12					; size = 4
_iI$227066 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
_pCenterPlot$ = 8					; size = 4
___formal$ = 12						; size = 4
_bCountFighters$ = 16					; size = 1
_bCountBombers$ = 20					; size = 1
?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z PROC ; CvMilitaryAI::GetNumEnemyAirUnitsInRange, COMDAT
; _this$ = ecx

; 3788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	DWORD PTR _this$[ebp], ecx

; 3789 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3790 : 
; 3791 : 	// Loop through all the players
; 3792 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$227066[ebp], 0
	jmp	SHORT $LN15@GetNumEnem
$LN14@GetNumEnem:
	mov	eax, DWORD PTR _iI$227066[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$227066[ebp], eax
$LN15@GetNumEnem:
	cmp	DWORD PTR _iI$227066[ebp], 64		; 00000040H
	jge	$LN13@GetNumEnem

; 3793 : 	{
; 3794 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$227066[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$227070[ebp], ecx

; 3795 : 		if(kPlayer.isAlive() && kPlayer.GetID() != m_pPlayer->GetID())

	mov	edx, DWORD PTR _kPlayer$227070[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T235189[ebp], al
	movzx	ecx, BYTE PTR $T235189[ebp]
	test	ecx, ecx
	je	$LN12@GetNumEnem
	mov	edx, DWORD PTR _kPlayer$227070[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235198[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235207[ebp], eax
	mov	ecx, DWORD PTR $T235198[ebp]
	cmp	ecx, DWORD PTR $T235207[ebp]
	je	$LN12@GetNumEnem

; 3796 : 		{
; 3797 : 			if (atWar(kPlayer.getTeam(), m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T235216[ebp], eax
	mov	ecx, DWORD PTR $T235216[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235217[ebp], eax
	mov	eax, DWORD PTR _kPlayer$227070[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235226[ebp], eax
	mov	edx, DWORD PTR $T235217[ebp]
	push	edx
	mov	eax, DWORD PTR $T235226[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@GetNumEnem

; 3798 : 			{
; 3799 : 				// Loop through their units looking for bombers (this will allow us to find bombers on carriers also
; 3800 : 				int iLoopUnit = 0;

	mov	DWORD PTR _iLoopUnit$227074[ebp], 0

; 3801 : 				for(CvUnit* pLoopUnit = kPlayer.firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoopUnit))

	push	0
	lea	edx, DWORD PTR _iLoopUnit$227074[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$227070[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$227075[ebp], eax
	jmp	SHORT $LN10@GetNumEnem
$LN9@GetNumEnem:
	push	0
	lea	eax, DWORD PTR _iLoopUnit$227074[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$227070[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$227075[ebp], eax
$LN10@GetNumEnem:
	cmp	DWORD PTR _pLoopUnit$227075[ebp], 0
	je	$LN12@GetNumEnem

; 3802 : 				{
; 3803 : 					if (pLoopUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _pLoopUnit$227075[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	$LN7@GetNumEnem

; 3804 : 					{
; 3805 : 						if ( plotDistance(pCenterPlot->getX(), pCenterPlot->getY(), pLoopUnit->getX(), pLoopUnit->getY()) <= 10 )

	mov	ecx, DWORD PTR _pLoopUnit$227075[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T235235[ebp], edx
	mov	eax, DWORD PTR _pLoopUnit$227075[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T235244[ebp], ecx
	mov	edx, DWORD PTR _pCenterPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T235248[ebp], eax
	mov	ecx, DWORD PTR _pCenterPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T235252[ebp], edx
	mov	eax, DWORD PTR $T235235[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235244[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235248[ebp]
	push	edx
	mov	eax, DWORD PTR $T235252[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 10					; 0000000aH
	jg	SHORT $LN7@GetNumEnem

; 3806 : 						{
; 3807 : 							// Let's not factor in revealed or visible - As a human I can remember past attacks and intuit whether a bomber could be in range of the city, AIs don't have great intuition...
; 3808 : 							if (pLoopUnit->IsAirSweepCapable() || pLoopUnit->canAirDefend())

	mov	ecx, DWORD PTR _pLoopUnit$227075[ebp]
	call	?IsAirSweepCapable@CvUnit@@QBE_NXZ	; CvUnit::IsAirSweepCapable
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@GetNumEnem
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$227075[ebp]
	call	?canAirDefend@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirDefend
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@GetNumEnem
$LN4@GetNumEnem:

; 3809 : 							{
; 3810 : 								if (bCountFighters) iRtnValue++;

	movzx	eax, BYTE PTR _bCountFighters$[ebp]
	test	eax, eax
	je	SHORT $LN3@GetNumEnem
	mov	ecx, DWORD PTR _iRtnValue$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRtnValue$[ebp], ecx
$LN3@GetNumEnem:

; 3811 : 							}
; 3812 : 							else

	jmp	SHORT $LN7@GetNumEnem
$LN5@GetNumEnem:

; 3813 : 							{
; 3814 : 								if (bCountBombers) iRtnValue++;

	movzx	edx, BYTE PTR _bCountBombers$[ebp]
	test	edx, edx
	je	SHORT $LN7@GetNumEnem
	mov	eax, DWORD PTR _iRtnValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN7@GetNumEnem:

; 3815 : 							}
; 3816 : 						}
; 3817 : 					}
; 3818 : 				}

	jmp	$LN9@GetNumEnem
$LN12@GetNumEnem:

; 3819 : 
; 3820 : 				// Loop through each of their cities
; 3821 : 				//int iLoop;
; 3822 : 				//CvCity* pLoopCity;
; 3823 : 				//for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
; 3824 : 				//{
; 3825 : 				//	CvPlot *pCityPlot = pLoopCity->plot();
; 3826 : 				//	if (pCityPlot->isRevealed(m_pPlayer->getTeam()) && plotDistance(pCenterPlot->getX(), pCenterPlot->getY(), pLoopCity->getX(), pLoopCity->getY()) <= iRange)
; 3827 : 				//	{
; 3828 : 				//		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
; 3829 : 				//		{
; 3830 : 				//			CvUnit *pUnit = pCityPlot->getUnitByIndex(iUnitLoop);
; 3831 : 				//			{
; 3832 : 				//				if (pUnit->getDomainType() == DOMAIN_AIR)
; 3833 : 				//				{
; 3834 : 				//					if (pUnit->IsAirSweepCapable() || pUnit->canAirDefend())
; 3835 : 				//					{
; 3836 : 				//						if (bCountFighters) iRtnValue++;
; 3837 : 				//					}
; 3838 : 				//					else
; 3839 : 				//					{
; 3840 : 				//						if (bCountBombers) iRtnValue++;
; 3841 : 				//					}
; 3842 : 				//				}
; 3843 : 				//			}
; 3844 : 				//		}
; 3845 : 				//	}
; 3846 : 				//}
; 3847 : 			}
; 3848 : 		}
; 3849 : 	}

	jmp	$LN14@GetNumEnem
$LN13@GetNumEnem:

; 3850 : 
; 3851 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3852 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ENDP ; CvMilitaryAI::GetNumEnemyAirUnitsInRange
_TEXT	ENDS
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?canAirSweepAt@CvUnit@@QBE_NHH@Z:PROC		; CvUnit::canAirSweepAt
; Function compile flags: /Odtp
;	COMDAT ?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -176						; size = 4
$T235521 = -172						; size = 4
$T235517 = -168						; size = 4
$T235444 = -92						; size = 4
$T235435 = -88						; size = 4
$T235426 = -84						; size = 4
$T235417 = -80						; size = 4
$T235408 = -73						; size = 1
$T235398 = -72						; size = 4
$T235397 = -68						; size = 4
$T235388 = -64						; size = 4
$T235379 = -60						; size = 4
$T235378 = -56						; size = 4
$T235369 = -52						; size = 4
$T235360 = -48						; size = 4
$T235351 = -41						; size = 1
_pUnit$227113 = -40					; size = 4
_iUnitLoop$227109 = -36					; size = 4
_iCountFighters$227108 = -32				; size = 4
_pCityPlot$227105 = -28					; size = 4
_pLoopCity$227101 = -24					; size = 4
_iLoop$227100 = -20					; size = 4
_kPlayer$227096 = -16					; size = 4
_iI$227092 = -12					; size = 4
_pBestTarget$ = -8					; size = 4
_iBestCount$ = -4					; size = 4
_pFighter$ = 8						; size = 4
?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvMilitaryAI::GetBestAirSweepTarget, COMDAT
; _this$ = ecx

; 3856 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3857 : 	CvPlot *pBestTarget = NULL;

	mov	DWORD PTR _pBestTarget$[ebp], 0

; 3858 : 	int iBestCount = 0;

	mov	DWORD PTR _iBestCount$[ebp], 0

; 3859 : 
; 3860 : 	// Loop through all the players
; 3861 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$227092[ebp], 0
	jmp	SHORT $LN17@GetBestAir
$LN16@GetBestAir:
	mov	eax, DWORD PTR _iI$227092[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$227092[ebp], eax
$LN17@GetBestAir:
	cmp	DWORD PTR _iI$227092[ebp], 64		; 00000040H
	jge	$LN15@GetBestAir

; 3862 : 	{
; 3863 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$227092[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$227096[ebp], ecx

; 3864 : 		if(kPlayer.isAlive() && kPlayer.GetID() != m_pPlayer->GetID())

	mov	edx, DWORD PTR _kPlayer$227096[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T235351[ebp], al
	movzx	ecx, BYTE PTR $T235351[ebp]
	test	ecx, ecx
	je	$LN14@GetBestAir
	mov	edx, DWORD PTR _kPlayer$227096[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235360[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235369[ebp], eax
	mov	ecx, DWORD PTR $T235360[ebp]
	cmp	ecx, DWORD PTR $T235369[ebp]
	je	$LN14@GetBestAir

; 3865 : 		{
; 3866 : 			if (atWar(kPlayer.getTeam(), m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T235378[ebp], eax
	mov	ecx, DWORD PTR $T235378[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235379[ebp], eax
	mov	eax, DWORD PTR _kPlayer$227096[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235388[ebp], eax
	mov	edx, DWORD PTR $T235379[ebp]
	push	edx
	mov	eax, DWORD PTR $T235388[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$LN14@GetBestAir

; 3867 : 			{
; 3868 : 				// Loop through each of their cities
; 3869 : 				int iLoop;
; 3870 : 				CvCity* pLoopCity;
; 3871 : 				for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$227100[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$227096[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227101[ebp], eax
	jmp	SHORT $LN12@GetBestAir
$LN11@GetBestAir:
	push	0
	lea	eax, DWORD PTR _iLoop$227100[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$227096[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227101[ebp], eax
$LN12@GetBestAir:
	cmp	DWORD PTR _pLoopCity$227101[ebp], 0
	je	$LN14@GetBestAir

; 3872 : 				{
; 3873 : 					CvPlot *pCityPlot = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$227101[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pCityPlot$227105[ebp], eax

; 3874 : 					if (pCityPlot->isVisible(m_pPlayer->getTeam()) && plotDistance(pFighter->getX(), pFighter->getY(), pLoopCity->getX(), pLoopCity->getY()) <= pFighter->GetRange())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T235397[ebp], edx
	mov	eax, DWORD PTR $T235397[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235398[ebp], eax
	cmp	DWORD PTR $T235398[ebp], -1
	jne	SHORT $LN49@GetBestAir
	mov	BYTE PTR $T235408[ebp], 0
	jmp	SHORT $LN47@GetBestAir
$LN49@GetBestAir:
	mov	edx, DWORD PTR _pCityPlot$227105[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR $T235398[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T235408[ebp], al
$LN47@GetBestAir:
	movzx	ecx, BYTE PTR $T235408[ebp]
	test	ecx, ecx
	je	$LN9@GetBestAir
	mov	edx, DWORD PTR _pLoopCity$227101[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T235417[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$227101[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T235426[ebp], edx
	mov	eax, DWORD PTR _pFighter$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T235435[ebp], ecx
	mov	edx, DWORD PTR _pFighter$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T235444[ebp], eax
	mov	ecx, DWORD PTR $T235417[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235426[ebp]
	push	edx
	mov	eax, DWORD PTR $T235435[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235444[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	esi, eax
	mov	ecx, DWORD PTR _pFighter$[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	esi, eax
	jg	$LN9@GetBestAir

; 3875 : 					{
; 3876 : 						if (pFighter->canAirSweepAt(pCityPlot->getX(), pCityPlot->getY()))

	mov	edx, DWORD PTR _pCityPlot$227105[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T235517[ebp], eax
	mov	ecx, DWORD PTR _pCityPlot$227105[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T235521[ebp], edx
	mov	eax, DWORD PTR $T235517[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235521[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFighter$[ebp]
	call	?canAirSweepAt@CvUnit@@QBE_NHH@Z	; CvUnit::canAirSweepAt
	movzx	edx, al
	test	edx, edx
	je	$LN9@GetBestAir

; 3877 : 						{
; 3878 : 							int iCountFighters = 0;

	mov	DWORD PTR _iCountFighters$227108[ebp], 0

; 3879 : 
; 3880 : #ifdef AUI_WARNING_FIXES
; 3881 : 							for (uint iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
; 3882 : #else
; 3883 : 							for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$227109[ebp], 0
	jmp	SHORT $LN7@GetBestAir
$LN6@GetBestAir:
	mov	eax, DWORD PTR _iUnitLoop$227109[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnitLoop$227109[ebp], eax
$LN7@GetBestAir:
	mov	ecx, DWORD PTR _pCityPlot$227105[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$227109[ebp], eax
	jge	SHORT $LN5@GetBestAir

; 3884 : #endif
; 3885 : 							{
; 3886 : 								CvUnit *pUnit = pCityPlot->getUnitByIndex(iUnitLoop);

	mov	ecx, DWORD PTR _iUnitLoop$227109[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityPlot$227105[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pUnit$227113[ebp], eax

; 3887 : 								{
; 3888 : 									if (pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _pUnit$227113[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN4@GetBestAir

; 3889 : 									{
; 3890 : 										if (pUnit->IsAirSweepCapable() || pUnit->canAirDefend())

	mov	ecx, DWORD PTR _pUnit$227113[ebp]
	call	?IsAirSweepCapable@CvUnit@@QBE_NXZ	; CvUnit::IsAirSweepCapable
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@GetBestAir
	push	0
	mov	ecx, DWORD PTR _pUnit$227113[ebp]
	call	?canAirDefend@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirDefend
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetBestAir
$LN2@GetBestAir:

; 3891 : 										{
; 3892 : 											iCountFighters++;

	mov	ecx, DWORD PTR _iCountFighters$227108[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCountFighters$227108[ebp], ecx
$LN4@GetBestAir:

; 3893 : 										}
; 3894 : 									}
; 3895 : 								}
; 3896 : 							}

	jmp	SHORT $LN6@GetBestAir
$LN5@GetBestAir:

; 3897 : 
; 3898 : 							if (iCountFighters > iBestCount)

	mov	edx, DWORD PTR _iCountFighters$227108[ebp]
	cmp	edx, DWORD PTR _iBestCount$[ebp]
	jle	SHORT $LN9@GetBestAir

; 3899 : 							{
; 3900 : 								iBestCount = iCountFighters;

	mov	eax, DWORD PTR _iCountFighters$227108[ebp]
	mov	DWORD PTR _iBestCount$[ebp], eax

; 3901 : 								pBestTarget = pCityPlot;

	mov	ecx, DWORD PTR _pCityPlot$227105[ebp]
	mov	DWORD PTR _pBestTarget$[ebp], ecx
$LN9@GetBestAir:

; 3902 : 							}
; 3903 : 						}
; 3904 : 					}
; 3905 : 				}

	jmp	$LN11@GetBestAir
$LN14@GetBestAir:

; 3906 : 			}
; 3907 : 		}
; 3908 : 	}

	jmp	$LN16@GetBestAir
$LN15@GetBestAir:

; 3909 : 
; 3910 : 	return pBestTarget;

	mov	eax, DWORD PTR _pBestTarget$[ebp]

; 3911 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvMilitaryAI::GetBestAirSweepTarget
_TEXT	ENDS
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
; Function compile flags: /Odtp
;	COMDAT ?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_iThisPower$227131 = -20				; size = 4
_eUnit$227127 = -16					; size = 4
_pkUnitEntry$227129 = -12				; size = 4
_iI$227123 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
_eDomain$ = 8						; size = 4
?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z PROC ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit, COMDAT
; _this$ = ecx

; 3915 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3916 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3917 : #ifdef AUI_WARNING_FIXES
; 3918 : 	for (uint iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 3919 : #else
; 3920 : 	for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)

	mov	DWORD PTR _iI$227123[ebp], 0
	jmp	SHORT $LN6@GetPowerOf
$LN5@GetPowerOf:
	mov	eax, DWORD PTR _iI$227123[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$227123[ebp], eax
$LN6@GetPowerOf:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	cmp	DWORD PTR _iI$227123[ebp], eax
	jge	SHORT $LN4@GetPowerOf

; 3921 : #endif
; 3922 : 	{
; 3923 : 		const UnitTypes eUnit = static_cast<UnitTypes>(iI);

	mov	ecx, DWORD PTR _iI$227123[ebp]
	mov	DWORD PTR _eUnit$227127[ebp], ecx

; 3924 : 		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	mov	edx, DWORD PTR _eUnit$227127[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$227129[ebp], eax

; 3925 : 		if(pkUnitEntry != NULL && pkUnitEntry->GetDomainType() == eDomain)

	cmp	DWORD PTR _pkUnitEntry$227129[ebp], 0
	je	SHORT $LN3@GetPowerOf
	mov	ecx, DWORD PTR _pkUnitEntry$227129[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	cmp	eax, DWORD PTR _eDomain$[ebp]
	jne	SHORT $LN3@GetPowerOf

; 3926 : 		{
; 3927 : 			int iThisPower = pkUnitEntry->GetPower();		// Test the power first, it is much less costly than testing canTrain

	mov	ecx, DWORD PTR _pkUnitEntry$227129[ebp]
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	mov	DWORD PTR _iThisPower$227131[ebp], eax

; 3928 : 			if(iThisPower > iRtnValue)

	mov	eax, DWORD PTR _iThisPower$227131[ebp]
	cmp	eax, DWORD PTR _iRtnValue$[ebp]
	jle	SHORT $LN3@GetPowerOf

; 3929 : 			{
; 3930 : 				if(m_pPlayer->canTrain(eUnit, false /*bContinue*/, false /*bTestVisible*/, true /*bIgnoreCost*/))

	push	0
	push	0
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _eUnit$227127[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvPlayer::canTrain
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetPowerOf

; 3931 : 				{
; 3932 : 					iRtnValue = iThisPower;

	mov	ecx, DWORD PTR _iThisPower$227131[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], ecx
$LN3@GetPowerOf:

; 3933 : 				}
; 3934 : 			}
; 3935 : 		}
; 3936 : 	}

	jmp	SHORT $LN5@GetPowerOf
$LN4@GetPowerOf:

; 3937 : 
; 3938 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3939 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ENDP ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
_TEXT	ENDS
PUBLIC	??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@		; `string'
PUBLIC	??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@	; `string'
PUBLIC	??_C@_0L@EJOHMCKE@TechAILog_?$AA@		; `string'
PUBLIC	??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z:PROC ; CvGlobals::getMilitaryAIStrategyInfo
;	COMDAT ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@ DB 'TechAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
CONST	SEGMENT
??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@ DB 'CityStrategyAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@
CONST	SEGMENT
??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@ DB 'CityStrategyAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
CONST	SEGMENT
??_C@_0L@EJOHMCKE@TechAILog_?$AA@ DB 'TechAILog_', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@ DB '%s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@
CONST	SEGMENT
??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@ DB 'FlavorAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@
CONST	SEGMENT
??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@ DB 'FlavorAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$16
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
tv351 = -668						; size = 4
tv336 = -664						; size = 4
tv319 = -660						; size = 4
tv627 = -656						; size = 4
tv389 = -652						; size = 4
tv626 = -648						; size = 4
tv387 = -644						; size = 4
tv625 = -640						; size = 4
tv385 = -636						; size = 4
tv624 = -632						; size = 4
tv74 = -628						; size = 4
tv245 = -624						; size = 4
tv397 = -620						; size = 4
tv378 = -616						; size = 4
tv408 = -612						; size = 4
tv419 = -608						; size = 4
tv193 = -604						; size = 4
tv374 = -600						; size = 4
tv430 = -596						; size = 4
tv151 = -592						; size = 4
tv441 = -588						; size = 4
tv370 = -584						; size = 4
tv548 = -580						; size = 4
_this$ = -576						; size = 4
$T235658 = -572						; size = 4
$T235654 = -568						; size = 4
$T235646 = -564						; size = 4
$T235642 = -560						; size = 4
$T235638 = -556						; size = 4
$T235630 = -552						; size = 4
$T235622 = -548						; size = 4
$T235618 = -544						; size = 4
$T235614 = -540						; size = 4
$T235610 = -536						; size = 4
$T235606 = -532						; size = 4
$T235599 = -528						; size = 4
$T235595 = -524						; size = 4
$T235586 = -520						; size = 4
$T235582 = -516						; size = 4
$T235539 = -512						; size = 28
$T235538 = -484						; size = 28
$T235537 = -456						; size = 28
$T235536 = -428						; size = 28
$T235535 = -400						; size = 28
$T235534 = -372						; size = 28
$T235533 = -344						; size = 28
$T235532 = -316						; size = 28
$T235529 = -288						; size = 28
$T235528 = -260						; size = 28
$T235527 = -232						; size = 28
_cityName$227161 = -204					; size = 28
_pLoopCity$227162 = -176				; size = 4
_iLoop$227163 = -172					; size = 4
_strOutBuf$227140 = -168				; size = 28
_playerName$227143 = -140				; size = 28
_szType$227154 = -112					; size = 4
_strLogName$227144 = -108				; size = 28
_pLog$227145 = -80					; size = 4
_strTemp$227142 = -76					; size = 28
_pEntry$227153 = -48					; size = 4
_strBaseString$227141 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z PROC ; CvMilitaryAI::LogStrategy, COMDAT
; _this$ = ecx

; 3943 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 656				; 00000290H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3944 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN9@LogStrateg
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@LogStrateg

; 3945 : 	{
; 3946 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3947 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227141[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3948 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227142[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3949 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227143[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3950 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3951 : 		FILogFile* pLog;
; 3952 : 
; 3953 : 		// Open the right file - strategies are logged to the flavor log, not the military one
; 3954 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T235582[ebp], eax
	cmp	DWORD PTR $T235582[ebp], 0
	je	SHORT $LN46@LogStrateg
	mov	edx, DWORD PTR $T235582[ebp]
	push	edx
	lea	ecx, DWORD PTR _playerName$227143[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN47@LogStrateg
$LN46@LogStrateg:
	lea	ecx, DWORD PTR _playerName$227143[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN47@LogStrateg:

; 3955 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogStrateg

; 3956 : 		{
; 3957 : 			strLogName = "FlavorAILog_" + playerName + ".csv";

	lea	ecx, DWORD PTR _playerName$227143[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@
	lea	edx, DWORD PTR $T235527[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv548[ebp], eax
	mov	eax, DWORD PTR tv548[ebp]
	mov	DWORD PTR tv370[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv370[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235528[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv441[ebp], eax
	mov	eax, DWORD PTR tv441[ebp]
	mov	DWORD PTR $T235586[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T235586[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235528[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235527[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3958 : 		}
; 3959 : 		else

	jmp	SHORT $LN6@LogStrateg
$LN7@LogStrateg:

; 3960 : 		{
; 3961 : 			strLogName = "FlavorAILog.csv";

	mov	ecx, OFFSET ??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN52@LogStrateg
	push	OFFSET ??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN6@LogStrateg
$LN52@LogStrateg:
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN6@LogStrateg:

; 3962 : 		}
; 3963 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv151[ebp], eax
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235595[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T235595[ebp]
	push	edx
	mov	eax, DWORD PTR tv151[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv151[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227145[ebp], eax

; 3964 : 
; 3965 : 		// Get the leading info for this line
; 3966 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235599[ebp], ecx
	mov	ecx, DWORD PTR $T235599[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$227141[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3967 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$227143[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235529[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv430[ebp], eax
	mov	edx, DWORD PTR tv430[ebp]
	mov	DWORD PTR tv374[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR tv374[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227141[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235529[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3968 : 
; 3969 : 		// Strategy Info
; 3970 : 		CvMilitaryAIStrategyXMLEntry* pEntry = GC.getMilitaryAIStrategyInfo(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z ; CvGlobals::getMilitaryAIStrategyInfo
	mov	DWORD PTR _pEntry$227153[ebp], eax

; 3971 : 		const char* szType = (pEntry != NULL)? pEntry->GetType() : NULL;

	cmp	DWORD PTR _pEntry$227153[ebp], 0
	je	SHORT $LN11@LogStrateg
	mov	ecx, DWORD PTR _pEntry$227153[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN12@LogStrateg
$LN11@LogStrateg:
	mov	DWORD PTR tv193[ebp], 0
$LN12@LogStrateg:
	mov	edx, DWORD PTR tv193[ebp]
	mov	DWORD PTR _szType$227154[ebp], edx

; 3972 : 
; 3973 : 		strTemp.Format("%s, %d", szType, bValue);

	movzx	eax, BYTE PTR _bValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szType$227154[ebp]
	push	ecx
	push	OFFSET ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	lea	edx, DWORD PTR _strTemp$227142[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3974 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$227142[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227141[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235532[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv419[ebp], eax
	mov	eax, DWORD PTR tv419[ebp]
	mov	DWORD PTR $T235606[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T235606[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235532[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3975 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235610[ebp], eax
	mov	ecx, DWORD PTR $T235610[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$227145[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$227145[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 3976 : 
; 3977 : 		// Also - write to Other Logs, so that we know what the player is doing in there as well
; 3978 : 
; 3979 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	$LN5@LogStrateg

; 3980 : 		{
; 3981 : 			strLogName = "TechAILog_" + playerName + ".csv";

	lea	ecx, DWORD PTR _playerName$227143[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
	lea	edx, DWORD PTR $T235533[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv408[ebp], eax
	mov	eax, DWORD PTR tv408[ebp]
	mov	DWORD PTR tv378[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv378[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235534[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv397[ebp], eax
	mov	eax, DWORD PTR tv397[ebp]
	mov	DWORD PTR $T235614[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T235614[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T235534[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235533[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3982 : 			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv245[ebp], eax
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235618[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T235618[ebp]
	push	ecx
	mov	edx, DWORD PTR tv245[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv245[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$227145[ebp], eax

; 3983 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235622[ebp], eax
	mov	eax, DWORD PTR $T235622[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$227145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$227145[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 3984 : 
; 3985 : 			CvString cityName;

	lea	ecx, DWORD PTR _cityName$227161[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 3986 : 
; 3987 : 			CvCity* pLoopCity;
; 3988 : 			int iLoop;
; 3989 : 
; 3990 : 			for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$227163[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227162[ebp], eax
	jmp	SHORT $LN4@LogStrateg
$LN3@LogStrateg:
	push	0
	lea	eax, DWORD PTR _iLoop$227163[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227162[ebp], eax
$LN4@LogStrateg:
	cmp	DWORD PTR _pLoopCity$227162[ebp], 0
	je	$LN2@LogStrateg

; 3991 : 			{
; 3992 : 				cityName = pLoopCity->getName();

	lea	ecx, DWORD PTR $T235535[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$227162[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T235630[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	eax, DWORD PTR $T235630[ebp]
	push	eax
	lea	ecx, DWORD PTR _cityName$227161[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T235535[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3993 : 				strLogName= "CityStrategyAILog_" + playerName + "_" + cityName + ".csv";

	lea	ecx, DWORD PTR _playerName$227143[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@
	lea	edx, DWORD PTR $T235536[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv624[ebp], eax
	mov	eax, DWORD PTR tv624[ebp]
	mov	DWORD PTR tv385[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	push	OFFSET ??_C@_01IDAFKMJL@_?$AA@
	mov	ecx, DWORD PTR tv385[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235537[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv625[ebp], eax
	mov	eax, DWORD PTR tv625[ebp]
	mov	DWORD PTR tv387[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR _cityName$227161[ebp]
	push	ecx
	mov	edx, DWORD PTR tv387[ebp]
	push	edx
	lea	eax, DWORD PTR $T235538[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv626[ebp], eax
	mov	ecx, DWORD PTR tv626[ebp]
	mov	DWORD PTR tv389[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv389[ebp]
	push	edx
	lea	eax, DWORD PTR $T235539[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv627[ebp], eax
	mov	ecx, DWORD PTR tv627[ebp]
	mov	DWORD PTR $T235638[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR $T235638[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	lea	ecx, DWORD PTR $T235539[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR $T235538[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	lea	ecx, DWORD PTR $T235537[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T235536[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3994 : 				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv319[ebp], eax
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235642[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T235642[ebp]
	push	edx
	mov	eax, DWORD PTR tv319[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv319[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227145[ebp], eax

; 3995 : 				pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235646[ebp], eax
	mov	ecx, DWORD PTR $T235646[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$227145[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$227145[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 3996 : 			}

	jmp	$LN3@LogStrateg
$LN2@LogStrateg:

; 3997 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _cityName$227161[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3998 : 		else

	jmp	$LN1@LogStrateg
$LN5@LogStrateg:

; 3999 : 		{
; 4000 : 			pLog = LOGFILEMGR.GetLog("CityStrategyAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv336[ebp], eax
	push	0
	push	1
	push	OFFSET ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
	mov	eax, DWORD PTR tv336[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv336[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227145[ebp], eax

; 4001 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235654[ebp], eax
	mov	ecx, DWORD PTR $T235654[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$227145[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$227145[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 4002 : 			pLog = LOGFILEMGR.GetLog("TechAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv351[ebp], eax
	push	0
	push	1
	push	OFFSET ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
	mov	eax, DWORD PTR tv351[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv351[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227145[ebp], eax

; 4003 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235658[ebp], eax
	mov	ecx, DWORD PTR $T235658[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$227145[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$227145[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
$LN1@LogStrateg:

; 4004 : 		}
; 4005 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$227143[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227142[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$227141[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@LogStrateg:

; 4006 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227140[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227141[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strTemp$227142[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$3:
	lea	ecx, DWORD PTR _playerName$227143[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$4:
	lea	ecx, DWORD PTR _strLogName$227144[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T235527[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$6:
	lea	ecx, DWORD PTR $T235528[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T235529[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T235532[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$9:
	lea	ecx, DWORD PTR $T235533[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$10:
	lea	ecx, DWORD PTR $T235534[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$11:
	lea	ecx, DWORD PTR _cityName$227161[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T235535[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T235536[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T235537[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T235538[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$16:
	lea	ecx, DWORD PTR $T235539[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-660]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ENDP ; CvMilitaryAI::LogStrategy
PUBLIC	??_C@_04KCMJEPHB@?0?5?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BN@BFHPOGHK@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$AA@ ; `string'
PUBLIC	??_C@_08JDDGIPCE@?$CFd?0?5?$CFd?0?5?$AA@	; `string'
PUBLIC	??_C@_0LI@FLPHCCAD@Turn?0?5Player?0?5Cities?0?5Settlers?0?5@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_04KCMJEPHB@?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_04KCMJEPHB@?0?5?$CFd?$AA@ DB ', %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BFHPOGHK@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$AA@
CONST	SEGMENT
??_C@_0BN@BFHPOGHK@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$AA@ DB '%'
	DB	'd, %d, %d, %d, %d, %d, %d, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JDDGIPCE@?$CFd?0?5?$CFd?0?5?$AA@
CONST	SEGMENT
??_C@_08JDDGIPCE@?$CFd?0?5?$CFd?0?5?$AA@ DB '%d, %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LI@FLPHCCAD@Turn?0?5Player?0?5Cities?0?5Settlers?0?5@
CONST	SEGMENT
??_C@_0LI@FLPHCCAD@Turn?0?5Player?0?5Cities?0?5Settlers?0?5@ DB 'Turn, Pl'
	DB	'ayer, Cities, Settlers, Civ Threat, Barb Threat, Land Units, '
	DB	'Land In Armies, Rec Land Size, Land Reserve, Naval Units, Nav'
	DB	'al In Armies, Rec Naval Size, Most Threatened, Danger', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
tv324 = -348						; size = 4
tv335 = -344						; size = 4
tv303 = -340						; size = 4
tv346 = -336						; size = 4
tv357 = -332						; size = 4
tv95 = -328						; size = 4
_this$ = -324						; size = 4
$T235772 = -320						; size = 4
$T235764 = -316						; size = 4
$T235760 = -312						; size = 4
$T235756 = -308						; size = 4
$T235752 = -304						; size = 4
$T235748 = -300						; size = 4
$T235739 = -296						; size = 4
$T235731 = -292						; size = 4
$T235730 = -288						; size = 4
$T235726 = -284						; size = 4
$T235691 = -280						; size = 28
$T235690 = -252						; size = 28
$T235689 = -224						; size = 28
$T235688 = -196						; size = 28
_strOutBuf$227181 = -168				; size = 28
_playerName$227184 = -140				; size = 28
_cityName$227186 = -112					; size = 28
_iNavalSize$227194 = -84				; size = 4
_pCity$227185 = -80					; size = 4
_pLog$227187 = -76					; size = 4
_strTemp$227183 = -72					; size = 28
_strBaseString$227182 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::LogMilitaryStatus, COMDAT
; _this$ = ecx

; 4010 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4011 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN4@LogMilitar
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@LogMilitar

; 4012 : 	{
; 4013 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4014 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227182[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4015 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4016 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227184[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4017 : 		CvCity* pCity;
; 4018 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$227186[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4019 : 		FILogFile* pLog;
; 4020 : 
; 4021 : 		// Open the right file
; 4022 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T235726[ebp], eax
	cmp	DWORD PTR $T235726[ebp], 0
	je	SHORT $LN31@LogMilitar
	mov	edx, DWORD PTR $T235726[ebp]
	push	edx
	lea	ecx, DWORD PTR _playerName$227184[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN32@LogMilitar
$LN31@LogMilitar:
	lea	ecx, DWORD PTR _playerName$227184[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN32@LogMilitar:

; 4023 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	push	0
	lea	eax, DWORD PTR _playerName$227184[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235688[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv357[ebp], eax
	mov	edx, DWORD PTR tv357[ebp]
	mov	DWORD PTR $T235730[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T235730[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235731[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T235731[ebp]
	push	eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227187[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235688[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4024 : 
; 4025 : 		// Very first update (to write header row?)
; 4026 : 		if(GC.getGame().getGameTurn() == 1 && m_pPlayer->GetID() == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235739[ebp], ecx
	mov	ecx, DWORD PTR $T235739[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 1
	jne	SHORT $LN2@LogMilitar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235748[ebp], ecx
	cmp	DWORD PTR $T235748[ebp], 0
	jne	SHORT $LN2@LogMilitar

; 4027 : 		{
; 4028 : 			strTemp.Format("Turn, Player, Cities, Settlers, Civ Threat, Barb Threat, Land Units, Land In Armies, Rec Land Size, Land Reserve, Naval Units, Naval In Armies, Rec Naval Size, Most Threatened, Danger");

	push	OFFSET ??_C@_0LI@FLPHCCAD@Turn?0?5Player?0?5Cities?0?5Settlers?0?5@
	lea	edx, DWORD PTR _strTemp$227183[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4029 : 			pLog->Msg(strTemp);

	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235752[ebp], eax
	mov	eax, DWORD PTR $T235752[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$227187[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$227187[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8
$LN2@LogMilitar:

; 4030 : 		}
; 4031 : 
; 4032 : 		// Get the leading info for this line
; 4033 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235756[ebp], edx
	mov	ecx, DWORD PTR $T235756[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	eax, DWORD PTR _strBaseString$227182[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4034 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR _playerName$227184[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235689[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv346[ebp], eax
	mov	eax, DWORD PTR tv346[ebp]
	mov	DWORD PTR tv303[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR tv303[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$227182[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235689[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4035 : 
; 4036 : 		// City info
; 4037 : 		strTemp.Format("%d, %d, ", m_pPlayer->getNumCities(), m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true));

	push	1
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	push	eax
	push	OFFSET ??_C@_08JDDGIPCE@?$CFd?0?5?$CFd?0?5?$AA@
	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4038 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$227183[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$227182[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235690[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv335[ebp], eax
	mov	edx, DWORD PTR tv335[ebp]
	mov	DWORD PTR $T235760[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T235760[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235690[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4039 : 
; 4040 : 		//Threat Info
; 4041 : 		strTemp.Format("%d, %d, ", m_iTotalThreatWeight, GetBarbarianThreatTotal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ ; CvMilitaryAI::GetBarbarianThreatTotal
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET ??_C@_08JDDGIPCE@?$CFd?0?5?$CFd?0?5?$AA@
	lea	edx, DWORD PTR _strTemp$227183[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4042 : 		strOutBuf += strTemp;

	lea	eax, DWORD PTR _strTemp$227183[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4043 : 
; 4044 : 		// Military size Info
; 4045 : 		int iNavalSize = MilitaryAIHelpers::ComputeRecommendedNavySize(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ; MilitaryAIHelpers::ComputeRecommendedNavySize
	add	esp, 4
	mov	DWORD PTR _iNavalSize$227194[ebp], eax

; 4046 : 		strTemp.Format("%d, %d, %d, %d, %d, %d, %d, ", m_iNumLandUnits, m_iNumLandUnitsInArmies, m_iRecommendedMilitarySize, m_iMandatoryReserveSize, m_iNumNavalUnits, m_iNumNavalUnitsInArmies, iNavalSize);

	mov	eax, DWORD PTR _iNavalSize$227194[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	OFFSET ??_C@_0BN@BFHPOGHK@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$AA@
	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 36					; 00000024H

; 4047 : 		strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$227183[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4048 : 
; 4049 : 		// Most threatened city
; 4050 : 		pCity = GetMostThreatenedCity();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
	mov	DWORD PTR _pCity$227185[ebp], eax

; 4051 : 		if(pCity != NULL)

	cmp	DWORD PTR _pCity$227185[ebp], 0
	je	SHORT $LN1@LogMilitar

; 4052 : 		{
; 4053 : 			cityName = pCity->getName();

	lea	eax, DWORD PTR $T235691[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$227185[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv324[ebp], eax
	mov	ecx, DWORD PTR tv324[ebp]
	mov	DWORD PTR $T235764[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR $T235764[ebp]
	push	edx
	lea	ecx, DWORD PTR _cityName$227186[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235691[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4054 : 			strOutBuf += cityName;

	lea	eax, DWORD PTR _cityName$227186[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4055 : 			strTemp.Format(", %d", pCity->getThreatValue());

	mov	ecx, DWORD PTR _pCity$227185[ebp]
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	push	eax
	push	OFFSET ??_C@_04KCMJEPHB@?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4056 : 			strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$227183[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN1@LogMilitar:

; 4057 : 		}
; 4058 : 
; 4059 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235772[ebp], eax
	mov	eax, DWORD PTR $T235772[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$227187[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$227187[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 4060 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _cityName$227186[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$227184[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$227182[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@LogMilitar:

; 4061 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$227181[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$227182[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$227183[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$227184[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _cityName$227186[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T235688[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T235689[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T235690[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T235691[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-340]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::LogMilitaryStatus
PUBLIC	??_C@_0DF@KMJLJNPL@?$CFs?0?5Damage?$DN?$CFd?0?5ArmyID?$DN?$CFd?0?5X?$DN?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0CC@CENKJDKH@Naval?5Invasion?5Under?5Constructio@ ; `string'
PUBLIC	??_C@_0BN@JOHKFACM@Land?5Army?5Under?5Construction?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?IsGreatAdmiral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatAdmiral
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
EXTRN	?TurnProcessed@CvUnit@@QBE_NXZ:PROC		; CvUnit::TurnProcessed
;	COMDAT ??_C@_0DF@KMJLJNPL@?$CFs?0?5Damage?$DN?$CFd?0?5ArmyID?$DN?$CFd?0?5X?$DN?$CFd?0?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DF@KMJLJNPL@?$CFs?0?5Damage?$DN?$CFd?0?5ArmyID?$DN?$CFd?0?5X?$DN?$CFd?0?5@ DB '%'
	DB	's, Damage=%d, ArmyID=%d, X=%d, Y=%d, DistFromCap=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CENKJDKH@Naval?5Invasion?5Under?5Constructio@
CONST	SEGMENT
??_C@_0CC@CENKJDKH@Naval?5Invasion?5Under?5Constructio@ DB 'Naval Invasio'
	DB	'n Under Construction', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JOHKFACM@Land?5Army?5Under?5Construction?$AA@
CONST	SEGMENT
??_C@_0BN@JOHKFACM@Land?5Army?5Under?5Construction?$AA@ DB 'Land Army Und'
	DB	'er Construction', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogAvailableForces@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogAvailableForces@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogAvailableForces@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$7
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogAvailableForces@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
tv74 = -444						; size = 4
tv326 = -440						; size = 4
tv337 = -436						; size = 4
tv314 = -432						; size = 4
tv348 = -428						; size = 4
tv359 = -424						; size = 4
tv133 = -420						; size = 4
_this$ = -416						; size = 4
$T235999 = -412						; size = 4
$T235995 = -408						; size = 4
$T235987 = -404						; size = 4
$T235986 = -400						; size = 4
$T235982 = -396						; size = 4
$T235973 = -392						; size = 4
$T235927 = -344						; size = 4
$T235918 = -340						; size = 4
$T235909 = -336						; size = 4
$T235905 = -332						; size = 4
$T235901 = -328						; size = 4
$T235884 = -324						; size = 4
$T235880 = -320						; size = 4
$T235866 = -316						; size = 4
$T235858 = -312						; size = 4
$T235857 = -308						; size = 4
$T235853 = -304						; size = 4
$T235806 = -300						; size = 28
$T235805 = -272						; size = 28
$T235804 = -244						; size = 28
$T235803 = -216						; size = 28
$T235802 = -188						; size = 28
_iArmyID$227230 = -160					; size = 4
_iDist$227231 = -156					; size = 4
_strOutBuf$227203 = -152				; size = 28
_playerName$227205 = -124				; size = 28
_pCapital$227210 = -96					; size = 4
_iCapitalX$227208 = -92					; size = 4
_pLoopUnit$227219 = -88					; size = 4
_pLog$227207 = -84					; size = 4
_iCapitalY$227209 = -80					; size = 4
_strTemp$227206 = -76					; size = 28
_strBaseString$227204 = -48				; size = 28
__$ArrayPad$ = -20					; size = 4
_iLoop$227220 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogAvailableForces@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::LogAvailableForces, COMDAT
; _this$ = ecx

; 4065 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogAvailableForces@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 432				; 000001b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4066 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN14@LogAvailab
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN14@LogAvailab

; 4067 : 	{
; 4068 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4069 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227204[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4070 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227205[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4071 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4072 : 		FILogFile* pLog;
; 4073 : 		int iCapitalX = 0;

	mov	DWORD PTR _iCapitalX$227208[ebp], 0

; 4074 : 		int iCapitalY = 0;

	mov	DWORD PTR _iCapitalY$227209[ebp], 0

; 4075 : 		CvCity* pCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapital$227210[ebp], eax

; 4076 : 		if(pCapital)

	cmp	DWORD PTR _pCapital$227210[ebp], 0
	je	SHORT $LN12@LogAvailab

; 4077 : 		{
; 4078 : 			iCapitalX = pCapital->getX();

	mov	edx, DWORD PTR _pCapital$227210[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iCapitalX$227208[ebp], eax

; 4079 : 			iCapitalY = pCapital->getY();

	mov	ecx, DWORD PTR _pCapital$227210[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iCapitalY$227209[ebp], edx
$LN12@LogAvailab:

; 4080 : 		}
; 4081 : 
; 4082 : 		// Open the right file
; 4083 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T235853[ebp], eax
	cmp	DWORD PTR $T235853[ebp], 0
	je	SHORT $LN46@LogAvailab
	mov	eax, DWORD PTR $T235853[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$227205[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN47@LogAvailab
$LN46@LogAvailab:
	lea	ecx, DWORD PTR _playerName$227205[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN47@LogAvailab:

; 4084 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv133[ebp], eax
	push	0
	lea	ecx, DWORD PTR _playerName$227205[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235802[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv359[ebp], eax
	mov	eax, DWORD PTR tv359[ebp]
	mov	DWORD PTR $T235857[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T235857[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235858[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T235858[ebp]
	push	ecx
	mov	edx, DWORD PTR tv133[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv133[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$227207[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235802[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4085 : 
; 4086 : 		// Get the leading info for this line
; 4087 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235866[ebp], eax
	mov	ecx, DWORD PTR $T235866[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$227204[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4088 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$227205[ebp]
	push	edx
	lea	eax, DWORD PTR $T235803[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv348[ebp], eax
	mov	ecx, DWORD PTR tv348[ebp]
	mov	DWORD PTR tv314[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv314[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$227204[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235803[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4089 : 
; 4090 : 		if(m_eArmyTypeBeingBuilt == ARMY_TYPE_LAND)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN11@LogAvailab

; 4091 : 		{
; 4092 : 			strTemp = "Land Army Under Construction";

	mov	ecx, OFFSET ??_C@_0BN@JOHKFACM@Land?5Army?5Under?5Construction?$AA@
	test	ecx, ecx
	je	SHORT $LN57@LogAvailab
	push	OFFSET ??_C@_0BN@JOHKFACM@Land?5Army?5Under?5Construction?$AA@
	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN58@LogAvailab
$LN57@LogAvailab:
	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN58@LogAvailab:

; 4093 : 		}
; 4094 : 		else

	jmp	SHORT $LN10@LogAvailab
$LN11@LogAvailab:

; 4095 : 		{
; 4096 : 			strTemp = "Naval Invasion Under Construction";

	mov	edx, OFFSET ??_C@_0CC@CENKJDKH@Naval?5Invasion?5Under?5Constructio@
	test	edx, edx
	je	SHORT $LN61@LogAvailab
	push	OFFSET ??_C@_0CC@CENKJDKH@Naval?5Invasion?5Under?5Constructio@
	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN10@LogAvailab
$LN61@LogAvailab:
	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN10@LogAvailab:

; 4097 : 		}
; 4098 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$227206[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227204[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235804[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv337[ebp], eax
	mov	eax, DWORD PTR tv337[ebp]
	mov	DWORD PTR $T235880[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T235880[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235804[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4099 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235884[ebp], eax
	mov	ecx, DWORD PTR $T235884[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$227207[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$227207[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 4100 : 
; 4101 : 		// Loop through our units
; 4102 : 		CvUnit* pLoopUnit;
; 4103 : 		int iLoop;
; 4104 : 		for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$227220[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$227219[ebp], eax
	jmp	SHORT $LN9@LogAvailab
$LN8@LogAvailab:
	push	0
	lea	edx, DWORD PTR _iLoop$227220[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$227219[ebp], eax
$LN9@LogAvailab:
	cmp	DWORD PTR _pLoopUnit$227219[ebp], 0
	je	$LN7@LogAvailab

; 4105 : 		{
; 4106 : 			// Never want immobile/dead units, explorers, ones that have already moved or automated human units
; 4107 : 			if(pLoopUnit->TurnProcessed() || pLoopUnit->isDelayedDeath() || pLoopUnit->AI_getUnitAIType() == UNITAI_UNKNOWN ||  pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE || !pLoopUnit->canMove() || pLoopUnit->isHuman())

	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	SHORT $LN5@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN5@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN68@LogAvailab
$LN5@LogAvailab:

; 4108 : 			{
; 4109 : 				continue;

	jmp	SHORT $LN8@LogAvailab
	jmp	SHORT $LN4@LogAvailab

; 4110 : 			}
; 4111 : 
; 4112 : 			// Now down to land and sea units ... in these groups our unit must have a base combat strength ... or be a great general/admiral
; 4113 : 			else if(!pLoopUnit->IsCombatUnit() && !(pLoopUnit->IsGreatGeneral() || pLoopUnit->IsGreatAdmiral()))

$LN68@LogAvailab:
	mov	edx, DWORD PTR _pLoopUnit$227219[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+1044], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN74@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN74@LogAvailab
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN74@LogAvailab
	jmp	$LN8@LogAvailab

; 4114 : 			{
; 4115 : 				continue;

	jmp	SHORT $LN4@LogAvailab

; 4116 : 			}
; 4117 : 
; 4118 : 			// No units finishing up operations
; 4119 : 			else if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() >= GC.getGame().getGameTurn())

$LN74@LogAvailab:
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR $T235901[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T235905[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235909[ebp], ecx
	mov	esi, DWORD PTR $T235901[ebp]
	add	esi, DWORD PTR $T235905[ebp]
	mov	ecx, DWORD PTR $T235909[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jl	SHORT $LN4@LogAvailab

; 4120 : 			{
; 4121 : 				continue;

	jmp	$LN8@LogAvailab
$LN4@LogAvailab:

; 4122 : 			}
; 4123 : 
; 4124 : 			int iArmyID = pLoopUnit->getArmyID();

	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	mov	DWORD PTR _iArmyID$227230[ebp], eax

; 4125 : 			int iDist = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iCapitalX, iCapitalY);

	mov	edx, DWORD PTR _pLoopUnit$227219[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T235918[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T235927[ebp], edx
	mov	eax, DWORD PTR _iCapitalY$227209[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCapitalX$227208[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235918[ebp]
	push	edx
	mov	eax, DWORD PTR $T235927[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDist$227231[ebp], eax

; 4126 : 			strTemp.Format("%s, Damage=%d, ArmyID=%d, X=%d, Y=%d, DistFromCap=%d", pLoopUnit->getName().GetCString(), pLoopUnit->getDamage(), iArmyID, pLoopUnit->getX(), pLoopUnit->getY(), iDist);

	lea	ecx, DWORD PTR $T235805[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv326[ebp], eax
	mov	edx, DWORD PTR tv326[ebp]
	mov	DWORD PTR $T235986[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _pLoopUnit$227219[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T235973[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$227219[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T235982[ebp], eax
	mov	ecx, DWORD PTR $T235986[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235987[ebp], eax
	mov	ecx, DWORD PTR _iDist$227231[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235973[ebp]
	push	edx
	mov	eax, DWORD PTR $T235982[ebp]
	push	eax
	mov	ecx, DWORD PTR _iArmyID$227230[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$227219[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	push	eax
	mov	edx, DWORD PTR $T235987[ebp]
	push	edx
	push	OFFSET ??_C@_0DF@KMJLJNPL@?$CFs?0?5Damage?$DN?$CFd?0?5ArmyID?$DN?$CFd?0?5X?$DN?$CFd?0?5@
	lea	eax, DWORD PTR _strTemp$227206[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235805[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4127 : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$227204[ebp]
	push	edx
	lea	eax, DWORD PTR $T235806[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T235995[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T235995[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235806[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4128 : 
; 4129 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235999[ebp], eax
	mov	edx, DWORD PTR $T235999[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$227207[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$227207[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 4130 : 		}

	jmp	$LN8@LogAvailab
$LN7@LogAvailab:

; 4131 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _playerName$227205[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$227204[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@LogAvailab:

; 4132 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$227203[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$227204[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _playerName$227205[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp$227206[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T235802[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T235803[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T235804[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T235805[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T235806[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogAvailableForces@CvMilitaryAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-440]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogAvailableForces@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogAvailableForces@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::LogAvailableForces
PUBLIC	??_C@_0BC@GDKIABDH@?0?5Old?5War?5State?3?5?$AA@	; `string'
PUBLIC	??_C@_03MAMPKPPK@XXX?$AA@			; `string'
PUBLIC	??_C@_0BA@OELJHDJA@Nearly?5Defeated?$AA@	; `string'
PUBLIC	??_C@_09NAIOPJHK@Defensive?$AA@			; `string'
PUBLIC	??_C@_09ECDNFMLC@Stalemate?$AA@			; `string'
PUBLIC	??_C@_09BBODDOEI@Offensive?$AA@			; `string'
PUBLIC	??_C@_0L@MNDABIHH@Nearly?5Won?$AA@		; `string'
PUBLIC	??_C@_04DEIKJNLD@Calm?$AA@			; `string'
PUBLIC	??_C@_0BC@KBGBJOHO@?0?5New?5War?5State?3?5?$AA@	; `string'
PUBLIC	??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@		; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BC@GDKIABDH@?0?5Old?5War?5State?3?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BC@GDKIABDH@?0?5Old?5War?5State?3?5?$AA@ DB ', Old War State: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAMPKPPK@XXX?$AA@
CONST	SEGMENT
??_C@_03MAMPKPPK@XXX?$AA@ DB 'XXX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OELJHDJA@Nearly?5Defeated?$AA@
CONST	SEGMENT
??_C@_0BA@OELJHDJA@Nearly?5Defeated?$AA@ DB 'Nearly Defeated', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NAIOPJHK@Defensive?$AA@
CONST	SEGMENT
??_C@_09NAIOPJHK@Defensive?$AA@ DB 'Defensive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ECDNFMLC@Stalemate?$AA@
CONST	SEGMENT
??_C@_09ECDNFMLC@Stalemate?$AA@ DB 'Stalemate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBODDOEI@Offensive?$AA@
CONST	SEGMENT
??_C@_09BBODDOEI@Offensive?$AA@ DB 'Offensive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MNDABIHH@Nearly?5Won?$AA@
CONST	SEGMENT
??_C@_0L@MNDABIHH@Nearly?5Won?$AA@ DB 'Nearly Won', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DEIKJNLD@Calm?$AA@
CONST	SEGMENT
??_C@_04DEIKJNLD@Calm?$AA@ DB 'Calm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBGBJOHO@?0?5New?5War?5State?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@KBGBJOHO@?0?5New?5War?5State?3?5?$AA@ DB ', New War State: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@
CONST	SEGMENT
??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@ DB ', vs. ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
_TEXT	SEGMENT
tv209 = -416						; size = 4
tv74 = -412						; size = 4
tv276 = -408						; size = 4
tv284 = -404						; size = 4
tv165 = -400						; size = 4
tv274 = -396						; size = 4
tv295 = -392						; size = 4
tv272 = -388						; size = 4
tv306 = -384						; size = 4
tv270 = -380						; size = 4
tv317 = -376						; size = 4
tv328 = -372						; size = 4
tv137 = -368						; size = 4
_this$ = -364						; size = 4
$T236098 = -360						; size = 4
$T236094 = -356						; size = 4
$T236090 = -352						; size = 4
$T236082 = -348						; size = 4
$T236081 = -344						; size = 4
$T236077 = -340						; size = 4
$T236071 = -336						; size = 4
$T236067 = -332						; size = 4
$T236030 = -328						; size = 28
$T236029 = -300						; size = 28
$T236028 = -272						; size = 28
$T236027 = -244						; size = 28
$T236026 = -216						; size = 28
$T236025 = -188						; size = 28
_strOutBuf$227242 = -160				; size = 28
_playerName$227245 = -132				; size = 28
_opponentName$227246 = -104				; size = 28
_pLog$227247 = -76					; size = 4
_strTemp$227244 = -72					; size = 28
_strBaseString$227243 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eNewWarState$ = 12					; size = 4
_eOldWarState$ = 16					; size = 4
?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z PROC ; CvMilitaryAI::LogWarStateChange, COMDAT
; _this$ = ecx

; 4136 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 404				; 00000194H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4137 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN20@LogWarStat
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@LogWarStat

; 4138 : 	{
; 4139 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227242[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4140 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227243[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4141 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4142 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227245[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4143 : 		CvString opponentName;

	lea	ecx, DWORD PTR _opponentName$227246[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4144 : 		FILogFile* pLog;
; 4145 : 
; 4146 : 		// Open the right file
; 4147 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ; CvMilitaryAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T236067[ebp], eax
	cmp	DWORD PTR $T236067[ebp], 0
	je	SHORT $LN49@LogWarStat
	mov	edx, DWORD PTR $T236067[ebp]
	push	edx
	lea	ecx, DWORD PTR _playerName$227245[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN50@LogWarStat
$LN49@LogWarStat:
	lea	ecx, DWORD PTR _playerName$227245[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN50@LogWarStat:

; 4148 : 		opponentName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236071[ebp], eax
	mov	ecx, DWORD PTR $T236071[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T236077[ebp], eax
	cmp	DWORD PTR $T236077[ebp], 0
	je	SHORT $LN55@LogWarStat
	mov	ecx, DWORD PTR $T236077[ebp]
	push	ecx
	lea	ecx, DWORD PTR _opponentName$227246[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN56@LogWarStat
$LN55@LogWarStat:
	lea	ecx, DWORD PTR _opponentName$227246[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN56@LogWarStat:

; 4149 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv137[ebp], eax
	push	0
	lea	edx, DWORD PTR _playerName$227245[ebp]
	push	edx
	lea	eax, DWORD PTR $T236025[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv328[ebp], eax
	mov	ecx, DWORD PTR tv328[ebp]
	mov	DWORD PTR $T236081[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T236081[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236082[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T236082[ebp]
	push	edx
	mov	eax, DWORD PTR tv137[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227247[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T236025[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4150 : 
; 4151 : 		// Get the leading info for this line
; 4152 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236090[ebp], ecx
	mov	ecx, DWORD PTR $T236090[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$227243[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4153 : 		strBaseString += playerName + ", vs. " + opponentName + ", New War State: ";

	push	OFFSET ??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@
	lea	eax, DWORD PTR _playerName$227245[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236026[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv317[ebp], eax
	mov	edx, DWORD PTR tv317[ebp]
	mov	DWORD PTR tv270[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	eax, DWORD PTR _opponentName$227246[ebp]
	push	eax
	mov	ecx, DWORD PTR tv270[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236027[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv306[ebp], eax
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR tv272[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	OFFSET ??_C@_0BC@KBGBJOHO@?0?5New?5War?5State?3?5?$AA@
	mov	ecx, DWORD PTR tv272[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236028[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv295[ebp], eax
	mov	eax, DWORD PTR tv295[ebp]
	mov	DWORD PTR tv274[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv274[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$227243[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T236028[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T236027[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T236026[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4154 : 
; 4155 : 		// New War State
; 4156 : 		switch(eNewWarState)

	mov	edx, DWORD PTR _eNewWarState$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	cmp	DWORD PTR tv165[ebp], 5
	ja	SHORT $LN10@LogWarStat
	mov	eax, DWORD PTR tv165[ebp]
	jmp	DWORD PTR $LN85@LogWarStat[eax*4]
$LN16@LogWarStat:

; 4157 : 		{
; 4158 : 		case WAR_STATE_CALM:
; 4159 : 			strTemp.Format("Calm");

	push	OFFSET ??_C@_04DEIKJNLD@Calm?$AA@
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4160 : 			break;

	jmp	SHORT $LN17@LogWarStat
$LN15@LogWarStat:

; 4161 : 		case WAR_STATE_NEARLY_WON:
; 4162 : 			strTemp.Format("Nearly Won");

	push	OFFSET ??_C@_0L@MNDABIHH@Nearly?5Won?$AA@
	lea	edx, DWORD PTR _strTemp$227244[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4163 : 			break;

	jmp	SHORT $LN17@LogWarStat
$LN14@LogWarStat:

; 4164 : 		case WAR_STATE_OFFENSIVE:
; 4165 : 			strTemp.Format("Offensive");

	push	OFFSET ??_C@_09BBODDOEI@Offensive?$AA@
	lea	eax, DWORD PTR _strTemp$227244[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4166 : 			break;

	jmp	SHORT $LN17@LogWarStat
$LN13@LogWarStat:

; 4167 : 		case WAR_STATE_STALEMATE:
; 4168 : 			strTemp.Format("Stalemate");

	push	OFFSET ??_C@_09ECDNFMLC@Stalemate?$AA@
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4169 : 			break;

	jmp	SHORT $LN17@LogWarStat
$LN12@LogWarStat:

; 4170 : 		case WAR_STATE_DEFENSIVE:
; 4171 : 			strTemp.Format("Defensive");

	push	OFFSET ??_C@_09NAIOPJHK@Defensive?$AA@
	lea	edx, DWORD PTR _strTemp$227244[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4172 : 			break;

	jmp	SHORT $LN17@LogWarStat
$LN11@LogWarStat:

; 4173 : 		case WAR_STATE_NEARLY_DEFEATED:
; 4174 : 			strTemp.Format("Nearly Defeated");

	push	OFFSET ??_C@_0BA@OELJHDJA@Nearly?5Defeated?$AA@
	lea	eax, DWORD PTR _strTemp$227244[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4175 : 			break;

	jmp	SHORT $LN17@LogWarStat
$LN10@LogWarStat:

; 4176 : 		default:
; 4177 : 			strTemp.Format("XXX");

	push	OFFSET ??_C@_03MAMPKPPK@XXX?$AA@
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8
$LN17@LogWarStat:

; 4178 : 			break;
; 4179 : 		}
; 4180 : 		strOutBuf = strBaseString + strTemp + ", Old War State: ";

	lea	edx, DWORD PTR _strTemp$227244[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$227243[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236029[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv284[ebp], eax
	mov	edx, DWORD PTR tv284[ebp]
	mov	DWORD PTR tv276[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_0BC@GDKIABDH@?0?5Old?5War?5State?3?5?$AA@
	mov	eax, DWORD PTR tv276[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236030[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T236094[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T236094[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227242[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T236030[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T236029[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4181 : 
; 4182 : 		// Old War State
; 4183 : 		switch(eOldWarState)

	mov	eax, DWORD PTR _eOldWarState$[ebp]
	mov	DWORD PTR tv209[ebp], eax
	cmp	DWORD PTR tv209[ebp], 5
	ja	SHORT $LN1@LogWarStat
	mov	ecx, DWORD PTR tv209[ebp]
	jmp	DWORD PTR $LN86@LogWarStat[ecx*4]
$LN7@LogWarStat:

; 4184 : 		{
; 4185 : 		case WAR_STATE_CALM:
; 4186 : 			strTemp.Format("Calm");

	push	OFFSET ??_C@_04DEIKJNLD@Calm?$AA@
	lea	edx, DWORD PTR _strTemp$227244[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4187 : 			break;

	jmp	SHORT $LN8@LogWarStat
$LN6@LogWarStat:

; 4188 : 		case WAR_STATE_NEARLY_WON:
; 4189 : 			strTemp.Format("Nearly Won");

	push	OFFSET ??_C@_0L@MNDABIHH@Nearly?5Won?$AA@
	lea	eax, DWORD PTR _strTemp$227244[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4190 : 			break;

	jmp	SHORT $LN8@LogWarStat
$LN5@LogWarStat:

; 4191 : 		case WAR_STATE_OFFENSIVE:
; 4192 : 			strTemp.Format("Offensive");

	push	OFFSET ??_C@_09BBODDOEI@Offensive?$AA@
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4193 : 			break;

	jmp	SHORT $LN8@LogWarStat
$LN4@LogWarStat:

; 4194 : 		case WAR_STATE_STALEMATE:
; 4195 : 			strTemp.Format("Stalemate");

	push	OFFSET ??_C@_09ECDNFMLC@Stalemate?$AA@
	lea	edx, DWORD PTR _strTemp$227244[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4196 : 			break;

	jmp	SHORT $LN8@LogWarStat
$LN3@LogWarStat:

; 4197 : 		case WAR_STATE_DEFENSIVE:
; 4198 : 			strTemp.Format("Defensive");

	push	OFFSET ??_C@_09NAIOPJHK@Defensive?$AA@
	lea	eax, DWORD PTR _strTemp$227244[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4199 : 			break;

	jmp	SHORT $LN8@LogWarStat
$LN2@LogWarStat:

; 4200 : 		case WAR_STATE_NEARLY_DEFEATED:
; 4201 : 			strTemp.Format("Nearly Defeated");

	push	OFFSET ??_C@_0BA@OELJHDJA@Nearly?5Defeated?$AA@
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4202 : 			break;

	jmp	SHORT $LN8@LogWarStat
$LN1@LogWarStat:

; 4203 : 		default:
; 4204 : 			strTemp.Format("XXX");

	push	OFFSET ??_C@_03MAMPKPPK@XXX?$AA@
	lea	edx, DWORD PTR _strTemp$227244[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8
$LN8@LogWarStat:

; 4205 : 			break;
; 4206 : 		}
; 4207 : 		strOutBuf += strTemp;

	lea	eax, DWORD PTR _strTemp$227244[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227242[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4208 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227242[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236098[ebp], eax
	mov	ecx, DWORD PTR $T236098[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$227247[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$227247[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 4209 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _opponentName$227246[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$227245[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$227243[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$227242[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN20@LogWarStat:

; 4210 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN85@LogWarStat:
	DD	$LN11@LogWarStat
	DD	$LN12@LogWarStat
	DD	$LN13@LogWarStat
	DD	$LN16@LogWarStat
	DD	$LN14@LogWarStat
	DD	$LN15@LogWarStat
$LN86@LogWarStat:
	DD	$LN2@LogWarStat
	DD	$LN3@LogWarStat
	DD	$LN4@LogWarStat
	DD	$LN7@LogWarStat
	DD	$LN5@LogWarStat
	DD	$LN6@LogWarStat
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227242[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227243[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$2:
	lea	ecx, DWORD PTR _strTemp$227244[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$3:
	lea	ecx, DWORD PTR _playerName$227245[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$4:
	lea	ecx, DWORD PTR _opponentName$227246[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$5:
	lea	ecx, DWORD PTR $T236025[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$6:
	lea	ecx, DWORD PTR $T236026[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$7:
	lea	ecx, DWORD PTR $T236027[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$8:
	lea	ecx, DWORD PTR $T236028[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$9:
	lea	ecx, DWORD PTR $T236029[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$10:
	lea	ecx, DWORD PTR $T236030[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-408]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ENDP ; CvMilitaryAI::LogWarStateChange
PUBLIC	??_C@_0L@LKDJHALM@Other?5GS?0?5?$AA@		; `string'
PUBLIC	??_C@_0L@IKMIKNBK@CONQUEST?0?5?$AA@		; `string'
PUBLIC	??_C@_0O@PFBBPPGC@Finances?5ok?0?5?$AA@		; `string'
PUBLIC	??_C@_0N@JEPLJCHM@IN?5DEFICIT?0?5?$AA@		; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0L@LKDJHALM@Other?5GS?0?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0L@LKDJHALM@Other?5GS?0?5?$AA@ DB 'Other GS, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKMIKNBK@CONQUEST?0?5?$AA@
CONST	SEGMENT
??_C@_0L@IKMIKNBK@CONQUEST?0?5?$AA@ DB 'CONQUEST, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PFBBPPGC@Finances?5ok?0?5?$AA@
CONST	SEGMENT
??_C@_0O@PFBBPPGC@Finances?5ok?0?5?$AA@ DB 'Finances ok, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JEPLJCHM@IN?5DEFICIT?0?5?$AA@
CONST	SEGMENT
??_C@_0N@JEPLJCHM@IN?5DEFICIT?0?5?$AA@ DB 'IN DEFICIT, ', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
_TEXT	SEGMENT
tv262 = -228						; size = 4
tv280 = -224						; size = 4
tv291 = -220						; size = 4
tv88 = -216						; size = 4
_this$ = -212						; size = 4
$T236210 = -208						; size = 4
$T236206 = -204						; size = 4
$T236202 = -200						; size = 4
$T236198 = -196						; size = 4
$T236194 = -192						; size = 4
$T236185 = -188						; size = 4
$T236181 = -184						; size = 4
$T236172 = -180						; size = 4
$T236168 = -176						; size = 4
$T236160 = -172						; size = 4
$T236159 = -168						; size = 4
$T236155 = -164						; size = 4
$T236131 = -160						; size = 28
$T236130 = -132						; size = 28
_strOutBuf$227293 = -104				; size = 28
_playerName$227295 = -76				; size = 28
_pLog$227296 = -48					; size = 4
_strTemp$227294 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_bDeficit$ = 16						; size = 1
_bConquest$ = 20					; size = 1
?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z PROC ; CvMilitaryAI::LogScrapUnit, COMDAT
; _this$ = ecx

; 4214 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4215 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogScrapUn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@LogScrapUn

; 4216 : 	{
; 4217 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4218 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227294[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4219 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227295[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4220 : 		FILogFile* pLog;
; 4221 : 
; 4222 : 		// Open the right file
; 4223 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T236155[ebp], eax
	cmp	DWORD PTR $T236155[ebp], 0
	je	SHORT $LN26@LogScrapUn
	mov	eax, DWORD PTR $T236155[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$227295[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN27@LogScrapUn
$LN26@LogScrapUn:
	lea	ecx, DWORD PTR _playerName$227295[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN27@LogScrapUn:

; 4224 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv88[ebp], eax
	push	0
	lea	ecx, DWORD PTR _playerName$227295[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236130[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv291[ebp], eax
	mov	eax, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T236159[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T236159[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236160[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T236160[ebp]
	push	ecx
	mov	edx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$227296[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T236130[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4225 : 
; 4226 : 		strOutBuf.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236168[ebp], eax
	mov	ecx, DWORD PTR $T236168[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4227 : 		strOutBuf += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$227295[ebp]
	push	edx
	lea	eax, DWORD PTR $T236131[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv280[ebp], eax
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR tv262[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv262[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T236131[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4228 : 
; 4229 : 		strTemp.Format("Scrapping %s, X: %d, Y: %d, ", pUnit->getUnitInfo().GetDescription(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236172[ebp], eax
	mov	ecx, DWORD PTR $T236172[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T236181[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236185[ebp], eax
	mov	ecx, DWORD PTR $T236185[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T236194[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236198[ebp], eax
	mov	ecx, DWORD PTR $T236198[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T236202[ebp], eax
	mov	ecx, DWORD PTR $T236181[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236194[ebp]
	push	edx
	mov	ecx, DWORD PTR $T236202[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BN@MLLFFMID@Scrapping?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5?$AA@
	lea	eax, DWORD PTR _strTemp$227294[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4230 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$227294[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4231 : 		if(bDeficit)

	movzx	edx, BYTE PTR _bDeficit$[ebp]
	test	edx, edx
	je	SHORT $LN6@LogScrapUn

; 4232 : 		{
; 4233 : 			strOutBuf += "IN DEFICIT, ";

	push	OFFSET ??_C@_0N@JEPLJCHM@IN?5DEFICIT?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4234 : 		}
; 4235 : 		else

	jmp	SHORT $LN5@LogScrapUn
$LN6@LogScrapUn:

; 4236 : 		{
; 4237 : 			strOutBuf += "Finances ok, ";

	push	OFFSET ??_C@_0O@PFBBPPGC@Finances?5ok?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN5@LogScrapUn:

; 4238 : 		}
; 4239 : 		if(bConquest)

	movzx	eax, BYTE PTR _bConquest$[ebp]
	test	eax, eax
	je	SHORT $LN4@LogScrapUn

; 4240 : 		{
; 4241 : 			strOutBuf += "CONQUEST, ";

	push	OFFSET ??_C@_0L@IKMIKNBK@CONQUEST?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4242 : 		}
; 4243 : 		else

	jmp	SHORT $LN3@LogScrapUn
$LN4@LogScrapUn:

; 4244 : 		{
; 4245 : 			strOutBuf += "Other GS, ";

	push	OFFSET ??_C@_0L@LKDJHALM@Other?5GS?0?5?$AA@
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN3@LogScrapUn:

; 4246 : 		}
; 4247 : 		if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236206[ebp], ecx
	mov	ecx, DWORD PTR $T236206[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN2@LogScrapUn

; 4248 : 		{
; 4249 : 			strTemp.Format("Num Land Units: %d, In Armies %d, Rec Size: %d, ", m_iNumLandUnits, m_iNumLandUnitsInArmies, m_iRecommendedMilitarySize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	push	OFFSET ??_C@_0DB@JIKILAFA@Num?5Land?5Units?3?5?$CFd?0?5In?5Armies?5?$CFd@
	lea	edx, DWORD PTR _strTemp$227294[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4250 : 		}
; 4251 : 		else

	jmp	SHORT $LN1@LogScrapUn
$LN2@LogScrapUn:

; 4252 : 		{
; 4253 : 			strTemp.Format("Num Naval Units: %d, In Armies %d, ", m_iNumNavalUnits, m_iNumNavalUnitsInArmies);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	push	OFFSET ??_C@_0CE@EDMLPMBB@Num?5Naval?5Units?3?5?$CFd?0?5In?5Armies?5?$CF@
	lea	ecx, DWORD PTR _strTemp$227294[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN1@LogScrapUn:

; 4254 : 		}
; 4255 : 		strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$227294[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4256 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236210[ebp], eax
	mov	eax, DWORD PTR $T236210[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$227296[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$227296[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 4257 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$227295[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227294[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogScrapUn:

; 4258 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN8@LogScrapUn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN8@LogScrapUn:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$227293[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$2:
	lea	ecx, DWORD PTR _strTemp$227294[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$3:
	lea	ecx, DWORD PTR _playerName$227295[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$4:
	lea	ecx, DWORD PTR $T236130[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$5:
	lea	ecx, DWORD PTR $T236131[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ENDP ; CvMilitaryAI::LogScrapUnit
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
tv193 = -240						; size = 4
tv185 = -236						; size = 4
tv204 = -232						; size = 4
tv215 = -228						; size = 4
tv86 = -224						; size = 4
tv217 = -220						; size = 4
_this$ = -216						; size = 4
$T236287 = -212						; size = 4
$T236283 = -208						; size = 4
$T236279 = -204						; size = 4
$T236271 = -200						; size = 4
$T236270 = -196						; size = 4
$T236266 = -192						; size = 4
$T236243 = -188						; size = 28
$T236242 = -160						; size = 28
$T236241 = -132						; size = 28
_strOutBuf$227314 = -104				; size = 28
_strPlayerName$227316 = -76				; size = 28
_pLog$227317 = -48					; size = 4
_strBaseString$227315 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z PROC ; CvMilitaryAI::LogMilitarySummaryMessage, COMDAT
; _this$ = ecx

; 4262 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4263 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogMilitar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogMilitar@2

; 4264 : 	{
; 4265 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227314[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4266 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227315[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4267 : 		CvString strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T236266[ebp], eax
	cmp	DWORD PTR $T236266[ebp], 0
	je	SHORT $LN18@LogMilitar@2
	mov	eax, DWORD PTR $T236266[ebp]
	mov	DWORD PTR tv217[ebp], eax
	jmp	SHORT $LN19@LogMilitar@2
$LN18@LogMilitar@2:
	mov	DWORD PTR tv217[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN19@LogMilitar@2:
	mov	ecx, DWORD PTR tv217[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$227316[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4268 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName, true/*bSummary*/), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv86[ebp], eax
	push	1
	lea	edx, DWORD PTR _strPlayerName$227316[ebp]
	push	edx
	lea	eax, DWORD PTR $T236241[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	DWORD PTR tv215[ebp], eax
	mov	ecx, DWORD PTR tv215[ebp]
	mov	DWORD PTR $T236270[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T236270[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236271[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T236271[ebp]
	push	edx
	mov	eax, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$227317[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236241[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4269 : 
; 4270 : 		// Get the leading info for this line
; 4271 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236279[ebp], ecx
	mov	ecx, DWORD PTR $T236279[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$227315[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4272 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _strPlayerName$227316[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv204[ebp], eax
	mov	edx, DWORD PTR tv204[ebp]
	mov	DWORD PTR tv185[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv185[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227315[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236242[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4273 : 		strOutBuf = strBaseString + strMsg;

	mov	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$227315[ebp]
	push	edx
	lea	eax, DWORD PTR $T236243[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv193[ebp], eax
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T236283[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T236283[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227314[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236243[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4274 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227314[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236287[ebp], eax
	mov	edx, DWORD PTR $T236287[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$227317[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$227317[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 4275 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strPlayerName$227316[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$227315[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$227314[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogMilitar@2:

; 4276 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227314[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227315[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$227316[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T236241[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$4:
	lea	ecx, DWORD PTR $T236242[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$5:
	lea	ecx, DWORD PTR $T236243[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ENDP ; CvMilitaryAI::LogMilitarySummaryMessage
PUBLIC	??_C@_0BC@GJMCNAMO@MilitaryAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_0P@EEKCHEKB@MilitaryAILog_?$AA@		; `string'
PUBLIC	??_C@_0BE@JHFBKEBB@MilitarySummary?4csv?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT ??_C@_0BC@GJMCNAMO@MilitaryAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BC@GJMCNAMO@MilitaryAILog?4csv?$AA@ DB 'MilitaryAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEKCHEKB@MilitaryAILog_?$AA@
CONST	SEGMENT
??_C@_0P@EEKCHEKB@MilitaryAILog_?$AA@ DB 'MilitaryAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JHFBKEBB@MilitarySummary?4csv?$AA@
CONST	SEGMENT
??_C@_0BE@JHFBKEBB@MilitarySummary?4csv?$AA@ DB 'MilitarySummary.csv', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$2
__ehfuncinfo$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
_TEXT	SEGMENT
tv146 = -124						; size = 4
tv133 = -120						; size = 4
tv183 = -116						; size = 4
_this$ = -112						; size = 4
$T236329 = -108						; size = 4
$T236315 = -104						; size = 4
$T236310 = -100						; size = 28
$T236309 = -72						; size = 28
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
_bSummary$ = 16						; size = 1
?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z PROC ; CvMilitaryAI::GetLogFileName, COMDAT
; _this$ = ecx

; 4280 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T236315[ebp], 0

; 4281 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4282 : 
; 4283 : 	if (bSummary)

	movzx	eax, BYTE PTR _bSummary$[ebp]
	test	eax, eax
	je	SHORT $LN4@GetLogFile

; 4284 : 	{
; 4285 : 		strLogName = "MilitarySummary.csv";

	mov	ecx, OFFSET ??_C@_0BE@JHFBKEBB@MilitarySummary?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN16@GetLogFile
	push	OFFSET ??_C@_0BE@JHFBKEBB@MilitarySummary?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN17@GetLogFile
$LN16@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN17@GetLogFile:

; 4286 : 	}
; 4287 : 	else

	jmp	$LN3@GetLogFile
$LN4@GetLogFile:

; 4288 : 	{
; 4289 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetLogFile

; 4290 : 		{
; 4291 : 			strLogName = "MilitaryAILog_" + playerName + ".csv";

	mov	eax, DWORD PTR _playerName$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@EEKCHEKB@MilitaryAILog_?$AA@
	lea	ecx, DWORD PTR $T236309[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv183[ebp], eax
	mov	edx, DWORD PTR tv183[ebp]
	mov	DWORD PTR tv133[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	eax, DWORD PTR tv133[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236310[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv146[ebp], eax
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR $T236329[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T236329[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236310[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236309[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4292 : 		}
; 4293 : 		else

	jmp	SHORT $LN3@GetLogFile
$LN2@GetLogFile:

; 4294 : 		{
; 4295 : 			strLogName = "MilitaryAILog.csv";

	mov	eax, OFFSET ??_C@_0BC@GJMCNAMO@MilitaryAILog?4csv?$AA@
	test	eax, eax
	je	SHORT $LN22@GetLogFile
	push	OFFSET ??_C@_0BC@GJMCNAMO@MilitaryAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN3@GetLogFile
$LN22@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN3@GetLogFile:

; 4296 : 		}
; 4297 : 	}
; 4298 : 
; 4299 : 	return strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T236315[ebp]
	or	edx, 1
	mov	DWORD PTR $T236315[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4300 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$1:
	lea	ecx, DWORD PTR $T236309[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$2:
	lea	ecx, DWORD PTR $T236310[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$3:
	mov	eax, DWORD PTR $T236315[ebp]
	and	eax, 1
	je	$LN11@GetLogFile
	and	DWORD PTR $T236315[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN11@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ENDP ; CvMilitaryAI::GetLogFileName
PUBLIC	?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::GetWeightThresholdModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236354 = -36						; size = 4
_iStrategyFlavorMod$227353 = -32			; size = 4
_pkEntry$227351 = -28					; size = 4
_iPersonalityFlavor$227350 = -24			; size = 4
_eFlavor$227348 = -20					; size = 4
_iFlavorLoop$227344 = -16				; size = 4
_iWeightThresholdModifier$ = -12			; size = 4
_pkAIStrategies$ = -8					; size = 4
_pkFlavorManager$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::GetWeightThresholdModifier, COMDAT

; 4311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 4312 : 	int iWeightThresholdModifier = 0;

	mov	DWORD PTR _iWeightThresholdModifier$[ebp], 0

; 4313 : 
; 4314 : 	CvMilitaryAIStrategyXMLEntries* pkAIStrategies = pPlayer->GetMilitaryAI()->GetMilitaryAIStrategies();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
	mov	DWORD PTR _pkAIStrategies$[ebp], eax

; 4315 : 	CvFlavorManager* pkFlavorManager = pPlayer->GetFlavorManager();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	DWORD PTR _pkFlavorManager$[ebp], eax

; 4316 : 	// Look at all Flavors for the Player & this Strategy
; 4317 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$227344[ebp], 0
	jmp	SHORT $LN4@GetWeightT
$LN3@GetWeightT:
	mov	eax, DWORD PTR _iFlavorLoop$227344[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$227344[ebp], eax
$LN4@GetWeightT:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T236354[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$227344[ebp]
	cmp	edx, DWORD PTR $T236354[ebp]
	jge	SHORT $LN2@GetWeightT

; 4318 : 	{
; 4319 : 		FlavorTypes eFlavor = (FlavorTypes) iFlavorLoop;

	mov	eax, DWORD PTR _iFlavorLoop$227344[ebp]
	mov	DWORD PTR _eFlavor$227348[ebp], eax

; 4320 : 		int iPersonalityFlavor = pkFlavorManager->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR _eFlavor$227348[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkFlavorManager$[ebp]
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iPersonalityFlavor$227350[ebp], eax

; 4321 : 		CvMilitaryAIStrategyXMLEntry* pkEntry = pkAIStrategies->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkAIStrategies$[ebp]
	call	?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ; CvMilitaryAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pkEntry$227351[ebp], eax

; 4322 : 		CvAssert(pkEntry != NULL);
; 4323 : 		if(pkEntry)

	cmp	DWORD PTR _pkEntry$227351[ebp], 0
	je	SHORT $LN1@GetWeightT

; 4324 : 		{
; 4325 : 			int iStrategyFlavorMod = pkEntry->GetPersonalityFlavorThresholdMod(eFlavor);

	mov	eax, DWORD PTR _eFlavor$227348[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkEntry$227351[ebp]
	call	?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
	mov	DWORD PTR _iStrategyFlavorMod$227353[ebp], eax

; 4326 : 
; 4327 : 			iWeightThresholdModifier += (iPersonalityFlavor * iStrategyFlavorMod);

	mov	ecx, DWORD PTR _iPersonalityFlavor$227350[ebp]
	imul	ecx, DWORD PTR _iStrategyFlavorMod$227353[ebp]
	add	ecx, DWORD PTR _iWeightThresholdModifier$[ebp]
	mov	DWORD PTR _iWeightThresholdModifier$[ebp], ecx
$LN1@GetWeightT:

; 4328 : 		}
; 4329 : 	}

	jmp	SHORT $LN3@GetWeightT
$LN2@GetWeightT:

; 4330 : 
; 4331 : 	return iWeightThresholdModifier;

	mov	eax, DWORD PTR _iWeightThresholdModifier$[ebp]

; 4332 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::GetWeightThresholdModifier
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236361 = -20						; size = 4
$T236360 = -16						; size = 4
_bInDeficit$ = -9					; size = 1
_eConquestGrandStrategy$ = -8				; size = 4
_eStrategyLosingMoney$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits, COMDAT

; 4336 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4337 : 	// Are we running at a deficit?
; 4338 : 	EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");

	push	0
	push	OFFSET ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyLosingMoney$[ebp], eax

; 4339 : 	bool bInDeficit = pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	eax, DWORD PTR _eStrategyLosingMoney$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	mov	BYTE PTR _bInDeficit$[ebp], al

; 4340 : 
; 4341 : 	// Are we running anything other than the Conquest Grand Strategy?
; 4342 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eConquestGrandStrategy$[ebp], eax

; 4343 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eConquestGrandStrategy$[ebp], -1
	je	SHORT $LN5@IsTestStra

; 4344 : 	{
; 4345 : 		if(bInDeficit || pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() != eConquestGrandStrategy || pPlayer->GetMilitaryAI()->GetPercentOfRecommendedMilitarySize() > 125)

	movzx	ecx, BYTE PTR _bInDeficit$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@IsTestStra
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eConquestGrandStrategy$[ebp]
	jne	SHORT $LN3@IsTestStra
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize
	cmp	eax, 125				; 0000007dH
	jle	SHORT $LN4@IsTestStra
$LN3@IsTestStra:

; 4346 : 		{
; 4347 : 			if(pPlayer->GetMilitaryAI()->GetLandDefenseState() == DEFENSE_STATE_ENOUGH)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236360[ebp], eax
	mov	edx, DWORD PTR $T236360[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR $T236361[ebp], eax
	cmp	DWORD PTR $T236361[ebp], 0
	jne	SHORT $LN2@IsTestStra

; 4348 : 			{
; 4349 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@IsTestStra
$LN2@IsTestStra:

; 4350 : 			}
; 4351 : 		}
; 4352 : 		else

	jmp	SHORT $LN5@IsTestStra
$LN4@IsTestStra:

; 4353 : 		{
; 4354 : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsTestStra
$LN5@IsTestStra:

; 4355 : 		}
; 4356 : 	}
; 4357 : 
; 4358 : 	return false;

	xor	al, al
$LN6@IsTestStra:

; 4359 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236368 = -8						; size = 4
$T236367 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense, COMDAT

; 4363 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4364 : 	if(pPlayer->GetMilitaryAI()->GetLandDefenseState() == DEFENSE_STATE_NEEDED)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236367[ebp], eax
	mov	eax, DWORD PTR $T236367[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR $T236368[ebp], ecx
	cmp	DWORD PTR $T236368[ebp], 2
	jne	SHORT $LN1@IsTestStra@2

; 4365 : 	{
; 4366 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@2
$LN1@IsTestStra@2:

; 4367 : 	}
; 4368 : 
; 4369 : 	return false;

	xor	al, al
$LN2@IsTestStra@2:

; 4370 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236375 = -8						; size = 4
$T236374 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical, COMDAT

; 4374 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4375 : 	if(pPlayer->GetMilitaryAI()->GetLandDefenseState() == DEFENSE_STATE_CRITICAL)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236374[ebp], eax
	mov	eax, DWORD PTR $T236374[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR $T236375[ebp], ecx
	cmp	DWORD PTR $T236375[ebp], 3
	jne	SHORT $LN1@IsTestStra@3

; 4376 : 	{
; 4377 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@3
$LN1@IsTestStra@3:

; 4378 : 	}
; 4379 : 
; 4380 : 	return false;

	xor	al, al
$LN2@IsTestStra@3:

; 4381 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236382 = -8						; size = 4
$T236381 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits, COMDAT

; 4385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4386 : 	if(pPlayer->GetMilitaryAI()->GetNavalDefenseState() == DEFENSE_STATE_ENOUGH)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236381[ebp], eax
	mov	eax, DWORD PTR $T236381[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T236382[ebp], ecx
	cmp	DWORD PTR $T236382[ebp], 0
	jne	SHORT $LN1@IsTestStra@4

; 4387 : 	{
; 4388 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@4
$LN1@IsTestStra@4:

; 4389 : 	}
; 4390 : 
; 4391 : 	return false;

	xor	al, al
$LN2@IsTestStra@4:

; 4392 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236389 = -8						; size = 4
$T236388 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits, COMDAT

; 4396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4397 : 	if(pPlayer->GetMilitaryAI()->GetNavalDefenseState() == DEFENSE_STATE_NEEDED)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236388[ebp], eax
	mov	eax, DWORD PTR $T236388[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T236389[ebp], ecx
	cmp	DWORD PTR $T236389[ebp], 2
	jne	SHORT $LN1@IsTestStra@5

; 4398 : 	{
; 4399 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@5
$LN1@IsTestStra@5:

; 4400 : 	}
; 4401 : 
; 4402 : 	return false;

	xor	al, al
$LN2@IsTestStra@5:

; 4403 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236396 = -8						; size = 4
$T236395 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical, COMDAT

; 4407 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4408 : 	if(pPlayer->GetMilitaryAI()->GetNavalDefenseState() == DEFENSE_STATE_CRITICAL)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236395[ebp], eax
	mov	eax, DWORD PTR $T236395[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T236396[ebp], ecx
	cmp	DWORD PTR $T236396[ebp], 3
	jne	SHORT $LN1@IsTestStra@6

; 4409 : 	{
; 4410 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@6
$LN1@IsTestStra@6:

; 4411 : 	}
; 4412 : 
; 4413 : 	return false;

	xor	al, al
$LN2@IsTestStra@6:

; 4414 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical
_TEXT	ENDS
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236403 = -40						; size = 4
$T236402 = -36						; size = 4
_iWeightThreshold$227417 = -32				; size = 4
_iMajorLoop$227402 = -28				; size = 4
_eOtherPlayer$ = -24					; size = 4
_eStrategyAtWar$ = -20					; size = 4
_eConquestGrandStrategy$ = -16				; size = 4
_iCurrentWeight$ = -12					; size = 4
_pStrategy$ = -8					; size = 4
_pkDiplomacyAI$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_WarMobilization, COMDAT

; 4418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 4419 : 	int iCurrentWeight = 0;

	mov	DWORD PTR _iCurrentWeight$[ebp], 0

; 4420 : 	PlayerTypes eOtherPlayer;
; 4421 : 
; 4422 : 	// If we're at war don't bother with this Strategy
; 4423 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 4424 : 
; 4425 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$[ebp], -1
	je	SHORT $LN17@IsTestStra@7

; 4426 : 	{
; 4427 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	eax, DWORD PTR _eStrategyAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@IsTestStra@7

; 4428 : 		{
; 4429 : 			return false;

	xor	al, al
	jmp	$LN18@IsTestStra@7
$LN17@IsTestStra@7:

; 4430 : 		}
; 4431 : 	}
; 4432 : 
; 4433 : 	// Are we running the Conquest Grand Strategy?
; 4434 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eConquestGrandStrategy$[ebp], eax

; 4435 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eConquestGrandStrategy$[ebp], -1
	je	SHORT $LN15@IsTestStra@7

; 4436 : 	{
; 4437 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eConquestGrandStrategy$[ebp]
	jne	SHORT $LN15@IsTestStra@7

; 4438 : 		{
; 4439 : 			iCurrentWeight += 25;

	mov	edx, DWORD PTR _iCurrentWeight$[ebp]
	add	edx, 25					; 00000019H
	mov	DWORD PTR _iCurrentWeight$[ebp], edx
$LN15@IsTestStra@7:

; 4440 : 		}
; 4441 : 	}
; 4442 : 
; 4443 : 	CvDiplomacyAI* pkDiplomacyAI = pPlayer->GetDiplomacyAI();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pkDiplomacyAI$[ebp], eax

; 4444 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	DWORD PTR _iMajorLoop$227402[ebp], 0
	jmp	SHORT $LN13@IsTestStra@7
$LN12@IsTestStra@7:
	mov	eax, DWORD PTR _iMajorLoop$227402[ebp]
	add	eax, 1
	mov	DWORD PTR _iMajorLoop$227402[ebp], eax
$LN13@IsTestStra@7:
	cmp	DWORD PTR _iMajorLoop$227402[ebp], 22	; 00000016H
	jge	$LN11@IsTestStra@7

; 4445 : 	{
; 4446 : 		eOtherPlayer = (PlayerTypes) iMajorLoop;

	mov	ecx, DWORD PTR _iMajorLoop$227402[ebp]
	mov	DWORD PTR _eOtherPlayer$[ebp], ecx

; 4447 : 
; 4448 : 		// Mobilize for war is automatic if we are preparing a sneak attack
; 4449 : 		if(pkDiplomacyAI->GetWarGoal(eOtherPlayer) == WAR_GOAL_PREPARE || pPlayer->GetMilitaryAI()->GetArmyBeingBuilt() != NO_ARMY_TYPE)

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkDiplomacyAI$[ebp]
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 1
	je	SHORT $LN9@IsTestStra@7
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236402[ebp], eax
	mov	eax, DWORD PTR $T236402[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T236403[ebp], ecx
	cmp	DWORD PTR $T236403[ebp], -1
	je	SHORT $LN10@IsTestStra@7
$LN9@IsTestStra@7:

; 4450 : 		{
; 4451 : 			iCurrentWeight += 100;

	mov	edx, DWORD PTR _iCurrentWeight$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _iCurrentWeight$[ebp], edx

; 4452 : 		}
; 4453 : 
; 4454 : 		// Add in weight for each civ we're on really bad terms with
; 4455 : 		else if(pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR ||

	jmp	SHORT $LN8@IsTestStra@7
$LN10@IsTestStra@7:

; 4456 : 		        pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_HOSTILE ||
; 4457 : 		        pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_AFRAID)

	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkDiplomacyAI$[ebp]
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	test	eax, eax
	je	SHORT $LN6@IsTestStra@7
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkDiplomacyAI$[ebp]
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 1
	je	SHORT $LN6@IsTestStra@7
	push	0
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkDiplomacyAI$[ebp]
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 4
	jne	SHORT $LN7@IsTestStra@7
$LN6@IsTestStra@7:

; 4458 : 		{
; 4459 : 			iCurrentWeight += 50;

	mov	eax, DWORD PTR _iCurrentWeight$[ebp]
	add	eax, 50					; 00000032H
	mov	DWORD PTR _iCurrentWeight$[ebp], eax

; 4460 : 		}
; 4461 : 
; 4462 : 		// And some if on fairly bad terms
; 4463 : 		// Add in weight for each civ we're on really bad terms with
; 4464 : 		else if(pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_GUARDED ||

	jmp	SHORT $LN8@IsTestStra@7
$LN7@IsTestStra@7:

; 4465 : 		        pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_DECEPTIVE)

	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkDiplomacyAI$[ebp]
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 3
	je	SHORT $LN3@IsTestStra@7
	push	0
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkDiplomacyAI$[ebp]
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 2
	jne	SHORT $LN8@IsTestStra@7
$LN3@IsTestStra@7:

; 4466 : 		{
; 4467 : 			iCurrentWeight += 25;

	mov	eax, DWORD PTR _iCurrentWeight$[ebp]
	add	eax, 25					; 00000019H
	mov	DWORD PTR _iCurrentWeight$[ebp], eax
$LN8@IsTestStra@7:

; 4468 : 		}
; 4469 : 	}

	jmp	$LN12@IsTestStra@7
$LN11@IsTestStra@7:

; 4470 : 
; 4471 : 	CvMilitaryAIStrategyXMLEntry* pStrategy = pPlayer->GetMilitaryAI()->GetMilitaryAIStrategies()->GetEntry(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ; CvMilitaryAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 4472 : 	CvAssert(pStrategy != NULL);
; 4473 : 	if(pStrategy)

	cmp	DWORD PTR _pStrategy$[ebp], 0
	je	SHORT $LN2@IsTestStra@7

; 4474 : 	{
; 4475 : 		int iWeightThreshold = pStrategy->GetWeightThreshold();	// 100

	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold
	mov	DWORD PTR _iWeightThreshold$227417[ebp], eax

; 4476 : 		if(iCurrentWeight >= iWeightThreshold)

	mov	edx, DWORD PTR _iCurrentWeight$[ebp]
	cmp	edx, DWORD PTR _iWeightThreshold$227417[ebp]
	jl	SHORT $LN2@IsTestStra@7

; 4477 : 		{
; 4478 : 			return true;

	mov	al, 1
	jmp	SHORT $LN18@IsTestStra@7
$LN2@IsTestStra@7:

; 4479 : 		}
; 4480 : 	}
; 4481 : 
; 4482 : 	return false;

	xor	al, al
$LN18@IsTestStra@7:

; 4483 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_WarMobilization
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_AtWar, COMDAT

; 4487 : {

	push	ebp
	mov	ebp, esp

; 4488 : 	return (pPlayer->GetMilitaryAI()->GetNumberCivsAtWarWith() > 0);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberCivsAtWarWith
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 4489 : }

	pop	ebp
	ret	0
?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_AtWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ
_TEXT	SEGMENT
?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ PROC ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense, COMDAT

; 4493 : {

	push	ebp
	mov	ebp, esp

; 4494 : 	return true;

	mov	al, 1

; 4495 : }

	pop	ebp
	ret	0
?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ ENDP ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense
_TEXT	ENDS
EXTRN	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ:PROC ; CvMinorCivAI::GetStatus
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated, COMDAT

; 4499 : {

	push	ebp
	mov	ebp, esp

; 4500 : 	if(pPlayer->GetMinorCivAI()->GetStatus() == MINOR_CIV_STATUS_ELEVATED)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ ; CvMinorCivAI::GetStatus
	cmp	eax, 1
	jne	SHORT $LN1@IsTestStra@8

; 4501 : 	{
; 4502 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@8
$LN1@IsTestStra@8:

; 4503 : 	}
; 4504 : 
; 4505 : 	return false;

	xor	al, al
$LN2@IsTestStra@8:

; 4506 : }

	pop	ebp
	ret	0
?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical, COMDAT

; 4510 : {

	push	ebp
	mov	ebp, esp

; 4511 : 	if(pPlayer->GetMinorCivAI()->GetStatus() == MINOR_CIV_STATUS_CRITICAL)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ ; CvMinorCivAI::GetStatus
	cmp	eax, 2
	jne	SHORT $LN1@IsTestStra@9

; 4512 : 	{
; 4513 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@9
$LN1@IsTestStra@9:

; 4514 : 	}
; 4515 : 
; 4516 : 	return false;

	xor	al, al
$LN2@IsTestStra@9:

; 4517 : }

	pop	ebp
	ret	0
?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z
_TEXT	SEGMENT
$T236425 = -48						; size = 4
_iMajorLoop$227462 = -44				; size = 4
_pkDiplomacyAI$227461 = -40				; size = 4
_iWeightThresholdModifier$227456 = -36			; size = 4
_iWeightThreshold$227457 = -32				; size = 4
_iStrategyWeight$ = -28					; size = 4
_eOtherPlayer$ = -24					; size = 4
_eStrategyAtWar$ = -20					; size = 4
_pLoopUnit$ = -16					; size = 4
_pStrategy$ = -12					; size = 4
_BarbPlayer$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_iBarbarianCampCount$ = 16				; size = 4
_iVisibleBarbarianCount$ = 20				; size = 4
?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians, COMDAT

; 4521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 4522 : 	int iStrategyWeight;
; 4523 : 	PlayerTypes eOtherPlayer;
; 4524 : 
; 4525 : 	// If we're at war don't bother with this Strategy (unless it is clear we are already winning)
; 4526 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 4527 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$[ebp], -1
	je	SHORT $LN21@IsTestStra@10

; 4528 : 	{
; 4529 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	eax, DWORD PTR _eStrategyAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@IsTestStra@10

; 4530 : 		{
; 4531 : 			if(!pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	neg	eax
	sbb	eax, eax
	add	eax, 1
	cmp	eax, 1
	jne	SHORT $LN21@IsTestStra@10

; 4532 : 			{
; 4533 : 				return false;

	xor	al, al
	jmp	$LN19@IsTestStra@10

; 4534 : 			}
; 4535 : 		}
; 4536 : 	}
; 4537 : 
; 4538 : 	// We ARE getting our guys back
; 4539 : 	CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

$LN21@IsTestStra@10:
	mov	edx, 63					; 0000003fH
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _BarbPlayer$[ebp], edx

; 4540 : 	CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 4541 : 	int iLoop;
; 4542 : 	for (pLoopUnit = BarbPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _BarbPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN15@IsTestStra@10
$LN14@IsTestStra@10:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _BarbPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN15@IsTestStra@10:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN13@IsTestStra@10

; 4543 : 	{
; 4544 : 		if (pLoopUnit->GetOriginalOwner() == pPlayer->GetID() && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER))

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T236425[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	cmp	eax, DWORD PTR $T236425[ebp]
	jne	SHORT $LN12@IsTestStra@10
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	SHORT $LN11@IsTestStra@10
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN12@IsTestStra@10
$LN11@IsTestStra@10:

; 4545 : 		{
; 4546 : 			return true;

	mov	al, 1
	jmp	$LN19@IsTestStra@10
$LN12@IsTestStra@10:

; 4547 : 		}
; 4548 : 	}

	jmp	SHORT $LN14@IsTestStra@10
$LN13@IsTestStra@10:

; 4549 : 
; 4550 : 	CvMilitaryAIStrategyXMLEntry* pStrategy = pPlayer->GetMilitaryAI()->GetMilitaryAIStrategies()->GetEntry(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ; CvMilitaryAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 4551 : 	CvAssert(pStrategy != NULL);
; 4552 : 	if(pStrategy)

	cmp	DWORD PTR _pStrategy$[ebp], 0
	je	$LN10@IsTestStra@10

; 4553 : 	{
; 4554 : 		iStrategyWeight = iBarbarianCampCount * 50 + iVisibleBarbarianCount * 25;   // Two visible camps or 3 roving Barbarians will trigger this

	mov	edx, DWORD PTR _iBarbarianCampCount$[ebp]
	imul	edx, 50					; 00000032H
	mov	eax, DWORD PTR _iVisibleBarbarianCount$[ebp]
	imul	eax, 25					; 00000019H
	add	edx, eax
	mov	DWORD PTR _iStrategyWeight$[ebp], edx

; 4555 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	call	?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$227456[ebp], eax

; 4556 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;

	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$227456[ebp]
	mov	DWORD PTR _iWeightThreshold$227457[ebp], eax

; 4557 : 
; 4558 : 		if(iStrategyWeight >= iWeightThreshold * 2 && iVisibleBarbarianCount > 0) // barbs are a big threat, our sneak attack plan can wait

	mov	eax, DWORD PTR _iWeightThreshold$227457[ebp]
	shl	eax, 1
	cmp	DWORD PTR _iStrategyWeight$[ebp], eax
	jl	SHORT $LN9@IsTestStra@10
	cmp	DWORD PTR _iVisibleBarbarianCount$[ebp], 0
	jle	SHORT $LN9@IsTestStra@10

; 4559 : 		{
; 4560 : 			return true;

	mov	al, 1
	jmp	SHORT $LN19@IsTestStra@10
	jmp	SHORT $LN10@IsTestStra@10
$LN9@IsTestStra@10:

; 4561 : 		}
; 4562 : 		else if(iStrategyWeight >= iWeightThreshold)

	mov	ecx, DWORD PTR _iStrategyWeight$[ebp]
	cmp	ecx, DWORD PTR _iWeightThreshold$227457[ebp]
	jl	SHORT $LN7@IsTestStra@10

; 4563 : 		{
; 4564 : 			// Also don't bother if we're building up for a sneak attack
; 4565 : 			CvDiplomacyAI* pkDiplomacyAI = pPlayer->GetDiplomacyAI();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pkDiplomacyAI$227461[ebp], eax

; 4566 : 			for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	DWORD PTR _iMajorLoop$227462[ebp], 0
	jmp	SHORT $LN6@IsTestStra@10
$LN5@IsTestStra@10:
	mov	edx, DWORD PTR _iMajorLoop$227462[ebp]
	add	edx, 1
	mov	DWORD PTR _iMajorLoop$227462[ebp], edx
$LN6@IsTestStra@10:
	cmp	DWORD PTR _iMajorLoop$227462[ebp], 22	; 00000016H
	jge	SHORT $LN4@IsTestStra@10

; 4567 : 			{
; 4568 : 				eOtherPlayer = (PlayerTypes) iMajorLoop;

	mov	eax, DWORD PTR _iMajorLoop$227462[ebp]
	mov	DWORD PTR _eOtherPlayer$[ebp], eax

; 4569 : 				if(pkDiplomacyAI->GetWarGoal(eOtherPlayer) == WAR_GOAL_PREPARE)

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkDiplomacyAI$227461[ebp]
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 1
	jne	SHORT $LN3@IsTestStra@10

; 4570 : 				{
; 4571 : 					return false;

	xor	al, al
	jmp	SHORT $LN19@IsTestStra@10
$LN3@IsTestStra@10:

; 4572 : 				}
; 4573 : 			}

	jmp	SHORT $LN5@IsTestStra@10
$LN4@IsTestStra@10:

; 4574 : 
; 4575 : 			return true;

	mov	al, 1
	jmp	SHORT $LN19@IsTestStra@10
	jmp	SHORT $LN10@IsTestStra@10
$LN7@IsTestStra@10:

; 4576 : 		}
; 4577 : 		// If we have an operation of this type running, we don't want to turn this strategy off
; 4578 : 		else if(pPlayer->haveAIOperationOfType(AI_OPERATION_DESTROY_BARBARIAN_CAMP))

	push	0
	push	-1
	push	0
	push	3
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@IsTestStra@10

; 4579 : 		{
; 4580 : 			return true;

	mov	al, 1
	jmp	SHORT $LN19@IsTestStra@10
$LN10@IsTestStra@10:

; 4581 : 		}
; 4582 : 	}
; 4583 : 
; 4584 : 	return false;

	xor	al, al
$LN19@IsTestStra@10:

; 4585 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_WinningWars, COMDAT

; 4589 : {

	push	ebp
	mov	ebp, esp

; 4590 : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN1@IsTestStra@11

; 4591 : 	{
; 4592 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@11
$LN1@IsTestStra@11:

; 4593 : 	}
; 4594 : 	return false;

	xor	al, al
$LN2@IsTestStra@11:

; 4595 : }

	pop	ebp
	ret	0
?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_WinningWars
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_LosingWars, COMDAT

; 4599 : {

	push	ebp
	mov	ebp, esp

; 4600 : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	SHORT $LN1@IsTestStra@12

; 4601 : 	{
; 4602 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@12
$LN1@IsTestStra@12:

; 4603 : 	}
; 4604 : 	return false;

	xor	al, al
$LN2@IsTestStra@12:

; 4605 : }

	pop	ebp
	ret	0
?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_LosingWars
_TEXT	ENDS
PUBLIC	??_C@_0O@EHNMEILB@FLAVOR_RANGED?$AA@		; `string'
;	COMDAT ??_C@_0O@EHNMEILB@FLAVOR_RANGED?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0O@EHNMEILB@FLAVOR_RANGED?$AA@ DB 'FLAVOR_RANGED', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv83 = -24						; size = 4
$T236440 = -20						; size = 4
$T236433 = -16						; size = 4
$T236432 = -12						; size = 4
_iRatio$ = -8						; size = 4
_iFlavorRange$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_iNumRanged$ = 12					; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits, COMDAT

; 4609 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4610 : 	int iFlavorRange = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RANGED"));

	push	0
	push	OFFSET ??_C@_0O@EHNMEILB@FLAVOR_RANGED?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorRange$[ebp], eax

; 4611 : 	int iRatio = iNumRanged * 10 / max(1,iNumMelee+iNumRanged);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumRanged$[ebp]
	mov	DWORD PTR $T236432[ebp], eax
	mov	DWORD PTR $T236433[ebp], 1
	mov	ecx, DWORD PTR $T236433[ebp]
	cmp	ecx, DWORD PTR $T236432[ebp]
	jge	SHORT $LN5@IsTestStra@13
	lea	edx, DWORD PTR $T236432[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN6@IsTestStra@13
$LN5@IsTestStra@13:
	lea	eax, DWORD PTR $T236433[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN6@IsTestStra@13:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T236440[ebp], ecx
	mov	eax, DWORD PTR _iNumRanged$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236440[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], eax

; 4612 : 	return (iRatio >= iFlavorRange);

	mov	edx, DWORD PTR _iRatio$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _iFlavorRange$[ebp]
	setge	al

; 4613 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
$T236453 = -20						; size = 4
$T236446 = -16						; size = 4
$T236445 = -12						; size = 4
_iRatio$ = -8						; size = 4
_iFlavorRange$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_iNumRanged$ = 12					; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits, COMDAT

; 4617 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4618 : 	int iFlavorRange = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RANGED"));

	push	0
	push	OFFSET ??_C@_0O@EHNMEILB@FLAVOR_RANGED?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorRange$[ebp], eax

; 4619 : 	int iRatio = iNumRanged * 10 / max(1,iNumMelee+iNumRanged);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumRanged$[ebp]
	mov	DWORD PTR $T236445[ebp], eax
	mov	DWORD PTR $T236446[ebp], 1
	mov	ecx, DWORD PTR $T236446[ebp]
	cmp	ecx, DWORD PTR $T236445[ebp]
	jge	SHORT $LN5@IsTestStra@14
	lea	edx, DWORD PTR $T236445[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN6@IsTestStra@14
$LN5@IsTestStra@14:
	lea	eax, DWORD PTR $T236446[ebp]
	mov	DWORD PTR tv84[ebp], eax
$LN6@IsTestStra@14:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR $T236453[ebp], ecx
	mov	eax, DWORD PTR _iNumRanged$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236453[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], eax

; 4620 : 	return (iRatio <= iFlavorRange / 2);

	mov	eax, DWORD PTR _iFlavorRange$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	cmp	DWORD PTR _iRatio$[ebp], eax
	setle	dl
	mov	al, dl

; 4621 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_eStrategyWarMob$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack, COMDAT

; 4625 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4626 : 	MilitaryAIStrategyTypes eStrategyWarMob = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_WAR_MOBILIZATION");

	push	0
	push	OFFSET ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyWarMob$[ebp], eax

; 4627 : 	if(eStrategyWarMob != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyWarMob$[ebp], -1
	je	SHORT $LN2@IsTestStra@15

; 4628 : 	{
; 4629 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyWarMob))

	mov	eax, DWORD PTR _eStrategyWarMob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsTestStra@15

; 4630 : 		{
; 4631 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@15
$LN2@IsTestStra@15:

; 4632 : 		}
; 4633 : 	}
; 4634 : 	return false;

	xor	al, al
$LN3@IsTestStra@15:

; 4635 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack
_TEXT	ENDS
PUBLIC	??_C@_0O@NPKFFFBK@FLAVOR_MOBILE?$AA@		; `string'
;	COMDAT ??_C@_0O@NPKFFFBK@FLAVOR_MOBILE?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0O@NPKFFFBK@FLAVOR_MOBILE?$AA@ DB 'FLAVOR_MOBILE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv83 = -24						; size = 4
$T236468 = -20						; size = 4
$T236461 = -16						; size = 4
$T236460 = -12						; size = 4
_iFlavorMobile$ = -8					; size = 4
_iRatio$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
_iNumMobile$ = 12					; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits, COMDAT

; 4639 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4640 : 	int iFlavorMobile = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_MOBILE"));

	push	0
	push	OFFSET ??_C@_0O@NPKFFFBK@FLAVOR_MOBILE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorMobile$[ebp], eax

; 4641 : 	int iRatio = iNumMobile * 10 / max(1,iNumMelee+iNumMobile);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumMobile$[ebp]
	mov	DWORD PTR $T236460[ebp], eax
	mov	DWORD PTR $T236461[ebp], 1
	mov	ecx, DWORD PTR $T236461[ebp]
	cmp	ecx, DWORD PTR $T236460[ebp]
	jge	SHORT $LN5@IsTestStra@16
	lea	edx, DWORD PTR $T236460[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN6@IsTestStra@16
$LN5@IsTestStra@16:
	lea	eax, DWORD PTR $T236461[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN6@IsTestStra@16:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T236468[ebp], ecx
	mov	eax, DWORD PTR _iNumMobile$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236468[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], eax

; 4642 : 	return (iRatio >= iFlavorMobile);

	mov	edx, DWORD PTR _iRatio$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _iFlavorMobile$[ebp]
	setge	al

; 4643 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
$T236481 = -20						; size = 4
$T236474 = -16						; size = 4
$T236473 = -12						; size = 4
_iFlavorMobile$ = -8					; size = 4
_iRatio$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
_iNumMobile$ = 12					; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits, COMDAT

; 4647 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4648 : 	int iFlavorMobile = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_MOBILE"));

	push	0
	push	OFFSET ??_C@_0O@NPKFFFBK@FLAVOR_MOBILE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorMobile$[ebp], eax

; 4649 : 	int iRatio = iNumMobile * 10 / max(1,iNumMelee+iNumMobile);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumMobile$[ebp]
	mov	DWORD PTR $T236473[ebp], eax
	mov	DWORD PTR $T236474[ebp], 1
	mov	ecx, DWORD PTR $T236474[ebp]
	cmp	ecx, DWORD PTR $T236473[ebp]
	jge	SHORT $LN5@IsTestStra@17
	lea	edx, DWORD PTR $T236473[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN6@IsTestStra@17
$LN5@IsTestStra@17:
	lea	eax, DWORD PTR $T236474[ebp]
	mov	DWORD PTR tv84[ebp], eax
$LN6@IsTestStra@17:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR $T236481[ebp], ecx
	mov	eax, DWORD PTR _iNumMobile$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236481[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], eax

; 4650 : 	return (iRatio <= iFlavorMobile / 2);

	mov	eax, DWORD PTR _iFlavorMobile$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	cmp	DWORD PTR _iRatio$[ebp], eax
	setle	dl
	mov	al, dl

; 4651 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits
_TEXT	ENDS
PUBLIC	??_C@_0L@OJILNFCD@FLAVOR_AIR?$AA@		; `string'
;	COMDAT ??_C@_0L@OJILNFCD@FLAVOR_AIR?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0L@OJILNFCD@FLAVOR_AIR?$AA@ DB 'FLAVOR_AIR', 00H	; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv83 = -24						; size = 4
$T236494 = -20						; size = 4
$T236487 = -16						; size = 4
$T236486 = -12						; size = 4
_iFlavorAir$ = -8					; size = 4
_iRatio$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
_iNumAir$ = 12						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits, COMDAT

; 4655 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4656 : 	int iFlavorAir = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_AIR"));

	push	0
	push	OFFSET ??_C@_0L@OJILNFCD@FLAVOR_AIR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorAir$[ebp], eax

; 4657 : 	int iRatio = iNumAir * 10 / max(1,iNumMelee+iNumAir);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumAir$[ebp]
	mov	DWORD PTR $T236486[ebp], eax
	mov	DWORD PTR $T236487[ebp], 1
	mov	ecx, DWORD PTR $T236487[ebp]
	cmp	ecx, DWORD PTR $T236486[ebp]
	jge	SHORT $LN5@IsTestStra@18
	lea	edx, DWORD PTR $T236486[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN6@IsTestStra@18
$LN5@IsTestStra@18:
	lea	eax, DWORD PTR $T236487[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN6@IsTestStra@18:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T236494[ebp], ecx
	mov	eax, DWORD PTR _iNumAir$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236494[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], eax

; 4658 : 	return (iRatio >= iFlavorAir);

	mov	edx, DWORD PTR _iRatio$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _iFlavorAir$[ebp]
	setge	al

; 4659 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
$T236507 = -20						; size = 4
$T236500 = -16						; size = 4
$T236499 = -12						; size = 4
_iFlavorAir$ = -8					; size = 4
_iRatio$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
_iNumAir$ = 12						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits, COMDAT

; 4663 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4664 : 	int iFlavorAir = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_AIR"));

	push	0
	push	OFFSET ??_C@_0L@OJILNFCD@FLAVOR_AIR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorAir$[ebp], eax

; 4665 : 	int iRatio = iNumAir * 10 / max(1,iNumMelee+iNumAir);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumAir$[ebp]
	mov	DWORD PTR $T236499[ebp], eax
	mov	DWORD PTR $T236500[ebp], 1
	mov	ecx, DWORD PTR $T236500[ebp]
	cmp	ecx, DWORD PTR $T236499[ebp]
	jge	SHORT $LN5@IsTestStra@19
	lea	edx, DWORD PTR $T236499[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN6@IsTestStra@19
$LN5@IsTestStra@19:
	lea	eax, DWORD PTR $T236500[ebp]
	mov	DWORD PTR tv84[ebp], eax
$LN6@IsTestStra@19:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR $T236507[ebp], ecx
	mov	eax, DWORD PTR _iNumAir$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236507[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$[ebp], eax

; 4666 : 	return (iRatio <= iFlavorAir / 2);

	mov	eax, DWORD PTR _iFlavorAir$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	cmp	DWORD PTR _iRatio$[ebp], eax
	setle	dl
	mov	al, dl

; 4667 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits
_TEXT	ENDS
PUBLIC	??_C@_0M@KEOIKGOO@FLAVOR_NUKE?$AA@		; `string'
EXTRN	?isNoNukes@CvGame@@QBE_NXZ:PROC			; CvGame::isNoNukes
;	COMDAT ??_C@_0M@KEOIKGOO@FLAVOR_NUKE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0M@KEOIKGOO@FLAVOR_NUKE?$AA@ DB 'FLAVOR_NUKE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236515 = -12						; size = 4
_iNumNukes$ = -8					; size = 4
_iFlavorNuke$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedANuke, COMDAT

; 4671 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4672 : 	if(GC.getGame().isNoNukes())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236515[ebp], eax
	mov	ecx, DWORD PTR $T236515[ebp]
	call	?isNoNukes@CvGame@@QBE_NXZ		; CvGame::isNoNukes
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@IsTestStra@20

; 4673 : 	{
; 4674 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@IsTestStra@20
$LN1@IsTestStra@20:

; 4675 : 	}
; 4676 : 
; 4677 : 	int iFlavorNuke = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NUKE"));

	push	0
	push	OFFSET ??_C@_0M@KEOIKGOO@FLAVOR_NUKE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorNuke$[ebp], eax

; 4678 : 	int iNumNukes = pPlayer->getNumNukeUnits();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	mov	DWORD PTR _iNumNukes$[ebp], eax

; 4679 : 
; 4680 : 	return (iNumNukes < iFlavorNuke / 3);

	mov	eax, DWORD PTR _iFlavorNuke$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	xor	edx, edx
	cmp	DWORD PTR _iNumNukes$[ebp], eax
	setl	dl
	mov	al, dl
$LN2@IsTestStra@20:

; 4681 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedANuke
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv139 = -44						; size = 4
$T236543 = -40						; size = 4
$T236536 = -36						; size = 4
$T236532 = -32						; size = 4
$T236528 = -28						; size = 4
$T236519 = -24						; size = 4
$T236518 = -20						; size = 4
_iRatio$227571 = -16					; size = 4
_iPlayerLoop$227563 = -12				; size = 4
_bAnyAirforce$ = -5					; size = 1
_eLoopPlayer$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_iNumAA$ = 12						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits, COMDAT

; 4685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 4686 : 	bool bAnyAirforce = false;

	mov	BYTE PTR _bAnyAirforce$[ebp], 0

; 4687 : 	PlayerTypes eLoopPlayer;
; 4688 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$227563[ebp], 0
	jmp	SHORT $LN7@IsTestStra@21
$LN6@IsTestStra@21:
	mov	eax, DWORD PTR _iPlayerLoop$227563[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$227563[ebp], eax
$LN7@IsTestStra@21:
	cmp	DWORD PTR _iPlayerLoop$227563[ebp], 22	; 00000016H
	jge	SHORT $LN5@IsTestStra@21

; 4689 : 	{
; 4690 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$227563[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 4691 : 		if(eLoopPlayer != pPlayer->GetID() && pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T236528[ebp], eax
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	ecx, DWORD PTR $T236528[ebp]
	je	SHORT $LN4@IsTestStra@21
	push	0
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsTestStra@21

; 4692 : 		{
; 4693 : 			if(GET_PLAYER(eLoopPlayer).GetMilitaryAI()->HasAirforce())

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236532[ebp], ecx
	mov	ecx, DWORD PTR $T236532[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236536[ebp], eax
	mov	edx, DWORD PTR $T236536[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+80], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsTestStra@21

; 4694 : 			{
; 4695 : 				bAnyAirforce = true;

	mov	BYTE PTR _bAnyAirforce$[ebp], 1

; 4696 : 				break;

	jmp	SHORT $LN5@IsTestStra@21
$LN4@IsTestStra@21:

; 4697 : 			}
; 4698 : 		}
; 4699 : 	}

	jmp	SHORT $LN6@IsTestStra@21
$LN5@IsTestStra@21:

; 4700 : 
; 4701 : 	if(bAnyAirforce)

	movzx	edx, BYTE PTR _bAnyAirforce$[ebp]
	test	edx, edx
	je	SHORT $LN2@IsTestStra@21

; 4702 : 	{
; 4703 : 		int iRatio = (iNumAA * 10) / max(1,iNumMelee+iNumAA);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumAA$[ebp]
	mov	DWORD PTR $T236518[ebp], eax
	mov	DWORD PTR $T236519[ebp], 1
	mov	ecx, DWORD PTR $T236519[ebp]
	cmp	ecx, DWORD PTR $T236518[ebp]
	jge	SHORT $LN20@IsTestStra@21
	lea	edx, DWORD PTR $T236518[ebp]
	mov	DWORD PTR tv139[ebp], edx
	jmp	SHORT $LN21@IsTestStra@21
$LN20@IsTestStra@21:
	lea	eax, DWORD PTR $T236519[ebp]
	mov	DWORD PTR tv139[ebp], eax
$LN21@IsTestStra@21:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T236543[ebp], ecx
	mov	eax, DWORD PTR _iNumAA$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236543[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$227571[ebp], eax

; 4704 : 		return (iRatio > 2);

	xor	eax, eax
	cmp	DWORD PTR _iRatio$227571[ebp], 2
	setg	al
	jmp	SHORT $LN8@IsTestStra@21

; 4705 : 	}
; 4706 : 	else

	jmp	SHORT $LN8@IsTestStra@21
$LN2@IsTestStra@21:

; 4707 : 	{
; 4708 : 		return true;

	mov	al, 1
$LN8@IsTestStra@21:

; 4709 : 	}
; 4710 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
tv139 = -44						; size = 4
$T236572 = -40						; size = 4
$T236566 = -36						; size = 4
$T236562 = -32						; size = 4
$T236558 = -28						; size = 4
$T236549 = -24						; size = 4
$T236548 = -20						; size = 4
_iRatio$227590 = -16					; size = 4
_iPlayerLoop$227582 = -12				; size = 4
_bAnyAirforce$ = -5					; size = 1
_eLoopPlayer$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_iNumAA$ = 12						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits, COMDAT

; 4714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 4715 : 	bool bAnyAirforce = false;

	mov	BYTE PTR _bAnyAirforce$[ebp], 0

; 4716 : 	PlayerTypes eLoopPlayer;
; 4717 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$227582[ebp], 0
	jmp	SHORT $LN7@IsTestStra@22
$LN6@IsTestStra@22:
	mov	eax, DWORD PTR _iPlayerLoop$227582[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$227582[ebp], eax
$LN7@IsTestStra@22:
	cmp	DWORD PTR _iPlayerLoop$227582[ebp], 22	; 00000016H
	jge	SHORT $LN5@IsTestStra@22

; 4718 : 	{
; 4719 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$227582[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 4720 : 		if(eLoopPlayer != pPlayer->GetID() && pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T236558[ebp], eax
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	ecx, DWORD PTR $T236558[ebp]
	je	SHORT $LN4@IsTestStra@22
	push	0
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsTestStra@22

; 4721 : 		{
; 4722 : 			if(GET_PLAYER(eLoopPlayer).GetMilitaryAI()->HasAirforce())

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236562[ebp], ecx
	mov	ecx, DWORD PTR $T236562[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T236566[ebp], eax
	mov	edx, DWORD PTR $T236566[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+80], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsTestStra@22

; 4723 : 			{
; 4724 : 				bAnyAirforce = true;

	mov	BYTE PTR _bAnyAirforce$[ebp], 1

; 4725 : 				break;

	jmp	SHORT $LN5@IsTestStra@22
$LN4@IsTestStra@22:

; 4726 : 			}
; 4727 : 		}
; 4728 : 	}

	jmp	SHORT $LN6@IsTestStra@22
$LN5@IsTestStra@22:

; 4729 : 
; 4730 : 	if(bAnyAirforce)

	movzx	edx, BYTE PTR _bAnyAirforce$[ebp]
	test	edx, edx
	je	SHORT $LN2@IsTestStra@22

; 4731 : 	{
; 4732 : 		int iRatio = (iNumAA * 10) / max(1,iNumMelee+iNumAA);

	mov	eax, DWORD PTR _iNumMelee$[ebp]
	add	eax, DWORD PTR _iNumAA$[ebp]
	mov	DWORD PTR $T236548[ebp], eax
	mov	DWORD PTR $T236549[ebp], 1
	mov	ecx, DWORD PTR $T236549[ebp]
	cmp	ecx, DWORD PTR $T236548[ebp]
	jge	SHORT $LN20@IsTestStra@22
	lea	edx, DWORD PTR $T236548[ebp]
	mov	DWORD PTR tv139[ebp], edx
	jmp	SHORT $LN21@IsTestStra@22
$LN20@IsTestStra@22:
	lea	eax, DWORD PTR $T236549[ebp]
	mov	DWORD PTR tv139[ebp], eax
$LN21@IsTestStra@22:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T236572[ebp], ecx
	mov	eax, DWORD PTR _iNumAA$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR $T236572[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iRatio$227590[ebp], eax

; 4733 : 		return (iRatio <= 2);

	xor	eax, eax
	cmp	DWORD PTR _iRatio$227590[ebp], 2
	setle	al
	jmp	SHORT $LN8@IsTestStra@22

; 4734 : 	}
; 4735 : 	else

	jmp	SHORT $LN8@IsTestStra@22
$LN2@IsTestStra@22:

; 4736 : 	{
; 4737 : 		return false;

	xor	al, al
$LN8@IsTestStra@22:

; 4738 : 	}
; 4739 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits
_TEXT	ENDS
PUBLIC	??_C@_0BE@OMPPLBNE@SPECIALUNIT_FIGHTER?$AA@	; `string'
EXTRN	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::getSpecialUnitType
EXTRN	?domainCargo@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::domainCargo
EXTRN	?specialCargo@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::specialCargo
EXTRN	?cargoSpace@CvUnit@@QBEHXZ:PROC			; CvUnit::cargoSpace
;	COMDAT ??_C@_0BE@OMPPLBNE@SPECIALUNIT_FIGHTER?$AA@
CONST	SEGMENT
??_C@_0BE@OMPPLBNE@SPECIALUNIT_FIGHTER?$AA@ DB 'SPECIALUNIT_FIGHTER', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iNumLoadableAirUnits$ = -20				; size = 4
_pLoopUnit$ = -16					; size = 4
_iNumTotalCargoSpace$ = -12				; size = 4
_eSpecialUnitPlane$ = -8				; size = 4
_iLoop$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers, COMDAT

; 4743 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4744 : 	int iNumLoadableAirUnits = 0;

	mov	DWORD PTR _iNumLoadableAirUnits$[ebp], 0

; 4745 : 	int iNumTotalCargoSpace = 0;

	mov	DWORD PTR _iNumTotalCargoSpace$[ebp], 0

; 4746 : 	CvUnit* pLoopUnit;
; 4747 : 	int iLoop;
; 4748 : 	SpecialUnitTypes eSpecialUnitPlane = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_FIGHTER");

	push	0
	push	OFFSET ??_C@_0BE@OMPPLBNE@SPECIALUNIT_FIGHTER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eSpecialUnitPlane$[ebp], eax

; 4749 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN13@IsTestStra@23
$LN12@IsTestStra@23:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN13@IsTestStra@23:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN11@IsTestStra@23

; 4750 : 	{
; 4751 : 		// Don't count civilians or exploration units
; 4752 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN10@IsTestStra@23
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN10@IsTestStra@23

; 4753 : 		{
; 4754 : 			if(pLoopUnit->cargoSpace() > 0)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?cargoSpace@CvUnit@@QBEHXZ		; CvUnit::cargoSpace
	test	eax, eax
	jle	SHORT $LN9@IsTestStra@23

; 4755 : 			{
; 4756 : 				if(pLoopUnit->specialCargo() != NO_SPECIALUNIT)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?specialCargo@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::specialCargo
	cmp	eax, -1
	je	SHORT $LN8@IsTestStra@23

; 4757 : 				{
; 4758 : 					if(pLoopUnit->specialCargo() != eSpecialUnitPlane)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?specialCargo@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::specialCargo
	cmp	eax, DWORD PTR _eSpecialUnitPlane$[ebp]
	je	SHORT $LN8@IsTestStra@23

; 4759 : 					{
; 4760 : 						continue;

	jmp	SHORT $LN12@IsTestStra@23
$LN8@IsTestStra@23:

; 4761 : 					}
; 4762 : 				}
; 4763 : 
; 4764 : 				if (pLoopUnit->domainCargo() != NO_DOMAIN)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?domainCargo@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::domainCargo
	cmp	eax, -1
	je	SHORT $LN6@IsTestStra@23

; 4765 : 				{
; 4766 : 					if (pLoopUnit->domainCargo() != DOMAIN_AIR)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?domainCargo@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::domainCargo
	cmp	eax, 1
	je	SHORT $LN6@IsTestStra@23

; 4767 : 					{
; 4768 : 						continue;

	jmp	SHORT $LN12@IsTestStra@23
$LN6@IsTestStra@23:

; 4769 : 					}
; 4770 : 				}
; 4771 : 				iNumTotalCargoSpace += pLoopUnit->cargoSpace();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?cargoSpace@CvUnit@@QBEHXZ		; CvUnit::cargoSpace
	add	eax, DWORD PTR _iNumTotalCargoSpace$[ebp]
	mov	DWORD PTR _iNumTotalCargoSpace$[ebp], eax
	jmp	SHORT $LN10@IsTestStra@23
$LN9@IsTestStra@23:

; 4772 : 			}
; 4773 : 			else if (pLoopUnit->getSpecialUnitType() == eSpecialUnitPlane)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, DWORD PTR _eSpecialUnitPlane$[ebp]
	jne	SHORT $LN10@IsTestStra@23

; 4774 : 			{
; 4775 : 				iNumLoadableAirUnits += 1;

	mov	edx, DWORD PTR _iNumLoadableAirUnits$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumLoadableAirUnits$[ebp], edx
$LN10@IsTestStra@23:

; 4776 : 			}
; 4777 : 		}
; 4778 : 	}

	jmp	$LN12@IsTestStra@23
$LN11@IsTestStra@23:

; 4779 : 
; 4780 : 	if (iNumLoadableAirUnits > iNumTotalCargoSpace)

	mov	eax, DWORD PTR _iNumLoadableAirUnits$[ebp]
	cmp	eax, DWORD PTR _iNumTotalCargoSpace$[ebp]
	jle	SHORT $LN2@IsTestStra@23

; 4781 : 	{
; 4782 : 		return true;

	mov	al, 1
	jmp	SHORT $LN14@IsTestStra@23

; 4783 : 	}
; 4784 : 	else

	jmp	SHORT $LN14@IsTestStra@23
$LN2@IsTestStra@23:

; 4785 : 	{
; 4786 : 		return false;

	xor	al, al
$LN14@IsTestStra@23:

; 4787 : 	}
; 4788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers
_TEXT	ENDS
PUBLIC	??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@ ; `string'
PUBLIC	__real@4044000000000000
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@4010000000000000
EXTRN	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ:PROC	; CvCivilizationInfo::isCoastalCiv
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
;	COMDAT ??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@ DB 'ECONOMICAISTRATE'
	DB	'GY_EXPAND_TO_OTHER_CONTINENTS', 00H		; `string'
CONST	ENDS
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv143 = -76						; size = 4
tv197 = -72						; size = 4
$T236604 = -68						; size = 4
$T236598 = -64						; size = 4
$T236592 = -60						; size = 4
$T236585 = -56						; size = 4
$T236581 = -52						; size = 4
$T236580 = -48						; size = 4
_iNumUnitsWanted$ = -44					; size = 4
_dMultiplier$ = -40					; size = 8
_eStrategyNavalMap$ = -32				; size = 4
_eConquestGrandStrategy$ = -28				; size = 4
_pCity$ = -24						; size = 4
_iGT$ = -20						; size = 4
_iFlavorNaval$ = -16					; size = 4
_iNumCoastalCities$ = -12				; size = 4
_iLoop$ = -8						; size = 4
_eExpandOtherContinents$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::ComputeRecommendedNavySize, COMDAT

; 4794 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 4795 : 	int iNumUnitsWanted = 0;

	mov	DWORD PTR _iNumUnitsWanted$[ebp], 0

; 4796 : 	int iFlavorNaval = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL"));

	push	0
	push	OFFSET ??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorNaval$[ebp], eax

; 4797 : 	// cap at 10?
; 4798 : 
; 4799 : 	double dMultiplier;
; 4800 : 
; 4801 : 	// Start with 1
; 4802 : 	iNumUnitsWanted = 1;

	mov	DWORD PTR _iNumUnitsWanted$[ebp], 1

; 4803 : 
; 4804 : 	int iNumCoastalCities = 0;

	mov	DWORD PTR _iNumCoastalCities$[ebp], 0

; 4805 : 	int iLoop;
; 4806 : 	CvCity* pCity;
; 4807 : 	for(pCity = pPlayer->firstCity(&iLoop); pCity != NULL; pCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN9@ComputeRec
$LN8@ComputeRec:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN9@ComputeRec:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN7@ComputeRec

; 4808 : 	{
; 4809 : 		if(pCity->isCoastal(-1))

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@ComputeRec

; 4810 : 		{
; 4811 : 			iNumCoastalCities++;

	mov	eax, DWORD PTR _iNumCoastalCities$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumCoastalCities$[ebp], eax
$LN6@ComputeRec:

; 4812 : 		}
; 4813 : 	}

	jmp	SHORT $LN8@ComputeRec
$LN7@ComputeRec:

; 4814 : 
; 4815 : 	iNumUnitsWanted += iNumCoastalCities;

	mov	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	add	ecx, DWORD PTR _iNumCoastalCities$[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], ecx

; 4816 : 	// Scale up or down based on true threat level and a bit by flavors (multiplier should range from about 0.75 to 2.0)
; 4817 : 	dMultiplier = (double)0.75 + ((double)pPlayer->GetMilitaryAI()->GetHighestThreat() / (double)4.0) + ((double)(iFlavorNaval) / (double)40.0);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ; CvMilitaryAI::GetHighestThreat
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@4010000000000000
	addsd	xmm0, QWORD PTR __real@3fe8000000000000
	cvtsi2sd xmm1, DWORD PTR _iFlavorNaval$[ebp]
	divsd	xmm1, QWORD PTR __real@4044000000000000
	addsd	xmm0, xmm1
	movsd	QWORD PTR _dMultiplier$[ebp], xmm0

; 4818 : 	iNumUnitsWanted = (int)((double)iNumUnitsWanted * dMultiplier* /*0.67*/ GC.getAI_STRATEGY_NAVAL_UNITS_PER_CITY());

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8108
	movss	DWORD PTR $T236585[ebp], xmm0
	cvtsi2sd xmm0, DWORD PTR _iNumUnitsWanted$[ebp]
	mulsd	xmm0, QWORD PTR _dMultiplier$[ebp]
	cvtss2sd xmm1, DWORD PTR $T236585[ebp]
	mulsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _iNumUnitsWanted$[ebp], edx

; 4819 : 
; 4820 : 	iNumUnitsWanted = max(1,iNumUnitsWanted);

	mov	DWORD PTR $T236580[ebp], 1
	mov	eax, DWORD PTR $T236580[ebp]
	cmp	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	jge	SHORT $LN16@ComputeRec
	lea	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	DWORD PTR tv197[ebp], ecx
	jmp	SHORT $LN17@ComputeRec
$LN16@ComputeRec:
	lea	edx, DWORD PTR $T236580[ebp]
	mov	DWORD PTR tv197[ebp], edx
$LN17@ComputeRec:
	mov	eax, DWORD PTR tv197[ebp]
	mov	DWORD PTR $T236592[ebp], eax
	mov	ecx, DWORD PTR $T236592[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], edx

; 4821 : 
; 4822 : 	EconomicAIStrategyTypes eStrategyNavalMap = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NAVAL_MAP");

	push	0
	push	OFFSET ??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyNavalMap$[ebp], eax

; 4823 : 	EconomicAIStrategyTypes eExpandOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");

	push	0
	push	OFFSET ??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eExpandOtherContinents$[ebp], eax

; 4824 : 	if (pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyNavalMap) || pPlayer->GetEconomicAI()->IsUsingStrategy(eExpandOtherContinents))

	mov	eax, DWORD PTR _eStrategyNavalMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@ComputeRec
	mov	edx, DWORD PTR _eExpandOtherContinents$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@ComputeRec
$LN4@ComputeRec:

; 4825 : 	{
; 4826 : 		iNumUnitsWanted *= 3;

	mov	ecx, DWORD PTR _iNumUnitsWanted$[ebp]
	imul	ecx, 3
	mov	DWORD PTR _iNumUnitsWanted$[ebp], ecx

; 4827 : 		iNumUnitsWanted /= 2;

	mov	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax
$LN5@ComputeRec:

; 4828 : 	}
; 4829 : 
; 4830 : 	if (pPlayer->getCivilizationInfo().isCoastalCiv())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ ; CvCivilizationInfo::isCoastalCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ComputeRec

; 4831 : 	{
; 4832 : 		iNumUnitsWanted *= 3;

	mov	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax

; 4833 : 		iNumUnitsWanted /= 2;

	mov	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax
$LN3@ComputeRec:

; 4834 : 	}
; 4835 : 
; 4836 : 	// if we are going for conquest we want at least one more task force
; 4837 : 	int iGT = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236598[ebp], ecx
	mov	ecx, DWORD PTR $T236598[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGT$[ebp], eax

; 4838 : 	iGT = min(iGT,200);

	mov	DWORD PTR $T236581[ebp], 200		; 000000c8H
	mov	edx, DWORD PTR $T236581[ebp]
	cmp	edx, DWORD PTR _iGT$[ebp]
	jge	SHORT $LN22@ComputeRec
	lea	eax, DWORD PTR $T236581[ebp]
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN23@ComputeRec
$LN22@ComputeRec:
	lea	ecx, DWORD PTR _iGT$[ebp]
	mov	DWORD PTR tv143[ebp], ecx
$LN23@ComputeRec:
	mov	edx, DWORD PTR tv143[ebp]
	mov	DWORD PTR $T236604[ebp], edx
	mov	eax, DWORD PTR $T236604[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iGT$[ebp], ecx

; 4839 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eConquestGrandStrategy$[ebp], eax

; 4840 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eConquestGrandStrategy$[ebp], -1
	je	SHORT $LN1@ComputeRec

; 4841 : 	{
; 4842 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eConquestGrandStrategy$[ebp]
	jne	SHORT $LN1@ComputeRec

; 4843 : 		{
; 4844 : 			iNumUnitsWanted += (10 * iGT) / 200;

	mov	eax, DWORD PTR _iGT$[ebp]
	imul	eax, 10					; 0000000aH
	cdq
	mov	ecx, 200				; 000000c8H
	idiv	ecx
	add	eax, DWORD PTR _iNumUnitsWanted$[ebp]
	mov	DWORD PTR _iNumUnitsWanted$[ebp], eax
$LN1@ComputeRec:

; 4845 : 		}
; 4846 : 	}
; 4847 : 
; 4848 : 	return iNumUnitsWanted;

	mov	eax, DWORD PTR _iNumUnitsWanted$[ebp]

; 4849 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::ComputeRecommendedNavySize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
PUBLIC	?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back
PUBLIC	??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>
PUBLIC	__$ArrayPad$
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ:PROC	; CvUnit::canRecruitFromTacticalAI
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
EXTRN	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ:PROC ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
EXTRN	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z:PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry
EXTRN	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ:PROC ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
EXTRN	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z:PROC ; CvGlobals::getMultiUnitFormationInfo
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z$0
__ehfuncinfo$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
_TEXT	SEGMENT
tv91 = -312						; size = 4
$T236687 = -296						; size = 4
_i$236680 = -292					; size = 4
_uIndex$236679 = -288					; size = 4
$T236666 = -284						; size = 4
$T236662 = -280						; size = 4
$T236658 = -276						; size = 4
$T236649 = -272						; size = 4
$T236645 = -268						; size = 4
$T236641 = -264						; size = 4
$T236619 = -256						; size = 4
_iThisSlotIndex$227843 = -252				; size = 4
_slotEntry$227835 = -248				; size = 16
_kUnitInfo$227836 = -232				; size = 4
_thisSlotEntry$227819 = -228				; size = 4
_iThisSlotIndex$227815 = -224				; size = 4
_slotsToFill$ = -220					; size = 176
__$ArrayPad$ = -44					; size = 4
_thisFormation$ = -40					; size = 4
_iLandReservesUsed$ = -36				; size = 4
_pLoopUnit$ = -32					; size = 4
_iLoop$ = -28						; size = 4
_it$ = -24						; size = 4
_iWillBeFilled$ = -20					; size = 4
_bMustBeDeepWaterNaval$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_formation$ = 12					; size = 4
_bRequiresNavalMoves$ = 16				; size = 1
_piNumberSlotsRequired$ = 20				; size = 4
_piNumberLandReservesUsed$ = 24				; size = 4
?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z PROC ; MilitaryAIHelpers::NumberOfFillableSlots, COMDAT

; 4853 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4854 : 	CvUnit* pLoopUnit;
; 4855 : 	int iLoop;
; 4856 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL > slotsToFill;

	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4857 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL >::iterator it;
; 4858 : 	int iWillBeFilled = 0;

	mov	DWORD PTR _iWillBeFilled$[ebp], 0

; 4859 : 	int iLandReservesUsed = 0;

	mov	DWORD PTR _iLandReservesUsed$[ebp], 0

; 4860 : 
; 4861 : 	CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(formation);

	mov	eax, DWORD PTR _formation$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	DWORD PTR _thisFormation$[ebp], eax

; 4862 : 	for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	DWORD PTR _iThisSlotIndex$227815[ebp], 0
	jmp	SHORT $LN26@NumberOfFi
$LN25@NumberOfFi:
	mov	ecx, DWORD PTR _iThisSlotIndex$227815[ebp]
	add	ecx, 1
	mov	DWORD PTR _iThisSlotIndex$227815[ebp], ecx
$LN26@NumberOfFi:
	mov	ecx, DWORD PTR _thisFormation$[ebp]
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cmp	DWORD PTR _iThisSlotIndex$227815[ebp], eax
	jge	SHORT $LN46@NumberOfFi

; 4863 : 	{
; 4864 : 		const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(iThisSlotIndex);

	mov	edx, DWORD PTR _iThisSlotIndex$227815[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisFormation$[ebp]
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	DWORD PTR _thisSlotEntry$227819[ebp], eax

; 4865 : 		slotsToFill.push_back(thisSlotEntry);

	mov	eax, DWORD PTR _thisSlotEntry$227819[ebp]
	push	eax
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back

; 4866 : 	}

	jmp	SHORT $LN25@NumberOfFi

; 4867 : 
; 4868 : 	bool bMustBeDeepWaterNaval = GET_TEAM(pPlayer->getTeam()).canEmbarkAllWaterPassage() && thisFormation->IsRequiresNavalUnitConsistency();

$LN46@NumberOfFi:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236641[ebp], eax
	mov	eax, DWORD PTR $T236641[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T236645[ebp], eax
	mov	ecx, DWORD PTR $T236645[ebp]
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN29@NumberOfFi
	mov	ecx, DWORD PTR _thisFormation$[ebp]
	call	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@NumberOfFi
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN30@NumberOfFi
$LN29@NumberOfFi:
	mov	DWORD PTR tv91[ebp], 0
$LN30@NumberOfFi:
	mov	al, BYTE PTR tv91[ebp]
	mov	BYTE PTR _bMustBeDeepWaterNaval$[ebp], al

; 4869 : 
; 4870 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN23@NumberOfFi
$LN22@NumberOfFi:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN23@NumberOfFi:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN21@NumberOfFi

; 4871 : 	{
; 4872 : 		// Don't count scouts
; 4873 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN20@NumberOfFi
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN20@NumberOfFi

; 4874 : 		{
; 4875 : 			// Don't count units that are damaged too heavily
; 4876 : 			if(pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	DWORD PTR $T236649[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	imul	eax, DWORD PTR $T236649[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	esi, eax
	jl	$LN20@NumberOfFi

; 4877 : 			{
; 4878 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX && pLoopUnit->canRecruitFromTacticalAI())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN20@NumberOfFi
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	movzx	edx, al
	test	edx, edx
	je	$LN20@NumberOfFi

; 4879 : 				{
; 4880 : 					if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR $T236658[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T236662[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236666[ebp], eax
	mov	esi, DWORD PTR $T236658[ebp]
	add	esi, DWORD PTR $T236662[ebp]
	mov	ecx, DWORD PTR $T236666[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jge	$LN20@NumberOfFi

; 4881 : 					{
; 4882 : 						if(!bRequiresNavalMoves || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	movzx	ecx, BYTE PTR _bRequiresNavalMoves$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@NumberOfFi
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN15@NumberOfFi
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	edx, al
	test	edx, edx
	je	$LN20@NumberOfFi
$LN15@NumberOfFi:

; 4883 : 						{
; 4884 : 							if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	movzx	eax, BYTE PTR _bMustBeDeepWaterNaval$[ebp]
	test	eax, eax
	je	SHORT $LN62@NumberOfFi
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN62@NumberOfFi
	push	6
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	add	ecx, 1972				; 000007b4H
	call	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN20@NumberOfFi

; 4885 : 							{
; 4886 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 4887 : 								for (it = slotsToFill.begin(); it != slotsToFill.end(); ++it)
; 4888 : #else
; 4889 : 								for(it = slotsToFill.begin(); it != slotsToFill.end(); it++)

$LN62@NumberOfFi:
	mov	eax, DWORD PTR _slotsToFill$[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN64@NumberOfFi
$LN11@NumberOfFi:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], ecx
$LN64@NumberOfFi:
	mov	edx, DWORD PTR _slotsToFill$[ebp+4]
	shl	edx, 4
	add	edx, DWORD PTR _slotsToFill$[ebp]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN20@NumberOfFi

; 4890 : #endif
; 4891 : 								{
; 4892 : 									CvFormationSlotEntry slotEntry = *it;

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _slotEntry$227835[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _slotEntry$227835[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _slotEntry$227835[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _slotEntry$227835[ebp+12], edx

; 4893 : 									CvUnitEntry& kUnitInfo = pLoopUnit->getUnitInfo();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR _kUnitInfo$227836[ebp], eax

; 4894 : 									if(kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_primaryUnitType) ||
; 4895 : 										kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_secondaryUnitType))

	mov	eax, DWORD PTR _slotEntry$227835[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUnitInfo$227836[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@NumberOfFi
	mov	edx, DWORD PTR _slotEntry$227835[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _kUnitInfo$227836[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	$LN9@NumberOfFi
$LN8@NumberOfFi:

; 4896 : 									{
; 4897 : 										slotsToFill.erase(it);

	mov	BYTE PTR _slotsToFill$[ebp+172], 0
	mov	ecx, DWORD PTR _it$[ebp]
	sub	ecx, DWORD PTR _slotsToFill$[ebp]
	sar	ecx, 4
	mov	DWORD PTR _uIndex$236679[ebp], ecx
	mov	edx, DWORD PTR _uIndex$236679[ebp]
	mov	DWORD PTR _i$236680[ebp], edx
	jmp	SHORT $LN68@NumberOfFi
$LN67@NumberOfFi:
	mov	eax, DWORD PTR _i$236680[ebp]
	add	eax, 1
	mov	DWORD PTR _i$236680[ebp], eax
$LN68@NumberOfFi:
	mov	ecx, DWORD PTR _i$236680[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _slotsToFill$[ebp+4]
	jae	SHORT $LN66@NumberOfFi
	mov	edx, DWORD PTR _i$236680[ebp]
	add	edx, 1
	shl	edx, 4
	add	edx, DWORD PTR _slotsToFill$[ebp]
	mov	eax, DWORD PTR _i$236680[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _slotsToFill$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN67@NumberOfFi
$LN66@NumberOfFi:
	mov	eax, DWORD PTR _slotsToFill$[ebp+4]
	sub	eax, 1
	mov	DWORD PTR _slotsToFill$[ebp+4], eax

; 4898 : 										iWillBeFilled++;

	mov	ecx, DWORD PTR _iWillBeFilled$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iWillBeFilled$[ebp], ecx

; 4899 : 
; 4900 : 										if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN7@NumberOfFi

; 4901 : 										{
; 4902 : 											iLandReservesUsed++;

	mov	edx, DWORD PTR _iLandReservesUsed$[ebp]
	add	edx, 1
	mov	DWORD PTR _iLandReservesUsed$[ebp], edx
$LN7@NumberOfFi:

; 4903 : 										}
; 4904 : 										break;

	jmp	SHORT $LN20@NumberOfFi
$LN9@NumberOfFi:

; 4905 : 									}
; 4906 : 								}

	jmp	$LN11@NumberOfFi
$LN20@NumberOfFi:

; 4907 : 							}
; 4908 : 						}
; 4909 : 					}
; 4910 : 				}
; 4911 : 			}
; 4912 : 		}
; 4913 : 	}

	jmp	$LN22@NumberOfFi
$LN21@NumberOfFi:

; 4914 : 
; 4915 : 	// Now go back through remaining slots and see how many were required, we'll need that many more units
; 4916 : 	if(piNumberSlotsRequired != NULL)

	cmp	DWORD PTR _piNumberSlotsRequired$[ebp], 0
	je	SHORT $LN6@NumberOfFi

; 4917 : 	{
; 4918 : 		(*piNumberSlotsRequired) = iWillBeFilled;

	mov	eax, DWORD PTR _piNumberSlotsRequired$[ebp]
	mov	ecx, DWORD PTR _iWillBeFilled$[ebp]
	mov	DWORD PTR [eax], ecx

; 4919 : 		for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	mov	DWORD PTR _iThisSlotIndex$227843[ebp], 0
	jmp	SHORT $LN5@NumberOfFi
$LN4@NumberOfFi:
	mov	edx, DWORD PTR _iThisSlotIndex$227843[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisSlotIndex$227843[ebp], edx
$LN5@NumberOfFi:
	mov	eax, DWORD PTR _slotsToFill$[ebp+4]
	mov	DWORD PTR $T236687[ebp], eax
	mov	ecx, DWORD PTR _iThisSlotIndex$227843[ebp]
	cmp	ecx, DWORD PTR $T236687[ebp]
	jge	SHORT $LN6@NumberOfFi

; 4920 : 		{
; 4921 : 			if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	mov	edx, DWORD PTR _iThisSlotIndex$227843[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _slotsToFill$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12]
	test	ecx, ecx
	je	SHORT $LN2@NumberOfFi

; 4922 : 			{
; 4923 : 				(*piNumberSlotsRequired)++;

	mov	edx, DWORD PTR _piNumberSlotsRequired$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _piNumberSlotsRequired$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@NumberOfFi:

; 4924 : 			}
; 4925 : 		}

	jmp	SHORT $LN4@NumberOfFi
$LN6@NumberOfFi:

; 4926 : 	}
; 4927 : 
; 4928 : 	if(piNumberLandReservesUsed != NULL)

	cmp	DWORD PTR _piNumberLandReservesUsed$[ebp], 0
	je	SHORT $LN1@NumberOfFi

; 4929 : 	{
; 4930 : 		*piNumberLandReservesUsed = iLandReservesUsed;

	mov	edx, DWORD PTR _piNumberLandReservesUsed$[ebp]
	mov	eax, DWORD PTR _iLandReservesUsed$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@NumberOfFi:

; 4931 : 	}
; 4932 : 	return iWillBeFilled;

	mov	ecx, DWORD PTR _iWillBeFilled$[ebp]
	mov	DWORD PTR $T236619[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	eax, DWORD PTR $T236619[ebp]

; 4933 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z$0:
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	jmp	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
__ehhandler$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ENDP ; MilitaryAIHelpers::NumberOfFillableSlots
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z$0
__ehfuncinfo$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
_TEXT	SEGMENT
tv91 = -372						; size = 4
$T236841 = -332						; size = 4
$T236801 = -312						; size = 4
_i$236794 = -308					; size = 4
_uIndex$236793 = -304					; size = 4
$T236780 = -300						; size = 4
$T236776 = -296						; size = 4
$T236772 = -292						; size = 4
$T236763 = -288						; size = 4
$T236759 = -284						; size = 4
$T236755 = -280						; size = 4
$T236733 = -272						; size = 4
$T236732 = -268						; size = 4
$T236731 = -264						; size = 4
$T236730 = -260						; size = 4
$T236729 = -256						; size = 4
_iThisSlotIndex$227908 = -252				; size = 4
_eType$227898 = -248					; size = 4
_iThisSlotIndex$227892 = -244				; size = 4
_slotEntry$227885 = -240				; size = 16
_kUnitInfo$227886 = -224				; size = 4
_thisSlotEntry$227869 = -220				; size = 4
_iThisSlotIndex$227865 = -216				; size = 4
_slotsToFill$ = -212					; size = 176
__$ArrayPad$ = -36					; size = 4
_thisFormation$ = -32					; size = 4
_pLoopUnit$ = -28					; size = 4
_iLoop$ = -24						; size = 4
_it$ = -20						; size = 4
_bMustBeDeepWaterNaval$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_formation$ = 12					; size = 4
_bRequiresNavalMoves$ = 16				; size = 1
_bAtCoastalCity$ = 20					; size = 1
_bSecondaryUnit$ = 24					; size = 1
?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z PROC ; MilitaryAIHelpers::FirstSlotCityCanFill, COMDAT

; 4937 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4938 : 	CvUnit* pLoopUnit;
; 4939 : 	int iLoop;
; 4940 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL > slotsToFill;

	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4941 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL >::iterator it;
; 4942 : 
; 4943 : 	CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(formation);

	mov	eax, DWORD PTR _formation$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	DWORD PTR _thisFormation$[ebp], eax

; 4944 : 	for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	DWORD PTR _iThisSlotIndex$227865[ebp], 0
	jmp	SHORT $LN34@FirstSlotC
$LN33@FirstSlotC:
	mov	ecx, DWORD PTR _iThisSlotIndex$227865[ebp]
	add	ecx, 1
	mov	DWORD PTR _iThisSlotIndex$227865[ebp], ecx
$LN34@FirstSlotC:
	mov	ecx, DWORD PTR _thisFormation$[ebp]
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cmp	DWORD PTR _iThisSlotIndex$227865[ebp], eax
	jge	SHORT $LN54@FirstSlotC

; 4945 : 	{
; 4946 : 		const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(iThisSlotIndex);

	mov	edx, DWORD PTR _iThisSlotIndex$227865[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisFormation$[ebp]
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	DWORD PTR _thisSlotEntry$227869[ebp], eax

; 4947 : 		slotsToFill.push_back(thisSlotEntry);

	mov	eax, DWORD PTR _thisSlotEntry$227869[ebp]
	push	eax
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back

; 4948 : 	}

	jmp	SHORT $LN33@FirstSlotC

; 4949 : 
; 4950 : 	bool bMustBeDeepWaterNaval = GET_TEAM(pPlayer->getTeam()).canEmbarkAllWaterPassage() && thisFormation->IsRequiresNavalUnitConsistency();

$LN54@FirstSlotC:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236755[ebp], eax
	mov	eax, DWORD PTR $T236755[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T236759[ebp], eax
	mov	ecx, DWORD PTR $T236759[ebp]
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@FirstSlotC
	mov	ecx, DWORD PTR _thisFormation$[ebp]
	call	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN37@FirstSlotC
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN38@FirstSlotC
$LN37@FirstSlotC:
	mov	DWORD PTR tv91[ebp], 0
$LN38@FirstSlotC:
	mov	al, BYTE PTR tv91[ebp]
	mov	BYTE PTR _bMustBeDeepWaterNaval$[ebp], al

; 4951 : 
; 4952 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN31@FirstSlotC
$LN30@FirstSlotC:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN31@FirstSlotC:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN29@FirstSlotC

; 4953 : 	{
; 4954 : 		// Don't count scouts
; 4955 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN28@FirstSlotC
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN28@FirstSlotC

; 4956 : 		{
; 4957 : 			// Don't count units that are damaged too heavily
; 4958 : 			if(pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	DWORD PTR $T236763[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	imul	eax, DWORD PTR $T236763[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	esi, eax
	jl	$LN28@FirstSlotC

; 4959 : 			{
; 4960 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX && pLoopUnit->canRecruitFromTacticalAI())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN28@FirstSlotC
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	movzx	edx, al
	test	edx, edx
	je	$LN28@FirstSlotC

; 4961 : 				{
; 4962 : 					if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR $T236772[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T236776[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236780[ebp], eax
	mov	esi, DWORD PTR $T236772[ebp]
	add	esi, DWORD PTR $T236776[ebp]
	mov	ecx, DWORD PTR $T236780[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jge	$LN28@FirstSlotC

; 4963 : 					{
; 4964 : 						if(!bRequiresNavalMoves || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	movzx	ecx, BYTE PTR _bRequiresNavalMoves$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@FirstSlotC
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN23@FirstSlotC
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	edx, al
	test	edx, edx
	je	$LN28@FirstSlotC
$LN23@FirstSlotC:

; 4965 : 						{
; 4966 : 							if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	movzx	eax, BYTE PTR _bMustBeDeepWaterNaval$[ebp]
	test	eax, eax
	je	SHORT $LN70@FirstSlotC
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN70@FirstSlotC
	push	6
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	add	ecx, 1972				; 000007b4H
	call	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN28@FirstSlotC

; 4967 : 							{
; 4968 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 4969 : 								for (it = slotsToFill.begin(); it != slotsToFill.end(); ++it)
; 4970 : #else
; 4971 : 								for(it = slotsToFill.begin(); it != slotsToFill.end(); it++)

$LN70@FirstSlotC:
	mov	eax, DWORD PTR _slotsToFill$[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN72@FirstSlotC
$LN19@FirstSlotC:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], ecx
$LN72@FirstSlotC:
	mov	edx, DWORD PTR _slotsToFill$[ebp+4]
	shl	edx, 4
	add	edx, DWORD PTR _slotsToFill$[ebp]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN28@FirstSlotC

; 4972 : #endif
; 4973 : 								{
; 4974 : 									CvFormationSlotEntry slotEntry = *it;

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _slotEntry$227885[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _slotEntry$227885[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _slotEntry$227885[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _slotEntry$227885[ebp+12], edx

; 4975 : 									CvUnitEntry& kUnitInfo = pLoopUnit->getUnitInfo();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR _kUnitInfo$227886[ebp], eax

; 4976 : 									if(kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_primaryUnitType) ||
; 4977 : 										kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_secondaryUnitType))

	mov	eax, DWORD PTR _slotEntry$227885[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUnitInfo$227886[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN16@FirstSlotC
	mov	edx, DWORD PTR _slotEntry$227885[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _kUnitInfo$227886[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	$LN17@FirstSlotC
$LN16@FirstSlotC:

; 4978 : 									{
; 4979 : 										slotsToFill.erase(it);

	mov	BYTE PTR _slotsToFill$[ebp+172], 0
	mov	ecx, DWORD PTR _it$[ebp]
	sub	ecx, DWORD PTR _slotsToFill$[ebp]
	sar	ecx, 4
	mov	DWORD PTR _uIndex$236793[ebp], ecx
	mov	edx, DWORD PTR _uIndex$236793[ebp]
	mov	DWORD PTR _i$236794[ebp], edx
	jmp	SHORT $LN76@FirstSlotC
$LN75@FirstSlotC:
	mov	eax, DWORD PTR _i$236794[ebp]
	add	eax, 1
	mov	DWORD PTR _i$236794[ebp], eax
$LN76@FirstSlotC:
	mov	ecx, DWORD PTR _i$236794[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _slotsToFill$[ebp+4]
	jae	SHORT $LN74@FirstSlotC
	mov	edx, DWORD PTR _i$236794[ebp]
	add	edx, 1
	shl	edx, 4
	add	edx, DWORD PTR _slotsToFill$[ebp]
	mov	eax, DWORD PTR _i$236794[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _slotsToFill$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN75@FirstSlotC
$LN74@FirstSlotC:
	mov	eax, DWORD PTR _slotsToFill$[ebp+4]
	sub	eax, 1
	mov	DWORD PTR _slotsToFill$[ebp+4], eax

; 4980 : 										break;

	jmp	SHORT $LN28@FirstSlotC
$LN17@FirstSlotC:

; 4981 : 									}
; 4982 : 								}

	jmp	$LN19@FirstSlotC
$LN28@FirstSlotC:

; 4983 : 							}
; 4984 : 						}
; 4985 : 					}
; 4986 : 				}
; 4987 : 			}
; 4988 : 		}
; 4989 : 	}

	jmp	$LN30@FirstSlotC
$LN29@FirstSlotC:

; 4990 : 
; 4991 : 	// If coastal city, try to find the first one that is a naval AI type
; 4992 : 	if(bAtCoastalCity)

	movzx	ecx, BYTE PTR _bAtCoastalCity$[ebp]
	test	ecx, ecx
	je	$LN15@FirstSlotC

; 4993 : 	{
; 4994 : 		for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	mov	DWORD PTR _iThisSlotIndex$227892[ebp], 0
	jmp	SHORT $LN14@FirstSlotC
$LN13@FirstSlotC:
	mov	edx, DWORD PTR _iThisSlotIndex$227892[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisSlotIndex$227892[ebp], edx
$LN14@FirstSlotC:
	mov	eax, DWORD PTR _slotsToFill$[ebp+4]
	mov	DWORD PTR $T236801[ebp], eax
	mov	ecx, DWORD PTR _iThisSlotIndex$227892[ebp]
	cmp	ecx, DWORD PTR $T236801[ebp]
	jge	$LN15@FirstSlotC

; 4995 : 		{
; 4996 : 			if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	mov	edx, DWORD PTR _iThisSlotIndex$227892[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _slotsToFill$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12]
	test	ecx, ecx
	je	$LN11@FirstSlotC

; 4997 : 			{
; 4998 : 				UnitAITypes eType = (UnitAITypes)slotsToFill[iThisSlotIndex].m_primaryUnitType;

	mov	edx, DWORD PTR _iThisSlotIndex$227892[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _slotsToFill$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _eType$227898[ebp], ecx

; 4999 : 				if(eType == UNITAI_ASSAULT_SEA || eType == UNITAI_ATTACK_SEA || eType == UNITAI_RESERVE_SEA || eType == UNITAI_ESCORT_SEA)

	cmp	DWORD PTR _eType$227898[ebp], 22	; 00000016H
	je	SHORT $LN9@FirstSlotC
	cmp	DWORD PTR _eType$227898[ebp], 18	; 00000012H
	je	SHORT $LN9@FirstSlotC
	cmp	DWORD PTR _eType$227898[ebp], 19	; 00000013H
	je	SHORT $LN9@FirstSlotC
	cmp	DWORD PTR _eType$227898[ebp], 20	; 00000014H
	jne	SHORT $LN11@FirstSlotC
$LN9@FirstSlotC:

; 5000 : 				{
; 5001 : 					if(!bSecondaryUnit)

	movzx	edx, BYTE PTR _bSecondaryUnit$[ebp]
	test	edx, edx
	jne	SHORT $LN96@FirstSlotC

; 5002 : 					{
; 5003 : 						return (UnitAITypes)slotsToFill[iThisSlotIndex].m_primaryUnitType;

	mov	eax, DWORD PTR _iThisSlotIndex$227892[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _slotsToFill$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR $T236729[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	eax, DWORD PTR $T236729[ebp]
	jmp	$LN35@FirstSlotC

; 5004 : 					}
; 5005 : 					else

	jmp	SHORT $LN11@FirstSlotC

; 5006 : 					{
; 5007 : 						return (UnitAITypes)slotsToFill[iThisSlotIndex].m_secondaryUnitType;

$LN96@FirstSlotC:
	mov	eax, DWORD PTR _iThisSlotIndex$227892[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _slotsToFill$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR $T236730[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	eax, DWORD PTR $T236730[ebp]
	jmp	$LN35@FirstSlotC
$LN11@FirstSlotC:

; 5008 : 					}
; 5009 : 				}
; 5010 : 			}
; 5011 : 		}

	jmp	$LN13@FirstSlotC
$LN15@FirstSlotC:

; 5012 : 	}
; 5013 : 
; 5014 : 	// Now go back through remaining slots and find first required one
; 5015 : 	for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	mov	DWORD PTR _iThisSlotIndex$227908[ebp], 0
	jmp	SHORT $LN6@FirstSlotC
$LN5@FirstSlotC:
	mov	eax, DWORD PTR _iThisSlotIndex$227908[ebp]
	add	eax, 1
	mov	DWORD PTR _iThisSlotIndex$227908[ebp], eax
$LN6@FirstSlotC:
	mov	ecx, DWORD PTR _slotsToFill$[ebp+4]
	mov	DWORD PTR $T236841[ebp], ecx
	mov	edx, DWORD PTR _iThisSlotIndex$227908[ebp]
	cmp	edx, DWORD PTR $T236841[ebp]
	jge	$LN4@FirstSlotC

; 5016 : 	{
; 5017 : 		if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	mov	eax, DWORD PTR _iThisSlotIndex$227908[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _slotsToFill$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+12]
	test	edx, edx
	je	SHORT $LN3@FirstSlotC

; 5018 : 		{
; 5019 : 			if(!bSecondaryUnit)

	movzx	eax, BYTE PTR _bSecondaryUnit$[ebp]
	test	eax, eax
	jne	SHORT $LN128@FirstSlotC

; 5020 : 			{
; 5021 : 				return (UnitAITypes)slotsToFill[iThisSlotIndex].m_primaryUnitType;

	mov	ecx, DWORD PTR _iThisSlotIndex$227908[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _slotsToFill$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR $T236731[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	eax, DWORD PTR $T236731[ebp]
	jmp	SHORT $LN35@FirstSlotC

; 5022 : 			}
; 5023 : 			else

	jmp	SHORT $LN3@FirstSlotC

; 5024 : 			{
; 5025 : 				return (UnitAITypes)slotsToFill[iThisSlotIndex].m_secondaryUnitType;

$LN128@FirstSlotC:
	mov	ecx, DWORD PTR _iThisSlotIndex$227908[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _slotsToFill$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR $T236732[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	eax, DWORD PTR $T236732[ebp]
	jmp	SHORT $LN35@FirstSlotC
$LN3@FirstSlotC:

; 5026 : 			}
; 5027 : 		}
; 5028 : 	}

	jmp	$LN5@FirstSlotC
$LN4@FirstSlotC:

; 5029 : 
; 5030 : 	return NO_UNITAI;

	mov	DWORD PTR $T236733[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	call	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
	mov	eax, DWORD PTR $T236733[ebp]
$LN35@FirstSlotC:

; 5031 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z$0:
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	jmp	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
__ehhandler$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ENDP ; MilitaryAIHelpers::FirstSlotCityCanFill
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back
PUBLIC	??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
_weightedElem$ = -28					; size = 28
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back, COMDAT
; _this$ = ecx

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;

	lea	ecx, DWORD PTR _weightedElem$[ebp]
	call	??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement

; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _weightedElem$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _weightedElem$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _weightedElem$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _weightedElem$[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _weightedElem$[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _weightedElem$[ebp+20], edx

; 108  : 		weightedElem.m_iWeight = iWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$[ebp+24], eax

; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	lea	ecx, DWORD PTR _weightedElem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back

; 111  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back
_TEXT	ENDS
PUBLIC	?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight
; Function compile flags: /Odtp
;	COMDAT ?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T237081 = -96						; size = 4
$T237077 = -92						; size = 4
$T237070 = -88						; size = 4
$T237066 = -84						; size = 4
_i$228029 = -36						; size = 4
_iChoice$ = -32						; size = 4
_elem$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight, COMDAT
; _this$ = ecx

; 197  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 		WeightedElement elem;

	lea	ecx, DWORD PTR _elem$[ebp]
	call	??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement

; 199  : 		int iChoice;
; 200  : 
; 201  : 		// Random roll up to total weight
; 202  : 		iChoice = (*rndFcn)(GetTotalWeight(), szRollName);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight
	mov	DWORD PTR $T237077[ebp], eax
	mov	eax, DWORD PTR _rndFcn$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237066[ebp], ecx
	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237070[ebp], eax
	mov	ecx, DWORD PTR _szRollName$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237077[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237070[ebp]
	call	DWORD PTR $T237066[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 203  : 
; 204  : 		// Loop through until we find the item that is in the range for this roll
; 205  : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	mov	DWORD PTR _i$228029[ebp], 0
	jmp	SHORT $LN4@ChooseByWe
$LN3@ChooseByWe:
	mov	eax, DWORD PTR _i$228029[ebp]
	add	eax, 1
	mov	DWORD PTR _i$228029[ebp], eax
$LN4@ChooseByWe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237081[ebp], edx
	mov	eax, DWORD PTR _i$228029[ebp]
	cmp	eax, DWORD PTR $T237081[ebp]
	jae	SHORT $LN2@ChooseByWe

; 206  : 		{
; 207  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _i$228029[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx]
	add	esi, ecx
	mov	ecx, 7
	lea	edi, DWORD PTR _elem$[ebp]
	rep movsd

; 208  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+24]
	mov	DWORD PTR _iChoice$[ebp], eax

; 209  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseByWe

; 210  : 			{
; 211  : 				return elem.m_Element;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _elem$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _elem$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _elem$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _elem$[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@ChooseByWe
$LN1@ChooseByWe:

; 212  : 			}
; 213  : 		}

	jmp	SHORT $LN3@ChooseByWe
$LN2@ChooseByWe:

; 214  : 
; 215  : 		// We should have found something, so reaching here is an error
; 216  : 		//    Just return last thing accessed
; 217  : 		FAssertMsg (true, "Internal error in CvWeightedVector.");
; 218  : 		return elem.m_Element;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _elem$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _elem$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _elem$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _elem$[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@ChooseByWe:

; 219  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T237097 = -44						; size = 4
$T237090 = -40						; size = 4
_elem$228009 = -36					; size = 28
_i$228005 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 		int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	mov	DWORD PTR _i$228005[ebp], 0
	jmp	SHORT $LN3@GetTotalWe
$LN2@GetTotalWe:
	mov	eax, DWORD PTR _i$228005[ebp]
	add	eax, 1
	mov	DWORD PTR _i$228005[ebp], eax
$LN3@GetTotalWe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237090[ebp], edx
	mov	eax, DWORD PTR _i$228005[ebp]
	cmp	eax, DWORD PTR $T237090[ebp]
	jae	SHORT $LN1@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];

	mov	ecx, DWORD PTR _i$228005[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T237097[ebp], ecx
	mov	eax, DWORD PTR $T237097[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$228009[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$228009[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$228009[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$228009[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _elem$228009[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _elem$228009[ebp+20], edx
	mov	eax, DWORD PTR $T237097[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _elem$228009[ebp+24], ecx

; 95   : 			rtnValue += elem.m_iWeight;

	mov	edx, DWORD PTR _rtnValue$[ebp]
	add	edx, DWORD PTR _elem$228009[ebp+24]
	mov	DWORD PTR _rtnValue$[ebp], edx

; 96   : 		}

	jmp	SHORT $LN2@GetTotalWe
$LN1@GetTotalWe:

; 97   : 
; 98   : 		return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 99   : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T237123 = -56						; size = 4
$T237119 = -52						; size = 4
$T237107 = -48						; size = 4
$T237103 = -44						; size = 4
_iTotalTopChoicesWeight$ = -40				; size = 4
_iChoice$ = -36						; size = 4
_i$ = -32						; size = 4
_elem$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
_iNumChoices$ = 12					; size = 4
_rndFcn$ = 16						; size = 4
_szRollName$ = 20					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237103[ebp], ecx
	mov	edx, DWORD PTR _iNumChoices$[ebp]
	cmp	edx, DWORD PTR $T237103[ebp]
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237107[ebp], ecx
	mov	edx, DWORD PTR $T237107[ebp]
	mov	DWORD PTR _iNumChoices$[ebp], edx
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	lea	ecx, DWORD PTR _elem$[ebp]
	call	??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], 0

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ChooseFrom
$LN6@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ChooseFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN5@ChooseFrom

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax]
	add	esi, edx
	mov	ecx, 7
	lea	edi, DWORD PTR _elem$[ebp]
	rep movsd

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	add	ecx, DWORD PTR _elem$[ebp+24]
	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], ecx

; 240  : 		}

	jmp	SHORT $LN6@ChooseFrom
$LN5@ChooseFrom:

; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237119[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237123[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237123[ebp]
	call	DWORD PTR $T237119[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ChooseFrom
$LN3@ChooseFrom:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN2@ChooseFrom

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx]
	add	esi, ecx
	mov	ecx, 7
	lea	edi, DWORD PTR _elem$[ebp]
	rep movsd

; 249  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+24]
	mov	DWORD PTR _iChoice$[ebp], eax

; 250  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseFrom

; 251  : 			{
; 252  : 				return elem.m_Element;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _elem$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _elem$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _elem$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _elem$[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN9@ChooseFrom
$LN1@ChooseFrom:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN3@ChooseFrom
$LN2@ChooseFrom:

; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _elem$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _elem$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _elem$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _elem$[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@ChooseFrom:

; 260  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T237149 = -20						; size = 4
_pRet$237148 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237148[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$237148[ebp]
	mov	DWORD PTR $T237149[ebp], eax
	jmp	SHORT $LN7@FFastVecto
$LN6@FFastVecto:
	mov	DWORD PTR $T237149[ebp], 0
$LN7@FFastVecto:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237149[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ	; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
__ehhandler$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T237184 = -24						; size = 4
$T237183 = -20						; size = 4
_i$237174 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237184[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237183[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto@2
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto@2
	mov	DWORD PTR _i$237174[ebp], 0
	jmp	SHORT $LN9@FFastVecto@2
$LN8@FFastVecto@2:
	mov	eax, DWORD PTR _i$237174[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237174[ebp], eax
$LN9@FFastVecto@2:
	mov	ecx, DWORD PTR _i$237174[ebp]
	cmp	ecx, DWORD PTR $T237184[ebp]
	jae	SHORT $LN4@FFastVecto@2
	jmp	SHORT $LN8@FFastVecto@2
$LN4@FFastVecto@2:
	mov	edx, DWORD PTR $T237183[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ	; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
__ehhandler$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
PUBLIC	?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z
_TEXT	SEGMENT
tv128 = -56						; size = 4
_this$ = -52						; size = 4
$T237196 = -8						; size = 4
_i$228070 = -4						; size = 4
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		uiNum += m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNum$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _uiNum$[ebp], ecx

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN4@push_back_

; 411  : 			GrowSize(uiNum);

	mov	ecx, DWORD PTR _uiNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _i$228070[ebp], eax
	jmp	SHORT $LN3@push_back_
$LN2@push_back_:
	mov	ecx, DWORD PTR _i$228070[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$228070[ebp], ecx
$LN3@push_back_:
	mov	edx, DWORD PTR _i$228070[ebp]
	cmp	edx, DWORD PTR _uiNum$[ebp]
	jae	SHORT $LN1@push_back_

; 413  : 			new( (void*)&m_pData[i] )T(element);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$228070[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T237196[ebp], eax
	cmp	DWORD PTR $T237196[ebp], 0
	je	SHORT $LN7@push_back_
	mov	ecx, DWORD PTR $T237196[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T237196[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN8@push_back_
$LN7@push_back_:
	mov	DWORD PTR tv128[ebp], 0
$LN8@push_back_:

; 414  : 		}

	jmp	SHORT $LN2@push_back_
$LN1@push_back_:

; 415  : 		m_uiCurrSize = uiNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	mov	DWORD PTR [edx+4], eax

; 416  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T237258 = -20						; size = 4
_pRet$237255 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237258[ebp], edx
	cmp	DWORD PTR $T237258[ebp], 10		; 0000000aH
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T237258[ebp]
	shl	eax, 4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237255[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237258[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$237255[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 10			; 0000000aH
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$237255[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>
__ehhandler$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T237289 = -24						; size = 4
$T237288 = -20						; size = 4
_i$237280 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237289[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237288[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$237280[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$237280[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237280[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$237280[ebp]
	cmp	ecx, DWORD PTR $T237289[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T237288[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T237288[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>
__ehhandler$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
PUBLIC	?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T237301 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+172], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T237301[ebp], ecx
	je	SHORT $LN4@push_back
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T237301[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T237301[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T237441 = -52						; size = 4
$T237430 = -48						; size = 4
$T237429 = -44						; size = 4
__Cat$237436 = -40					; size = 1
$T237434 = -39						; size = 1
__Ptr$228120 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$228120[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237441[ebp], edx
	mov	eax, DWORD PTR $T237441[ebp]
	mov	DWORD PTR $T237430[ebp], eax
	mov	ecx, DWORD PTR __Ptr$228120[ebp]
	mov	DWORD PTR $T237429[ebp], ecx
	mov	dl, BYTE PTR __Cat$237436[ebp]
	mov	BYTE PTR $T237434[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$228120[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$237455 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$237455[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$237455[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$237455[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T237522 = -28						; size = 4
$T237521 = -24						; size = 4
$T237517 = -20						; size = 4
$T237516 = -16						; size = 4
$T237505 = -12						; size = 4
$T237504 = -8						; size = 4
__Cat$237511 = -2					; size = 1
$T237509 = -1						; size = 1
?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237517[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237516[ebp], ecx
	mov	edx, DWORD PTR $T237517[ebp]
	mov	DWORD PTR $T237505[ebp], edx
	mov	eax, DWORD PTR $T237516[ebp]
	mov	DWORD PTR $T237504[ebp], eax
	mov	cl, BYTE PTR __Cat$237511[ebp]
	mov	BYTE PTR $T237509[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T237522[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237521[ebp], eax
	mov	ecx, DWORD PTR $T237521[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T237535 = -20						; size = 4
_pRet$237532 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 640			; 00000280H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237535[ebp], edx
	cmp	DWORD PTR $T237535[ebp], 640		; 00000280H
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T237535[ebp]
	imul	eax, 28					; 0000001cH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237532[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237535[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$237532[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 640			; 00000280H
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$237532[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T237566 = -24						; size = 4
$T237565 = -20						; size = 4
_i$237557 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237566[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237565[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$237557[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$237557[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237557[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$237557[ebp]
	cmp	ecx, DWORD PTR $T237566[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T237565[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T237565[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T237579 = -8						; size = 4
$T237578 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+17932], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T237579[ebp], ecx
	je	SHORT $LN4@push_back@2
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T237579[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR $T237579[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR $T237579[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@2:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T237578[ebp], edx

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv157[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 32   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ PROC		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ ENDP		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T237682 = -40						; size = 4
$T237681 = -36						; size = 4
_i$237672 = -32						; size = 4
$T237653 = -28						; size = 4
_pRet$237652 = -24					; size = 4
$T237640 = -20						; size = 4
_i$228206 = -16						; size = 4
_uiNewSize$228197 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$228197[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$228197[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize
$LN8@GrowSize:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$228197[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize
$LN9@GrowSize:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T237653[ebp], eax
	cmp	DWORD PTR $T237653[ebp], 0
	jbe	SHORT $LN16@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T237653[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237652[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T237653[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$237652[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize
$LN6@GrowSize:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228206[ebp], 0
	jmp	SHORT $LN4@GrowSize
$LN3@GrowSize:
	mov	edx, DWORD PTR _i$228206[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228206[ebp], edx
$LN4@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$228206[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$228206[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T237640[ebp], ecx
	cmp	DWORD PTR $T237640[ebp], 0
	je	SHORT $LN14@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T237640[ebp]
	mov	edx, DWORD PTR _i$228206[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T237640[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize
$LN14@GrowSize:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize:
	jmp	SHORT $LN3@GrowSize
$LN5@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237682[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237681[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN23@GrowSize
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize
	mov	DWORD PTR _i$237672[ebp], 0
	jmp	SHORT $LN28@GrowSize
$LN27@GrowSize:
	mov	edx, DWORD PTR _i$237672[ebp]
	add	edx, 1
	mov	DWORD PTR _i$237672[ebp], edx
$LN28@GrowSize:
	mov	eax, DWORD PTR _i$237672[ebp]
	cmp	eax, DWORD PTR $T237682[ebp]
	jae	SHORT $LN23@GrowSize
	jmp	SHORT $LN27@GrowSize
$LN23@GrowSize:
	mov	ecx, DWORD PTR $T237681[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize
$LN7@GrowSize:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T237720 = -36						; size = 4
$T237719 = -32						; size = 4
_i$237711 = -28						; size = 4
$T237695 = -24						; size = 4
_pRet$237692 = -20					; size = 4
$T237686 = -16						; size = 4
_i$228252 = -12						; size = 4
_uiNewSize$228244 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$228244[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$228244[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$228244[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237695[ebp], ecx
	cmp	DWORD PTR $T237695[ebp], 10		; 0000000aH
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T237695[ebp]
	shl	edx, 4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237692[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237695[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$237692[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$237692[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	xor	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228252[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$228252[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228252[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$228252[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$228252[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T237686[ebp], edx
	je	SHORT $LN12@GrowSize@2
	mov	eax, DWORD PTR _i$228252[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR $T237686[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T237686[ebp]
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237720[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237719[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN21@GrowSize@2
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$237711[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	ecx, DWORD PTR _i$237711[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$237711[ebp], ecx
$LN26@GrowSize@2:
	mov	edx, DWORD PTR _i$237711[ebp]
	cmp	edx, DWORD PTR $T237720[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR $T237719[ebp], eax
	je	SHORT $LN22@GrowSize@2
	mov	ecx, DWORD PTR $T237719[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+172], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ PROC ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ ENDP ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T237726 = -80						; size = 28
$T237725 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T237726[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T237725[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T237725[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T237726[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237725[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T237725[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T237725[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T237726[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T237726[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T237725[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T237809 = -44						; size = 4
$T237808 = -40						; size = 4
_i$237800 = -36						; size = 4
$T237787 = -32						; size = 4
$T237780 = -28						; size = 4
_pRet$237777 = -24					; size = 4
$T237770 = -20						; size = 4
$T237769 = -16						; size = 4
_i$228326 = -12						; size = 4
_uiNewSize$228318 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@3

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$228318[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$228318[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@3

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@3
$LN6@GrowSize@3:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$228318[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@3
$LN7@GrowSize@3:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237780[ebp], ecx
	cmp	DWORD PTR $T237780[ebp], 640		; 00000280H
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T237780[ebp]
	imul	edx, 28					; 0000001cH
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237777[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237780[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$237777[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 640			; 00000280H
$LN17@GrowSize@3:
	mov	ecx, DWORD PTR _pRet$237777[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@3

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	$LN4@GrowSize@3
$LN5@GrowSize@3:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228326[ebp], 0
	jmp	SHORT $LN3@GrowSize@3
$LN2@GrowSize@3:
	mov	edx, DWORD PTR _i$228326[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228326[ebp], edx
$LN3@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$228326[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@3

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$228326[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T237770[ebp], edx
	je	SHORT $LN12@GrowSize@3
	mov	eax, DWORD PTR _i$228326[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T237787[ebp], eax
	mov	edx, DWORD PTR $T237787[ebp]
	mov	eax, DWORD PTR $T237770[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T237770[ebp]
	mov	ecx, DWORD PTR $T237787[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR $T237770[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@3
$LN12@GrowSize@3:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@3:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T237769[ebp], ecx
	jmp	SHORT $LN2@GrowSize@3
$LN4@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237809[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237808[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@3
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@3
	mov	DWORD PTR _i$237800[ebp], 0
	jmp	SHORT $LN29@GrowSize@3
$LN28@GrowSize@3:
	mov	edx, DWORD PTR _i$237800[ebp]
	add	edx, 1
	mov	DWORD PTR _i$237800[ebp], edx
$LN29@GrowSize@3:
	mov	eax, DWORD PTR _i$237800[ebp]
	cmp	eax, DWORD PTR $T237809[ebp]
	jae	SHORT $LN24@GrowSize@3
	jmp	SHORT $LN28@GrowSize@3
$LN24@GrowSize@3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T237808[ebp], ecx
	je	SHORT $LN25@GrowSize@3
	mov	edx, DWORD PTR $T237808[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+17932], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z PROC ; operator>><bool>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ENDP ; operator>><bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ENDP ; operator<<<bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@4:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@4

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2030 : FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 

	push	ebp
	mov	ebp, esp

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2032 : }

	pop	ebp
	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T237912 = -26						; size = 1
$T237911 = -25						; size = 1
$T237910 = -24						; size = 4
$T237909 = -20						; size = 4
__Off$237905 = -16					; size = 4
__Result$237906 = -12					; size = 4
__Cat$237897 = -4					; size = 1
$T237894 = -3						; size = 1
$T237893 = -2						; size = 1
$T237892 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T237892[ebp], al
	mov	cl, BYTE PTR __Cat$237897[ebp]
	mov	BYTE PTR $T237893[ebp], cl
	mov	dl, BYTE PTR $T237892[ebp]
	mov	BYTE PTR $T237912[ebp], dl
	mov	al, BYTE PTR $T237894[ebp]
	mov	BYTE PTR $T237911[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237910[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237909[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T237909[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$237905[ebp], eax
	mov	ecx, DWORD PTR __Off$237905[ebp]
	mov	edx, DWORD PTR $T237910[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$237906[ebp], eax
	cmp	DWORD PTR __Off$237905[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$237905[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T237909[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$237905[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T237910[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$237906[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T237919 = -16						; size = 4
$T237915 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T237919[ebp], 0
	lea	eax, DWORD PTR $T237919[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237915[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T237915[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237915[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z
_TEXT	SEGMENT
$T238053 = -148						; size = 4
__Mid$228611 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	esi
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$228611[ebp]
	push	ecx
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	eax, DWORD PTR __Mid$228611[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Mid$228611[ebp+4]
	cdq
	mov	esi, 28					; 0000001cH
	idiv	esi
	cmp	ecx, eax
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	edx, DWORD PTR __Ideal$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228611[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	edx, DWORD PTR __Mid$228611[ebp+4]
	mov	DWORD PTR __First$[ebp], edx

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$228611[ebp+4]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	eax, DWORD PTR __Mid$228611[ebp]
	mov	DWORD PTR __Last$[ebp], eax
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T238053[ebp], ecx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	edx, DWORD PTR $T238053[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR $T238053[ebp], edx
$LN92@Sort:
	mov	eax, DWORD PTR $T238053[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, 1
	jle	SHORT $LN88@Sort
	mov	eax, DWORD PTR $T238053[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	edx, DWORD PTR $T238053[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
$T238296 = -264						; size = 4
__Tmp$238292 = -260					; size = 28
$T238276 = -232						; size = 4
$T238275 = -228						; size = 4
__Tmp$238271 = -224					; size = 28
$T238255 = -196						; size = 4
__Tmp$238251 = -192					; size = 28
$T238235 = -164						; size = 4
$T238234 = -160						; size = 4
__Tmp$238230 = -156					; size = 28
$T238214 = -128						; size = 4
$T238213 = -124						; size = 4
__Tmp$238209 = -120					; size = 28
$T238190 = -92						; size = 4
$T238189 = -88						; size = 4
__Tmp$238185 = -84					; size = 28
$T238163 = -56						; size = 4
__Tmp$238159 = -52					; size = 28
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	esi
	push	edi

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], edx

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Plast$[ebp], eax
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+24]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR __Pfirst$[ebp], eax
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+24]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+24]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Plast$[ebp], eax
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], ecx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], edx
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Gfirst$[ebp], eax
$LN21@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+24]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+24]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T238163[ebp], eax
	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Plast$[ebp], ecx
	mov	edx, DWORD PTR $T238163[ebp]
	cmp	edx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	eax, DWORD PTR $T238163[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$238159[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$238159[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$238159[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$238159[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$238159[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$238159[ebp+20], edx
	mov	eax, DWORD PTR $T238163[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Tmp$238159[ebp+24], ecx
	mov	esi, DWORD PTR __Gfirst$[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238163[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238159[ebp]
	mov	edi, DWORD PTR __Gfirst$[ebp]
	rep movsd
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR __Glast$[ebp], edx
$LN14@Unguarded_:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [ecx-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+24]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN55@Unguarded_
	jmp	$LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR [eax+24]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx-4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR $T238190[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T238189[ebp], ecx
	mov	edx, DWORD PTR $T238189[ebp]
	cmp	edx, DWORD PTR $T238190[ebp]
	je	SHORT $LN10@Unguarded_
	mov	eax, DWORD PTR $T238189[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$238185[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$238185[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$238185[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$238185[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$238185[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$238185[ebp+20], edx
	mov	eax, DWORD PTR $T238189[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Tmp$238185[ebp+24], ecx
	mov	esi, DWORD PTR $T238190[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238189[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238185[ebp]
	mov	edi, DWORD PTR $T238190[ebp]
	rep movsd
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	eax, DWORD PTR __Plast$[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T238214[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T238213[ebp], edx
	mov	eax, DWORD PTR $T238213[ebp]
	cmp	eax, DWORD PTR $T238214[ebp]
	je	SHORT $LN5@Unguarded_
	mov	ecx, DWORD PTR $T238213[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$238209[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$238209[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$238209[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$238209[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$238209[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Tmp$238209[ebp+20], eax
	mov	ecx, DWORD PTR $T238213[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Tmp$238209[ebp+24], edx
	mov	esi, DWORD PTR $T238214[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238213[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238209[ebp]
	mov	edi, DWORD PTR $T238214[ebp]
	rep movsd
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Plast$[ebp], eax

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T238235[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T238234[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Gfirst$[ebp], ecx
	mov	edx, DWORD PTR $T238234[ebp]
	cmp	edx, DWORD PTR $T238235[ebp]
	je	SHORT $LN73@Unguarded_
	mov	eax, DWORD PTR $T238234[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$238230[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$238230[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$238230[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$238230[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$238230[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$238230[ebp+20], edx
	mov	eax, DWORD PTR $T238234[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Tmp$238230[ebp+24], ecx
	mov	esi, DWORD PTR $T238235[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238234[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238230[ebp]
	mov	edi, DWORD PTR $T238235[ebp]
	rep movsd
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T238255[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR $T238255[ebp]
	je	SHORT $LN2@Unguarded_
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$238251[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$238251[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$238251[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$238251[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$238251[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$238251[ebp+20], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR __Tmp$238251[ebp+24], eax
	mov	esi, DWORD PTR $T238255[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR __Glast$[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238251[ebp]
	mov	edi, DWORD PTR $T238255[ebp]
	rep movsd
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR __Plast$[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T238276[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T238275[ebp], eax
	mov	ecx, DWORD PTR $T238275[ebp]
	cmp	ecx, DWORD PTR $T238276[ebp]
	je	SHORT $LN87@Unguarded_
	mov	edx, DWORD PTR $T238275[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$238271[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$238271[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$238271[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$238271[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$238271[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$238271[ebp+20], ecx
	mov	edx, DWORD PTR $T238275[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR __Tmp$238271[ebp+24], eax
	mov	esi, DWORD PTR $T238276[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238275[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238271[ebp]
	mov	edi, DWORD PTR $T238276[ebp]
	rep movsd
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	$LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T238296[ebp], edx
	mov	eax, DWORD PTR $T238296[ebp]
	cmp	eax, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	ecx, DWORD PTR $T238296[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$238292[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$238292[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$238292[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$238292[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$238292[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Tmp$238292[ebp+20], eax
	mov	ecx, DWORD PTR $T238296[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Tmp$238292[ebp+24], edx
	mov	esi, DWORD PTR __Glast$[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238296[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238292[ebp]
	mov	edi, DWORD PTR __Glast$[ebp]
	rep movsd
$LN94@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Gfirst$[ebp], eax
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
__Step$228784 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$228784[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edx, DWORD PTR __Step$228784[ebp]
	shl	edx, 1
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$228784[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$228784[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$228784[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Mid$[ebp]
	sub	edx, ecx
	push	edx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$228784[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Step$228784[ebp]
	shl	eax, 1
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR __Step$228784[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$228784[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z
_TEXT	SEGMENT
$T238609 = -20						; size = 4
$T238608 = -16						; size = 4
__Hole$228802 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$228802[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$228802[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	edx, DWORD PTR __Hole$228802[ebp]
	sub	edx, 1
	mov	DWORD PTR __Hole$228802[ebp], edx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	eax, DWORD PTR __Hole$228802[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238609[ebp], eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T238608[ebp], esp
	mov	ecx, DWORD PTR $T238609[ebp]
	mov	edx, DWORD PTR $T238608[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR $T238608[ebp]
	mov	eax, DWORD PTR $T238609[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$228802[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 40					; 00000028H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
$T238679 = -72						; size = 4
$T238678 = -68						; size = 4
$T238662 = -62						; size = 1
$T238661 = -61						; size = 1
$T238660 = -60						; size = 4
$T238659 = -56						; size = 4
$T238658 = -52						; size = 4
__Cat$238669 = -44					; size = 1
$T238666 = -43						; size = 1
$T238665 = -42						; size = 1
$T238664 = -41						; size = 1
__First1$228843 = -40					; size = 4
__Val$228833 = -36					; size = 28
__Next1$228832 = -8					; size = 4
__Next$228828 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$228828[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$228828[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next$228828[ebp], edx
	mov	eax, DWORD PTR __Next$228828[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$228828[ebp]
	mov	DWORD PTR __Next1$228832[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$228828[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$228833[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$228833[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$228833[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$228833[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Val$228833[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Val$228833[ebp+20], ecx
	mov	edx, DWORD PTR __Next$228828[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR __Val$228833[ebp+24], eax

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$228833[ebp+24]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+24]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$228832[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next1$228832[ebp], edx
	mov	eax, DWORD PTR __Next1$228832[ebp]
	mov	DWORD PTR $T238679[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238678[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238664[ebp], dl
	mov	al, BYTE PTR __Cat$238669[ebp]
	mov	BYTE PTR $T238665[ebp], al
	mov	cl, BYTE PTR $T238664[ebp]
	mov	BYTE PTR $T238662[ebp], cl
	mov	dl, BYTE PTR $T238666[ebp]
	mov	BYTE PTR $T238661[ebp], dl
	mov	eax, DWORD PTR $T238679[ebp]
	mov	DWORD PTR $T238660[ebp], eax
	mov	ecx, DWORD PTR __Next$228828[ebp]
	mov	DWORD PTR $T238659[ebp], ecx
	mov	edx, DWORD PTR $T238678[ebp]
	mov	DWORD PTR $T238658[ebp], edx
$LN22@Insertion_:
	mov	eax, DWORD PTR $T238658[ebp]
	cmp	eax, DWORD PTR $T238659[ebp]
	je	SHORT $LN15@Insertion_
	mov	ecx, DWORD PTR $T238659[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR $T238659[ebp], ecx
	mov	edx, DWORD PTR $T238660[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR $T238660[ebp], edx
	mov	esi, DWORD PTR $T238659[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR $T238660[ebp]
	rep movsd
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	ecx, 7
	lea	esi, DWORD PTR __Val$228833[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$228832[ebp]
	mov	DWORD PTR __First1$228843[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$228843[ebp]
	mov	DWORD PTR __Next1$228832[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$228843[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR __First1$228843[ebp], edx
	mov	eax, DWORD PTR __First1$228843[ebp]
	mov	ecx, DWORD PTR __Val$228833[ebp+24]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+24]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	esi, DWORD PTR __First1$228843[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR __Next1$228832[ebp]
	rep movsd
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, 7
	lea	esi, DWORD PTR __Val$228833[ebp]
	mov	edi, DWORD PTR __Next1$228832[ebp]
	rep movsd
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
__Tmp$238749 = -84					; size = 28
__Tmp$238727 = -56					; size = 28
__Tmp$238705 = -28					; size = 28
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+24]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+24]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$238705[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$238705[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$238705[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$238705[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$238705[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$238705[ebp+20], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Tmp$238705[ebp+24], ecx
	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR __Mid$[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238705[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+24]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$238727[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$238727[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$238727[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$238727[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$238727[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$238727[ebp+20], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR __Tmp$238727[ebp+24], eax
	mov	esi, DWORD PTR __Mid$[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR __Last$[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238727[ebp]
	mov	edi, DWORD PTR __Mid$[ebp]
	rep movsd

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+24]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$238749[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$238749[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$238749[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$238749[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$238749[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Tmp$238749[ebp+20], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Tmp$238749[ebp+24], edx
	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, 7
	mov	edi, DWORD PTR __Mid$[ebp]
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238749[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd
$LN4@Med3:

; 3005 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z
_TEXT	SEGMENT
$T238774 = -52						; size = 4
$T238773 = -48						; size = 28
__Idx$238769 = -20					; size = 4
$T238760 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 28
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Idx$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __First$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+24]
	xor	edx, edx
	cmp	ecx, DWORD PTR [esi+eax+24]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Idx$[ebp], ecx
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	esi, DWORD PTR __Idx$[ebp]
	imul	esi, 28					; 0000001cH
	add	esi, DWORD PTR __First$[ebp]
	mov	edi, DWORD PTR __Hole$[ebp]
	imul	edi, 28					; 0000001cH
	add	edi, DWORD PTR __First$[ebp]
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], edx

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	eax, DWORD PTR __Idx$[ebp]
	cmp	eax, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	esi, DWORD PTR __Bottom$[ebp]
	sub	esi, 1
	imul	esi, 28					; 0000001cH
	add	esi, DWORD PTR __First$[ebp]
	mov	edi, DWORD PTR __Hole$[ebp]
	imul	edi, 28					; 0000001cH
	add	edi, DWORD PTR __First$[ebp]
	mov	ecx, 7
	rep movsd

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T238773[ebp]
	mov	DWORD PTR $T238760[ebp], edx
	mov	eax, DWORD PTR $T238760[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Val$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Val$[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T238760[ebp]
	mov	ecx, DWORD PTR __Val$[ebp+24]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T238774[ebp], edx
	mov	eax, DWORD PTR $T238774[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$238769[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T238774[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$238769[ebp], eax
$LN14@Adjust_hea:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR $T238774[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	ecx, DWORD PTR __Idx$238769[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T238773[ebp+24]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN12@Adjust_hea
	mov	esi, DWORD PTR __Idx$238769[ebp]
	imul	esi, 28					; 0000001cH
	add	esi, DWORD PTR __First$[ebp]
	mov	edi, DWORD PTR $T238774[ebp]
	imul	edi, 28					; 0000001cH
	add	edi, DWORD PTR __First$[ebp]
	mov	ecx, 7
	rep movsd
	mov	eax, DWORD PTR __Idx$238769[ebp]
	mov	DWORD PTR $T238774[ebp], eax
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edi, DWORD PTR $T238774[ebp]
	imul	edi, 28					; 0000001cH
	add	edi, DWORD PTR __First$[ebp]
	mov	ecx, 7
	lea	esi, DWORD PTR $T238773[ebp]
	rep movsd

; 2072 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
$T238830 = -100						; size = 28
$T238801 = -20						; size = 4
$T238795 = -12						; size = 4
$T238794 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi
	push	edi

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR $T238795[ebp], eax
	lea	ecx, DWORD PTR $T238830[ebp]
	mov	DWORD PTR $T238794[ebp], ecx
	mov	edx, DWORD PTR $T238795[ebp]
	mov	eax, DWORD PTR $T238794[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T238794[ebp]
	mov	ecx, DWORD PTR $T238795[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	esi, DWORD PTR __First$[ebp]
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, 28					; 0000001cH
	mov	ecx, 7
	rep movsd
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T238801[ebp], esp
	mov	eax, DWORD PTR $T238801[ebp]
	mov	ecx, DWORD PTR $T238830[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T238830[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T238830[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T238830[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR $T238830[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T238830[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T238801[ebp]
	mov	ecx, DWORD PTR $T238830[ebp+24]
	mov	DWORD PTR [eax+24], ecx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 28					; 0000001cH
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 40					; 00000028H

; 2090 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T238861 = -2092					; size = 4
$T238860 = -2088					; size = 4
$T238859 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T238859[ebp], eax
	mov	ecx, DWORD PTR $T238859[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T238860[ebp], eax
	mov	eax, DWORD PTR $T238860[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T238861[ebp], eax
	mov	ecx, DWORD PTR $T238861[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T238872 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238872[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T238872[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T238878 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238878[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T238878[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T238890 = -8						; size = 4
$T238886 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238886[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T238886[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238890[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T238890[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovector.h
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
