; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvGameQueries.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ		; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
PUBLIC	?SortItems@?$CvWeightedVector@H$0FK@$00@@QAEXXZ	; CvWeightedVector<int,90,1>::SortItems
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back
PUBLIC	??_C@_0EB@KGIFDJDP@Minor?5Civ?5Quest?3?5Gift?5Unit?5?9?5Add@ ; `string'
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
PUBLIC	__$ArrayPad$
PUBLIC	?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z ; CvGameQueries::GetLeastAdvancedUnitClassNobodyHas
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetResearchCost@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetResearchCost
EXTRN	?GetPower@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetPower
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getUnitClassCount@CvPlayer@@QBEHW4UnitClassTypes@@@Z:PROC ; CvPlayer::getUnitClassCount
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
EXTRN	?GetCombat@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetCombat
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getDefaultUnitIndex@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getDefaultUnitIndex
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0EB@KGIFDJDP@Minor?5Civ?5Quest?3?5Gift?5Unit?5?9?5Add@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EB@KGIFDJDP@Minor?5Civ?5Quest?3?5Gift?5Unit?5?9?5Add@ DB 'Minor Ci'
	DB	'v Quest: Gift Unit - Adding random weight to Unit Chosen', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z$0
__ehfuncinfo$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamequeries.cpp
xdata$x	ENDS
;	COMDAT ?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z
_TEXT	SEGMENT
$T217998 = -876						; size = 4
_weightedElem$217966 = -852				; size = 8
$T217960 = -844						; size = 4
$T217956 = -840						; size = 4
$T217952 = -836						; size = 4
$T217943 = -832						; size = 4
$T217939 = -828						; size = 4
$T217935 = -821						; size = 1
$T217926 = -820						; size = 4
$T217917 = -816						; size = 4
$T217916 = -812						; size = 4
_eUnitClass$217165 = -808				; size = 4
_i$217161 = -804					; size = 4
_iMajorLoop$217146 = -800				; size = 4
_ePrereqTech$217140 = -796				; size = 4
_bAllPlayersHaveTech$217145 = -789			; size = 1
_pkTechInfo$217143 = -788				; size = 4
_eDefaultUnit$217133 = -784				; size = 4
_pkUnitInfo$217136 = -780				; size = 4
_pkUnitClassInfo$217131 = -776				; size = 4
_eUnitClass$217129 = -772				; size = 4
_i$217125 = -768					; size = 4
_bValid$ = -761						; size = 1
_iWeight$ = -760					; size = 4
_UnitClassesVector$ = -756				; size = 736
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bUseRandom$ = 8					; size = 1
?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z PROC ; CvGameQueries::GetLeastAdvancedUnitClassNobodyHas, COMDAT

; 23   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 888				; 00000378H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 24   : 	CvWeightedVector<int, SAFE_ESTIMATE_NUM_UNITS, true> UnitClassesVector;

	lea	ecx, DWORD PTR _UnitClassesVector$[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 25   : 	int iWeight;
; 26   : 
; 27   : 	bool bValid;
; 28   : 
; 29   : #ifdef AUI_WARNING_FIXES
; 30   : 	for (uint i = 0; i < GC.getNumUnitClassInfos(); i++)
; 31   : #else
; 32   : 	for (int i = 0; i < GC.getNumUnitClassInfos(); i++)

	mov	DWORD PTR _i$217125[ebp], 0
	jmp	SHORT $LN23@GetLeastAd
$LN22@GetLeastAd:
	mov	eax, DWORD PTR _i$217125[ebp]
	add	eax, 1
	mov	DWORD PTR _i$217125[ebp], eax
$LN23@GetLeastAd:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _i$217125[ebp], eax
	jge	$LN21@GetLeastAd

; 33   : #endif
; 34   : 	{
; 35   : 		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(i);

	mov	ecx, DWORD PTR _i$217125[ebp]
	mov	DWORD PTR _eUnitClass$217129[ebp], ecx

; 36   : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	edx, DWORD PTR _eUnitClass$217129[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$217131[ebp], eax

; 37   : 		if(pkUnitClassInfo)

	cmp	DWORD PTR _pkUnitClassInfo$217131[ebp], 0
	je	$LN20@GetLeastAd

; 38   : 		{
; 39   : 			const UnitTypes eDefaultUnit = (UnitTypes) pkUnitClassInfo->getDefaultUnitIndex();

	mov	ecx, DWORD PTR _pkUnitClassInfo$217131[ebp]
	call	?getDefaultUnitIndex@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getDefaultUnitIndex
	mov	DWORD PTR _eDefaultUnit$217133[ebp], eax

; 40   : 
; 41   : 			// If the UnitClass doesn't have a Default Unit available to everyone, skip it
; 42   : 			if (eDefaultUnit == NO_UNIT)

	cmp	DWORD PTR _eDefaultUnit$217133[ebp], -1
	jne	SHORT $LN19@GetLeastAd

; 43   : 			{
; 44   : 				continue;

	jmp	SHORT $LN22@GetLeastAd
$LN19@GetLeastAd:

; 45   : 			}
; 46   : 
; 47   : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eDefaultUnit);

	mov	eax, DWORD PTR _eDefaultUnit$217133[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$217136[ebp], eax

; 48   : 			if(pkUnitInfo == NULL)

	cmp	DWORD PTR _pkUnitInfo$217136[ebp], 0
	jne	SHORT $LN18@GetLeastAd

; 49   : 			{
; 50   : 				continue;

	jmp	$LN22@GetLeastAd
$LN18@GetLeastAd:

; 51   : 			}
; 52   : 
; 53   : 			// Only look at Land Units
; 54   : 			if (pkUnitInfo->GetDomainType() != DOMAIN_LAND)

	mov	ecx, DWORD PTR _pkUnitInfo$217136[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	cmp	eax, 2
	je	SHORT $LN17@GetLeastAd

; 55   : 			{
; 56   : 				continue;

	jmp	$LN22@GetLeastAd
$LN17@GetLeastAd:

; 57   : 			}
; 58   : 			// Only look at Military Units
; 59   : 			if (pkUnitInfo->GetCombat() <= 0)

	mov	ecx, DWORD PTR _pkUnitInfo$217136[ebp]
	call	?GetCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombat
	test	eax, eax
	jg	SHORT $LN16@GetLeastAd

; 60   : 			{
; 61   : 				continue;

	jmp	$LN22@GetLeastAd
$LN16@GetLeastAd:

; 62   : 			}
; 63   : 
; 64   : 			const TechTypes ePrereqTech = (TechTypes) pkUnitInfo->GetPrereqAndTech();

	mov	ecx, DWORD PTR _pkUnitInfo$217136[ebp]
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	mov	DWORD PTR _ePrereqTech$217140[ebp], eax

; 65   : 
; 66   : 			// Unit has to require a Tech, otherwise it's too easy!
; 67   : 			if (ePrereqTech == NO_TECH)

	cmp	DWORD PTR _ePrereqTech$217140[ebp], -1
	jne	SHORT $LN15@GetLeastAd

; 68   : 			{
; 69   : 				continue;

	jmp	$LN22@GetLeastAd
$LN15@GetLeastAd:

; 70   : 			}
; 71   : 
; 72   : 			CvTechEntry* pkTechInfo = GC.getTechInfo(ePrereqTech);

	mov	ecx, DWORD PTR _ePrereqTech$217140[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$217143[ebp], eax

; 73   : 			if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$217143[ebp], 0
	jne	SHORT $LN14@GetLeastAd

; 74   : 			{
; 75   : 				continue;

	jmp	$LN22@GetLeastAd
$LN14@GetLeastAd:

; 76   : 			}
; 77   : 
; 78   : 			bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 79   : 			bool bAllPlayersHaveTech = true;

	mov	BYTE PTR _bAllPlayersHaveTech$217145[ebp], 1

; 80   : 
; 81   : 			for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	DWORD PTR _iMajorLoop$217146[ebp], 0
	jmp	SHORT $LN13@GetLeastAd
$LN12@GetLeastAd:
	mov	edx, DWORD PTR _iMajorLoop$217146[ebp]
	add	edx, 1
	mov	DWORD PTR _iMajorLoop$217146[ebp], edx
$LN13@GetLeastAd:
	cmp	DWORD PTR _iMajorLoop$217146[ebp], 22	; 00000016H
	jge	$LN11@GetLeastAd

; 82   : 			{
; 83   : 				if (GET_PLAYER((PlayerTypes) iMajorLoop).isAlive())

	mov	eax, DWORD PTR _iMajorLoop$217146[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T217926[ebp], eax
	mov	ecx, DWORD PTR $T217926[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T217935[ebp], dl
	movzx	eax, BYTE PTR $T217935[ebp]
	test	eax, eax
	je	$LN10@GetLeastAd

; 84   : 				{
; 85   : 					// If a player already has one of this Unit, throw it out - we want something more advanced
; 86   : 					if (GET_PLAYER((PlayerTypes) iMajorLoop).getUnitClassCount(eUnitClass) > 0)

	mov	ecx, DWORD PTR _iMajorLoop$217146[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T217939[ebp], ecx
	mov	edx, DWORD PTR _eUnitClass$217129[ebp]
	push	edx
	mov	ecx, DWORD PTR $T217939[ebp]
	call	?getUnitClassCount@CvPlayer@@QBEHW4UnitClassTypes@@@Z ; CvPlayer::getUnitClassCount
	test	eax, eax
	jle	SHORT $LN9@GetLeastAd

; 87   : 					{
; 88   : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 89   : 						break;

	jmp	SHORT $LN11@GetLeastAd
$LN9@GetLeastAd:

; 90   : 					}
; 91   : 
; 92   : 					// Even if no one has this Unit lying around, if all players already have the Tech which unlocks it, throw it out - too easy
; 93   : 					if (bAllPlayersHaveTech && !GET_TEAM((TeamTypes) GET_PLAYER((PlayerTypes) iMajorLoop).getTeam()).GetTeamTechs()->HasTech(ePrereqTech))

	movzx	eax, BYTE PTR _bAllPlayersHaveTech$217145[ebp]
	test	eax, eax
	je	SHORT $LN10@GetLeastAd
	mov	ecx, DWORD PTR _iMajorLoop$217146[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T217943[ebp], ecx
	mov	edx, DWORD PTR $T217943[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T217952[ebp], eax
	mov	ecx, DWORD PTR $T217952[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T217956[ebp], ecx
	mov	edx, DWORD PTR _ePrereqTech$217140[ebp]
	push	edx
	mov	ecx, DWORD PTR $T217956[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@GetLeastAd

; 94   : 					{
; 95   : 						bAllPlayersHaveTech = false;

	mov	BYTE PTR _bAllPlayersHaveTech$217145[ebp], 0
$LN10@GetLeastAd:

; 96   : 					}
; 97   : 				}
; 98   : 			}

	jmp	$LN12@GetLeastAd
$LN11@GetLeastAd:

; 99   : 			if (!bValid || bAllPlayersHaveTech)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@GetLeastAd
	movzx	edx, BYTE PTR _bAllPlayersHaveTech$217145[ebp]
	test	edx, edx
	je	SHORT $LN7@GetLeastAd
$LN6@GetLeastAd:

; 100  : 			{
; 101  : 				continue;

	jmp	$LN22@GetLeastAd
$LN7@GetLeastAd:

; 102  : 			}
; 103  : 
; 104  : 			iWeight = pkUnitInfo->GetPower();

	mov	ecx, DWORD PTR _pkUnitInfo$217136[ebp]
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	mov	DWORD PTR _iWeight$[ebp], eax

; 105  : 
; 106  : 			// Add a Tech factor, since we want something in the near future, not too far off
; 107  : 			iWeight += (pkTechInfo->GetResearchCost() / 8);

	mov	ecx, DWORD PTR _pkTechInfo$217143[ebp]
	call	?GetResearchCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetResearchCost
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	add	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax

; 108  : 
; 109  : 			// Add a random bit so that the same Unit isn't ALWAYS picked
; 110  : 			if (bUseRandom)

	movzx	eax, BYTE PTR _bUseRandom$[ebp]
	test	eax, eax
	je	SHORT $LN5@GetLeastAd

; 111  : 			{
; 112  : 				iWeight += GC.getGame().getJonRandNum(iWeight / 10, "Minor Civ Quest: Gift Unit - Adding random weight to Unit Chosen");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T217960[ebp], ecx
	push	OFFSET ??_C@_0EB@KGIFDJDP@Minor?5Civ?5Quest?3?5Gift?5Unit?5?9?5Add@
	mov	eax, DWORD PTR _iWeight$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	mov	ecx, DWORD PTR $T217960[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax
$LN5@GetLeastAd:

; 113  : 			}
; 114  : 
; 115  : 			UnitClassesVector.push_back(i, iWeight);

	mov	DWORD PTR _weightedElem$217966[ebp], 0
	mov	DWORD PTR _weightedElem$217966[ebp+4], 0
	mov	edx, DWORD PTR _i$217125[ebp]
	mov	DWORD PTR _weightedElem$217966[ebp], edx
	mov	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$217966[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$217966[ebp]
	push	ecx
	lea	ecx, DWORD PTR _UnitClassesVector$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back
$LN20@GetLeastAd:

; 116  : 		}
; 117  : 	}

	jmp	$LN22@GetLeastAd
$LN21@GetLeastAd:

; 118  : 
; 119  : 	UnitClassesVector.SortItems();

	lea	ecx, DWORD PTR _UnitClassesVector$[ebp]
	call	?SortItems@?$CvWeightedVector@H$0FK@$00@@QAEXXZ ; CvWeightedVector<int,90,1>::SortItems

; 120  : 
; 121  : 	//int iValue;
; 122  : 
; 123  : 	bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 124  : 
; 125  : 	for (int i = UnitClassesVector.size() - 1; i >= 0; i--)

	mov	edx, DWORD PTR _UnitClassesVector$[ebp+4]
	mov	DWORD PTR $T217998[ebp], edx
	mov	eax, DWORD PTR $T217998[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$217161[ebp], eax
	jmp	SHORT $LN4@GetLeastAd
$LN3@GetLeastAd:
	mov	ecx, DWORD PTR _i$217161[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$217161[ebp], ecx
$LN4@GetLeastAd:
	cmp	DWORD PTR _i$217161[ebp], 0
	jl	SHORT $LN2@GetLeastAd

; 126  : 	{
; 127  : 		const UnitClassTypes eUnitClass = (UnitClassTypes) UnitClassesVector.GetElement(i);

	mov	edx, DWORD PTR _i$217161[ebp]
	mov	eax, DWORD PTR _UnitClassesVector$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _eUnitClass$217165[ebp], ecx

; 128  : 
; 129  : 		// First Unit we find in this sorted Vector is our guy
; 130  : 		if (bValid)

	movzx	edx, BYTE PTR _bValid$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetLeastAd

; 131  : 		{
; 132  : 			return eUnitClass;

	mov	eax, DWORD PTR _eUnitClass$217165[ebp]
	mov	DWORD PTR $T217916[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _UnitClassesVector$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	eax, DWORD PTR $T217916[ebp]
	jmp	SHORT $LN24@GetLeastAd
$LN1@GetLeastAd:

; 133  : 		}
; 134  : 	}

	jmp	SHORT $LN3@GetLeastAd
$LN2@GetLeastAd:

; 135  : 
; 136  : 	return NO_UNITCLASS;

	mov	DWORD PTR $T217917[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _UnitClassesVector$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	eax, DWORD PTR $T217917[ebp]
$LN24@GetLeastAd:

; 137  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _UnitClassesVector$[ebp]
	jmp	??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ	; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
__ehhandler$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-892]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLeastAdvancedUnitClassNobodyHas@CvGameQueries@@SA?AW4UnitClassTypes@@_N@Z ENDP ; CvGameQueries::GetLeastAdvancedUnitClassNobodyHas
PUBLIC	?GetTeamClosenessScore@CvGameQueries@@SAHPAPAHPAH@Z ; CvGameQueries::GetTeamClosenessScore
; Function compile flags: /Odtp
;	COMDAT ?GetTeamClosenessScore@CvGameQueries@@SAHPAPAHPAH@Z
_TEXT	SEGMENT
$T218121 = -60						; size = 4
$T218109 = -56						; size = 4
$T218105 = -49						; size = 1
$T218096 = -48						; size = 4
$T218089 = -44						; size = 4
_iTemp$217202 = -40					; size = 4
_iPlayerStart$217199 = -36				; size = 4
_iOtherPlayerStart$217200 = -32				; size = 4
_iOtherPlayer$217192 = -28				; size = 4
_iPlayer$217183 = -24					; size = 4
_iTeamScore$217205 = -20				; size = 4
_iTeamTotalDist$217181 = -16				; size = 4
_iNumEdges$217182 = -12					; size = 4
_iTeam$217175 = -8					; size = 4
_iScore$ = -4						; size = 4
_aaiDistances$ = 8					; size = 4
_aiStartingLocs$ = 12					; size = 4
?GetTeamClosenessScore@CvGameQueries@@SAHPAPAHPAH@Z PROC ; CvGameQueries::GetTeamClosenessScore, COMDAT

; 146  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 147  : 	int iScore = 0;

	mov	DWORD PTR _iScore$[ebp], 0

; 148  : 
; 149  : 	for(int iTeam = 0; iTeam < MAX_CIV_TEAMS; iTeam++)

	mov	DWORD PTR _iTeam$217175[ebp], 0
	jmp	SHORT $LN18@GetTeamClo
$LN17@GetTeamClo:
	mov	eax, DWORD PTR _iTeam$217175[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeam$217175[ebp], eax
$LN18@GetTeamClo:
	cmp	DWORD PTR _iTeam$217175[ebp], 63	; 0000003fH
	jge	$LN16@GetTeamClo

; 150  : 	{
; 151  : 		if(GET_TEAM((TeamTypes)iTeam).isAlive())

	mov	ecx, DWORD PTR _iTeam$217175[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T218089[ebp], ecx
	mov	edx, DWORD PTR $T218089[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@GetTeamClo

; 152  : 		{
; 153  : 			int iTeamTotalDist = 0;

	mov	DWORD PTR _iTeamTotalDist$217181[ebp], 0

; 154  : 			int iNumEdges = 0;

	mov	DWORD PTR _iNumEdges$217182[ebp], 0

; 155  : 			for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)

	mov	DWORD PTR _iPlayer$217183[ebp], 0
	jmp	SHORT $LN14@GetTeamClo
$LN13@GetTeamClo:
	mov	edx, DWORD PTR _iPlayer$217183[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayer$217183[ebp], edx
$LN14@GetTeamClo:
	cmp	DWORD PTR _iPlayer$217183[ebp], 63	; 0000003fH
	jge	$LN12@GetTeamClo

; 156  : 			{
; 157  : 				if(GET_PLAYER((PlayerTypes)iPlayer).isAlive())

	mov	eax, DWORD PTR _iPlayer$217183[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218096[ebp], eax
	mov	ecx, DWORD PTR $T218096[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T218105[ebp], dl
	movzx	eax, BYTE PTR $T218105[ebp]
	test	eax, eax
	je	$LN11@GetTeamClo

; 158  : 				{
; 159  : 					if(GET_PLAYER((PlayerTypes)iPlayer).getTeam() == (TeamTypes)iTeam)

	mov	ecx, DWORD PTR _iPlayer$217183[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218109[ebp], ecx
	mov	edx, DWORD PTR $T218109[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _iTeam$217175[ebp]
	jne	$LN11@GetTeamClo

; 160  : 					{
; 161  : 						for(int iOtherPlayer = 0; iOtherPlayer < iPlayer; iOtherPlayer++)

	mov	DWORD PTR _iOtherPlayer$217192[ebp], 0
	jmp	SHORT $LN9@GetTeamClo
$LN8@GetTeamClo:
	mov	ecx, DWORD PTR _iOtherPlayer$217192[ebp]
	add	ecx, 1
	mov	DWORD PTR _iOtherPlayer$217192[ebp], ecx
$LN9@GetTeamClo:
	mov	edx, DWORD PTR _iOtherPlayer$217192[ebp]
	cmp	edx, DWORD PTR _iPlayer$217183[ebp]
	jge	SHORT $LN11@GetTeamClo

; 162  : 						{
; 163  : 							if(GET_PLAYER((PlayerTypes)iOtherPlayer).getTeam() == (TeamTypes)iTeam)

	mov	eax, DWORD PTR _iOtherPlayer$217192[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218121[ebp], eax
	mov	ecx, DWORD PTR $T218121[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _iTeam$217175[ebp]
	jne	SHORT $LN6@GetTeamClo

; 164  : 							{
; 165  : 								// Add the edge between these two players that are on the same team
; 166  : 								iNumEdges++;

	mov	eax, DWORD PTR _iNumEdges$217182[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumEdges$217182[ebp], eax

; 167  : 								int iPlayerStart = aiStartingLocs[iPlayer];

	mov	ecx, DWORD PTR _iPlayer$217183[ebp]
	mov	edx, DWORD PTR _aiStartingLocs$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _iPlayerStart$217199[ebp], eax

; 168  : 								int iOtherPlayerStart = aiStartingLocs[iOtherPlayer];

	mov	ecx, DWORD PTR _iOtherPlayer$217192[ebp]
	mov	edx, DWORD PTR _aiStartingLocs$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _iOtherPlayerStart$217200[ebp], eax

; 169  : 
; 170  : 								if(iPlayerStart < iOtherPlayerStart)  // Make sure that iPlayerStart > iOtherPlayerStart

	mov	ecx, DWORD PTR _iPlayerStart$217199[ebp]
	cmp	ecx, DWORD PTR _iOtherPlayerStart$217200[ebp]
	jge	SHORT $LN4@GetTeamClo

; 171  : 								{
; 172  : 									int iTemp = iPlayerStart;

	mov	edx, DWORD PTR _iPlayerStart$217199[ebp]
	mov	DWORD PTR _iTemp$217202[ebp], edx

; 173  : 									iPlayerStart = iOtherPlayerStart;

	mov	eax, DWORD PTR _iOtherPlayerStart$217200[ebp]
	mov	DWORD PTR _iPlayerStart$217199[ebp], eax

; 174  : 									iOtherPlayerStart = iTemp;

	mov	ecx, DWORD PTR _iTemp$217202[ebp]
	mov	DWORD PTR _iOtherPlayerStart$217200[ebp], ecx
$LN4@GetTeamClo:

; 175  : 								}
; 176  : 								else if(iPlayerStart == iOtherPlayerStart)
; 177  : 								{
; 178  : 									CvAssertMsg(false, "Two players are (hypothetically) assigned to the same starting location!");
; 179  : 								}
; 180  : 								iTeamTotalDist += aaiDistances[iPlayerStart][iOtherPlayerStart];

	mov	eax, DWORD PTR _iPlayerStart$217199[ebp]
	mov	ecx, DWORD PTR _aaiDistances$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _iOtherPlayerStart$217200[ebp]
	mov	ecx, DWORD PTR _iTeamTotalDist$217181[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iTeamTotalDist$217181[ebp], ecx
$LN6@GetTeamClo:

; 181  : 							}
; 182  : 						}

	jmp	$LN8@GetTeamClo
$LN11@GetTeamClo:

; 183  : 					}
; 184  : 				}
; 185  : 			}

	jmp	$LN13@GetTeamClo
$LN12@GetTeamClo:

; 186  : 
; 187  : 			int iTeamScore;
; 188  : 			if(iNumEdges == 0)

	cmp	DWORD PTR _iNumEdges$217182[ebp], 0
	jne	SHORT $LN2@GetTeamClo

; 189  : 			{
; 190  : 				iTeamScore = 0;

	mov	DWORD PTR _iTeamScore$217205[ebp], 0

; 191  : 			}
; 192  : 			else

	jmp	SHORT $LN1@GetTeamClo
$LN2@GetTeamClo:

; 193  : 			{
; 194  : 				iTeamScore = iTeamTotalDist/iNumEdges; // the avg distance between team edges is the team score

	mov	eax, DWORD PTR _iTeamTotalDist$217181[ebp]
	cdq
	idiv	DWORD PTR _iNumEdges$217182[ebp]
	mov	DWORD PTR _iTeamScore$217205[ebp], eax
$LN1@GetTeamClo:

; 195  : 			}
; 196  : 
; 197  : 			iScore += iTeamScore;

	mov	edx, DWORD PTR _iScore$[ebp]
	add	edx, DWORD PTR _iTeamScore$217205[ebp]
	mov	DWORD PTR _iScore$[ebp], edx
$LN15@GetTeamClo:

; 198  : 		}
; 199  : 	}

	jmp	$LN17@GetTeamClo
$LN16@GetTeamClo:

; 200  : 	return iScore;

	mov	eax, DWORD PTR _iScore$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeamClosenessScore@CvGameQueries@@SAHPAPAHPAH@Z ENDP ; CvGameQueries::GetTeamClosenessScore
_TEXT	ENDS
PUBLIC	?AreUnitsSameType@CvGameQueries@@SA_NW4UnitTypes@@0@Z ; CvGameQueries::AreUnitsSameType
EXTRN	?GetRange@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetRange
; Function compile flags: /Odtp
;	COMDAT ?AreUnitsSameType@CvGameQueries@@SA_NW4UnitTypes@@0@Z
_TEXT	SEGMENT
_bUnit1Combat$217225 = -18				; size = 1
_bUnit2Combat$217226 = -17				; size = 1
_eSecondDomain$ = -16					; size = 4
_eFirstDomain$ = -12					; size = 4
_pkFirstUnitInfo$ = -8					; size = 4
_pkSecondUnitInfo$ = -4					; size = 4
_eFirstUnitType$ = 8					; size = 4
_eSecondUnitType$ = 12					; size = 4
?AreUnitsSameType@CvGameQueries@@SA_NW4UnitTypes@@0@Z PROC ; CvGameQueries::AreUnitsSameType, COMDAT

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 206  : 	CvUnitEntry* pkFirstUnitInfo = GC.getUnitInfo(eFirstUnitType);

	mov	eax, DWORD PTR _eFirstUnitType$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkFirstUnitInfo$[ebp], eax

; 207  : 	CvUnitEntry* pkSecondUnitInfo = GC.getUnitInfo(eSecondUnitType);

	mov	ecx, DWORD PTR _eSecondUnitType$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkSecondUnitInfo$[ebp], eax

; 208  : 
; 209  : 	if(pkFirstUnitInfo == NULL || pkSecondUnitInfo == NULL)

	cmp	DWORD PTR _pkFirstUnitInfo$[ebp], 0
	je	SHORT $LN13@AreUnitsSa
	cmp	DWORD PTR _pkSecondUnitInfo$[ebp], 0
	jne	SHORT $LN14@AreUnitsSa
$LN13@AreUnitsSa:

; 210  : 		return false;

	xor	al, al
	jmp	$LN15@AreUnitsSa
$LN14@AreUnitsSa:

; 211  : 
; 212  : 	int eFirstDomain = pkFirstUnitInfo->GetDomainType();

	mov	ecx, DWORD PTR _pkFirstUnitInfo$[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	mov	DWORD PTR _eFirstDomain$[ebp], eax

; 213  : 	int eSecondDomain = pkSecondUnitInfo->GetDomainType();

	mov	ecx, DWORD PTR _pkSecondUnitInfo$[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	mov	DWORD PTR _eSecondDomain$[ebp], eax

; 214  : 
; 215  : 	// antonjs: Added for Smoky Skies scenario. 
; 216  : 	// If unit is DOMAIN_HOVER, its effective domain is a wildcard, equal to the other unit's domain. This prevents HOVER units from disobeying 1UPT.
; 217  : 	if (eFirstDomain == DOMAIN_HOVER && eSecondDomain == DOMAIN_HOVER)

	cmp	DWORD PTR _eFirstDomain$[ebp], 4
	jne	SHORT $LN12@AreUnitsSa
	cmp	DWORD PTR _eSecondDomain$[ebp], 4
	jne	SHORT $LN12@AreUnitsSa
	jmp	SHORT $LN11@AreUnitsSa
$LN12@AreUnitsSa:

; 218  : 	{
; 219  : 		// Already a match
; 220  : 	}
; 221  : 	else if (eFirstDomain == DOMAIN_HOVER)

	cmp	DWORD PTR _eFirstDomain$[ebp], 4
	jne	SHORT $LN10@AreUnitsSa

; 222  : 	{
; 223  : 		eFirstDomain = eSecondDomain; // Make it a match

	mov	edx, DWORD PTR _eSecondDomain$[ebp]
	mov	DWORD PTR _eFirstDomain$[ebp], edx
	jmp	SHORT $LN11@AreUnitsSa
$LN10@AreUnitsSa:

; 224  : 	}
; 225  : 	else if (eSecondDomain == DOMAIN_HOVER)

	cmp	DWORD PTR _eSecondDomain$[ebp], 4
	jne	SHORT $LN11@AreUnitsSa

; 226  : 	{
; 227  : 		eSecondDomain = eFirstDomain; // Make it a match

	mov	eax, DWORD PTR _eFirstDomain$[ebp]
	mov	DWORD PTR _eSecondDomain$[ebp], eax
$LN11@AreUnitsSa:

; 228  : 	}
; 229  : 
; 230  : 	// Must be in the same domain
; 231  : 	if(eFirstDomain == eSecondDomain)

	mov	ecx, DWORD PTR _eFirstDomain$[ebp]
	cmp	ecx, DWORD PTR _eSecondDomain$[ebp]
	jne	SHORT $LN7@AreUnitsSa

; 232  : 	{
; 233  : 		// Conversely air units can always stack
; 234  : 		if(eFirstDomain == DOMAIN_AIR)

	cmp	DWORD PTR _eFirstDomain$[ebp], 1
	jne	SHORT $LN6@AreUnitsSa

; 235  : 		{
; 236  : 			return false;

	xor	al, al
	jmp	SHORT $LN15@AreUnitsSa
$LN6@AreUnitsSa:

; 237  : 		}
; 238  : 
; 239  : 		bool bUnit1Combat = false;

	mov	BYTE PTR _bUnit1Combat$217225[ebp], 0

; 240  : 		bool bUnit2Combat = false;

	mov	BYTE PTR _bUnit2Combat$217226[ebp], 0

; 241  : 
; 242  : 		// Unit 1 is a combat unit?
; 243  : 		if(pkFirstUnitInfo->GetCombat() > 0 || pkFirstUnitInfo->GetRange() > 0)

	mov	ecx, DWORD PTR _pkFirstUnitInfo$[ebp]
	call	?GetCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombat
	test	eax, eax
	jg	SHORT $LN4@AreUnitsSa
	mov	ecx, DWORD PTR _pkFirstUnitInfo$[ebp]
	call	?GetRange@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRange
	test	eax, eax
	jle	SHORT $LN5@AreUnitsSa
$LN4@AreUnitsSa:

; 244  : 		{
; 245  : 			bUnit1Combat = true;

	mov	BYTE PTR _bUnit1Combat$217225[ebp], 1
$LN5@AreUnitsSa:

; 246  : 		}
; 247  : 
; 248  : 		// Unit 2 is a combat unit?
; 249  : 		if(pkSecondUnitInfo->GetCombat() > 0 || pkSecondUnitInfo->GetRange() > 0)

	mov	ecx, DWORD PTR _pkSecondUnitInfo$[ebp]
	call	?GetCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombat
	test	eax, eax
	jg	SHORT $LN2@AreUnitsSa
	mov	ecx, DWORD PTR _pkSecondUnitInfo$[ebp]
	call	?GetRange@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRange
	test	eax, eax
	jle	SHORT $LN3@AreUnitsSa
$LN2@AreUnitsSa:

; 250  : 		{
; 251  : 			bUnit2Combat = true;

	mov	BYTE PTR _bUnit2Combat$217226[ebp], 1
$LN3@AreUnitsSa:

; 252  : 		}
; 253  : 
; 254  : 		// Looped unit matches combat or non-combat type?
; 255  : 		if(bUnit1Combat == bUnit2Combat)

	movzx	edx, BYTE PTR _bUnit1Combat$217225[ebp]
	movzx	eax, BYTE PTR _bUnit2Combat$217226[ebp]
	cmp	edx, eax
	jne	SHORT $LN7@AreUnitsSa

; 256  : 		{
; 257  : 			// Unit is the same domain & combat type, so we have a match
; 258  : 			return true;

	mov	al, 1
	jmp	SHORT $LN15@AreUnitsSa
$LN7@AreUnitsSa:

; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	return false;

	xor	al, al
$LN15@AreUnitsSa:

; 263  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AreUnitsSameType@CvGameQueries@@SA_NW4UnitTypes@@0@Z ENDP ; CvGameQueries::AreUnitsSameType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ PROC		; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ ENDP		; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
; Function compile flags: /Odtp
;	COMDAT ?SortItems@?$CvWeightedVector@H$0FK@$00@@QAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T218171 = -8						; size = 4
$T218167 = -4						; size = 4
?SortItems@?$CvWeightedVector@H$0FK@$00@@QAEXXZ PROC	; CvWeightedVector<int,90,1>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T218167[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218171[ebp], eax
	mov	ecx, DWORD PTR $T218167[ebp]
	sub	ecx, DWORD PTR $T218171[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T218167[ebp]
	push	edx
	mov	eax, DWORD PTR $T218171[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortItems@?$CvWeightedVector@H$0FK@$00@@QAEXXZ ENDP	; CvWeightedVector<int,90,1>::SortItems
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T218362 = -20						; size = 4
_pRet$218358 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 90			; 0000005aH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218362[ebp], edx
	cmp	DWORD PTR $T218362[ebp], 90		; 0000005aH
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T218362[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$218358[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T218362[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$218358[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 90			; 0000005aH
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$218358[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T218393 = -24						; size = 4
$T218392 = -20						; size = 4
_i$218387 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218393[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218392[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$218387[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$218387[ebp]
	add	eax, 1
	mov	DWORD PTR _i$218387[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$218387[ebp]
	cmp	ecx, DWORD PTR $T218393[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T218392[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T218392[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T218406 = -8						; size = 4
$T218405 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+732], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T218406[ebp], ecx
	cmp	DWORD PTR $T218406[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T218406[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T218406[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T218406[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T218405[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T218500 = -44						; size = 4
$T218499 = -40						; size = 4
_i$218494 = -36						; size = 4
$T218478 = -32						; size = 4
$T218471 = -28						; size = 4
_pRet$218467 = -24					; size = 4
$T218461 = -20						; size = 4
$T218460 = -16						; size = 4
_i$217288 = -12						; size = 4
_uiNewSize$217280 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$217280[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$217280[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$217280[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T218471[ebp], ecx
	cmp	DWORD PTR $T218471[ebp], 90		; 0000005aH
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T218471[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$218467[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T218471[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$218467[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 90			; 0000005aH
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$218467[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$217288[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$217288[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217288[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$217288[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$217288[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T218461[ebp], ecx
	cmp	DWORD PTR $T218461[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$217288[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T218478[ebp], edx
	mov	eax, DWORD PTR $T218461[ebp]
	mov	ecx, DWORD PTR $T218478[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T218461[ebp]
	mov	ecx, DWORD PTR $T218478[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T218461[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T218460[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218500[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T218499[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$218494[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$218494[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218494[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$218494[ebp]
	cmp	eax, DWORD PTR $T218500[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T218499[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T218499[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+732], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z
_TEXT	SEGMENT
$T218630 = -128						; size = 4
__Mid$217371 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$217371[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$217371[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$217371[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$217371[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$217371[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$217371[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$217371[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T218630[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T218630[ebp]
	sub	eax, 8
	mov	DWORD PTR $T218630[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T218630[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T218630[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T218630[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z
_TEXT	SEGMENT
$T218873 = -124						; size = 4
__Tmp$218869 = -120					; size = 8
$T218853 = -112						; size = 4
$T218852 = -108						; size = 4
__Tmp$218848 = -104					; size = 8
$T218832 = -96						; size = 4
__Tmp$218828 = -92					; size = 8
$T218812 = -84						; size = 4
$T218811 = -80						; size = 4
__Tmp$218807 = -76					; size = 8
$T218791 = -68						; size = 4
$T218790 = -64						; size = 4
__Tmp$218786 = -60					; size = 8
$T218767 = -52						; size = 4
$T218766 = -48						; size = 4
__Tmp$218762 = -44					; size = 8
$T218740 = -36						; size = 4
__Tmp$218736 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T218740[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T218740[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T218740[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$218736[ebp], edx
	mov	eax, DWORD PTR $T218740[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$218736[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T218740[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$218736[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$218736[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T218767[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T218766[ebp], edx
	mov	eax, DWORD PTR $T218766[ebp]
	cmp	eax, DWORD PTR $T218767[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T218766[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$218762[ebp], edx
	mov	eax, DWORD PTR $T218766[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$218762[ebp+4], ecx
	mov	edx, DWORD PTR $T218767[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T218766[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T218767[ebp]
	mov	ecx, DWORD PTR __Tmp$218762[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$218762[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T218791[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T218790[ebp], eax
	mov	ecx, DWORD PTR $T218790[ebp]
	cmp	ecx, DWORD PTR $T218791[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T218790[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$218786[ebp], eax
	mov	ecx, DWORD PTR $T218790[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$218786[ebp+4], edx
	mov	eax, DWORD PTR $T218791[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T218790[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T218791[ebp]
	mov	edx, DWORD PTR __Tmp$218786[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$218786[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T218812[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T218811[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T218811[ebp]
	cmp	eax, DWORD PTR $T218812[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T218811[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$218807[ebp], edx
	mov	eax, DWORD PTR $T218811[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$218807[ebp+4], ecx
	mov	edx, DWORD PTR $T218812[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T218811[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T218812[ebp]
	mov	ecx, DWORD PTR __Tmp$218807[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$218807[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T218832[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T218832[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$218828[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$218828[ebp+4], eax
	mov	ecx, DWORD PTR $T218832[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T218832[ebp]
	mov	eax, DWORD PTR __Tmp$218828[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$218828[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T218853[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T218852[ebp], ecx
	mov	edx, DWORD PTR $T218852[ebp]
	cmp	edx, DWORD PTR $T218853[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T218852[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$218848[ebp], ecx
	mov	edx, DWORD PTR $T218852[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$218848[ebp+4], eax
	mov	ecx, DWORD PTR $T218853[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T218852[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T218853[ebp]
	mov	eax, DWORD PTR __Tmp$218848[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$218848[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T218873[ebp], eax
	mov	ecx, DWORD PTR $T218873[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T218873[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$218869[ebp], eax
	mov	ecx, DWORD PTR $T218873[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$218869[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T218873[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$218869[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$218869[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
__Step$217515 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$217515[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$217515[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$217515[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$217515[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$217515[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$217515[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$217515[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$217515[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$217515[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z
_TEXT	SEGMENT
$T219186 = -20						; size = 4
$T219185 = -16						; size = 4
__Hole$217533 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$217533[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$217533[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$217533[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$217533[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$217533[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T219186[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T219185[ebp], esp
	mov	edx, DWORD PTR $T219185[ebp]
	mov	eax, DWORD PTR $T219186[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T219185[ebp]
	mov	eax, DWORD PTR $T219186[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$217533[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
$T219256 = -52						; size = 4
$T219255 = -48						; size = 4
$T219239 = -42						; size = 1
$T219238 = -41						; size = 1
$T219237 = -40						; size = 4
$T219236 = -36						; size = 4
$T219235 = -32						; size = 4
__Cat$219246 = -24					; size = 1
$T219243 = -23						; size = 1
$T219242 = -22						; size = 1
$T219241 = -21						; size = 1
__First1$217574 = -20					; size = 4
__Val$217564 = -16					; size = 8
__Next1$217563 = -8					; size = 4
__Next$217559 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$217559[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$217559[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$217559[ebp], edx
	mov	eax, DWORD PTR __Next$217559[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$217559[ebp]
	mov	DWORD PTR __Next1$217563[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$217559[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$217564[ebp], eax
	mov	ecx, DWORD PTR __Next$217559[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$217564[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$217564[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$217563[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$217563[ebp], ecx
	mov	edx, DWORD PTR __Next1$217563[ebp]
	mov	DWORD PTR $T219256[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T219255[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T219241[ebp], cl
	mov	dl, BYTE PTR __Cat$219246[ebp]
	mov	BYTE PTR $T219242[ebp], dl
	mov	al, BYTE PTR $T219241[ebp]
	mov	BYTE PTR $T219239[ebp], al
	mov	cl, BYTE PTR $T219243[ebp]
	mov	BYTE PTR $T219238[ebp], cl
	mov	edx, DWORD PTR $T219256[ebp]
	mov	DWORD PTR $T219237[ebp], edx
	mov	eax, DWORD PTR __Next$217559[ebp]
	mov	DWORD PTR $T219236[ebp], eax
	mov	ecx, DWORD PTR $T219255[ebp]
	mov	DWORD PTR $T219235[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T219235[ebp]
	cmp	edx, DWORD PTR $T219236[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T219236[ebp]
	sub	eax, 8
	mov	DWORD PTR $T219236[ebp], eax
	mov	ecx, DWORD PTR $T219237[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T219237[ebp], ecx
	mov	edx, DWORD PTR $T219236[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T219237[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$217564[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$217564[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$217563[ebp]
	mov	DWORD PTR __First1$217574[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$217574[ebp]
	mov	DWORD PTR __Next1$217563[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$217574[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$217574[ebp], edx
	mov	eax, DWORD PTR __First1$217574[ebp]
	mov	ecx, DWORD PTR __Val$217564[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$217574[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$217563[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$217563[ebp]
	mov	eax, DWORD PTR __Val$217564[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$217564[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
__Tmp$219326 = -24					; size = 8
__Tmp$219304 = -16					; size = 8
__Tmp$219282 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$219282[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$219282[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$219282[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$219282[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$219304[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$219304[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$219304[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$219304[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$219326[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$219326[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$219326[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$219326[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z
_TEXT	SEGMENT
$T219351 = -32						; size = 4
$T219350 = -28						; size = 8
__Idx$219346 = -20					; size = 4
$T219337 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T219350[ebp]
	mov	DWORD PTR $T219337[ebp], edx
	mov	eax, DWORD PTR $T219337[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T219337[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T219351[ebp], ecx
	mov	eax, DWORD PTR $T219351[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$219346[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T219351[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$219346[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T219351[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$219346[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T219350[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$219346[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T219351[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$219346[ebp]
	mov	DWORD PTR $T219351[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T219351[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T219350[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T219350[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
$T219397 = -60						; size = 8
$T219368 = -20						; size = 4
$T219362 = -12						; size = 4
$T219361 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T219362[ebp], eax
	lea	ecx, DWORD PTR $T219397[ebp]
	mov	DWORD PTR $T219361[ebp], ecx
	mov	edx, DWORD PTR $T219361[ebp]
	mov	eax, DWORD PTR $T219362[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T219361[ebp]
	mov	eax, DWORD PTR $T219362[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T219368[ebp], esp
	mov	eax, DWORD PTR $T219368[ebp]
	mov	ecx, DWORD PTR $T219397[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T219368[ebp]
	mov	eax, DWORD PTR $T219397[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
END
