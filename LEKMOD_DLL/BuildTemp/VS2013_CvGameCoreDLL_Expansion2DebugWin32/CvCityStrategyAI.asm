; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCityStrategyAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA	; CvCityStrategyAI::m_acBestYields
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
_BSS	SEGMENT
?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA DB 0deH DUP (?) ; CvCityStrategyAI::m_acBestYields
_BSS	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvAICityStrategyEntry@@6B@			; CvAICityStrategyEntry::`vftable'
PUBLIC	??0CvAICityStrategyEntry@@QAE@XZ		; CvAICityStrategyEntry::CvAICityStrategyEntry
PUBLIC	?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvAICityStrategyEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvAICityStrategyEntry@@UAEPAXI@Z:PROC	; CvAICityStrategyEntry::`vector deleting destructor'
;	COMDAT ??_7CvAICityStrategyEntry@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvAICityStrategyEntry@@6B@ DD FLAT:?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvAICityStrategyEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvAICityStrategyEntry@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvAICityStrategyEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvAICityStrategyEntry@@QAE@XZ$0
__ehfuncinfo$??0CvAICityStrategyEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvAICityStrategyEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvAICityStrategyEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230401 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvAICityStrategyEntry@@QAE@XZ PROC			; CvAICityStrategyEntry::CvAICityStrategyEntry, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvAICityStrategyEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAICityStrategyEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+288], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+289], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 296				; 00000128H
	mov	DWORD PTR $T230401[ebp], edx
	mov	ecx, DWORD PTR $T230401[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+324], 1

; 41   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvAICityStrategyEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvAICityStrategyEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvAICityStrategyEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvAICityStrategyEntry@@QAE@XZ ENDP			; CvAICityStrategyEntry::CvAICityStrategyEntry
PUBLIC	??1CvAICityStrategyEntry@@UAE@XZ		; CvAICityStrategyEntry::~CvAICityStrategyEntry
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvAICityStrategyEntry@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAICityStrategyEntry@@UAEPAXI@Z PROC		; CvAICityStrategyEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAICityStrategyEntry@@UAE@XZ	; CvAICityStrategyEntry::~CvAICityStrategyEntry
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAICityStrategyEntry@@UAEPAXI@Z ENDP		; CvAICityStrategyEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T230470 = -48						; size = 4
$T230465 = -44						; size = 4
$T230460 = -40						; size = 4
$T230455 = -36						; size = 4
$T230450 = -32						; size = 4
$T230445 = -28						; size = 4
$T230440 = -24						; size = 4
$T230435 = -20						; size = 4
$T230430 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T230430[ebp], eax
	mov	ecx, DWORD PTR $T230430[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T230435[ebp], ecx
	mov	ecx, DWORD PTR $T230435[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T230440[ebp], edx
	mov	ecx, DWORD PTR $T230440[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T230445[ebp], eax
	mov	ecx, DWORD PTR $T230445[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T230450[ebp], ecx
	mov	ecx, DWORD PTR $T230450[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T230455[ebp], edx
	mov	ecx, DWORD PTR $T230455[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T230460[ebp], eax
	mov	ecx, DWORD PTR $T230460[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T230465[ebp], ecx
	mov	ecx, DWORD PTR $T230465[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T230470[ebp], edx
	mov	ecx, DWORD PTR $T230470[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvAICityStrategyEntry@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAICityStrategyEntry@@UAE@XZ$0
__ehfuncinfo$??1CvAICityStrategyEntry@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvAICityStrategyEntry@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvAICityStrategyEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T230497 = -32						; size = 4
$T230492 = -28						; size = 4
$T230490 = -24						; size = 4
$T230486 = -20						; size = 4
$T230484 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAICityStrategyEntry@@UAE@XZ PROC			; CvAICityStrategyEntry::~CvAICityStrategyEntry, COMDAT
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvAICityStrategyEntry@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAICityStrategyEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 45   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	mov	DWORD PTR $T230486[ebp], ecx
	mov	edx, DWORD PTR $T230486[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230484[ebp], eax
	mov	ecx, DWORD PTR $T230484[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230486[ebp]
	mov	DWORD PTR [edx], 0

; 46   : 	SAFE_DELETE_ARRAY(m_piPersonalityFlavorThresholdMod);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 268				; 0000010cH
	mov	DWORD PTR $T230492[ebp], eax
	mov	ecx, DWORD PTR $T230492[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230490[ebp], edx
	mov	eax, DWORD PTR $T230490[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230492[ebp]
	mov	DWORD PTR [ecx], 0

; 47   : }

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 296				; 00000128H
	mov	DWORD PTR $T230497[ebp], edx
	mov	ecx, DWORD PTR $T230497[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAICityStrategyEntry@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvAICityStrategyEntry@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvAICityStrategyEntry@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAICityStrategyEntry@@UAE@XZ ENDP			; CvAICityStrategyEntry::~CvAICityStrategyEntry
PUBLIC	??_C@_0CO@PLDOECEE@AICityStrategy_PersonalityFlavor@ ; `string'
PUBLIC	??_C@_0BH@BAIDBNFC@AICityStrategy_Flavors?$AA@	; `string'
PUBLIC	??_C@_0BD@BEKMHKAN@AICityStrategyType?$AA@	; `string'
PUBLIC	??_C@_0L@IANCLNMF@TechPrereq?$AA@		; `string'
PUBLIC	??_C@_0N@COMAJFAF@TechObsolete?$AA@		; `string'
PUBLIC	??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@ ; `string'
PUBLIC	??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@		; `string'
PUBLIC	??_C@_07IMKJABN@SCIENCE?$AA@			; `string'
PUBLIC	??_C@_07OLAKHONA@FOREIGN?$AA@			; `string'
PUBLIC	??_C@_08LKDCODGK@ECONOMIC?$AA@			; `string'
PUBLIC	??_C@_08EBHPNIPO@MILITARY?$AA@			; `string'
PUBLIC	??_C@_07GOECOJOI@Advisor?$AA@			; `string'
PUBLIC	??_C@_0BA@BKBCAEL@WeightThreshold?$AA@		; `string'
PUBLIC	??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@	; `string'
PUBLIC	??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@	; `string'
PUBLIC	??_C@_09FHMJCGNI@Permanent?$AA@			; `string'
PUBLIC	??_C@_0M@PGLGACOH@NoMinorCivs?$AA@		; `string'
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0CO@PLDOECEE@AICityStrategy_PersonalityFlavor@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
CONST	SEGMENT
??_C@_0CO@PLDOECEE@AICityStrategy_PersonalityFlavor@ DB 'AICityStrategy_P'
	DB	'ersonalityFlavorThresholdMods', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BAIDBNFC@AICityStrategy_Flavors?$AA@
CONST	SEGMENT
??_C@_0BH@BAIDBNFC@AICityStrategy_Flavors?$AA@ DB 'AICityStrategy_Flavors'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BEKMHKAN@AICityStrategyType?$AA@
CONST	SEGMENT
??_C@_0BD@BEKMHKAN@AICityStrategyType?$AA@ DB 'AICityStrategyType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IANCLNMF@TechPrereq?$AA@
CONST	SEGMENT
??_C@_0L@IANCLNMF@TechPrereq?$AA@ DB 'TechPrereq', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@COMAJFAF@TechObsolete?$AA@
CONST	SEGMENT
??_C@_0N@COMAJFAF@TechObsolete?$AA@ DB 'TechObsolete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@
CONST	SEGMENT
??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@ DB 'AdvisorCounselImport'
	DB	'ance', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@
CONST	SEGMENT
??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@ DB 'AdvisorCounsel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMKJABN@SCIENCE?$AA@
CONST	SEGMENT
??_C@_07IMKJABN@SCIENCE?$AA@ DB 'SCIENCE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLAKHONA@FOREIGN?$AA@
CONST	SEGMENT
??_C@_07OLAKHONA@FOREIGN?$AA@ DB 'FOREIGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LKDCODGK@ECONOMIC?$AA@
CONST	SEGMENT
??_C@_08LKDCODGK@ECONOMIC?$AA@ DB 'ECONOMIC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBHPNIPO@MILITARY?$AA@
CONST	SEGMENT
??_C@_08EBHPNIPO@MILITARY?$AA@ DB 'MILITARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOECOJOI@Advisor?$AA@
CONST	SEGMENT
??_C@_07GOECOJOI@Advisor?$AA@ DB 'Advisor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BKBCAEL@WeightThreshold?$AA@
CONST	SEGMENT
??_C@_0BA@BKBCAEL@WeightThreshold?$AA@ DB 'WeightThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@
CONST	SEGMENT
??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@ DB 'MinimumNumTurnsExecut'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@
CONST	SEGMENT
??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@ DB 'CheckTriggerTurnCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FHMJCGNI@Permanent?$AA@
CONST	SEGMENT
??_C@_09FHMJCGNI@Permanent?$AA@ DB 'Permanent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGLGACOH@NoMinorCivs?$AA@
CONST	SEGMENT
??_C@_0M@PGLGACOH@NoMinorCivs?$AA@ DB 'NoMinorCivs', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv152 = -104						; size = 4
tv319 = -100						; size = 4
tv314 = -94						; size = 1
tv307 = -93						; size = 1
tv302 = -92						; size = 4
tv304 = -88						; size = 4
tv146 = -84						; size = 4
tv296 = -80						; size = 4
tv291 = -74						; size = 1
tv284 = -73						; size = 1
tv279 = -72						; size = 4
tv281 = -68						; size = 4
tv140 = -64						; size = 4
tv273 = -60						; size = 4
tv268 = -54						; size = 1
tv261 = -53						; size = 1
tv256 = -52						; size = 4
tv258 = -48						; size = 4
tv134 = -44						; size = 4
tv250 = -40						; size = 4
tv245 = -34						; size = 1
tv238 = -33						; size = 1
tv233 = -32						; size = 4
tv235 = -28						; size = 4
_this$ = -24						; size = 4
$T230567 = -20						; size = 4
$T230566 = -16						; size = 4
_szType$ = -12						; size = 4
_strAdvisor$ = -8					; size = 4
_szTextVal$ = -4					; size = 4
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvAICityStrategyEntry::CacheResults, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@CacheResul

; 52   : 		return false;

	xor	al, al
	jmp	$LN10@CacheResul
$LN9@CacheResul:

; 53   : 
; 54   : 	//Basic Properties
; 55   : 	m_bNoMinorCivs				= kResults.GetBool("NoMinorCivs");

	push	OFFSET ??_C@_0M@PGLGACOH@NoMinorCivs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+288], al

; 56   : 	m_bPermanent				= kResults.GetBool("Permanent");

	push	OFFSET ??_C@_09FHMJCGNI@Permanent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+289], al

; 57   : 	m_iCheckTriggerTurnCount	= kResults.GetInt("CheckTriggerTurnCount");

	push	OFFSET ??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 58   : 	m_iMinimumNumTurnsExecuted	= kResults.GetInt("MinimumNumTurnsExecuted");

	push	OFFSET ??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], eax

; 59   : 	m_iWeightThreshold			= kResults.GetInt("WeightThreshold");

	push	OFFSET ??_C@_0BA@BKBCAEL@WeightThreshold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 60   : 
; 61   : 	const char* strAdvisor = kResults.GetText("Advisor");

	push	OFFSET ??_C@_07GOECOJOI@Advisor?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _strAdvisor$[ebp], eax

; 62   : 	m_eAdvisor = NO_ADVISOR_TYPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], -1

; 63   : 	if(strAdvisor)

	cmp	DWORD PTR _strAdvisor$[ebp], 0
	je	$LN8@CacheResul

; 64   : 	{
; 65   : 		if(strcmp(strAdvisor, "MILITARY") == 0)

	mov	DWORD PTR tv235[ebp], OFFSET ??_C@_08EBHPNIPO@MILITARY?$AA@
	mov	eax, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv233[ebp], eax
$LL18@CacheResul:
	mov	ecx, DWORD PTR tv233[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv238[ebp], dl
	mov	eax, DWORD PTR tv235[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN19@CacheResul
	cmp	BYTE PTR tv238[ebp], 0
	je	SHORT $LN20@CacheResul
	mov	ecx, DWORD PTR tv233[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv245[ebp], dl
	mov	eax, DWORD PTR tv235[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN19@CacheResul
	add	DWORD PTR tv233[ebp], 2
	add	DWORD PTR tv235[ebp], 2
	cmp	BYTE PTR tv245[ebp], 0
	jne	SHORT $LL18@CacheResul
$LN20@CacheResul:
	mov	DWORD PTR tv250[ebp], 0
	jmp	SHORT $LN21@CacheResul
$LN19@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv250[ebp], ecx
$LN21@CacheResul:
	mov	edx, DWORD PTR tv250[ebp]
	mov	DWORD PTR tv134[ebp], edx
	cmp	DWORD PTR tv134[ebp], 0
	jne	SHORT $LN7@CacheResul

; 66   : 		{
; 67   : 			m_eAdvisor = ADVISOR_MILITARY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0
	jmp	$LN8@CacheResul
$LN7@CacheResul:

; 68   : 		}
; 69   : 		else if(strcmp(strAdvisor, "ECONOMIC") == 0)

	mov	DWORD PTR tv258[ebp], OFFSET ??_C@_08LKDCODGK@ECONOMIC?$AA@
	mov	ecx, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv256[ebp], ecx
$LL22@CacheResul:
	mov	edx, DWORD PTR tv256[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv261[ebp], al
	mov	ecx, DWORD PTR tv258[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN23@CacheResul
	cmp	BYTE PTR tv261[ebp], 0
	je	SHORT $LN24@CacheResul
	mov	edx, DWORD PTR tv256[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv268[ebp], al
	mov	ecx, DWORD PTR tv258[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN23@CacheResul
	add	DWORD PTR tv256[ebp], 2
	add	DWORD PTR tv258[ebp], 2
	cmp	BYTE PTR tv268[ebp], 0
	jne	SHORT $LL22@CacheResul
$LN24@CacheResul:
	mov	DWORD PTR tv273[ebp], 0
	jmp	SHORT $LN25@CacheResul
$LN23@CacheResul:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv273[ebp], edx
$LN25@CacheResul:
	mov	eax, DWORD PTR tv273[ebp]
	mov	DWORD PTR tv140[ebp], eax
	cmp	DWORD PTR tv140[ebp], 0
	jne	SHORT $LN5@CacheResul

; 70   : 		{
; 71   : 			m_eAdvisor = ADVISOR_ECONOMIC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], 1
	jmp	$LN8@CacheResul
$LN5@CacheResul:

; 72   : 		}
; 73   : 		else if(strcmp(strAdvisor, "FOREIGN") == 0)

	mov	DWORD PTR tv281[ebp], OFFSET ??_C@_07OLAKHONA@FOREIGN?$AA@
	mov	edx, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv279[ebp], edx
$LL26@CacheResul:
	mov	eax, DWORD PTR tv279[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv284[ebp], cl
	mov	edx, DWORD PTR tv281[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN27@CacheResul
	cmp	BYTE PTR tv284[ebp], 0
	je	SHORT $LN28@CacheResul
	mov	eax, DWORD PTR tv279[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv291[ebp], cl
	mov	edx, DWORD PTR tv281[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN27@CacheResul
	add	DWORD PTR tv279[ebp], 2
	add	DWORD PTR tv281[ebp], 2
	cmp	BYTE PTR tv291[ebp], 0
	jne	SHORT $LL26@CacheResul
$LN28@CacheResul:
	mov	DWORD PTR tv296[ebp], 0
	jmp	SHORT $LN29@CacheResul
$LN27@CacheResul:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv296[ebp], eax
$LN29@CacheResul:
	mov	ecx, DWORD PTR tv296[ebp]
	mov	DWORD PTR tv146[ebp], ecx
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN3@CacheResul

; 74   : 		{
; 75   : 			m_eAdvisor = ADVISOR_FOREIGN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], 2
	jmp	SHORT $LN8@CacheResul
$LN3@CacheResul:

; 76   : 		}
; 77   : 		else if(strcmp(strAdvisor, "SCIENCE") == 0)

	mov	DWORD PTR tv304[ebp], OFFSET ??_C@_07IMKJABN@SCIENCE?$AA@
	mov	eax, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv302[ebp], eax
$LL30@CacheResul:
	mov	ecx, DWORD PTR tv302[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv307[ebp], dl
	mov	eax, DWORD PTR tv304[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN31@CacheResul
	cmp	BYTE PTR tv307[ebp], 0
	je	SHORT $LN32@CacheResul
	mov	ecx, DWORD PTR tv302[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv314[ebp], dl
	mov	eax, DWORD PTR tv304[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN31@CacheResul
	add	DWORD PTR tv302[ebp], 2
	add	DWORD PTR tv304[ebp], 2
	cmp	BYTE PTR tv314[ebp], 0
	jne	SHORT $LL30@CacheResul
$LN32@CacheResul:
	mov	DWORD PTR tv319[ebp], 0
	jmp	SHORT $LN33@CacheResul
$LN31@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv319[ebp], ecx
$LN33@CacheResul:
	mov	edx, DWORD PTR tv319[ebp]
	mov	DWORD PTR tv152[ebp], edx
	cmp	DWORD PTR tv152[ebp], 0
	jne	SHORT $LN8@CacheResul

; 78   : 		{
; 79   : 			m_eAdvisor = ADVISOR_SCIENCE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 3
$LN8@CacheResul:

; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	m_strAdvisorCounselText = kResults.GetText("AdvisorCounsel");

	push	OFFSET ??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR $T230567[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	mov	DWORD PTR $T230566[ebp], ecx
	cmp	DWORD PTR $T230567[ebp], 0
	je	SHORT $LN13@CacheResul
	mov	edx, DWORD PTR $T230567[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230566[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@CacheResul
$LN13@CacheResul:
	mov	ecx, DWORD PTR $T230566[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@CacheResul:

; 84   : 	m_iAdvisorCounselImportance = kResults.GetInt("AdvisorCounselImportance");

	push	OFFSET ??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], eax

; 85   : 
; 86   : 	//References
; 87   : 	const char* szTextVal;
; 88   : 	szTextVal = kResults.GetText("TechObsolete");

	push	OFFSET ??_C@_0N@COMAJFAF@TechObsolete?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 89   : 	m_iTechObsolete = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 90   : 
; 91   : 	szTextVal = kResults.GetText("TechPrereq");

	push	OFFSET ??_C@_0L@IANCLNMF@TechPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 92   : 	m_iTechPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 93   : 
; 94   : 	//Arrays
; 95   : 	const char* szType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szType$[ebp], eax

; 96   : 	kUtility.SetFlavors(m_piFlavorValue, "AICityStrategy_Flavors",
; 97   : 	                    "AICityStrategyType", szType);

	push	0
	mov	edx, DWORD PTR _szType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BD@BEKMHKAN@AICityStrategyType?$AA@
	push	OFFSET ??_C@_0BH@BAIDBNFC@AICityStrategy_Flavors?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 98   : 
; 99   : 	kUtility.SetFlavors(m_piPersonalityFlavorThresholdMod,
; 100  : 	                    "AICityStrategy_PersonalityFlavorThresholdMods",
; 101  : 	                    "AICityStrategyType", szType);

	push	0
	mov	ecx, DWORD PTR _szType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@BEKMHKAN@AICityStrategyType?$AA@
	push	OFFSET ??_C@_0CO@PLDOECEE@AICityStrategy_PersonalityFlavor@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 268				; 0000010cH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 102  : 
; 103  : 	return true;

	mov	al, 1
$LN10@CacheResul:

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvAICityStrategyEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z	; CvAICityStrategyEntry::GetFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z PROC	; CvAICityStrategyEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 110  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 111  : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetFlavorV
$LN3@GetFlavorV:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetFlavorV:
	mov	eax, DWORD PTR tv69[ebp]

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z ENDP	; CvAICityStrategyEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
; Function compile flags: /Odtp
;	COMDAT ?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ PROC	; CvAICityStrategyEntry::GetWeightThreshold, COMDAT
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	return m_iWeightThreshold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 118  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ENDP	; CvAICityStrategyEntry::GetWeightThreshold
_TEXT	ENDS
PUBLIC	?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod
; Function compile flags: /Odtp
;	COMDAT ?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z PROC ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod, COMDAT
; _this$ = ecx

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 124  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 125  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $LN3@GetPersona
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPersona
$LN3@GetPersona:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPersona:
	mov	eax, DWORD PTR tv69[ebp]

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z ENDP ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ	; CvAICityStrategyEntry::GetTechPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ PROC	; CvAICityStrategyEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ ENDP	; CvAICityStrategyEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ	; CvAICityStrategyEntry::GetTechObsolete
; Function compile flags: /Odtp
;	COMDAT ?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ PROC	; CvAICityStrategyEntry::GetTechObsolete, COMDAT
; _this$ = ecx

; 136  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 	return m_iTechObsolete;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ ENDP	; CvAICityStrategyEntry::GetTechObsolete
_TEXT	ENDS
PUBLIC	?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted
; Function compile flags: /Odtp
;	COMDAT ?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ PROC ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	return m_iMinimumNumTurnsExecuted;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 144  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ ENDP ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted
_TEXT	ENDS
PUBLIC	?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetCheckTriggerTurnCount
; Function compile flags: /Odtp
;	COMDAT ?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ PROC ; CvAICityStrategyEntry::GetCheckTriggerTurnCount, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	return m_iCheckTriggerTurnCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ ENDP ; CvAICityStrategyEntry::GetCheckTriggerTurnCount
_TEXT	ENDS
PUBLIC	?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ	; CvAICityStrategyEntry::IsNoMinorCivs
; Function compile flags: /Odtp
;	COMDAT ?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ PROC	; CvAICityStrategyEntry::IsNoMinorCivs, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	return m_bNoMinorCivs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+288]

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ ENDP	; CvAICityStrategyEntry::IsNoMinorCivs
_TEXT	ENDS
PUBLIC	?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ	; CvAICityStrategyEntry::IsPermanent
; Function compile flags: /Odtp
;	COMDAT ?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ PROC	; CvAICityStrategyEntry::IsPermanent, COMDAT
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	return m_bPermanent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+289]

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ ENDP	; CvAICityStrategyEntry::IsPermanent
_TEXT	ENDS
PUBLIC	?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ ; CvAICityStrategyEntry::GetAdvisor
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ PROC ; CvAICityStrategyEntry::GetAdvisor, COMDAT
; _this$ = ecx

; 165  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 	return m_eAdvisor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ ENDP ; CvAICityStrategyEntry::GetAdvisor
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ ; CvAICityStrategyEntry::GetAdvisorCounselText
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ PROC ; CvAICityStrategyEntry::GetAdvisorCounselText, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	return m_strAdvisorCounselText.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ ENDP ; CvAICityStrategyEntry::GetAdvisorCounselText
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetAdvisorCounselImportance
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ PROC ; CvAICityStrategyEntry::GetAdvisorCounselImportance, COMDAT
; _this$ = ecx

; 175  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 	return m_iAdvisorCounselImportance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+324]

; 177  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ ENDP ; CvAICityStrategyEntry::GetAdvisorCounselImportance
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy
PUBLIC	??0CvAICityStrategies@@QAE@XZ			; CvAICityStrategies::CvAICityStrategies
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvAICityStrategies@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvAICityStrategies@@QAE@XZ$1
__ehfuncinfo$??0CvAICityStrategies@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvAICityStrategies@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvAICityStrategies@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T230648 = -30						; size = 1
$T230635 = -29						; size = 1
$T230631 = -28						; size = 4
$T230624 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvAICityStrategies@@QAE@XZ PROC			; CvAICityStrategies::CvAICityStrategies, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvAICityStrategies@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T230648[ebp]
	mov	DWORD PTR $T230624[ebp], eax
	lea	ecx, DWORD PTR $T230635[ebp]
	mov	DWORD PTR $T230631[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 187  : 
; 188  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvAICityStrategies@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvAICityStrategies@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvAICityStrategies@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvAICityStrategies@@QAE@XZ ENDP			; CvAICityStrategies::CvAICityStrategies
PUBLIC	??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvAICityStrategies@@QAEXXZ		; CvAICityStrategies::DeleteArray
PUBLIC	??1CvAICityStrategies@@QAE@XZ			; CvAICityStrategies::~CvAICityStrategies
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvAICityStrategies@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAICityStrategies@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAICityStrategies@@QAE@XZ$1
__ehfuncinfo$??1CvAICityStrategies@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvAICityStrategies@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvAICityStrategies@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAICityStrategies@@QAE@XZ PROC			; CvAICityStrategies::~CvAICityStrategies, COMDAT
; _this$ = ecx

; 192  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvAICityStrategies@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 193  : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvAICityStrategies@@QAEXXZ	; CvAICityStrategies::DeleteArray

; 194  : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAICityStrategies@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
__unwindfunclet$??1CvAICityStrategies@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvAICityStrategies@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvAICityStrategies@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAICityStrategies@@QAE@XZ ENDP			; CvAICityStrategies::~CvAICityStrategies
PUBLIC	?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ; CvAICityStrategies::GetAICityStrategyEntries
; Function compile flags: /Odtp
;	COMDAT ?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ PROC ; CvAICityStrategies::GetAICityStrategyEntries, COMDAT
; _this$ = ecx

; 198  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 	return m_paAICityStrategyEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 200  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ENDP ; CvAICityStrategies::GetAICityStrategyEntries
_TEXT	ENDS
PUBLIC	?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ; CvAICityStrategies::GetNumAICityStrategies
; Function compile flags: /Odtp
;	COMDAT ?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ PROC	; CvAICityStrategies::GetNumAICityStrategies, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 	return m_paAICityStrategyEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ENDP	; CvAICityStrategies::GetNumAICityStrategies
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvAICityStrategies@@QAEXXZ
_TEXT	SEGMENT
tv145 = -116						; size = 4
_this$ = -112						; size = 4
$T230884 = -56						; size = 4
$T230868 = -52						; size = 4
$T230988 = -48						; size = 4
$T230987 = -44						; size = 4
$T230986 = -40						; size = 4
$T230985 = -36						; size = 4
$T230984 = -32						; size = 4
$T230852 = -28						; size = 4
$T230849 = -24						; size = 4
$T230848 = -20						; size = 4
$T230818 = -16						; size = 4
$T230794 = -12						; size = 4
$T230784 = -8						; size = 4
_it$225273 = -4						; size = 4
?DeleteArray@CvAICityStrategies@@QAEXXZ PROC		; CvAICityStrategies::DeleteArray, COMDAT
; _this$ = ecx

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	for(std::vector<CvAICityStrategyEntry*>::iterator it = m_paAICityStrategyEntries.begin(); it != m_paAICityStrategyEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230794[ebp], ecx
	mov	edx, DWORD PTR $T230794[ebp]
	mov	DWORD PTR _it$225273[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$225273[ebp]
	add	eax, 4
	mov	DWORD PTR _it$225273[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230818[ebp], edx
	mov	eax, DWORD PTR $T230818[ebp]
	mov	DWORD PTR $T230784[ebp], eax
	mov	ecx, DWORD PTR _it$225273[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T230784[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 212  : 	{
; 213  : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$225273[ebp]
	mov	DWORD PTR $T230852[ebp], edx
	mov	eax, DWORD PTR $T230852[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230849[ebp], ecx
	mov	edx, DWORD PTR $T230849[ebp]
	mov	DWORD PTR $T230848[ebp], edx
	cmp	DWORD PTR $T230848[ebp], 0
	je	SHORT $LN32@DeleteArra
	push	1
	mov	eax, DWORD PTR $T230848[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T230848[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv145[ebp], 0
$LN33@DeleteArra:
	mov	ecx, DWORD PTR $T230852[ebp]
	mov	DWORD PTR [ecx], 0

; 214  : 	}

	jmp	SHORT $LN2@DeleteArra
$LN1@DeleteArra:

; 215  : 
; 216  : 	m_paAICityStrategyEntries.clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230868[ebp], eax
	mov	ecx, DWORD PTR $T230868[ebp]
	mov	DWORD PTR $T230985[ebp], ecx
	mov	edx, DWORD PTR $T230985[ebp]
	mov	DWORD PTR $T230984[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230884[ebp], ecx
	mov	edx, DWORD PTR $T230884[ebp]
	mov	DWORD PTR $T230987[ebp], edx
	mov	eax, DWORD PTR $T230987[ebp]
	mov	DWORD PTR $T230986[ebp], eax
	mov	ecx, DWORD PTR $T230984[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230986[ebp]
	push	edx
	lea	eax, DWORD PTR $T230988[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase

; 217  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvAICityStrategies@@QAEXXZ ENDP		; CvAICityStrategies::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z PROC ; CvAICityStrategies::GetEntry, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 	return m_paAICityStrategyEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ENDP ; CvAICityStrategies::GetEntry
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
PUBLIC	??_7CvCityStrategyAI@@6B@			; CvCityStrategyAI::`vftable'
PUBLIC	??0CvCityStrategyAI@@QAE@XZ			; CvCityStrategyAI::CvCityStrategyAI
PUBLIC	?Uninit@CvCityStrategyAI@@UAEXXZ		; CvCityStrategyAI::Uninit
PUBLIC	?FlavorUpdate@CvCityStrategyAI@@UAEXXZ		; CvCityStrategyAI::FlavorUpdate
PUBLIC	?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z ; CvCityStrategyAI::LogFlavors
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
;	COMDAT ??_7CvCityStrategyAI@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_7CvCityStrategyAI@@6B@ DD FLAT:?Init@CvFlavorRecipient@@UAEXXZ ; CvCityStrategyAI::`vftable'
	DD	FLAT:?Uninit@CvCityStrategyAI@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvCityStrategyAI@@UAEXXZ
	DD	FLAT:?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvCityStrategyAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCityStrategyAI@@QAE@XZ$0
__ehfuncinfo$??0CvCityStrategyAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvCityStrategyAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvCityStrategyAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T231027 = -24						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCityStrategyAI@@QAE@XZ PROC			; CvCityStrategyAI::CvCityStrategyAI, COMDAT
; _this$ = ecx

; 258  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvCityStrategyAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvCityStrategyAI@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR $T231027[ebp], edx
	mov	ecx, DWORD PTR $T231027[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3696], -1

; 259  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCityStrategyAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
__ehhandler$??0CvCityStrategyAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvCityStrategyAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCityStrategyAI@@QAE@XZ ENDP			; CvCityStrategyAI::CvCityStrategyAI
PUBLIC	??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
PUBLIC	??1CvCityStrategyAI@@QAE@XZ			; CvCityStrategyAI::~CvCityStrategyAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvCityStrategyAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$1
__ehfuncinfo$??1CvCityStrategyAI@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvCityStrategyAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvCityStrategyAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T231069 = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvCityStrategyAI@@QAE@XZ PROC			; CvCityStrategyAI::~CvCityStrategyAI, COMDAT
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvCityStrategyAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvCityStrategyAI@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 264  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvCityStrategyAI@@UAEXXZ	; CvCityStrategyAI::Uninit

; 265  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR $T231069[ebp], ecx
	mov	ecx, DWORD PTR $T231069[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>
__ehhandler$??1CvCityStrategyAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvCityStrategyAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvCityStrategyAI@@QAE@XZ ENDP			; CvCityStrategyAI::~CvCityStrategyAI
PUBLIC	?Reset@CvCityStrategyAI@@QAEXXZ			; CvCityStrategyAI::Reset
PUBLIC	?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z ; CvCityStrategyAI::Init
EXTRN	??0CvProcessProductionAI@@QAE@PAVCvCity@@@Z:PROC ; CvProcessProductionAI::CvProcessProductionAI
EXTRN	??0CvProjectProductionAI@@QAE@PAVCvCity@@@Z:PROC ; CvProjectProductionAI::CvProjectProductionAI
EXTRN	??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z:PROC ; CvUnitProductionAI::CvUnitProductionAI
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z:PROC ; CvBuildingProductionAI::CvBuildingProductionAI
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$3
__ehfuncinfo$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
_TEXT	SEGMENT
tv177 = -80						; size = 4
tv168 = -76						; size = 4
tv159 = -72						; size = 4
tv147 = -68						; size = 4
_this$ = -64						; size = 4
$T231104 = -60						; size = 4
$T231094 = -56						; size = 4
$T231093 = -52						; size = 4
$T231090 = -48						; size = 4
$T231089 = -44						; size = 4
$T231086 = -40						; size = 4
$T231085 = -36						; size = 4
$T231082 = -32						; size = 4
$T231081 = -28						; size = 4
$T231080 = -24						; size = 4
$T231079 = -20						; size = 4
$T231078 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pAICityStrategies$ = 8					; size = 4
_pCity$ = 12						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z PROC ; CvCityStrategyAI::Init, COMDAT
; _this$ = ecx

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 270  : 	// Init base class
; 271  : 	CvFlavorRecipient::Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 272  : 
; 273  : 	// Store off the pointers passed in to this object
; 274  : 	m_bIsCity = bIsCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bIsCity$[ebp]
	mov	BYTE PTR [eax+4], cl

; 275  : 	m_pAICityStrategies = pAICityStrategies;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pAICityStrategies$[ebp]
	mov	DWORD PTR [edx+16], eax

; 276  : 	m_pCity = pCity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pCity$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 277  : 
; 278  : 	// Initialize arrays
; 279  : 	CvAssertMsg(m_pabUsingCityStrategy==NULL, "about to leak memory, CvCityAIStrategies::m_pabUsingCityStrategy");
; 280  : 	m_pabUsingCityStrategy = FNEW(bool[m_pAICityStrategies->GetNumAICityStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ; CvAICityStrategies::GetNumAICityStrategies
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231078[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T231078[ebp]
	mov	DWORD PTR [ecx+28], edx

; 281  : 
; 282  : 	CvAssertMsg(m_paiTurnCityStrategyAdopted==NULL, "about to leak memory, CvCityAIStrategies::m_paiTurnCityStrategyAdopted");
; 283  : 	m_paiTurnCityStrategyAdopted = FNEW(int[m_pAICityStrategies->GetNumAICityStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ; CvAICityStrategies::GetNumAICityStrategies
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231079[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231079[ebp]
	mov	DWORD PTR [eax+32], ecx

; 284  : 
; 285  : 	CvAssertMsg(m_aiTempFlavors==NULL, "about to leak memory, CvCityAIStrategies::m_aiTempFlavors");
; 286  : 	m_aiTempFlavors = FNEW(int[GC.getNumFlavorTypes()], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231104[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T231104[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231080[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231080[ebp]
	mov	DWORD PTR [eax+36], ecx

; 287  : 
; 288  : 	// Create AI subobjects
; 289  : 	m_pBuildingProductionAI = FNEW(CvBuildingProductionAI(pCity, pCity->GetCityBuildings()), c_eCiv5GameplayDLL, 0);

	push	2200					; 00000898H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231082[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T231082[ebp], 0
	je	SHORT $LN3@Init
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	push	eax
	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231082[ebp]
	call	??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z ; CvBuildingProductionAI::CvBuildingProductionAI
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN4@Init
$LN3@Init:
	mov	DWORD PTR tv147[ebp], 0
$LN4@Init:
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T231081[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T231081[ebp]
	mov	DWORD PTR [ecx+40], edx

; 290  : 	m_pUnitProductionAI = FNEW(CvUnitProductionAI(pCity, GC.GetGameUnits()), c_eCiv5GameplayDLL, 0);

	push	1480					; 000005c8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231086[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T231086[ebp], 0
	je	SHORT $LN5@Init
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	push	eax
	mov	eax, DWORD PTR _pCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231086[ebp]
	call	??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z ; CvUnitProductionAI::CvUnitProductionAI
	mov	DWORD PTR tv159[ebp], eax
	jmp	SHORT $LN6@Init
$LN5@Init:
	mov	DWORD PTR tv159[ebp], 0
$LN6@Init:
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T231085[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T231085[ebp]
	mov	DWORD PTR [edx+44], eax

; 291  : 	m_pProjectProductionAI = FNEW(CvProjectProductionAI(pCity), c_eCiv5GameplayDLL, 0);

	push	324					; 00000144H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231090[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T231090[ebp], 0
	je	SHORT $LN7@Init
	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231090[ebp]
	call	??0CvProjectProductionAI@@QAE@PAVCvCity@@@Z ; CvProjectProductionAI::CvProjectProductionAI
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN8@Init
$LN7@Init:
	mov	DWORD PTR tv168[ebp], 0
$LN8@Init:
	mov	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T231089[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231089[ebp]
	mov	DWORD PTR [eax+48], ecx

; 292  : 	m_pProcessProductionAI = FNEW(CvProcessProductionAI(pCity), c_eCiv5GameplayDLL, 0);

	push	100					; 00000064H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231094[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T231094[ebp], 0
	je	SHORT $LN9@Init
	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231094[ebp]
	call	??0CvProcessProductionAI@@QAE@PAVCvCity@@@Z ; CvProcessProductionAI::CvProcessProductionAI
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN10@Init
$LN9@Init:
	mov	DWORD PTR tv177[ebp], 0
$LN10@Init:
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T231093[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T231093[ebp]
	mov	DWORD PTR [ecx+52], edx

; 293  : 
; 294  : 	// Clear variables
; 295  : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvCityStrategyAI@@QAEXXZ		; CvCityStrategyAI::Reset

; 296  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$0:
	mov	eax, DWORD PTR $T231082[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$1:
	mov	eax, DWORD PTR $T231086[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$2:
	mov	eax, DWORD PTR $T231090[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$3:
	mov	eax, DWORD PTR $T231094[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z ENDP ; CvCityStrategyAI::Init
EXTRN	??1CvProcessProductionAI@@QAE@XZ:PROC		; CvProcessProductionAI::~CvProcessProductionAI
EXTRN	??1CvProjectProductionAI@@QAE@XZ:PROC		; CvProjectProductionAI::~CvProjectProductionAI
EXTRN	??1CvUnitProductionAI@@QAE@XZ:PROC		; CvUnitProductionAI::~CvUnitProductionAI
EXTRN	??1CvBuildingProductionAI@@QAE@XZ:PROC		; CvBuildingProductionAI::~CvBuildingProductionAI
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvCityStrategyAI@@UAEXXZ
_TEXT	SEGMENT
tv137 = -92						; size = 4
tv131 = -88						; size = 4
tv93 = -84						; size = 4
tv87 = -80						; size = 4
_this$ = -76						; size = 4
$T231206 = -72						; size = 4
$T231200 = -68						; size = 4
$T231199 = -64						; size = 4
$T231187 = -60						; size = 4
$T231181 = -56						; size = 4
$T231180 = -52						; size = 4
$T231168 = -48						; size = 4
$T231162 = -44						; size = 4
$T231161 = -40						; size = 4
$T231149 = -36						; size = 4
$T231143 = -32						; size = 4
$T231142 = -28						; size = 4
$T231130 = -24						; size = 4
$T231129 = -20						; size = 4
$T231124 = -16						; size = 4
$T231123 = -12						; size = 4
$T231118 = -8						; size = 4
$T231117 = -4						; size = 4
?Uninit@CvCityStrategyAI@@UAEXXZ PROC			; CvCityStrategyAI::Uninit, COMDAT
; _this$ = ecx

; 300  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	// Uninit base class
; 302  : 	CvFlavorRecipient::Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvFlavorRecipient@@UAEXXZ	; CvFlavorRecipient::Uninit

; 303  : 
; 304  : 	// Deallocate member variables
; 305  : 	SAFE_DELETE_ARRAY(m_pabUsingCityStrategy);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T231118[ebp], eax
	mov	ecx, DWORD PTR $T231118[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231117[ebp], edx
	mov	eax, DWORD PTR $T231117[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T231118[ebp]
	mov	DWORD PTR [ecx], 0

; 306  : 	SAFE_DELETE_ARRAY(m_paiTurnCityStrategyAdopted);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T231124[ebp], edx
	mov	eax, DWORD PTR $T231124[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231123[ebp], ecx
	mov	edx, DWORD PTR $T231123[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T231124[ebp]
	mov	DWORD PTR [eax], 0

; 307  : 	SAFE_DELETE_ARRAY(m_aiTempFlavors);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T231130[ebp], ecx
	mov	edx, DWORD PTR $T231130[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T231129[ebp], eax
	mov	ecx, DWORD PTR $T231129[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T231130[ebp]
	mov	DWORD PTR [edx], 0

; 308  : 	SAFE_DELETE(m_pBuildingProductionAI);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR $T231149[ebp], eax
	mov	ecx, DWORD PTR $T231149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231143[ebp], edx
	mov	eax, DWORD PTR $T231143[ebp]
	mov	DWORD PTR $T231142[ebp], eax
	cmp	DWORD PTR $T231142[ebp], 0
	je	SHORT $LN11@Uninit
	mov	ecx, DWORD PTR $T231142[ebp]
	call	??1CvBuildingProductionAI@@QAE@XZ	; CvBuildingProductionAI::~CvBuildingProductionAI
	mov	ecx, 1
	and	ecx, 1
	je	SHORT $LN14@Uninit
	mov	edx, DWORD PTR $T231142[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN14@Uninit:
	mov	eax, DWORD PTR $T231142[ebp]
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN12@Uninit
$LN11@Uninit:
	mov	DWORD PTR tv87[ebp], 0
$LN12@Uninit:
	mov	ecx, DWORD PTR $T231149[ebp]
	mov	DWORD PTR [ecx], 0

; 309  : 	SAFE_DELETE(m_pUnitProductionAI);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T231168[ebp], edx
	mov	eax, DWORD PTR $T231168[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231162[ebp], ecx
	mov	edx, DWORD PTR $T231162[ebp]
	mov	DWORD PTR $T231161[ebp], edx
	cmp	DWORD PTR $T231161[ebp], 0
	je	SHORT $LN18@Uninit
	mov	ecx, DWORD PTR $T231161[ebp]
	call	??1CvUnitProductionAI@@QAE@XZ		; CvUnitProductionAI::~CvUnitProductionAI
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN21@Uninit
	mov	ecx, DWORD PTR $T231161[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@Uninit:
	mov	edx, DWORD PTR $T231161[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN19@Uninit
$LN18@Uninit:
	mov	DWORD PTR tv93[ebp], 0
$LN19@Uninit:
	mov	eax, DWORD PTR $T231168[ebp]
	mov	DWORD PTR [eax], 0

; 310  : 	SAFE_DELETE(m_pProjectProductionAI);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR $T231187[ebp], ecx
	mov	edx, DWORD PTR $T231187[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T231181[ebp], eax
	mov	ecx, DWORD PTR $T231181[ebp]
	mov	DWORD PTR $T231180[ebp], ecx
	cmp	DWORD PTR $T231180[ebp], 0
	je	SHORT $LN25@Uninit
	mov	ecx, DWORD PTR $T231180[ebp]
	call	??1CvProjectProductionAI@@QAE@XZ	; CvProjectProductionAI::~CvProjectProductionAI
	mov	edx, 1
	and	edx, 1
	je	SHORT $LN28@Uninit
	mov	eax, DWORD PTR $T231180[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@Uninit:
	mov	ecx, DWORD PTR $T231180[ebp]
	mov	DWORD PTR tv131[ebp], ecx
	jmp	SHORT $LN26@Uninit
$LN25@Uninit:
	mov	DWORD PTR tv131[ebp], 0
$LN26@Uninit:
	mov	edx, DWORD PTR $T231187[ebp]
	mov	DWORD PTR [edx], 0

; 311  : 	SAFE_DELETE(m_pProcessProductionAI);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR $T231206[ebp], eax
	mov	ecx, DWORD PTR $T231206[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231200[ebp], edx
	mov	eax, DWORD PTR $T231200[ebp]
	mov	DWORD PTR $T231199[ebp], eax
	cmp	DWORD PTR $T231199[ebp], 0
	je	SHORT $LN32@Uninit
	mov	ecx, DWORD PTR $T231199[ebp]
	call	??1CvProcessProductionAI@@QAE@XZ	; CvProcessProductionAI::~CvProcessProductionAI
	mov	ecx, 1
	and	ecx, 1
	je	SHORT $LN35@Uninit
	mov	edx, DWORD PTR $T231199[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@Uninit:
	mov	eax, DWORD PTR $T231199[ebp]
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN33@Uninit
$LN32@Uninit:
	mov	DWORD PTR tv137[ebp], 0
$LN33@Uninit:
	mov	ecx, DWORD PTR $T231206[ebp]
	mov	DWORD PTR [ecx], 0

; 312  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvCityStrategyAI@@UAEXXZ ENDP			; CvCityStrategyAI::Uninit
_TEXT	ENDS
EXTRN	?Reset@CvProcessProductionAI@@QAEXXZ:PROC	; CvProcessProductionAI::Reset
EXTRN	?Reset@CvProjectProductionAI@@QAEXXZ:PROC	; CvProjectProductionAI::Reset
EXTRN	?Reset@CvUnitProductionAI@@QAEXXZ:PROC		; CvUnitProductionAI::Reset
EXTRN	?Reset@CvBuildingProductionAI@@QAEXXZ:PROC	; CvBuildingProductionAI::Reset
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?Reset@CvCityStrategyAI@@QAEXXZ PROC			; CvCityStrategyAI::Reset, COMDAT
; _this$ = ecx

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 317  : 	int iI;
; 318  : 
; 319  : 	for(iI = 0; iI < m_pAICityStrategies->GetNumAICityStrategies(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ; CvAICityStrategies::GetNumAICityStrategies
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN1@Reset

; 320  : 	{
; 321  : 		m_pabUsingCityStrategy[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 322  : 		m_paiTurnCityStrategyAdopted[iI] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 323  : 	}

	jmp	SHORT $LN2@Reset
$LN1@Reset:

; 324  : 
; 325  : 	m_eSpecialization = NO_CITY_SPECIALIZATION;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], -1

; 326  : 	m_eDefaultSpecialization = NO_CITY_SPECIALIZATION;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], -1

; 327  : 	m_eFocusYield = (YieldTypes)NO_YIELD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3696], -1

; 328  : 
; 329  : 	// Reset sub AI objects
; 330  : 	m_pBuildingProductionAI->Reset();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	call	?Reset@CvBuildingProductionAI@@QAEXXZ	; CvBuildingProductionAI::Reset

; 331  : 	m_pUnitProductionAI->Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?Reset@CvUnitProductionAI@@QAEXXZ	; CvUnitProductionAI::Reset

; 332  : 	m_pProjectProductionAI->Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?Reset@CvProjectProductionAI@@QAEXXZ	; CvProjectProductionAI::Reset

; 333  : 	m_pProcessProductionAI->Reset();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?Reset@CvProcessProductionAI@@QAEXXZ	; CvProcessProductionAI::Reset

; 334  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvCityStrategyAI@@QAEXXZ ENDP			; CvCityStrategyAI::Reset
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z	; CvCityStrategyAI::Read
EXTRN	?Read@CvProcessProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvProcessProductionAI::Read
EXTRN	?Read@CvProjectProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvProjectProductionAI::Read
EXTRN	?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvUnitProductionAI::Read
EXTRN	?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvBuildingProductionAI::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CitySpecializationTypes@@@Z:PROC ; operator>>
EXTRN	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumAICityStrategyInfos
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T231221 = -24						; size = 4
$T231220 = -20						; size = 4
_uiVersion$ = -16					; size = 4
_wrapLatestFlavor$ = -12				; size = 8
_iNumFlavors$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z PROC	; CvCityStrategyAI::Read, COMDAT
; _this$ = ecx

; 338  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 	// Version number to maintain backwards compatibility
; 340  : 	uint uiVersion;
; 341  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 342  : 
; 343  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 344  : 
; 345  : 	int iNumFlavors;
; 346  : 	kStream >> iNumFlavors;

	lea	ecx, DWORD PTR _iNumFlavors$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 347  : 	ArrayWrapper<int> wrapLatestFlavor(iNumFlavors, m_piLatestFlavorValues);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T231221[ebp], eax
	mov	ecx, DWORD PTR _iNumFlavors$[ebp]
	mov	DWORD PTR $T231220[ebp], ecx
	mov	edx, DWORD PTR $T231221[ebp]
	mov	DWORD PTR _wrapLatestFlavor$[ebp], edx
	mov	eax, DWORD PTR $T231220[ebp]
	mov	DWORD PTR _wrapLatestFlavor$[ebp+4], eax

; 348  : 	kStream >> wrapLatestFlavor;

	lea	ecx, DWORD PTR _wrapLatestFlavor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 349  : 
; 350  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabUsingCityStrategy, GC.getNumAICityStrategyInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAICityStrategyInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 351  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiTurnCityStrategyAdopted, GC.getNumAICityStrategyInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAICityStrategyInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 352  : 
; 353  : 	kStream >> m_eSpecialization;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4CitySpecializationTypes@@@Z ; operator>>
	add	esp, 8

; 354  : 	kStream >> m_eDefaultSpecialization;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4CitySpecializationTypes@@@Z ; operator>>
	add	esp, 8

; 355  : 	m_eFocusYield = (YieldTypes)NO_YIELD;	//force yield to default since we don't serialize it.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3696], -1

; 356  : 
; 357  : 	m_pBuildingProductionAI->Read(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ; CvBuildingProductionAI::Read

; 358  : 	m_pUnitProductionAI->Read(kStream);

	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z ; CvUnitProductionAI::Read

; 359  : 	m_pProjectProductionAI->Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?Read@CvProjectProductionAI@@QAEXAAVFDataStream@@@Z ; CvProjectProductionAI::Read

; 360  : 	m_pProcessProductionAI->Read(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?Read@CvProcessProductionAI@@QAEXAAVFDataStream@@@Z ; CvProcessProductionAI::Read

; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z ENDP	; CvCityStrategyAI::Read
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>
PUBLIC	??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z	; CvCityStrategyAI::Write
EXTRN	?Write@CvProcessProductionAI@@QBEXAAVFDataStream@@@Z:PROC ; CvProcessProductionAI::Write
EXTRN	?Write@CvProjectProductionAI@@QBEXAAVFDataStream@@@Z:PROC ; CvProjectProductionAI::Write
EXTRN	?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z:PROC ; CvUnitProductionAI::Write
EXTRN	?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvBuildingProductionAI::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CitySpecializationTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T231239 = -32						; size = 4
$T231238 = -28						; size = 4
$T231231 = -24						; size = 4
$T231224 = -20						; size = 8
_uiVersion$ = -12					; size = 4
_iNumStrategies$ = -8					; size = 4
_iNumFlavors$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z PROC	; CvCityStrategyAI::Write, COMDAT
; _this$ = ecx

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 	// Current version number
; 367  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 368  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 369  : 
; 370  : 	CvAssertMsg(GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 371  : 	int iNumFlavors = GC.getNumFlavorTypes();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231231[ebp], ecx
	mov	edx, DWORD PTR $T231231[ebp]
	mov	DWORD PTR _iNumFlavors$[ebp], edx

; 372  : 	kStream << iNumFlavors;

	lea	eax, DWORD PTR _iNumFlavors$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 373  : 	kStream << ArrayWrapper<int>(iNumFlavors, m_piLatestFlavorValues);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231239[ebp], edx
	mov	eax, DWORD PTR _iNumFlavors$[ebp]
	mov	DWORD PTR $T231238[ebp], eax
	mov	ecx, DWORD PTR $T231239[ebp]
	mov	DWORD PTR $T231224[ebp], ecx
	mov	edx, DWORD PTR $T231238[ebp]
	mov	DWORD PTR $T231224[ebp+4], edx
	lea	eax, DWORD PTR $T231224[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 374  : 
; 375  : 	int iNumStrategies = GC.getNumAICityStrategyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAICityStrategyInfos
	mov	DWORD PTR _iNumStrategies$[ebp], eax

; 376  : 
; 377  : 	CvInfosSerializationHelper::WriteHashedDataArray<AICityStrategyTypes, bool>(kStream, m_pabUsingCityStrategy, iNumStrategies);

	mov	edx, DWORD PTR _iNumStrategies$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>
	add	esp, 12					; 0000000cH

; 378  : 	CvInfosSerializationHelper::WriteHashedDataArray<AICityStrategyTypes, int>(kStream, m_paiTurnCityStrategyAdopted, iNumStrategies);

	mov	eax, DWORD PTR _iNumStrategies$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>
	add	esp, 12					; 0000000cH

; 379  : 
; 380  : 	kStream << m_eSpecialization;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4CitySpecializationTypes@@@Z ; operator<<
	add	esp, 8

; 381  : 	kStream << m_eDefaultSpecialization;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4CitySpecializationTypes@@@Z ; operator<<
	add	esp, 8

; 382  : 
; 383  : 	m_pBuildingProductionAI->Write(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ; CvBuildingProductionAI::Write

; 384  : 	m_pUnitProductionAI->Write(kStream);

	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z ; CvUnitProductionAI::Write

; 385  : 	m_pProjectProductionAI->Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?Write@CvProjectProductionAI@@QBEXAAVFDataStream@@@Z ; CvProjectProductionAI::Write

; 386  : 	m_pProcessProductionAI->Write(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?Write@CvProcessProductionAI@@QBEXAAVFDataStream@@@Z ; CvProcessProductionAI::Write

; 387  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z ENDP	; CvCityStrategyAI::Write
_TEXT	ENDS
EXTRN	?AddFlavorWeights@CvProcessProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvProcessProductionAI::AddFlavorWeights
EXTRN	?AddFlavorWeights@CvProjectProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvProjectProductionAI::AddFlavorWeights
EXTRN	?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvUnitProductionAI::AddFlavorWeights
EXTRN	?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvBuildingProductionAI::AddFlavorWeights
EXTRN	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z:PROC ; CvFlavorRecipient::GetLatestFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?FlavorUpdate@CvCityStrategyAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T231245 = -12						; size = 4
_iFlavorValue$225465 = -8				; size = 4
_iFlavor$225461 = -4					; size = 4
?FlavorUpdate@CvCityStrategyAI@@UAEXXZ PROC		; CvCityStrategyAI::FlavorUpdate, COMDAT
; _this$ = ecx

; 391  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	// Reset our sub AI objects
; 393  : 	m_pBuildingProductionAI->Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	?Reset@CvBuildingProductionAI@@QAEXXZ	; CvBuildingProductionAI::Reset

; 394  : 	m_pUnitProductionAI->Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?Reset@CvUnitProductionAI@@QAEXXZ	; CvUnitProductionAI::Reset

; 395  : 	m_pProjectProductionAI->Reset();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?Reset@CvProjectProductionAI@@QAEXXZ	; CvProjectProductionAI::Reset

; 396  : 	m_pProcessProductionAI->Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?Reset@CvProcessProductionAI@@QAEXXZ	; CvProcessProductionAI::Reset

; 397  : 
; 398  : 	// Broadcast to our sub AI objects
; 399  : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$225461[ebp], 0
	jmp	SHORT $LN3@FlavorUpda
$LN2@FlavorUpda:
	mov	ecx, DWORD PTR _iFlavor$225461[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavor$225461[ebp], ecx
$LN3@FlavorUpda:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231245[ebp], edx
	mov	eax, DWORD PTR _iFlavor$225461[ebp]
	cmp	eax, DWORD PTR $T231245[ebp]
	jge	SHORT $LN4@FlavorUpda

; 400  : 	{
; 401  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_PUPPETS_NULLIFY_BARRACKS
; 402  : 		if (GetCity()->IsPuppet() && (FlavorTypes)iFlavor == (FlavorTypes)GC.getInfoTypeForString("FLAVOR_MILITARY_TRAINING"))
; 403  : 			continue;
; 404  : #endif
; 405  : 		int iFlavorValue = GetLatestFlavorValue((FlavorTypes)iFlavor);// m_piLatestFlavorValues[iFlavor];

	push	0
	mov	ecx, DWORD PTR _iFlavor$225461[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue
	mov	DWORD PTR _iFlavorValue$225465[ebp], eax

; 406  : 
; 407  : #ifdef AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF
; 408  : 		m_pUnitProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);
; 409  : #endif
; 410  : 		m_pBuildingProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	edx, DWORD PTR _iFlavorValue$225465[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlavor$225461[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	call	?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvBuildingProductionAI::AddFlavorWeights

; 411  : #ifndef AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF
; 412  : 		m_pUnitProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	edx, DWORD PTR _iFlavorValue$225465[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlavor$225461[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvUnitProductionAI::AddFlavorWeights

; 413  : #endif
; 414  : 		m_pProjectProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	edx, DWORD PTR _iFlavorValue$225465[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlavor$225461[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?AddFlavorWeights@CvProjectProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvProjectProductionAI::AddFlavorWeights

; 415  : 		m_pProcessProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	edx, DWORD PTR _iFlavorValue$225465[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlavor$225461[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?AddFlavorWeights@CvProcessProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvProcessProductionAI::AddFlavorWeights
	jmp	SHORT $LN2@FlavorUpda
$LN4@FlavorUpda:

; 416  : 	}
; 417  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlavorUpdate@CvCityStrategyAI@@UAEXXZ ENDP		; CvCityStrategyAI::FlavorUpdate
_TEXT	ENDS
PUBLIC	?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ ; CvCityStrategyAI::UpdateFlavorsForNewCity
EXTRN	?ChangeFlavors@CvFlavorRecipient@@QAEXPAH_N@Z:PROC ; CvFlavorRecipient::ChangeFlavors
EXTRN	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z:PROC ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
EXTRN	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z:PROC ; CvMilitaryAI::IsUsingStrategy
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z:PROC ; CvGlobals::getMilitaryAIStrategyInfo
EXTRN	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumMilitaryAIStrategyInfos
EXTRN	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z:PROC ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z:PROC ; CvGlobals::getEconomicAIStrategyInfo
EXTRN	?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumEconomicAIStrategyInfos
; Function compile flags: /Odtp
;	COMDAT ?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T231285 = -56						; size = 4
$T231281 = -52						; size = 4
$T231277 = -48						; size = 4
$T231268 = -44						; size = 4
$T231264 = -40						; size = 4
$T231260 = -36						; size = 4
$T231251 = -32						; size = 4
_eStrategy$225494 = -28					; size = 4
_pStrategy$225496 = -24					; size = 4
_iStrategyLoop$225490 = -20				; size = 4
_eStrategy$225482 = -16					; size = 4
_pStrategy$225484 = -12					; size = 4
_iStrategyLoop$225478 = -8				; size = 4
_iFlavorLoop$ = -4					; size = 4
?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ PROC	; CvCityStrategyAI::UpdateFlavorsForNewCity, COMDAT
; _this$ = ecx

; 421  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 	int iFlavorLoop;
; 423  : 
; 424  : 	// Clear out Temp array
; 425  : 	for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$[ebp], 0
	jmp	SHORT $LN19@UpdateFlav
$LN18@UpdateFlav:
	mov	eax, DWORD PTR _iFlavorLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$[ebp], eax
$LN19@UpdateFlav:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231251[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$[ebp]
	cmp	edx, DWORD PTR $T231251[ebp]
	jge	SHORT $LN17@UpdateFlav

; 426  : 	{
; 427  : 		m_aiTempFlavors[iFlavorLoop] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _iFlavorLoop$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 428  : 	}

	jmp	SHORT $LN18@UpdateFlav
$LN17@UpdateFlav:

; 429  : 
; 430  : 	// Go through all Player strategies and for the active ones apply the Flavors
; 431  : #ifdef AUI_WARNING_FIXES
; 432  : 	for (uint iStrategyLoop = 0; iStrategyLoop < GC.getNumEconomicAIStrategyInfos(); iStrategyLoop++)
; 433  : #else
; 434  : 	for(int iStrategyLoop = 0; iStrategyLoop < GC.getNumEconomicAIStrategyInfos(); iStrategyLoop++)

	mov	DWORD PTR _iStrategyLoop$225478[ebp], 0
	jmp	SHORT $LN16@UpdateFlav
$LN15@UpdateFlav:
	mov	eax, DWORD PTR _iStrategyLoop$225478[ebp]
	add	eax, 1
	mov	DWORD PTR _iStrategyLoop$225478[ebp], eax
$LN16@UpdateFlav:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumEconomicAIStrategyInfos
	cmp	DWORD PTR _iStrategyLoop$225478[ebp], eax
	jge	$LN14@UpdateFlav

; 435  : #endif
; 436  : 	{
; 437  : 		EconomicAIStrategyTypes eStrategy = (EconomicAIStrategyTypes) iStrategyLoop;

	mov	ecx, DWORD PTR _iStrategyLoop$225478[ebp]
	mov	DWORD PTR _eStrategy$225482[ebp], ecx

; 438  : 		CvEconomicAIStrategyXMLEntry* pStrategy = GC.getEconomicAIStrategyInfo(eStrategy);

	mov	edx, DWORD PTR _eStrategy$225482[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z ; CvGlobals::getEconomicAIStrategyInfo
	mov	DWORD PTR _pStrategy$225484[ebp], eax

; 439  : 
; 440  : 		if(pStrategy)

	cmp	DWORD PTR _pStrategy$225484[ebp], 0
	je	$LN13@UpdateFlav

; 441  : 		{
; 442  : 			// Active?
; 443  : 			if(GET_PLAYER(m_pCity->getOwner()).GetEconomicAI()->IsUsingStrategy(eStrategy))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T231260[ebp], edx
	mov	eax, DWORD PTR $T231260[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231264[ebp], eax
	mov	ecx, DWORD PTR _eStrategy$225482[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231264[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@UpdateFlav

; 444  : 			{
; 445  : 				for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$[ebp], 0
	jmp	SHORT $LN11@UpdateFlav
$LN10@UpdateFlav:
	mov	eax, DWORD PTR _iFlavorLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$[ebp], eax
$LN11@UpdateFlav:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231268[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$[ebp]
	cmp	edx, DWORD PTR $T231268[ebp]
	jge	SHORT $LN13@UpdateFlav

; 446  : 				{
; 447  : 					m_aiTempFlavors[iFlavorLoop] += pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _iFlavorLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pStrategy$225484[ebp]
	call	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
	mov	edx, DWORD PTR _iFlavorLoop$[ebp]
	add	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _iFlavorLoop$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 448  : 				}

	jmp	SHORT $LN10@UpdateFlav
$LN13@UpdateFlav:

; 449  : 			}
; 450  : 		}
; 451  : 	}

	jmp	$LN15@UpdateFlav
$LN14@UpdateFlav:

; 452  : #ifdef AUI_WARNING_FIXES
; 453  : 	for (uint iStrategyLoop = 0; iStrategyLoop < GC.getNumMilitaryAIStrategyInfos(); iStrategyLoop++)
; 454  : #else
; 455  : 	for(int iStrategyLoop = 0; iStrategyLoop < GC.getNumMilitaryAIStrategyInfos(); iStrategyLoop++)

	mov	DWORD PTR _iStrategyLoop$225490[ebp], 0
	jmp	SHORT $LN8@UpdateFlav
$LN7@UpdateFlav:
	mov	edx, DWORD PTR _iStrategyLoop$225490[ebp]
	add	edx, 1
	mov	DWORD PTR _iStrategyLoop$225490[ebp], edx
$LN8@UpdateFlav:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMilitaryAIStrategyInfos
	cmp	DWORD PTR _iStrategyLoop$225490[ebp], eax
	jge	$LN6@UpdateFlav

; 456  : #endif
; 457  : 	{
; 458  : 		MilitaryAIStrategyTypes eStrategy = (MilitaryAIStrategyTypes) iStrategyLoop;

	mov	eax, DWORD PTR _iStrategyLoop$225490[ebp]
	mov	DWORD PTR _eStrategy$225494[ebp], eax

; 459  : 		CvMilitaryAIStrategyXMLEntry* pStrategy = GC.getMilitaryAIStrategyInfo(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$225494[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z ; CvGlobals::getMilitaryAIStrategyInfo
	mov	DWORD PTR _pStrategy$225496[ebp], eax

; 460  : 
; 461  : 		if(pStrategy)

	cmp	DWORD PTR _pStrategy$225496[ebp], 0
	je	$LN5@UpdateFlav

; 462  : 		{
; 463  : 			// Active?
; 464  : 			if(GET_PLAYER(m_pCity->getOwner()).GetMilitaryAI()->IsUsingStrategy(eStrategy))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T231277[ebp], ecx
	mov	edx, DWORD PTR $T231277[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231281[ebp], edx
	mov	eax, DWORD PTR _eStrategy$225494[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231281[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@UpdateFlav

; 465  : 			{
; 466  : 				for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$[ebp], 0
	jmp	SHORT $LN3@UpdateFlav
$LN2@UpdateFlav:
	mov	edx, DWORD PTR _iFlavorLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavorLoop$[ebp], edx
$LN3@UpdateFlav:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231285[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$[ebp]
	cmp	ecx, DWORD PTR $T231285[ebp]
	jge	SHORT $LN5@UpdateFlav

; 467  : 				{
; 468  : 					m_aiTempFlavors[iFlavorLoop] += pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _iFlavorLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStrategy$225496[ebp]
	call	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
	mov	ecx, DWORD PTR _iFlavorLoop$[ebp]
	add	eax, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _iFlavorLoop$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 469  : 				}

	jmp	SHORT $LN2@UpdateFlav
$LN5@UpdateFlav:

; 470  : 			}
; 471  : 		}
; 472  : 	}

	jmp	$LN7@UpdateFlav
$LN6@UpdateFlav:

; 473  : 
; 474  : 	ChangeFlavors(m_aiTempFlavors, true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeFlavors@CvFlavorRecipient@@QAEXPAH_N@Z ; CvFlavorRecipient::ChangeFlavors

; 475  : 
; 476  : 	LogFlavors();

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 477  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ ENDP	; CvCityStrategyAI::UpdateFlavorsForNewCity
_TEXT	ENDS
PUBLIC	?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SpecializationFlavorChange
PUBLIC	?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::LogSpecializationChange
PUBLIC	?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SetSpecialization
; Function compile flags: /Odtp
;	COMDAT ?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eSpecialization$ = 8					; size = 4
?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::SetSpecialization, COMDAT
; _this$ = ecx

; 481  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	if(eSpecialization != m_eSpecialization)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eSpecialization$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	je	SHORT $LN1@SetSpecial

; 483  : 	{
; 484  : 		LogSpecializationChange(eSpecialization);

	mov	edx, DWORD PTR _eSpecialization$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::LogSpecializationChange

; 485  : 
; 486  : 		// Turn off old specialization
; 487  : 		SpecializationFlavorChange(false /*Don't turn on */, m_eSpecialization);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SpecializationFlavorChange

; 488  : 
; 489  : 		// Turn on new specialization
; 490  : 		SpecializationFlavorChange(true /* Do turn on */, eSpecialization);

	mov	edx, DWORD PTR _eSpecialization$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SpecializationFlavorChange

; 491  : 
; 492  : 		m_eSpecialization = eSpecialization;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eSpecialization$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 493  : 
; 494  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@SetSpecial
$LN1@SetSpecial:

; 495  : 	}
; 496  : 
; 497  : 	return false;

	xor	al, al
$LN2@SetSpecial:

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::SetSpecialization
_TEXT	ENDS
PUBLIC	?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SetDefaultSpecialization
; Function compile flags: /Odtp
;	COMDAT ?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eDefaultSpecialization$ = 8				; size = 4
?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::SetDefaultSpecialization, COMDAT
; _this$ = ecx

; 502  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 	if(eDefaultSpecialization != m_eDefaultSpecialization)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eDefaultSpecialization$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	je	SHORT $LN1@SetDefault

; 504  : 	{
; 505  : 		m_eDefaultSpecialization = eDefaultSpecialization;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eDefaultSpecialization$[ebp]
	mov	DWORD PTR [edx+24], eax

; 506  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@SetDefault
$LN1@SetDefault:

; 507  : 	}
; 508  : 
; 509  : 	return false;

	xor	al, al
$LN2@SetDefault:

; 510  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::SetDefaultSpecialization
_TEXT	ENDS
EXTRN	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z:PROC ; CvCitySpecializationXMLEntry::GetFlavorValue
EXTRN	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z:PROC ; CvGlobals::getCitySpecializationInfo
; Function compile flags: /Odtp
;	COMDAT ?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T231299 = -16						; size = 4
$T231295 = -12						; size = 4
_iFlavorLoop$225520 = -8				; size = 4
_pSpecialization$225518 = -4				; size = 4
_bTurnOn$ = 8						; size = 1
_eSpecialization$ = 12					; size = 4
?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::SpecializationFlavorChange, COMDAT
; _this$ = ecx

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	if(eSpecialization != NO_CITY_SPECIALIZATION)

	cmp	DWORD PTR _eSpecialization$[ebp], -1
	je	$LN11@Specializa

; 516  : 	{
; 517  : 		CvCitySpecializationXMLEntry* pSpecialization = GC.getCitySpecializationInfo(eSpecialization);

	mov	eax, DWORD PTR _eSpecialization$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	DWORD PTR _pSpecialization$225518[ebp], eax

; 518  : 		if(pSpecialization)

	cmp	DWORD PTR _pSpecialization$225518[ebp], 0
	je	$LN11@Specializa

; 519  : 		{
; 520  : 			int iFlavorLoop;
; 521  : 
; 522  : 			// Clear out Temp array
; 523  : 			for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225520[ebp], 0
	jmp	SHORT $LN8@Specializa
$LN7@Specializa:
	mov	ecx, DWORD PTR _iFlavorLoop$225520[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$225520[ebp], ecx
$LN8@Specializa:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231295[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$225520[ebp]
	cmp	eax, DWORD PTR $T231295[ebp]
	jge	SHORT $LN6@Specializa

; 524  : 			{
; 525  : 				m_aiTempFlavors[iFlavorLoop] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _iFlavorLoop$225520[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 526  : 			}

	jmp	SHORT $LN7@Specializa
$LN6@Specializa:

; 527  : 
; 528  : 			for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225520[ebp], 0
	jmp	SHORT $LN5@Specializa
$LN4@Specializa:
	mov	ecx, DWORD PTR _iFlavorLoop$225520[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$225520[ebp], ecx
$LN5@Specializa:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231299[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$225520[ebp]
	cmp	eax, DWORD PTR $T231299[ebp]
	jge	SHORT $LN3@Specializa

; 529  : 			{
; 530  : 				if(bTurnOn)

	movzx	ecx, BYTE PTR _bTurnOn$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@Specializa

; 531  : 				{
; 532  : 					m_aiTempFlavors[iFlavorLoop] += pSpecialization->GetFlavorValue(iFlavorLoop);

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _iFlavorLoop$225520[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSpecialization$225518[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	ecx, DWORD PTR _iFlavorLoop$225520[ebp]
	add	eax, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _iFlavorLoop$225520[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 533  : 				}
; 534  : 				else

	jmp	SHORT $LN1@Specializa
$LN2@Specializa:

; 535  : 				{
; 536  : 					m_aiTempFlavors[iFlavorLoop] -= pSpecialization->GetFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _iFlavorLoop$225520[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSpecialization$225518[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	edx, DWORD PTR _iFlavorLoop$225520[ebp]
	mov	ecx, DWORD PTR [esi+edx*4]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _iFlavorLoop$225520[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN1@Specializa:

; 537  : 				}
; 538  : 			}

	jmp	SHORT $LN4@Specializa
$LN3@Specializa:

; 539  : 
; 540  : 			ChangeFlavors(m_aiTempFlavors, true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeFlavors@CvFlavorRecipient@@QAEXPAH_N@Z ; CvFlavorRecipient::ChangeFlavors

; 541  : 
; 542  : 			LogFlavors();

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
$LN11@Specializa:

; 543  : 		}
; 544  : 	}
; 545  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::SpecializationFlavorChange
_TEXT	ENDS
PUBLIC	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ	; CvCityStrategyAI::GetCity
; Function compile flags: /Odtp
;	COMDAT ?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ PROC	; CvCityStrategyAI::GetCity, COMDAT
; _this$ = ecx

; 551  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 552  : 	return m_pCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 553  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ENDP	; CvCityStrategyAI::GetCity
_TEXT	ENDS
PUBLIC	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
; Function compile flags: /Odtp
;	COMDAT ?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ PROC ; CvCityStrategyAI::GetAICityStrategies, COMDAT
; _this$ = ecx

; 557  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 558  : 	return m_pAICityStrategies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 559  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ENDP ; CvCityStrategyAI::GetAICityStrategies
_TEXT	ENDS
PUBLIC	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
; Function compile flags: /Odtp
;	COMDAT ?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z PROC ; CvCityStrategyAI::IsUsingCityStrategy, COMDAT
; _this$ = ecx

; 563  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 	return m_pabUsingCityStrategy[(int) eStrategy];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ENDP ; CvCityStrategyAI::IsUsingCityStrategy
_TEXT	ENDS
PUBLIC	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
PUBLIC	?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z ; CvCityStrategyAI::SetTurnCityStrategyAdopted
PUBLIC	?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::SetUsingCityStrategy
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Odtp
;	COMDAT ?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T231311 = -4						; size = 4
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z PROC ; CvCityStrategyAI::SetUsingCityStrategy, COMDAT
; _this$ = ecx

; 569  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 	if(m_pabUsingCityStrategy[eStrategy] != bValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN4@SetUsingCi

; 571  : 	{
; 572  : 		m_pabUsingCityStrategy[eStrategy] = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 573  : 
; 574  : 		if(bValue)

	movzx	eax, BYTE PTR _bValue$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetUsingCi

; 575  : 		{
; 576  : 			SetTurnCityStrategyAdopted(eStrategy, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231311[ebp], ecx
	mov	ecx, DWORD PTR $T231311[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z ; CvCityStrategyAI::SetTurnCityStrategyAdopted

; 577  : 		}
; 578  : 		else

	jmp	SHORT $LN1@SetUsingCi
$LN2@SetUsingCi:

; 579  : 		{
; 580  : 			SetTurnCityStrategyAdopted(eStrategy, -1);

	push	-1
	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z ; CvCityStrategyAI::SetTurnCityStrategyAdopted
$LN1@SetUsingCi:

; 581  : 		}
; 582  : 
; 583  : 		LogStrategy(eStrategy, bValue);

	movzx	ecx, BYTE PTR _bValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
$LN4@SetUsingCi:

; 584  : 	}
; 585  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z ENDP ; CvCityStrategyAI::SetUsingCityStrategy
_TEXT	ENDS
PUBLIC	?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::GetTurnCityStrategyAdopted
; Function compile flags: /Odtp
;	COMDAT ?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z PROC ; CvCityStrategyAI::GetTurnCityStrategyAdopted, COMDAT
; _this$ = ecx

; 589  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 590  : 	return m_paiTurnCityStrategyAdopted[(int) eStrategy];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z ENDP ; CvCityStrategyAI::GetTurnCityStrategyAdopted
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z PROC ; CvCityStrategyAI::SetTurnCityStrategyAdopted, COMDAT
; _this$ = ecx

; 595  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 596  : 	if(m_paiTurnCityStrategyAdopted[(int) eStrategy] != iValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _iValue$[ebp]
	je	SHORT $LN2@SetTurnCit

; 597  : 	{
; 598  : 		m_paiTurnCityStrategyAdopted[(int) eStrategy] = iValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _eStrategy$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN2@SetTurnCit:

; 599  : 	}
; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z ENDP ; CvCityStrategyAI::SetTurnCityStrategyAdopted
_TEXT	ENDS
PUBLIC	?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ ; CvCityStrategyAI::GetBuildingProductionAI
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ PROC ; CvCityStrategyAI::GetBuildingProductionAI, COMDAT
; _this$ = ecx

; 604  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 605  : 	return m_pBuildingProductionAI;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 606  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ ENDP ; CvCityStrategyAI::GetBuildingProductionAI
_TEXT	ENDS
PUBLIC	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
; Function compile flags: /Odtp
;	COMDAT ?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ PROC ; CvCityStrategyAI::GetUnitProductionAI, COMDAT
; _this$ = ecx

; 610  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 611  : 	return m_pUnitProductionAI;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 612  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ENDP ; CvCityStrategyAI::GetUnitProductionAI
_TEXT	ENDS
PUBLIC	?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ ; CvCityStrategyAI::GetProjectProductionAI
; Function compile flags: /Odtp
;	COMDAT ?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ PROC ; CvCityStrategyAI::GetProjectProductionAI, COMDAT
; _this$ = ecx

; 616  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 617  : 	return m_pProjectProductionAI;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ ENDP ; CvCityStrategyAI::GetProjectProductionAI
_TEXT	ENDS
PUBLIC	?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ ; CvCityStrategyAI::GetProcessProductionAI
; Function compile flags: /Odtp
;	COMDAT ?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ PROC ; CvCityStrategyAI::GetProcessProductionAI, COMDAT
; _this$ = ecx

; 621  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 	return m_pProcessProductionAI;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 623  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ ENDP ; CvCityStrategyAI::GetProcessProductionAI
_TEXT	ENDS
PUBLIC	??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@ DB 'CityStrategyAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@
CONST	SEGMENT
??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@ DB 'CityStrategyAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
_TEXT	SEGMENT
tv205 = -196						; size = 4
tv149 = -192						; size = 4
tv156 = -188						; size = 4
tv147 = -184						; size = 4
tv162 = -180						; size = 4
tv145 = -176						; size = 4
tv189 = -172						; size = 4
_this$ = -168						; size = 4
$T231346 = -164						; size = 4
$T231337 = -160						; size = 4
$T231330 = -156						; size = 28
$T231329 = -128						; size = 28
$T231328 = -100						; size = 28
$T231327 = -72						; size = 28
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
_cityName$ = 16						; size = 4
?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z PROC ; CvCityStrategyAI::GetLogFileName, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T231337[ebp], 0

; 628  : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 629  : 
; 630  : 	// Open the log file
; 631  : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	$LN2@GetLogFile

; 632  : 	{
; 633  : 		strLogName = "CityStrategyAILog_" + playerName + "_" + cityName + ".csv";

	mov	ecx, DWORD PTR _playerName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@
	lea	edx, DWORD PTR $T231327[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv189[ebp], eax
	mov	eax, DWORD PTR tv189[ebp]
	mov	DWORD PTR tv145[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_01IDAFKMJL@_?$AA@
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231328[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv162[ebp], eax
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv147[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _cityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv147[ebp]
	push	edx
	lea	eax, DWORD PTR $T231329[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv156[ebp], eax
	mov	ecx, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv149[ebp]
	push	edx
	lea	eax, DWORD PTR $T231330[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv205[ebp], eax
	mov	ecx, DWORD PTR tv205[ebp]
	mov	DWORD PTR $T231346[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T231346[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T231330[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T231329[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T231328[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T231327[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 634  : 	}
; 635  : 	else

	jmp	SHORT $LN1@GetLogFile
$LN2@GetLogFile:

; 636  : 	{
; 637  : 		strLogName = "CityStrategyAILog.csv";

	mov	edx, OFFSET ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN18@GetLogFile
	push	OFFSET ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@GetLogFile
$LN18@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@GetLogFile:

; 638  : 	}
; 639  : 
; 640  : 	return strLogName;

	lea	eax, DWORD PTR _strLogName$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T231337[ebp]
	or	ecx, 1
	mov	DWORD PTR $T231337[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 641  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$1:
	lea	ecx, DWORD PTR $T231327[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$2:
	lea	ecx, DWORD PTR $T231328[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$3:
	lea	ecx, DWORD PTR $T231329[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$4:
	lea	ecx, DWORD PTR $T231330[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$5:
	mov	eax, DWORD PTR $T231337[ebp]
	and	eax, 1
	je	$LN11@GetLogFile
	and	DWORD PTR $T231337[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN11@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ENDP ; CvCityStrategyAI::GetLogFileName
PUBLIC	__real@4059000000000000
PUBLIC	?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldAverage
PUBLIC	?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetDeficientYieldValue
PUBLIC	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_fDesiredYield$ = -24					; size = 8
_iYieldAverage$ = -16					; size = 4
_iDesiredYield$ = -12					; size = 4
_fYieldAverage$ = -8					; size = 8
_eYieldType$ = 8					; size = 4
?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z PROC ; CvCityStrategyAI::IsYieldDeficient, COMDAT
; _this$ = ecx

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 652  : 	double fDesiredYield = GetDeficientYieldValue(eYieldType);

	mov	eax, DWORD PTR _eYieldType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetDeficientYieldValue
	fstp	QWORD PTR _fDesiredYield$[ebp]

; 653  : 	double fYieldAverage = GetYieldAverage(eYieldType);

	mov	ecx, DWORD PTR _eYieldType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldAverage
	fstp	QWORD PTR _fYieldAverage$[ebp]

; 654  : 
; 655  : 	int iDesiredYield = (int)citystrategyround(fDesiredYield * 100);

	movsd	xmm0, QWORD PTR _fDesiredYield$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?citystrategyround@@YANN@Z		; citystrategyround
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _iDesiredYield$[ebp], eax

; 656  : 	int iYieldAverage = (int)citystrategyround(fYieldAverage * 100);

	movsd	xmm0, QWORD PTR _fYieldAverage$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?citystrategyround@@YANN@Z		; citystrategyround
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _iYieldAverage$[ebp], eax

; 657  : 
; 658  : 	if(iYieldAverage < iDesiredYield)

	mov	edx, DWORD PTR _iYieldAverage$[ebp]
	cmp	edx, DWORD PTR _iDesiredYield$[ebp]
	jge	SHORT $LN2@IsYieldDef

; 659  : 	{
; 660  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@IsYieldDef

; 661  : 	}
; 662  : 	else

	jmp	SHORT $LN1@IsYieldDef
$LN2@IsYieldDef:

; 663  : 	{
; 664  : 		return false;

	xor	al, al
$LN1@IsYieldDef:

; 665  : 	}
; 666  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::IsYieldDeficient
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@0000000000000000
EXTRN	__imp__ceil:PROC
EXTRN	_floor:PROC
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?citystrategyround@@YANN@Z
_TEXT	SEGMENT
tv71 = -8						; size = 8
_x$ = 8							; size = 8
?citystrategyround@@YANN@Z PROC				; citystrategyround, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 646  : 	return (x >= 0) ? floor(x + .5) : ceil(x - .5);

	movsd	xmm0, QWORD PTR _x$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN3@citystrate
	fld	QWORD PTR _x$[ebp]
	fadd	QWORD PTR __real@3fe0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv71[ebp]
	jmp	SHORT $LN4@citystrate
$LN3@citystrate:
	movsd	xmm0, QWORD PTR _x$[ebp]
	subsd	xmm0, QWORD PTR __real@3fe0000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	fstp	QWORD PTR tv71[ebp]
$LN4@citystrate:
	fld	QWORD PTR tv71[ebp]

; 647  : };

	mov	esp, ebp
	pop	ebp
	ret	0
?citystrategyround@@YANN@Z ENDP				; citystrategyround
_TEXT	ENDS
PUBLIC	?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetDeficientYield
; Function compile flags: /Odtp
;	COMDAT ?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_yield$225617 = -8					; size = 4
_ui$225613 = -4						; size = 4
?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ PROC ; CvCityStrategyAI::GetDeficientYield, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 671  : 	if(IsYieldDeficient(YIELD_FOOD))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@GetDeficie

; 672  : 	{
; 673  : 		return YIELD_FOOD;

	xor	eax, eax
	jmp	SHORT $LN9@GetDeficie
	jmp	SHORT $LN7@GetDeficie
$LN8@GetDeficie:

; 674  : 	}
; 675  : 	else if(IsYieldDeficient(YIELD_PRODUCTION))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@GetDeficie

; 676  : 	{
; 677  : 		return YIELD_PRODUCTION;

	mov	eax, 1
	jmp	SHORT $LN9@GetDeficie

; 678  : 	}
; 679  : 	else

	jmp	SHORT $LN7@GetDeficie
$LN6@GetDeficie:

; 680  : 	{
; 681  : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$225613[ebp], 0
	jmp	SHORT $LN4@GetDeficie
$LN3@GetDeficie:
	mov	edx, DWORD PTR _ui$225613[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225613[ebp], edx
$LN4@GetDeficie:
	cmp	DWORD PTR _ui$225613[ebp], 6
	jae	SHORT $LN7@GetDeficie

; 682  : 		{
; 683  : 			YieldTypes yield = (YieldTypes)ui;

	mov	eax, DWORD PTR _ui$225613[ebp]
	mov	DWORD PTR _yield$225617[ebp], eax

; 684  : 			if(IsYieldDeficient(yield))

	mov	ecx, DWORD PTR _yield$225617[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetDeficie

; 685  : 			{
; 686  : 				return yield;

	mov	eax, DWORD PTR _yield$225617[ebp]
	jmp	SHORT $LN9@GetDeficie
$LN1@GetDeficie:

; 687  : 			}
; 688  : 		}

	jmp	SHORT $LN3@GetDeficie
$LN7@GetDeficie:

; 689  : 	}
; 690  : 
; 691  : 	return NO_YIELD;

	or	eax, -1
$LN9@GetDeficie:

; 692  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ENDP ; CvCityStrategyAI::GetDeficientYield
_TEXT	ENDS
EXTRN	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z:PROC ; CvPlot::calculateYield
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
; Function compile flags: /Odtp
;	COMDAT ?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z
_TEXT	SEGMENT
tv163 = -64						; size = 4
_this$ = -60						; size = 4
$T231425 = -56						; size = 4
$T231418 = -52						; size = 4
$T231411 = -48						; size = 4
$T231407 = -44						; size = 4
$T231400 = -40						; size = 4
$T231393 = -36						; size = 4
_pPlot$225633 = -32					; size = 4
_ui$225628 = -28					; size = 4
_iTilesWorked$ = -24					; size = 4
_aiPlots$ = -20						; size = 4
_iYieldAmount$ = -16					; size = 4
_pPlayer$ = -12						; size = 4
_fRatio$ = -8						; size = 8
_eYieldType$ = 8					; size = 4
?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetYieldAverage, COMDAT
; _this$ = ecx

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 697  : 	CvPlayer* pPlayer = &GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T231393[ebp], edx
	mov	eax, DWORD PTR $T231393[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pPlayer$[ebp], eax

; 698  : 	CvPlotsVector& aiPlots = pPlayer->GetPlots();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _aiPlots$[ebp], eax

; 699  : 
; 700  : 	int iTilesWorked = 0;

	mov	DWORD PTR _iTilesWorked$[ebp], 0

; 701  : 	int iYieldAmount = 0;

	mov	DWORD PTR _iYieldAmount$[ebp], 0

; 702  : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	mov	DWORD PTR _ui$225628[ebp], 0
	jmp	SHORT $LN6@GetYieldAv
$LN5@GetYieldAv:
	mov	ecx, DWORD PTR _ui$225628[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225628[ebp], ecx
$LN6@GetYieldAv:
	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231400[ebp], eax
	mov	ecx, DWORD PTR _ui$225628[ebp]
	cmp	ecx, DWORD PTR $T231400[ebp]
	jae	$LN4@GetYieldAv

; 703  : 	{
; 704  : 		// at the end of the plot list
; 705  : 		if(aiPlots[ui] == -1)

	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$225628[ebp]
	cmp	DWORD PTR [eax+ecx*4], -1
	jne	SHORT $LN3@GetYieldAv

; 706  : 		{
; 707  : 			break;

	jmp	$LN4@GetYieldAv
$LN3@GetYieldAv:

; 708  : 		}
; 709  : 
; 710  : 		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$225628[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T231407[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231411[ebp], eax
	mov	ecx, DWORD PTR $T231407[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231425[ebp], edx
	cmp	DWORD PTR $T231425[ebp], 0
	jl	SHORT $LN25@GetYieldAv
	mov	eax, DWORD PTR $T231411[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T231418[ebp], ecx
	mov	edx, DWORD PTR $T231425[ebp]
	cmp	edx, DWORD PTR $T231418[ebp]
	jge	SHORT $LN25@GetYieldAv
	mov	eax, DWORD PTR $T231425[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T231411[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN26@GetYieldAv
$LN25@GetYieldAv:
	mov	DWORD PTR tv163[ebp], 0
$LN26@GetYieldAv:
	mov	edx, DWORD PTR tv163[ebp]
	mov	DWORD PTR _pPlot$225633[ebp], edx

; 711  : 		if(!m_pCity->GetCityCitizens()->IsWorkingPlot(pPlot))

	mov	eax, DWORD PTR _pPlot$225633[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@GetYieldAv

; 712  : 		{
; 713  : 			continue;

	jmp	$LN5@GetYieldAv
$LN2@GetYieldAv:

; 714  : 		}
; 715  : 
; 716  : 		iTilesWorked++;

	mov	eax, DWORD PTR _iTilesWorked$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTilesWorked$[ebp], eax

; 717  : 		iYieldAmount += pPlot->calculateYield(eYieldType);

	push	0
	mov	ecx, DWORD PTR _eYieldType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$225633[ebp]
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	add	eax, DWORD PTR _iYieldAmount$[ebp]
	mov	DWORD PTR _iYieldAmount$[ebp], eax

; 718  : 	}

	jmp	$LN5@GetYieldAv
$LN4@GetYieldAv:

; 719  : 
; 720  : 	double fRatio = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _fRatio$[ebp], xmm0

; 721  : 	if(iTilesWorked > 0)

	cmp	DWORD PTR _iTilesWorked$[ebp], 0
	jle	SHORT $LN1@GetYieldAv

; 722  : 	{
; 723  : 		fRatio = iYieldAmount / (double)iTilesWorked;

	cvtsi2sd xmm0, DWORD PTR _iYieldAmount$[ebp]
	cvtsi2sd xmm1, DWORD PTR _iTilesWorked$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _fRatio$[ebp], xmm0
$LN1@GetYieldAv:

; 724  : 	}
; 725  : 
; 726  : 	return fRatio;

	fld	QWORD PTR _fRatio$[ebp]

; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetYieldAverage
_TEXT	ENDS
PUBLIC	__real@c08f380000000000
;	COMDAT __real@c08f380000000000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@c08f380000000000 DQ 0c08f380000000000r	; -999
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z
_TEXT	SEGMENT
tv64 = -32						; size = 4
_this$ = -28						; size = 4
$T231443 = -24						; size = 4
$T231439 = -20						; size = 4
$T231435 = -16						; size = 4
$T231431 = -12						; size = 4
_fDesiredYield$ = -8					; size = 8
_eYieldType$ = 8					; size = 4
?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetDeficientYieldValue, COMDAT
; _this$ = ecx

; 731  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 732  : 	double fDesiredYield = -999.0;

	movsd	xmm0, QWORD PTR __real@c08f380000000000
	movsd	QWORD PTR _fDesiredYield$[ebp], xmm0

; 733  : 
; 734  : 	switch(eYieldType)

	mov	eax, DWORD PTR _eYieldType$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN1@GetDeficie@2
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN20@GetDeficie@2[ecx*4]
$LN7@GetDeficie@2:

; 735  : 	{
; 736  : 	case YIELD_FOOD:
; 737  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2348
	movss	DWORD PTR $T231431[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T231431[ebp]
	movsd	QWORD PTR _fDesiredYield$[ebp], xmm0

; 738  : 		break;

	jmp	SHORT $LN8@GetDeficie@2
$LN6@GetDeficie@2:

; 739  : 	case YIELD_PRODUCTION:
; 740  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2352
	movss	DWORD PTR $T231435[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T231435[ebp]
	movsd	QWORD PTR _fDesiredYield$[ebp], xmm0

; 741  : 		break;

	jmp	SHORT $LN8@GetDeficie@2
$LN5@GetDeficie@2:

; 742  : 	case YIELD_SCIENCE:
; 743  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2360
	movss	DWORD PTR $T231439[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T231439[ebp]
	movsd	QWORD PTR _fDesiredYield$[ebp], xmm0

; 744  : 		break;

	jmp	SHORT $LN8@GetDeficie@2
$LN4@GetDeficie@2:

; 745  : 	case YIELD_GOLD:
; 746  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2356
	movss	DWORD PTR $T231443[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T231443[ebp]
	movsd	QWORD PTR _fDesiredYield$[ebp], xmm0

; 747  : 		break;

	jmp	SHORT $LN8@GetDeficie@2
$LN3@GetDeficie@2:

; 748  : 		// OK if deficient in the newer (bonus) yields
; 749  : 	case YIELD_CULTURE:
; 750  : 		break;

	jmp	SHORT $LN8@GetDeficie@2
$LN2@GetDeficie@2:

; 751  : 	case YIELD_FAITH:
; 752  : 		break;

	jmp	SHORT $LN8@GetDeficie@2
$LN1@GetDeficie@2:

; 753  : 	default:
; 754  : 		FAssertMsg(false, "Yield type is not handled. What?");
; 755  : 		return false;

	fldz
	jmp	SHORT $LN10@GetDeficie@2
$LN8@GetDeficie@2:

; 756  : 	}
; 757  : 
; 758  : 	return fDesiredYield;

	fld	QWORD PTR _fDesiredYield$[ebp]
$LN10@GetDeficie@2:

; 759  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN20@GetDeficie@2:
	DD	$LN7@GetDeficie@2
	DD	$LN6@GetDeficie@2
	DD	$LN4@GetDeficie@2
	DD	$LN5@GetDeficie@2
	DD	$LN3@GetDeficie@2
	DD	$LN2@GetDeficie@2
?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetDeficientYieldValue
_TEXT	ENDS
PUBLIC	?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z ; CvCityStrategyAI::LogCityProduction
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices
PUBLIC	??_C@_0CF@HNJOJGCJ@Choosing?5city?5build?5from?5Top?5Cho@ ; `string'
PUBLIC	?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight
PUBLIC	?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ	; CvCityStrategyAI::LogPossibleBuilds
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
PUBLIC	?ReweightByCost@CvCityStrategyAI@@AAEXXZ	; CvCityStrategyAI::ReweightByCost
PUBLIC	??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@ ; `string'
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
PUBLIC	??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@		; `string'
PUBLIC	??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@ ; `string'
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
PUBLIC	?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z ; CvCityStrategyAI::ChooseProduction
EXTRN	?CommitToBuildingUnitForOperation@CvCity@@QAE_NXZ:PROC ; CvCity::CommitToBuildingUnitForOperation
EXTRN	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z:PROC ; CvCity::pushOrder
EXTRN	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::GetCityProductionNumOptions
EXTRN	?GetWeight@CvProcessProductionAI@@QAEHW4ProcessTypes@@@Z:PROC ; CvProcessProductionAI::GetWeight
EXTRN	?canMaintain@CvCity@@QBE_NW4ProcessTypes@@_N@Z:PROC ; CvCity::canMaintain
EXTRN	?getNumProcessInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumProcessInfos
EXTRN	?getBaseYieldRateModifier@CvCity@@QBEHW4YieldTypes@@HPAVCvString@@@Z:PROC ; CvCity::getBaseYieldRateModifier
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetYieldPerPopTimes100@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::GetYieldPerPopTimes100
EXTRN	?getBaseYieldRate@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getBaseYieldRate
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?GetWeight@CvProjectProductionAI@@QAEHW4ProjectTypes@@@Z:PROC ; CvProjectProductionAI::GetWeight
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4ProjectTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?canCreate@CvCity@@QBE_NW4ProjectTypes@@_N1@Z:PROC ; CvCity::canCreate
EXTRN	?isWorldProject@@YA_NW4ProjectTypes@@@Z:PROC	; isWorldProject
EXTRN	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ:PROC ; CvProjectXMLEntries::GetNumProjects
EXTRN	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ:PROC ; CvGlobals::GetGameProjects
EXTRN	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getUnitsPerPlayer
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?waterArea@CvCity@@QBEPAVCvArea@@XZ:PROC	; CvCity::waterArea
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?canTrain@CvCity@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvCity::canTrain
EXTRN	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ:PROC	; CvUnitXMLEntries::GetNumUnits
EXTRN	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetGoldMaintenance
EXTRN	?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetDomainFreeExperience
EXTRN	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isLimitedWonderClass
EXTRN	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isNationalWonderClass
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ:PROC ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForDiploVictory
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC ; CvTeam::GetLiberatedByTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ:PROC ; CvGame::GetVotesNeededForDiploVictory
EXTRN	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsDiplomaticVoting
EXTRN	?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z:PROC ; CvBuildingProductionAI::GetWeight
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4BuildingTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z:PROC ; CvMilitaryAI::GetUnitForArmy
EXTRN	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z:PROC	; CvPlayer::GetBestSettleAreas
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z:PROC ; CvUnitProductionAI::GetWeight
EXTRN	?IsOperationUnitProvider@CvCitySpecializationXMLEntry@@QBE_NXZ:PROC ; CvCitySpecializationXMLEntry::IsOperationUnitProvider
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?GetUnitForOperation@CvCity@@QAE?AW4UnitTypes@@XZ:PROC ; CvCity::GetUnitForOperation
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?getAsyncRandNum@CvGame@@QAEHHPBD@Z:PROC	; CvGame::getAsyncRandNum
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
;	COMDAT ??_C@_0CF@HNJOJGCJ@Choosing?5city?5build?5from?5Top?5Cho@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.h
CONST	SEGMENT
??_C@_0CF@HNJOJGCJ@Choosing?5city?5build?5from?5Top?5Cho@ DB 'Choosing ci'
	DB	'ty build from Top Choices', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@
CONST	SEGMENT
??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@ DB 'GAMEOPTION_AI_GI'
	DB	'MP_NO_WORLD_WONDER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
CONST	SEGMENT
??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@ DB 'FLAVOR_OFFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@
CONST	SEGMENT
??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@ DB 'ECONOMICAISTRATE'
	DB	'GY_ENOUGH_EXPANSION', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
tv802 = -704						; size = 4
tv922 = -700						; size = 4
tv256 = -696						; size = 4
_this$ = -692						; size = 4
$T232039 = -688						; size = 4
$T232035 = -684						; size = 4
$T232031 = -680						; size = 4
$T232027 = -676						; size = 4
$T231977 = -628						; size = 4
$T231961 = -592						; size = 4
$T231892 = -572						; size = 4
$T231888 = -568						; size = 4
_weightedElem$231883 = -556				; size = 16
$T231855 = -540						; size = 4
$T231851 = -536						; size = 4
$T231842 = -532						; size = 4
$T231838 = -528						; size = 4
_weightedElem$231837 = -516				; size = 16
$T231809 = -500						; size = 4
$T231805 = -496						; size = 4
_weightedElem$231801 = -484				; size = 16
$T231773 = -468						; size = 4
$T231764 = -464						; size = 4
$T231763 = -460						; size = 4
_weightedElem$231759 = -448				; size = 16
$T231731 = -432						; size = 4
$T231727 = -428						; size = 4
$T231720 = -424						; size = 4
$T231714 = -420						; size = 4
$T231710 = -416						; size = 4
$T231706 = -412						; size = 4
$T231694 = -408						; size = 4
$T231690 = -401						; size = 1
$T231681 = -400						; size = 4
$T231661 = -396						; size = 4
_weightedElem$231657 = -392				; size = 16
$T231641 = -376						; size = 4
$T231634 = -372						; size = 4
$T231628 = -368						; size = 4
$T231627 = -364						; size = 4
$T231623 = -360						; size = 4
$T231616 = -356						; size = 4
_weightedElem$231612 = -352				; size = 16
$T231596 = -336						; size = 4
$T231595 = -332						; size = 4
$T231591 = -328						; size = 4
$T231587 = -324						; size = 4
$T231583 = -320						; size = 4
$T231579 = -316						; size = 4
$T231578 = -312						; size = 4
$T231571 = -308						; size = 4
_i$231566 = -304					; size = 4
$T231540 = -300						; size = 4
$T231524 = -296						; size = 4
$T231520 = -292						; size = 4
$T231504 = -288						; size = 4
$T231497 = -284						; size = 4
$T231455 = -280						; size = 12
$T231454 = -268						; size = 4
$T231453 = -264						; size = 4
$T231452 = -260						; size = 4
$T231451 = -256						; size = 4
$T231450 = -252						; size = 8
$T231449 = -244						; size = 8
_eProcessType$225978 = -236				; size = 4
_eProjectType$225975 = -232				; size = 4
_eBuildingType$225972 = -228				; size = 4
_eUnitAI$225969 = -224					; size = 4
_pkUnitInfo$225967 = -220				; size = 4
_eUnitType$225965 = -216				; size = 4
_bRush$225959 = -209					; size = 1
_iRushIfMoreThanXTurns$225957 = -208			; size = 4
_iNumChoices$225954 = -204				; size = 4
_eProcess$225949 = -200					; size = 4
_iBaseYield$225943 = -196				; size = 4
_iModifiedYield$225944 = -192				; size = 4
_iNumUnitsofMine$225925 = -188				; size = 4
_iWaterTiles$225924 = -184				; size = 4
_pBiggestNearbyBodyOfWater$225922 = -180		; size = 4
_eDomain$225919 = -176					; size = 4
_iNumGoodAreas$225916 = -172				; size = 4
_iBestArea$225914 = -168				; size = 4
_iSecondBestArea$225915 = -164				; size = 4
_pkUnitEntry$225909 = -160				; size = 4
_iResourceLoop$225895 = -156				; size = 4
_kBuildingClassInfo$225889 = -152			; size = 4
_iNumResources$225894 = -148				; size = 4
_iPlayerLoop$225869 = -144				; size = 4
_iVotesNeededToWin$225863 = -140			; size = 4
_eLoopPlayer$225867 = -136				; size = 4
_iSecuredVotes$225864 = -132				; size = 4
_iNumberOfPlayersWeNeedToBuyOff$225879 = -128		; size = 4
_myTeamID$225865 = -124					; size = 4
_eLoopTeam$225868 = -120				; size = 4
_myPlayerID$225866 = -116				; size = 4
_eLoopBuilding$225857 = -112				; size = 4
_pkBuildingInfo$225859 = -108				; size = 4
_iBonusMultiplier$225850 = -104				; size = 4
_iOffenseFlavor$225848 = -100				; size = 4
_iNumGoodAreas$225843 = -96				; size = 4
_iBestArea$225841 = -92					; size = 4
_iSecondBestArea$225842 = -88				; size = 4
_pkUnitEntry$225837 = -84				; size = 4
_iOffenseFlavor$225833 = -80				; size = 4
_fcn$ = -76						; size = 8
_bIsVenice$ = -66					; size = 1
_bEnoughSettlers$ = -65					; size = 1
_iProcessLoop$ = -64					; size = 4
_selection$ = -60					; size = 12
_eUnitForOperation$ = -48				; size = 4
_eStrategyEnoughSettlers$ = -44				; size = 4
_buildable$ = -40					; size = 12
_iBldgLoop$ = -28					; size = 4
_eUnitForArmy$ = -24					; size = 4
_iUnitLoop$ = -20					; size = 4
_iTempWeight$ = -16					; size = 4
_pDiploAI$ = -12					; size = 4
_iProjectLoop$ = -8					; size = 4
_kPlayer$ = -4						; size = 4
_bUseAsyncRandom$ = 8					; size = 1
_eIgnoreBldg$ = 12					; size = 4
_eIgnoreUnit$ = 16					; size = 4
?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z PROC ; CvCityStrategyAI::ChooseProduction, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 704				; 000002c0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0
	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0

; 765  : #ifdef AUI_WARNING_FIXES
; 766  : 	uint iBldgLoop, iUnitLoop, iProjectLoop, iProcessLoop;
; 767  : 	int iTempWeight;
; 768  : #else
; 769  : 	int iBldgLoop, iUnitLoop, iProjectLoop, iProcessLoop, iTempWeight;
; 770  : #endif
; 771  : 	CvCityBuildable buildable;

	mov	DWORD PTR _buildable$[ebp], 0
	mov	DWORD PTR _buildable$[ebp+4], 0
	mov	DWORD PTR _buildable$[ebp+8], 0

; 772  : 	CvCityBuildable selection;

	mov	DWORD PTR _selection$[ebp], 0
	mov	DWORD PTR _selection$[ebp+4], 0
	mov	DWORD PTR _selection$[ebp+8], 0

; 773  : 	UnitTypes eUnitForOperation;
; 774  : 	UnitTypes eUnitForArmy;
; 775  : 
; 776  : 	CvPlayerAI& kPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T231497[ebp], edx
	mov	eax, DWORD PTR $T231497[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 777  : 	CvDiplomacyAI* pDiploAI = kPlayer.GetDiplomacyAI();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pDiploAI$[ebp], eax

; 778  : 
; 779  : 	//int iSettlersOnMap = kPlayer.GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);
; 780  : 
; 781  : 	// Use the asynchronous random number generate if "no random" is set
; 782  : 	if(bUseAsyncRandom)

	movzx	ecx, BYTE PTR _bUseAsyncRandom$[ebp]
	test	ecx, ecx
	je	SHORT $LN78@ChooseProd

; 783  : 	{
; 784  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getAsyncRandNum);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231504[ebp], edx
	push	OFFSET ?getAsyncRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getAsyncRandNum
	mov	eax, DWORD PTR $T231504[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231449[ebp]
	push	ecx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T231520[ebp], eax
	mov	edx, DWORD PTR $T231520[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _fcn$[ebp+4], eax
	mov	ecx, DWORD PTR $T231520[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _fcn$[ebp], edx

; 785  : 	}
; 786  : 	else

	jmp	SHORT $LN77@ChooseProd
$LN78@ChooseProd:

; 787  : 	{
; 788  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231524[ebp], eax
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	ecx, DWORD PTR $T231524[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231450[ebp]
	push	edx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T231540[ebp], eax
	mov	eax, DWORD PTR $T231540[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fcn$[ebp+4], ecx
	mov	edx, DWORD PTR $T231540[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _fcn$[ebp], eax
$LN77@ChooseProd:

; 789  : 	}
; 790  : 
; 791  : 	// Reset vector holding items we can currently build
; 792  : 	m_Buildables.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR $T231571[ebp], ecx
	xor	edx, edx
	je	SHORT $LN125@ChooseProd
	mov	DWORD PTR _i$231566[ebp], 0
	jmp	SHORT $LN123@ChooseProd
$LN122@ChooseProd:
	mov	eax, DWORD PTR _i$231566[ebp]
	add	eax, 1
	mov	DWORD PTR _i$231566[ebp], eax
$LN123@ChooseProd:
	mov	ecx, DWORD PTR $T231571[ebp]
	mov	edx, DWORD PTR _i$231566[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN125@ChooseProd
	jmp	SHORT $LN122@ChooseProd
$LN125@ChooseProd:
	mov	eax, DWORD PTR $T231571[ebp]
	mov	DWORD PTR [eax+4], 0

; 793  : 
; 794  : 	EconomicAIStrategyTypes eStrategyEnoughSettlers = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_ENOUGH_EXPANSION");

	push	0
	push	OFFSET ??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyEnoughSettlers$[ebp], eax

; 795  : 	bool bEnoughSettlers = kPlayer.GetEconomicAI()->IsUsingStrategy(eStrategyEnoughSettlers);

	mov	ecx, DWORD PTR _eStrategyEnoughSettlers$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	mov	BYTE PTR _bEnoughSettlers$[ebp], al

; 796  : 
; 797  : 	// Check units for operations first
; 798  : 	eUnitForOperation = m_pCity->GetUnitForOperation();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?GetUnitForOperation@CvCity@@QAE?AW4UnitTypes@@XZ ; CvCity::GetUnitForOperation
	mov	DWORD PTR _eUnitForOperation$[ebp], eax

; 799  : 	if(eUnitForOperation != NO_UNIT)

	cmp	DWORD PTR _eUnitForOperation$[ebp], -1
	je	$LN76@ChooseProd

; 800  : 	{
; 801  : 		buildable.m_eBuildableType = CITY_BUILDABLE_UNIT_FOR_OPERATION;

	mov	DWORD PTR _buildable$[ebp], 5

; 802  : 		buildable.m_iIndex = (int)eUnitForOperation;

	mov	eax, DWORD PTR _eUnitForOperation$[ebp]
	mov	DWORD PTR _buildable$[ebp+4], eax

; 803  : 		buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft(eUnitForOperation, 0);

	push	0
	mov	ecx, DWORD PTR _eUnitForOperation$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _buildable$[ebp+8], eax

; 804  : 		iTempWeight = GC.getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2364
	mov	DWORD PTR _iTempWeight$[ebp], edx

; 805  : 		int iOffenseFlavor = kPlayer.GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE")) + kPlayer.GetMilitaryAI()->GetNumberOfTimesOpsBuildSkippedOver();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T231578[ebp], eax
	mov	eax, DWORD PTR $T231578[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T231579[ebp], ecx
	push	0
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	add	eax, DWORD PTR $T231579[ebp]
	mov	DWORD PTR _iOffenseFlavor$225833[ebp], eax

; 806  : 		iTempWeight += (GC.getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER() * iOffenseFlavor);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2368
	mov	DWORD PTR $T231583[ebp], edx
	mov	eax, DWORD PTR $T231583[ebp]
	imul	eax, DWORD PTR _iOffenseFlavor$225833[ebp]
	add	eax, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 807  : 
; 808  : 		if(GetSpecialization() != NO_CITY_SPECIALIZATION && GC.getCitySpecializationInfo(GetSpecialization())->IsOperationUnitProvider())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T231587[ebp], edx
	cmp	DWORD PTR $T231587[ebp], -1
	je	SHORT $LN75@ChooseProd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T231591[ebp], ecx
	mov	edx, DWORD PTR $T231591[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	ecx, eax
	call	?IsOperationUnitProvider@CvCitySpecializationXMLEntry@@QBE_NXZ ; CvCitySpecializationXMLEntry::IsOperationUnitProvider
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN75@ChooseProd

; 809  : 		{
; 810  : 			iTempWeight *= 5;

	mov	ecx, DWORD PTR _iTempWeight$[ebp]
	imul	ecx, 5
	mov	DWORD PTR _iTempWeight$[ebp], ecx
$LN75@ChooseProd:

; 811  : 		}
; 812  : 
; 813  : 		// add in the weight of this unit as if I were deciding to build it without having a reason
; 814  : 		iTempWeight += m_pUnitProductionAI->GetWeight(eUnitForOperation);

	mov	edx, DWORD PTR _eUnitForOperation$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight
	add	eax, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 815  : 
; 816  : 		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnitForOperation);

	mov	ecx, DWORD PTR _eUnitForOperation$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$225837[ebp], eax

; 817  : 		if(pkUnitEntry && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_SETTLE)

	cmp	DWORD PTR _pkUnitEntry$225837[ebp], 0
	je	SHORT $LN74@ChooseProd
	mov	ecx, DWORD PTR _pkUnitEntry$225837[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 1
	jne	SHORT $LN74@ChooseProd

; 818  : 		{
; 819  : 			if(bEnoughSettlers)

	movzx	edx, BYTE PTR _bEnoughSettlers$[ebp]
	test	edx, edx
	je	SHORT $LN73@ChooseProd

; 820  : 			{
; 821  : 				iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0

; 822  : 			}
; 823  : 			else

	jmp	SHORT $LN74@ChooseProd
$LN73@ChooseProd:

; 824  : 			{
; 825  : 				int iBestArea, iSecondBestArea;
; 826  : 				int iNumGoodAreas = kPlayer.GetBestSettleAreas(kPlayer.GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T231595[ebp], eax
	mov	eax, DWORD PTR $T231595[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T231596[ebp], ecx
	lea	edx, DWORD PTR _iSecondBestArea$225842[ebp]
	push	edx
	lea	eax, DWORD PTR _iBestArea$225841[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231596[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas
	mov	DWORD PTR _iNumGoodAreas$225843[ebp], eax

; 827  : 				if(iNumGoodAreas == 0)

	cmp	DWORD PTR _iNumGoodAreas$225843[ebp], 0
	jne	SHORT $LN74@ChooseProd

; 828  : 				{
; 829  : 					iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN74@ChooseProd:

; 830  : 				}
; 831  : 			}
; 832  : 		}
; 833  : 
; 834  : 		if (iTempWeight > 0)

	cmp	DWORD PTR _iTempWeight$[ebp], 0
	jle	$LN76@ChooseProd

; 835  : 		{
; 836  : 			m_Buildables.push_back(buildable, iTempWeight);

	mov	DWORD PTR _weightedElem$231612[ebp], 0
	mov	DWORD PTR _weightedElem$231612[ebp+4], 0
	mov	DWORD PTR _weightedElem$231612[ebp+8], 0
	mov	DWORD PTR _weightedElem$231612[ebp+12], 0
	mov	edx, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR _weightedElem$231612[ebp], edx
	mov	eax, DWORD PTR _buildable$[ebp+4]
	mov	DWORD PTR _weightedElem$231612[ebp+4], eax
	mov	ecx, DWORD PTR _buildable$[ebp+8]
	mov	DWORD PTR _weightedElem$231612[ebp+8], ecx
	mov	edx, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _weightedElem$231612[ebp+12], edx
	lea	eax, DWORD PTR _weightedElem$231612[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back

; 837  : 			kPlayer.GetMilitaryAI()->BumpNumberOfTimesOpsBuildSkippedOver();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T231616[ebp], eax
	mov	ecx, DWORD PTR $T231616[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	mov	eax, DWORD PTR $T231616[ebp]
	mov	DWORD PTR [eax+48], edx
$LN76@ChooseProd:

; 838  : 		}
; 839  : 
; 840  : 	}
; 841  : 
; 842  : 	// Next units for sneak attack armies
; 843  : 	eUnitForArmy = kPlayer.GetMilitaryAI()->GetUnitForArmy(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z ; CvMilitaryAI::GetUnitForArmy
	mov	DWORD PTR _eUnitForArmy$[ebp], eax

; 844  : 	if(eUnitForArmy != NO_UNIT)

	cmp	DWORD PTR _eUnitForArmy$[ebp], -1
	je	$LN69@ChooseProd

; 845  : 	{
; 846  : 		buildable.m_eBuildableType = CITY_BUILDABLE_UNIT_FOR_ARMY;

	mov	DWORD PTR _buildable$[ebp], 6

; 847  : 		buildable.m_iIndex = (int)eUnitForArmy;

	mov	ecx, DWORD PTR _eUnitForArmy$[ebp]
	mov	DWORD PTR _buildable$[ebp+4], ecx

; 848  : 		buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft(eUnitForArmy, 0);

	push	0
	mov	edx, DWORD PTR _eUnitForArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _buildable$[ebp+8], eax

; 849  : 		iTempWeight = GC.getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2372
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 850  : 		int iOffenseFlavor = kPlayer.GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));

	push	0
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iOffenseFlavor$225848[ebp], eax

; 851  : 		int iBonusMultiplier = max(1,GC.getGame().getHandicapInfo().GetID() - 5); // more at the higher difficulties

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231623[ebp], ecx
	mov	ecx, DWORD PTR $T231623[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T231627[ebp], eax
	mov	edx, DWORD PTR $T231627[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231628[ebp], eax
	mov	ecx, DWORD PTR $T231628[ebp]
	sub	ecx, 5
	mov	DWORD PTR $T231451[ebp], ecx
	mov	DWORD PTR $T231452[ebp], 1
	mov	edx, DWORD PTR $T231452[ebp]
	cmp	edx, DWORD PTR $T231451[ebp]
	jge	SHORT $LN155@ChooseProd
	lea	eax, DWORD PTR $T231451[ebp]
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN156@ChooseProd
$LN155@ChooseProd:
	lea	ecx, DWORD PTR $T231452[ebp]
	mov	DWORD PTR tv256[ebp], ecx
$LN156@ChooseProd:
	mov	edx, DWORD PTR tv256[ebp]
	mov	DWORD PTR $T231634[ebp], edx
	mov	eax, DWORD PTR $T231634[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iBonusMultiplier$225850[ebp], ecx

; 852  : 		iTempWeight += (GC.getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER() * iOffenseFlavor * iBonusMultiplier);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2368
	mov	DWORD PTR $T231641[ebp], edx
	mov	eax, DWORD PTR $T231641[ebp]
	imul	eax, DWORD PTR _iOffenseFlavor$225848[ebp]
	imul	eax, DWORD PTR _iBonusMultiplier$225850[ebp]
	add	eax, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 853  : 		// add in the weight of this unit as if I were deciding to build it without having a reason
; 854  : 		iTempWeight += m_pUnitProductionAI->GetWeight(eUnitForArmy);

	mov	ecx, DWORD PTR _eUnitForArmy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight
	add	eax, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 855  : 
; 856  : 		if (iTempWeight > 0)

	cmp	DWORD PTR _iTempWeight$[ebp], 0
	jle	SHORT $LN69@ChooseProd

; 857  : 		{
; 858  : 			m_Buildables.push_back(buildable, iTempWeight);

	mov	DWORD PTR _weightedElem$231657[ebp], 0
	mov	DWORD PTR _weightedElem$231657[ebp+4], 0
	mov	DWORD PTR _weightedElem$231657[ebp+8], 0
	mov	DWORD PTR _weightedElem$231657[ebp+12], 0
	mov	eax, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR _weightedElem$231657[ebp], eax
	mov	ecx, DWORD PTR _buildable$[ebp+4]
	mov	DWORD PTR _weightedElem$231657[ebp+4], ecx
	mov	edx, DWORD PTR _buildable$[ebp+8]
	mov	DWORD PTR _weightedElem$231657[ebp+8], edx
	mov	eax, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _weightedElem$231657[ebp+12], eax
	lea	ecx, DWORD PTR _weightedElem$231657[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
$LN69@ChooseProd:

; 859  : 		}
; 860  : 	}
; 861  : 
; 862  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_SLIDING_LOGISTIC_MAINTENANCE_SCALE
; 863  : 	bool bCapitolConnectedHasHarbor = false;
; 864  : 	if (GetCity()->IsPuppet() && !GetCity()->IsRouteToCapitalConnected())
; 865  : 	{
; 866  : 		int iLoop;
; 867  : 		const CvPlayer* pPlayer = GetCity()->GetPlayer();
; 868  : 		const CvCity* pLoopCity;
; 869  : 		for (uint uiBuildingTypes = 0; uiBuildingTypes < GC.GetGameBuildings()->GetNumBuildings(); uiBuildingTypes++)
; 870  : 		{
; 871  : 			const BuildingTypes eHarborBuilding = static_cast<BuildingTypes>(uiBuildingTypes);
; 872  : 			CvBuildingEntry* pkHarborBuildingInfo = GC.getBuildingInfo(eHarborBuilding);
; 873  : 			if (pkHarborBuildingInfo && pkHarborBuildingInfo->AllowsWaterRoutes())
; 874  : 			{
; 875  : 				for (pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))
; 876  : 				{
; 877  : 					if (pLoopCity->IsRouteToCapitalConnected() && pLoopCity->GetCityBuildings()->GetNumActiveBuilding(eHarborBuilding) > 0)
; 878  : 					{
; 879  : 						bCapitolConnectedHasHarbor = true;
; 880  : 						goto EndHarborLoop;
; 881  : 					}
; 882  : 				}
; 883  : 			}
; 884  : 		}
; 885  : 	}
; 886  : EndHarborLoop:;
; 887  : #endif
; 888  : 
; 889  : 	// Loop through adding the available buildings
; 890  : 	for(iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	DWORD PTR _iBldgLoop$[ebp], 0
	jmp	SHORT $LN67@ChooseProd
$LN66@ChooseProd:
	mov	edx, DWORD PTR _iBldgLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iBldgLoop$[ebp], edx
$LN67@ChooseProd:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _iBldgLoop$[ebp], eax
	jge	$LN65@ChooseProd

; 891  : 	{
; 892  : 		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iBldgLoop);

	mov	eax, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR _eLoopBuilding$225857[ebp], eax

; 893  : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eLoopBuilding);

	mov	ecx, DWORD PTR _eLoopBuilding$225857[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$225859[ebp], eax

; 894  : 
; 895  : 		//Skip if null
; 896  : 		if(pkBuildingInfo == NULL)

	cmp	DWORD PTR _pkBuildingInfo$225859[ebp], 0
	jne	SHORT $LN64@ChooseProd

; 897  : 			continue;

	jmp	SHORT $LN66@ChooseProd
$LN64@ChooseProd:

; 898  : 
; 899  : 		// Make sure this building can be built now
; 900  : #ifdef AUI_WARNING_FIXES
; 901  : 		if (iBldgLoop != uint(eIgnoreBldg) && m_pCity->canConstruct(eLoopBuilding))
; 902  : #else
; 903  : 		if(iBldgLoop != eIgnoreBldg && m_pCity->canConstruct(eLoopBuilding))

	mov	edx, DWORD PTR _iBldgLoop$[ebp]
	cmp	edx, DWORD PTR _eIgnoreBldg$[ebp]
	je	$LN63@ChooseProd
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _eLoopBuilding$225857[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	movzx	edx, al
	test	edx, edx
	je	$LN63@ChooseProd

; 904  : #endif
; 905  : 		{
; 906  : 			buildable.m_eBuildableType = CITY_BUILDABLE_BUILDING;

	mov	DWORD PTR _buildable$[ebp], 1

; 907  : 			buildable.m_iIndex = iBldgLoop;

	mov	eax, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR _buildable$[ebp+4], eax

; 908  : 			buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft(eLoopBuilding, 0);

	push	0
	mov	ecx, DWORD PTR _eLoopBuilding$225857[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getProductionTurnsLeft@CvCity@@QBEHW4BuildingTypes@@H@Z ; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _buildable$[ebp+8], eax

; 909  : 
; 910  : 			iTempWeight = m_pBuildingProductionAI->GetWeight(eLoopBuilding);

	mov	edx, DWORD PTR _eLoopBuilding$225857[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z ; CvBuildingProductionAI::GetWeight
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 911  : 
; 912  : 			// Don't build the UN if you aren't going for the diplo victory
; 913  : 			if(pkBuildingInfo->IsDiplomaticVoting())

	mov	ecx, DWORD PTR _pkBuildingInfo$225859[ebp]
	call	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsDiplomaticVoting
	movzx	ecx, al
	test	ecx, ecx
	je	$LN62@ChooseProd

; 914  : 			{
; 915  : 				int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231661[ebp], edx
	mov	ecx, DWORD PTR $T231661[ebp]
	call	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ ; CvGame::GetVotesNeededForDiploVictory
	mov	DWORD PTR _iVotesNeededToWin$225863[ebp], eax

; 916  : 				int iSecuredVotes = 0;

	mov	DWORD PTR _iSecuredVotes$225864[ebp], 0

; 917  : 				TeamTypes myTeamID = kPlayer.getTeam();

	mov	eax, DWORD PTR _kPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _myTeamID$225865[ebp], eax

; 918  : 				PlayerTypes myPlayerID = kPlayer.GetID();

	mov	edx, DWORD PTR _kPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _myPlayerID$225866[ebp], eax

; 919  : 
; 920  : 				// Loop through Players to see if they'll vote for this player
; 921  : 				PlayerTypes eLoopPlayer;
; 922  : 				TeamTypes eLoopTeam;
; 923  : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225869[ebp], 0
	jmp	SHORT $LN61@ChooseProd
$LN60@ChooseProd:
	mov	ecx, DWORD PTR _iPlayerLoop$225869[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$225869[ebp], ecx
$LN61@ChooseProd:
	cmp	DWORD PTR _iPlayerLoop$225869[ebp], 63	; 0000003fH
	jge	$LN59@ChooseProd

; 924  : 				{
; 925  : 					eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$225869[ebp]
	mov	DWORD PTR _eLoopPlayer$225867[ebp], edx

; 926  : 
; 927  : 					if(GET_PLAYER(eLoopPlayer).isAlive())

	mov	eax, DWORD PTR _eLoopPlayer$225867[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231681[ebp], eax
	mov	ecx, DWORD PTR $T231681[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T231690[ebp], dl
	movzx	eax, BYTE PTR $T231690[ebp]
	test	eax, eax
	je	$LN58@ChooseProd

; 928  : 					{
; 929  : 						eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

	mov	ecx, DWORD PTR _eLoopPlayer$225867[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231694[ebp], ecx
	mov	edx, DWORD PTR $T231694[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eLoopTeam$225868[ebp], eax

; 930  : 
; 931  : 						// Liberated?
; 932  : 						if(GET_TEAM(eLoopTeam).GetLiberatedByTeam() == myTeamID)

	mov	ecx, DWORD PTR _eLoopTeam$225868[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231706[ebp], ecx
	mov	ecx, DWORD PTR $T231706[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, DWORD PTR _myTeamID$225865[ebp]
	jne	SHORT $LN57@ChooseProd

; 933  : 						{
; 934  : 							iSecuredVotes++;

	mov	edx, DWORD PTR _iSecuredVotes$225864[ebp]
	add	edx, 1
	mov	DWORD PTR _iSecuredVotes$225864[ebp], edx
	jmp	SHORT $LN58@ChooseProd
$LN57@ChooseProd:

; 935  : 						}
; 936  : 
; 937  : 						// Minor civ?
; 938  : 						else if(GET_PLAYER(eLoopPlayer).isMinorCiv())

	mov	eax, DWORD PTR _eLoopPlayer$225867[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231710[ebp], eax
	mov	ecx, DWORD PTR $T231710[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN58@ChooseProd

; 939  : 						{
; 940  : 							// Best Relations?
; 941  : 							if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly() == myPlayerID)

	mov	edx, DWORD PTR _eLoopPlayer$225867[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231714[ebp], edx
	mov	ecx, DWORD PTR $T231714[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _myPlayerID$225866[ebp]
	jne	SHORT $LN58@ChooseProd

; 942  : 							{
; 943  : 								iSecuredVotes++;

	mov	eax, DWORD PTR _iSecuredVotes$225864[ebp]
	add	eax, 1
	mov	DWORD PTR _iSecuredVotes$225864[ebp], eax
$LN58@ChooseProd:

; 944  : 							}
; 945  : 						}
; 946  : 					}
; 947  : 				}

	jmp	$LN60@ChooseProd
$LN59@ChooseProd:

; 948  : 
; 949  : 				int iNumberOfPlayersWeNeedToBuyOff = MAX(0, iVotesNeededToWin - iSecuredVotes);

	mov	ecx, DWORD PTR _iVotesNeededToWin$225863[ebp]
	sub	ecx, DWORD PTR _iSecuredVotes$225864[ebp]
	mov	DWORD PTR $T231453[ebp], ecx
	mov	DWORD PTR $T231454[ebp], 0
	mov	edx, DWORD PTR $T231454[ebp]
	cmp	edx, DWORD PTR $T231453[ebp]
	jge	SHORT $LN195@ChooseProd
	lea	eax, DWORD PTR $T231453[ebp]
	mov	DWORD PTR tv922[ebp], eax
	jmp	SHORT $LN196@ChooseProd
$LN195@ChooseProd:
	lea	ecx, DWORD PTR $T231454[ebp]
	mov	DWORD PTR tv922[ebp], ecx
$LN196@ChooseProd:
	mov	edx, DWORD PTR tv922[ebp]
	mov	DWORD PTR $T231720[ebp], edx
	mov	eax, DWORD PTR $T231720[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumberOfPlayersWeNeedToBuyOff$225879[ebp], ecx

; 950  : 
; 951  : 				if(!pDiploAI  || !pDiploAI->IsGoingForDiploVictory() || kPlayer.GetTreasury()->GetGold() < iNumberOfPlayersWeNeedToBuyOff * 500)

	cmp	DWORD PTR _pDiploAI$[ebp], 0
	je	SHORT $LN52@ChooseProd
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN52@ChooseProd
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ecx, DWORD PTR _iNumberOfPlayersWeNeedToBuyOff$225879[ebp]
	imul	ecx, 500				; 000001f4H
	cmp	eax, ecx
	jge	SHORT $LN62@ChooseProd
$LN52@ChooseProd:

; 952  : 				{
; 953  : 					iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN62@ChooseProd:

; 954  : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 955  : 					continue;
; 956  : #endif
; 957  : 				}
; 958  : 			}
; 959  : 
; 960  : #ifdef NQM_AI_GIMP_NO_WORLD_WONDERS
; 961  : 			if ((GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_WORLD_WONDER")) && isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231727[ebp], edx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T231727[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN50@ChooseProd
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231731[ebp], ecx
	push	OFFSET ??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@
	mov	ecx, DWORD PTR $T231731[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN51@ChooseProd
$LN50@ChooseProd:
	mov	ecx, DWORD PTR _pkBuildingInfo$225859[ebp]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN51@ChooseProd

; 962  : 			{
; 963  : 				iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0

; 964  : 				continue;

	jmp	$LN66@ChooseProd
$LN51@ChooseProd:

; 965  : 			}
; 966  : #endif
; 967  : 
; 968  : 			// If the City is a puppet, it avoids Wonders (because the human can't change it if he wants to build it somewhere else!)
; 969  : 			if(GetCity()->IsPuppet())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN49@ChooseProd

; 970  : 			{
; 971  : 				const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();

	mov	ecx, DWORD PTR _pkBuildingInfo$225859[ebp]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	mov	DWORD PTR _kBuildingClassInfo$225889[ebp], eax

; 972  : 
; 973  : 				if(isWorldWonderClass(kBuildingClassInfo) || isTeamWonderClass(kBuildingClassInfo) || isNationalWonderClass(kBuildingClassInfo) || isLimitedWonderClass(kBuildingClassInfo))

	mov	edx, DWORD PTR _kBuildingClassInfo$225889[ebp]
	push	edx
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN47@ChooseProd
	mov	ecx, DWORD PTR _kBuildingClassInfo$225889[ebp]
	push	ecx
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN47@ChooseProd
	mov	eax, DWORD PTR _kBuildingClassInfo$225889[ebp]
	push	eax
	call	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isNationalWonderClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN47@ChooseProd
	mov	edx, DWORD PTR _kBuildingClassInfo$225889[ebp]
	push	edx
	call	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isLimitedWonderClass
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN48@ChooseProd
$LN47@ChooseProd:

; 974  : 				{
; 975  : 					iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN48@ChooseProd:

; 976  : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 977  : 					continue;
; 978  : #endif
; 979  : 				}
; 980  : #ifndef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_PUPPETS_NULLIFY_BARRACKS
; 981  : 				// it also avoids military training buildings - since it can't build units
; 982  : 				if(pkBuildingInfo->GetDomainFreeExperience(DOMAIN_LAND))

	push	2
	mov	ecx, DWORD PTR _pkBuildingInfo$225859[ebp]
	call	?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainFreeExperience
	test	eax, eax
	je	SHORT $LN46@ChooseProd

; 983  : 				{
; 984  : 					iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN46@ChooseProd:

; 985  : 				}
; 986  : #endif
; 987  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_SLIDING_LOGISTIC_MAINTENANCE_SCALE
; 988  : 				int iEffectiveMaintenanceT100 = pkBuildingInfo->GetGoldMaintenance() * (100 + GetCity()->GetPlayer()->GetBuildingGoldMaintenanceMod());
; 989  : 				int iBonusGoldFromYield = pkBuildingInfo->GetYieldChange(YIELD_GOLD) + GetCity()->getPopulation() * pkBuildingInfo->GetYieldChangePerPop(YIELD_GOLD);
; 990  : 				iBonusGoldFromYield += GetCity()->GetCityBuildings()->GetBuildingYieldChange((BuildingClassTypes)pkBuildingInfo->GetBuildingClassType(), YIELD_GOLD);
; 991  : 				iBonusGoldFromYield *= GetCity()->getYieldRateModifier(YIELD_GOLD) + pkBuildingInfo->GetYieldModifier(YIELD_GOLD);
; 992  : 				iEffectiveMaintenanceT100 -= iBonusGoldFromYield;
; 993  : 
; 994  : 				int iBonusGoldFromModifier = GetCity()->getBaseYieldRate(YIELD_GOLD) * 100;
; 995  : 				iBonusGoldFromModifier += GetCity()->GetYieldPerPopTimes100(YIELD_GOLD) * GetCity()->getPopulation();
; 996  : 				iBonusGoldFromModifier += GetCity()->GetYieldPerReligionTimes100(YIELD_GOLD) * GetCity()->GetCityReligions()->GetNumReligionsWithFollowers();
; 997  : 				iBonusGoldFromModifier *= pkBuildingInfo->GetYieldModifier(YIELD_GOLD);
; 998  : 				iEffectiveMaintenanceT100 -= iBonusGoldFromModifier;
; 999  : 
; 1000 : 				if (bCapitolConnectedHasHarbor && pkBuildingInfo->AllowsWaterRoutes())
; 1001 : 				{
; 1002 : 					iEffectiveMaintenanceT100 -= GetCity()->GetPlayer()->GetTreasury()->GetCityConnectionRouteGoldTimes100(GetCity());
; 1003 : 				}
; 1004 : 				
; 1005 : 				iTempWeight *= int(2.0 / (1.0 + exp(double(iEffectiveMaintenanceT100) / 200.0)) + 0.5);
; 1006 : #else
; 1007 : 				// they also like stuff that won't burden the empire with maintenance costs
; 1008 : 				if(pkBuildingInfo->GetGoldMaintenance() == 0)

	mov	ecx, DWORD PTR _pkBuildingInfo$225859[ebp]
	call	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGoldMaintenance
	test	eax, eax
	jne	SHORT $LN45@ChooseProd

; 1009 : 				{
; 1010 : 					iTempWeight *= 2;

	mov	ecx, DWORD PTR _iTempWeight$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _iTempWeight$[ebp], ecx
$LN45@ChooseProd:

; 1011 : 				}
; 1012 : #endif
; 1013 : 				// and they avoid any buildings that require resources
; 1014 : 				int iNumResources = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResources$225894[ebp], eax

; 1015 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResources; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$225895[ebp], 0
	jmp	SHORT $LN44@ChooseProd
$LN43@ChooseProd:
	mov	edx, DWORD PTR _iResourceLoop$225895[ebp]
	add	edx, 1
	mov	DWORD PTR _iResourceLoop$225895[ebp], edx
$LN44@ChooseProd:
	mov	eax, DWORD PTR _iResourceLoop$225895[ebp]
	cmp	eax, DWORD PTR _iNumResources$225894[ebp]
	jge	SHORT $LN49@ChooseProd

; 1016 : 				{
; 1017 : 					if(pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	ecx, DWORD PTR _iResourceLoop$225895[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkBuildingInfo$225859[ebp]
	call	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN41@ChooseProd

; 1018 : 					{
; 1019 : 						iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN41@ChooseProd:

; 1020 : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 1021 : 						break;
; 1022 : #endif
; 1023 : 					}
; 1024 : 				}

	jmp	SHORT $LN43@ChooseProd
$LN49@ChooseProd:

; 1025 : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 1026 : 				iTempWeight += 1;
; 1027 : #endif
; 1028 : 			}
; 1029 : 			if(iTempWeight > 0)

	cmp	DWORD PTR _iTempWeight$[ebp], 0
	jle	SHORT $LN63@ChooseProd

; 1030 : 				m_Buildables.push_back(buildable, iTempWeight);

	mov	DWORD PTR _weightedElem$231759[ebp], 0
	mov	DWORD PTR _weightedElem$231759[ebp+4], 0
	mov	DWORD PTR _weightedElem$231759[ebp+8], 0
	mov	DWORD PTR _weightedElem$231759[ebp+12], 0
	mov	edx, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR _weightedElem$231759[ebp], edx
	mov	eax, DWORD PTR _buildable$[ebp+4]
	mov	DWORD PTR _weightedElem$231759[ebp+4], eax
	mov	ecx, DWORD PTR _buildable$[ebp+8]
	mov	DWORD PTR _weightedElem$231759[ebp+8], ecx
	mov	edx, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _weightedElem$231759[ebp+12], edx
	lea	eax, DWORD PTR _weightedElem$231759[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
$LN63@ChooseProd:

; 1031 : 		}
; 1032 : 	}

	jmp	$LN66@ChooseProd
$LN65@ChooseProd:

; 1033 : 
; 1034 : 	// If the City is a puppet, it avoids training Units and projects
; 1035 : 	if(!GetCity()->IsPuppet())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN39@ChooseProd

; 1036 : 	{
; 1037 : 		// Loop through adding the available units
; 1038 : 		for(iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$[ebp], 0
	jmp	SHORT $LN38@ChooseProd
$LN37@ChooseProd:
	mov	edx, DWORD PTR _iUnitLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnitLoop$[ebp], edx
$LN38@ChooseProd:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	DWORD PTR _iUnitLoop$[ebp], eax
	jge	$LN36@ChooseProd

; 1039 : 		{
; 1040 : 			// Make sure this unit can be built now
; 1041 : #ifdef AUI_WARNING_FIXES
; 1042 : 			if (iUnitLoop != uint(eIgnoreUnit) &&
; 1043 : #else
; 1044 : 			if(iUnitLoop != eIgnoreUnit &&
; 1045 : #endif
; 1046 : 			        //GC.GetGameBuildings()->GetEntry(iUnitLoop)->GetAdvisorType() != eIgnoreAdvisor &&
; 1047 : 			        m_pCity->canTrain((UnitTypes)iUnitLoop))

	mov	eax, DWORD PTR _iUnitLoop$[ebp]
	cmp	eax, DWORD PTR _eIgnoreUnit$[ebp]
	je	$LN35@ChooseProd
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?canTrain@CvCity@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvCity::canTrain
	movzx	eax, al
	test	eax, eax
	je	$LN35@ChooseProd

; 1048 : 			{
; 1049 : 				buildable.m_eBuildableType = CITY_BUILDABLE_UNIT;

	mov	DWORD PTR _buildable$[ebp], 2

; 1050 : 				buildable.m_iIndex = iUnitLoop;

	mov	ecx, DWORD PTR _iUnitLoop$[ebp]
	mov	DWORD PTR _buildable$[ebp+4], ecx

; 1051 : 				buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft((UnitTypes)iUnitLoop, 0);

	push	0
	mov	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _buildable$[ebp+8], eax

; 1052 : 
; 1053 : 				iTempWeight = m_pUnitProductionAI->GetWeight((UnitTypes)iUnitLoop);

	mov	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 1054 : 
; 1055 : 				CvUnitEntry* pkUnitEntry = GC.getUnitInfo((UnitTypes)iUnitLoop);

	mov	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$225909[ebp], eax

; 1056 : 				if(pkUnitEntry && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_SETTLE)

	cmp	DWORD PTR _pkUnitEntry$225909[ebp], 0
	je	SHORT $LN34@ChooseProd
	mov	ecx, DWORD PTR _pkUnitEntry$225909[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 1
	jne	SHORT $LN34@ChooseProd

; 1057 : 				{
; 1058 : 					if(bEnoughSettlers)

	movzx	eax, BYTE PTR _bEnoughSettlers$[ebp]
	test	eax, eax
	je	SHORT $LN33@ChooseProd

; 1059 : 					{
; 1060 : 						iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0

; 1061 : 					}
; 1062 : 					else

	jmp	SHORT $LN34@ChooseProd
$LN33@ChooseProd:

; 1063 : 					{
; 1064 : 						int iBestArea, iSecondBestArea;
; 1065 : 						int iNumGoodAreas = kPlayer.GetBestSettleAreas(kPlayer.GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T231763[ebp], eax
	mov	ecx, DWORD PTR $T231763[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T231764[ebp], edx
	lea	eax, DWORD PTR _iSecondBestArea$225915[ebp]
	push	eax
	lea	ecx, DWORD PTR _iBestArea$225914[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231764[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas
	mov	DWORD PTR _iNumGoodAreas$225916[ebp], eax

; 1066 : 						if(iNumGoodAreas == 0)

	cmp	DWORD PTR _iNumGoodAreas$225916[ebp], 0
	jne	SHORT $LN34@ChooseProd

; 1067 : 						{
; 1068 : 							iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN34@ChooseProd:

; 1069 : 						}
; 1070 : 					}
; 1071 : 				}
; 1072 : 
; 1073 : 				// sanity check for building ships on small inland seas (not lakes)
; 1074 : 				if (pkUnitEntry)

	cmp	DWORD PTR _pkUnitEntry$225909[ebp], 0
	je	$LN30@ChooseProd

; 1075 : 				{
; 1076 : 					DomainTypes eDomain = (DomainTypes) pkUnitEntry->GetDomainType();

	mov	ecx, DWORD PTR _pkUnitEntry$225909[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	mov	DWORD PTR _eDomain$225919[ebp], eax

; 1077 : 					if (eDomain == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() != UNITAI_WORKER_SEA) // if needed allow workboats...

	cmp	DWORD PTR _eDomain$225919[ebp], 0
	jne	$LN30@ChooseProd
	mov	ecx, DWORD PTR _pkUnitEntry$225909[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 17					; 00000011H
	je	SHORT $LN30@ChooseProd

; 1078 : 					{
; 1079 : 						CvArea* pBiggestNearbyBodyOfWater = m_pCity->waterArea();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?waterArea@CvCity@@QBEPAVCvArea@@XZ	; CvCity::waterArea
	mov	DWORD PTR _pBiggestNearbyBodyOfWater$225922[ebp], eax

; 1080 : 						if (pBiggestNearbyBodyOfWater)

	cmp	DWORD PTR _pBiggestNearbyBodyOfWater$225922[ebp], 0
	je	SHORT $LN28@ChooseProd

; 1081 : 						{
; 1082 : 							int iWaterTiles = pBiggestNearbyBodyOfWater->getNumTiles();

	mov	ecx, DWORD PTR _pBiggestNearbyBodyOfWater$225922[ebp]
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	DWORD PTR _iWaterTiles$225924[ebp], eax

; 1083 : 							int iNumUnitsofMine = pBiggestNearbyBodyOfWater->getUnitsPerPlayer(m_pCity->getOwner());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T231773[ebp], eax
	mov	ecx, DWORD PTR $T231773[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pBiggestNearbyBodyOfWater$225922[ebp]
	call	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer
	mov	DWORD PTR _iNumUnitsofMine$225925[ebp], eax

; 1084 : 							if (iNumUnitsofMine * 5 > iWaterTiles)

	mov	edx, DWORD PTR _iNumUnitsofMine$225925[ebp]
	imul	edx, 5
	cmp	edx, DWORD PTR _iWaterTiles$225924[ebp]
	jle	SHORT $LN27@ChooseProd

; 1085 : 							{
; 1086 : 								iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN27@ChooseProd:

; 1087 : 							}
; 1088 : 						}
; 1089 : 						else // this should never happen, but...

	jmp	SHORT $LN30@ChooseProd
$LN28@ChooseProd:

; 1090 : 						{
; 1091 : 							iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[ebp], 0
$LN30@ChooseProd:

; 1092 : 						}
; 1093 : 					}
; 1094 : 				}
; 1095 : 
; 1096 : 
; 1097 : 				if(iTempWeight > 0)

	cmp	DWORD PTR _iTempWeight$[ebp], 0
	jle	SHORT $LN35@ChooseProd

; 1098 : 					m_Buildables.push_back(buildable, iTempWeight);

	mov	DWORD PTR _weightedElem$231801[ebp], 0
	mov	DWORD PTR _weightedElem$231801[ebp+4], 0
	mov	DWORD PTR _weightedElem$231801[ebp+8], 0
	mov	DWORD PTR _weightedElem$231801[ebp+12], 0
	mov	eax, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR _weightedElem$231801[ebp], eax
	mov	ecx, DWORD PTR _buildable$[ebp+4]
	mov	DWORD PTR _weightedElem$231801[ebp+4], ecx
	mov	edx, DWORD PTR _buildable$[ebp+8]
	mov	DWORD PTR _weightedElem$231801[ebp+8], edx
	mov	eax, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _weightedElem$231801[ebp+12], eax
	lea	ecx, DWORD PTR _weightedElem$231801[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
$LN35@ChooseProd:

; 1099 : 			}
; 1100 : 		}

	jmp	$LN37@ChooseProd
$LN36@ChooseProd:

; 1101 : 
; 1102 : 		// Loop through adding the available projects
; 1103 : 		for(iProjectLoop = 0; iProjectLoop < GC.GetGameProjects()->GetNumProjects(); iProjectLoop++)

	mov	DWORD PTR _iProjectLoop$[ebp], 0
	jmp	SHORT $LN24@ChooseProd
$LN23@ChooseProd:
	mov	edx, DWORD PTR _iProjectLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iProjectLoop$[ebp], edx
$LN24@ChooseProd:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ; CvProjectXMLEntries::GetNumProjects
	cmp	DWORD PTR _iProjectLoop$[ebp], eax
	jge	$LN39@ChooseProd

; 1104 : 		{
; 1105 : #ifdef NQM_AI_GIMP_NO_WORLD_WONDERS
; 1106 : 			if ((GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_WORLD_WONDER")) && isWorldProject((ProjectTypes)iProjectLoop))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231805[ebp], eax
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T231805[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@ChooseProd
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231809[ebp], edx
	push	OFFSET ??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@
	mov	ecx, DWORD PTR $T231809[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@ChooseProd
$LN20@ChooseProd:
	mov	ecx, DWORD PTR _iProjectLoop$[ebp]
	push	ecx
	call	?isWorldProject@@YA_NW4ProjectTypes@@@Z	; isWorldProject
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@ChooseProd

; 1107 : 				continue;

	jmp	SHORT $LN23@ChooseProd
$LN21@ChooseProd:

; 1108 : #endif
; 1109 : 			if(m_pCity->canCreate((ProjectTypes)iProjectLoop))

	push	0
	push	0
	mov	eax, DWORD PTR _iProjectLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?canCreate@CvCity@@QBE_NW4ProjectTypes@@_N1@Z ; CvCity::canCreate
	movzx	edx, al
	test	edx, edx
	je	$LN19@ChooseProd

; 1110 : 			{
; 1111 : 				buildable.m_eBuildableType = CITY_BUILDABLE_PROJECT;

	mov	DWORD PTR _buildable$[ebp], 3

; 1112 : 				buildable.m_iIndex = iProjectLoop;

	mov	eax, DWORD PTR _iProjectLoop$[ebp]
	mov	DWORD PTR _buildable$[ebp+4], eax

; 1113 : 				buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft((ProjectTypes)iProjectLoop, 0);

	push	0
	mov	ecx, DWORD PTR _iProjectLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getProductionTurnsLeft@CvCity@@QBEHW4ProjectTypes@@H@Z ; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _buildable$[ebp+8], eax

; 1114 : 				m_Buildables.push_back(buildable, m_pProjectProductionAI->GetWeight((ProjectTypes)iProjectLoop));

	mov	edx, DWORD PTR _iProjectLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?GetWeight@CvProjectProductionAI@@QAEHW4ProjectTypes@@@Z ; CvProjectProductionAI::GetWeight
	mov	DWORD PTR $T231838[ebp], eax
	mov	DWORD PTR _weightedElem$231837[ebp], 0
	mov	DWORD PTR _weightedElem$231837[ebp+4], 0
	mov	DWORD PTR _weightedElem$231837[ebp+8], 0
	mov	DWORD PTR _weightedElem$231837[ebp+12], 0
	mov	ecx, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR _weightedElem$231837[ebp], ecx
	mov	edx, DWORD PTR _buildable$[ebp+4]
	mov	DWORD PTR _weightedElem$231837[ebp+4], edx
	mov	eax, DWORD PTR _buildable$[ebp+8]
	mov	DWORD PTR _weightedElem$231837[ebp+8], eax
	mov	ecx, DWORD PTR $T231838[ebp]
	mov	DWORD PTR _weightedElem$231837[ebp+12], ecx
	lea	edx, DWORD PTR _weightedElem$231837[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
$LN19@ChooseProd:

; 1115 : 			}
; 1116 : 		}

	jmp	$LN23@ChooseProd
$LN39@ChooseProd:

; 1117 : 	}
; 1118 : 
; 1119 : 	// Normally, a puppeted city cannot run processes, but as Venice they are allowed to.
; 1120 : 	bool bIsVenice = kPlayer.GetPlayerTraits()->IsNoAnnexing();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T231842[ebp], eax
	mov	eax, DWORD PTR $T231842[ebp]
	mov	cl, BYTE PTR [eax+351]
	mov	BYTE PTR _bIsVenice$[ebp], cl

; 1121 : 	if (!GetCity()->IsPuppet() || bIsVenice)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN263@ChooseProd
	movzx	eax, BYTE PTR _bIsVenice$[ebp]
	test	eax, eax
	je	$LN18@ChooseProd

; 1122 : 	{	
; 1123 : 		// Loop through adding available processes
; 1124 : 		if (!GET_PLAYER(m_pCity->getOwner()).isMinorCiv())

$LN263@ChooseProd:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T231851[ebp], eax
	mov	ecx, DWORD PTR $T231851[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231855[ebp], ecx
	mov	ecx, DWORD PTR $T231855[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	$LN18@ChooseProd

; 1125 : 		{
; 1126 : 			//I cannot use the yield rate since it adds in set process yield, which is what I am trying to set...
; 1127 : 			int iBaseYield = GetCity()->getBaseYieldRate(YIELD_PRODUCTION) * 100;

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getBaseYieldRate@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getBaseYieldRate
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iBaseYield$225943[ebp], eax

; 1128 : 			iBaseYield += (GetCity()->GetYieldPerPopTimes100(YIELD_PRODUCTION) * GetCity()->getPopulation());

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?GetYieldPerPopTimes100@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::GetYieldPerPopTimes100
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	esi, eax
	add	esi, DWORD PTR _iBaseYield$225943[ebp]
	mov	DWORD PTR _iBaseYield$225943[ebp], esi

; 1129 : 			int iModifiedYield = iBaseYield * GetCity()->getBaseYieldRateModifier(YIELD_PRODUCTION);

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getBaseYieldRateModifier@CvCity@@QBEHW4YieldTypes@@HPAVCvString@@@Z ; CvCity::getBaseYieldRateModifier
	imul	eax, DWORD PTR _iBaseYield$225943[ebp]
	mov	DWORD PTR _iModifiedYield$225944[ebp], eax

; 1130 : 			iModifiedYield /= 100;

	mov	eax, DWORD PTR _iModifiedYield$225944[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iModifiedYield$225944[ebp], eax

; 1131 : 
; 1132 : 			if (iModifiedYield >= 8)

	cmp	DWORD PTR _iModifiedYield$225944[ebp], 8
	jl	$LN18@ChooseProd

; 1133 : 			{
; 1134 : 				for (iProcessLoop = 0; iProcessLoop < GC.getNumProcessInfos(); iProcessLoop++)

	mov	DWORD PTR _iProcessLoop$[ebp], 0
	jmp	SHORT $LN14@ChooseProd
$LN13@ChooseProd:
	mov	edx, DWORD PTR _iProcessLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iProcessLoop$[ebp], edx
$LN14@ChooseProd:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProcessInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProcessInfos
	cmp	DWORD PTR _iProcessLoop$[ebp], eax
	jge	$LN18@ChooseProd

; 1135 : 				{
; 1136 : 					ProcessTypes eProcess = (ProcessTypes)iProcessLoop;

	mov	eax, DWORD PTR _iProcessLoop$[ebp]
	mov	DWORD PTR _eProcess$225949[ebp], eax

; 1137 : 					if (m_pCity->canMaintain(eProcess))

	push	0
	mov	ecx, DWORD PTR _eProcess$225949[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?canMaintain@CvCity@@QBE_NW4ProcessTypes@@_N@Z ; CvCity::canMaintain
	movzx	eax, al
	test	eax, eax
	je	$LN11@ChooseProd

; 1138 : 					{
; 1139 : 						iTempWeight = m_pProcessProductionAI->GetWeight((ProcessTypes)iProcessLoop);

	mov	ecx, DWORD PTR _iProcessLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetWeight@CvProcessProductionAI@@QAEHW4ProcessTypes@@@Z ; CvProcessProductionAI::GetWeight
	mov	DWORD PTR _iTempWeight$[ebp], eax

; 1140 : 						buildable.m_eBuildableType = CITY_BUILDABLE_PROCESS;

	mov	DWORD PTR _buildable$[ebp], 4

; 1141 : 						buildable.m_iIndex = iProcessLoop;

	mov	eax, DWORD PTR _iProcessLoop$[ebp]
	mov	DWORD PTR _buildable$[ebp+4], eax

; 1142 : 						buildable.m_iTurnsToConstruct = 1;

	mov	DWORD PTR _buildable$[ebp+8], 1

; 1143 : 						m_Buildables.push_back(buildable, iTempWeight);

	mov	DWORD PTR _weightedElem$231883[ebp], 0
	mov	DWORD PTR _weightedElem$231883[ebp+4], 0
	mov	DWORD PTR _weightedElem$231883[ebp+8], 0
	mov	DWORD PTR _weightedElem$231883[ebp+12], 0
	mov	ecx, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR _weightedElem$231883[ebp], ecx
	mov	edx, DWORD PTR _buildable$[ebp+4]
	mov	DWORD PTR _weightedElem$231883[ebp+4], edx
	mov	eax, DWORD PTR _buildable$[ebp+8]
	mov	DWORD PTR _weightedElem$231883[ebp+8], eax
	mov	ecx, DWORD PTR _iTempWeight$[ebp]
	mov	DWORD PTR _weightedElem$231883[ebp+12], ecx
	lea	edx, DWORD PTR _weightedElem$231883[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
$LN11@ChooseProd:

; 1144 : 					}
; 1145 : 				}

	jmp	$LN13@ChooseProd
$LN18@ChooseProd:

; 1146 : 			}
; 1147 : 		}
; 1148 : 	}
; 1149 : 
; 1150 : 	ReweightByCost();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReweightByCost@CvCityStrategyAI@@AAEXXZ ; CvCityStrategyAI::ReweightByCost

; 1151 : 
; 1152 : 	m_Buildables.SortItems();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	mov	DWORD PTR $T231961[ebp], eax
	mov	ecx, DWORD PTR $T231961[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T231961[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T231888[ebp], edx
	mov	ecx, DWORD PTR $T231961[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231892[ebp], edx
	mov	eax, DWORD PTR $T231888[ebp]
	sub	eax, DWORD PTR $T231892[ebp]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR $T231888[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231892[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 1153 : 
; 1154 : 	LogPossibleBuilds();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ ; CvCityStrategyAI::LogPossibleBuilds

; 1155 : 
; 1156 : 	if(m_Buildables.GetTotalWeight() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight
	test	eax, eax
	jle	$LN79@ChooseProd

; 1157 : 	{
; 1158 : 		// Choose from the best options (currently 2)
; 1159 : 		int iNumChoices = GC.getGame().getHandicapInfo().GetCityProductionNumOptions();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231977[ebp], eax
	mov	ecx, DWORD PTR $T231977[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetCityProductionNumOptions
	mov	DWORD PTR _iNumChoices$225954[ebp], eax

; 1160 : 		selection = m_Buildables.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing city build from Top Choices");

	push	OFFSET ??_C@_0CF@HNJOJGCJ@Choosing?5city?5build?5from?5Top?5Cho@
	lea	ecx, DWORD PTR _fcn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumChoices$225954[ebp]
	push	edx
	lea	eax, DWORD PTR $T231455[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _selection$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _selection$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _selection$[ebp+8], eax

; 1161 : 		int iRushIfMoreThanXTurns = GC.getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1808
	mov	DWORD PTR _iRushIfMoreThanXTurns$225957[ebp], ecx

; 1162 : 		if(GET_PLAYER(m_pCity->getOwner()).isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T232027[ebp], ecx
	mov	edx, DWORD PTR $T232027[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232031[ebp], edx
	mov	ecx, DWORD PTR $T232031[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ChooseProd

; 1163 : 		{
; 1164 : 			iRushIfMoreThanXTurns *= GC.getMINOR_CIV_PRODUCTION_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7292
	mov	DWORD PTR $T232035[ebp], ecx
	mov	edx, DWORD PTR _iRushIfMoreThanXTurns$225957[ebp]
	imul	edx, DWORD PTR $T232035[ebp]
	mov	DWORD PTR _iRushIfMoreThanXTurns$225957[ebp], edx

; 1165 : 			iRushIfMoreThanXTurns /= 100;

	mov	eax, DWORD PTR _iRushIfMoreThanXTurns$225957[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iRushIfMoreThanXTurns$225957[ebp], eax
$LN9@ChooseProd:

; 1166 : 		}
; 1167 : 
; 1168 : 		bool bRush = selection.m_iTurnsToConstruct > iRushIfMoreThanXTurns;

	mov	edx, DWORD PTR _selection$[ebp+8]
	xor	eax, eax
	cmp	edx, DWORD PTR _iRushIfMoreThanXTurns$225957[ebp]
	setg	al
	mov	BYTE PTR _bRush$225959[ebp], al

; 1169 : 		LogCityProduction(selection, bRush);

	movzx	ecx, BYTE PTR _bRush$225959[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	eax, DWORD PTR _selection$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _selection$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _selection$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z ; CvCityStrategyAI::LogCityProduction

; 1170 : 
; 1171 : 		switch(selection.m_eBuildableType)

	mov	ecx, DWORD PTR _selection$[ebp]
	mov	DWORD PTR tv802[ebp], ecx
	mov	edx, DWORD PTR tv802[ebp]
	sub	edx, 1
	mov	DWORD PTR tv802[ebp], edx
	cmp	DWORD PTR tv802[ebp], 5
	ja	$LN79@ChooseProd
	mov	eax, DWORD PTR tv802[ebp]
	jmp	DWORD PTR $LN376@ChooseProd[eax*4]
$LN6@ChooseProd:

; 1172 : 		{
; 1173 : 		case CITY_BUILDABLE_UNIT:
; 1174 : 		case CITY_BUILDABLE_UNIT_FOR_ARMY:
; 1175 : 		{
; 1176 : 			UnitTypes eUnitType = (UnitTypes) selection.m_iIndex;

	mov	ecx, DWORD PTR _selection$[ebp+4]
	mov	DWORD PTR _eUnitType$225965[ebp], ecx

; 1177 : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);

	mov	edx, DWORD PTR _eUnitType$225965[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$225967[ebp], eax

; 1178 : 			if(pkUnitInfo)

	cmp	DWORD PTR _pkUnitInfo$225967[ebp], 0
	je	SHORT $LN5@ChooseProd

; 1179 : 			{
; 1180 : 				UnitAITypes eUnitAI = (UnitAITypes) pkUnitInfo->GetDefaultUnitAIType();

	mov	ecx, DWORD PTR _pkUnitInfo$225967[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	mov	DWORD PTR _eUnitAI$225969[ebp], eax

; 1181 : 				GetCity()->pushOrder(ORDER_TRAIN, eUnitType, eUnitAI, false, true, false, bRush);

	movzx	eax, BYTE PTR _bRush$225959[ebp]
	push	eax
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _eUnitAI$225969[ebp]
	push	ecx
	mov	edx, DWORD PTR _eUnitType$225965[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder
$LN5@ChooseProd:

; 1182 : 			}
; 1183 : 		}
; 1184 : 		break;

	jmp	$LN79@ChooseProd
$LN4@ChooseProd:

; 1185 : 
; 1186 : 		case CITY_BUILDABLE_BUILDING:
; 1187 : 		{
; 1188 : 			BuildingTypes eBuildingType = (BuildingTypes) selection.m_iIndex;

	mov	eax, DWORD PTR _selection$[ebp+4]
	mov	DWORD PTR _eBuildingType$225972[ebp], eax

; 1189 : 			GetCity()->pushOrder(ORDER_CONSTRUCT, eBuildingType, -1, false, true, false, bRush);

	movzx	ecx, BYTE PTR _bRush$225959[ebp]
	push	ecx
	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR _eBuildingType$225972[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 1190 : 		}
; 1191 : 		break;

	jmp	$LN79@ChooseProd
$LN3@ChooseProd:

; 1192 : 
; 1193 : 		case CITY_BUILDABLE_PROJECT:
; 1194 : 		{
; 1195 : 			ProjectTypes eProjectType = (ProjectTypes) selection.m_iIndex;

	mov	eax, DWORD PTR _selection$[ebp+4]
	mov	DWORD PTR _eProjectType$225975[ebp], eax

; 1196 : 			GetCity()->pushOrder(ORDER_CREATE, eProjectType, -1, false, true, false, bRush);

	movzx	ecx, BYTE PTR _bRush$225959[ebp]
	push	ecx
	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR _eProjectType$225975[ebp]
	push	edx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 1197 : 		}
; 1198 : 		break;

	jmp	SHORT $LN79@ChooseProd
$LN2@ChooseProd:

; 1199 : 
; 1200 : 		case CITY_BUILDABLE_PROCESS:
; 1201 : 		{
; 1202 : 			ProcessTypes eProcessType = (ProcessTypes)selection.m_iIndex;

	mov	eax, DWORD PTR _selection$[ebp+4]
	mov	DWORD PTR _eProcessType$225978[ebp], eax

; 1203 : 			GetCity()->pushOrder(ORDER_MAINTAIN, eProcessType, -1, false, true, false, false); // ignoring rush because we can't rush a process

	push	0
	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _eProcessType$225978[ebp]
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder
$LN1@ChooseProd:

; 1204 : 		}
; 1205 : 
; 1206 : 		case CITY_BUILDABLE_UNIT_FOR_OPERATION:
; 1207 : 		{
; 1208 : 			GetCity()->CommitToBuildingUnitForOperation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?CommitToBuildingUnitForOperation@CvCity@@QAE_NXZ ; CvCity::CommitToBuildingUnitForOperation

; 1209 : 			kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR $T232039[ebp], eax
	mov	edx, DWORD PTR $T232039[ebp]
	mov	DWORD PTR [edx+48], 0
$LN79@ChooseProd:

; 1210 : 		}
; 1211 : 		break;
; 1212 : 		}
; 1213 : 
; 1214 : 	}
; 1215 : 
; 1216 : 	return;
; 1217 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN376@ChooseProd:
	DD	$LN4@ChooseProd
	DD	$LN6@ChooseProd
	DD	$LN3@ChooseProd
	DD	$LN2@ChooseProd
	DD	$LN1@ChooseProd
	DD	$LN6@ChooseProd
?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z ENDP ; CvCityStrategyAI::ChooseProduction
_TEXT	ENDS
PUBLIC	??_C@_0BI@OBIIEEEC@CityStrategyCanActivate?$AA@	; `string'
PUBLIC	?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity
PUBLIC	??_C@_0CB@FJDKEHMJ@AICITYSTRATEGY_GOOD_AIRLIFT_CITY@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding
PUBLIC	??_C@_0CF@FBKODDGD@AICITYSTRATEGY_NEED_TOURISM_BUIL@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding
PUBLIC	??_C@_0CF@LBPACDHK@AICITYSTRATEGY_NEED_CULTURE_BUIL@ ; `string'
PUBLIC	?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin
PUBLIC	??_C@_0CK@MKEELCEJ@AICITYSTRATEGY_INTERNATIONAL_TRA@ ; `string'
PUBLIC	?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination
PUBLIC	??_C@_0CP@NDHLDCB@AICITYSTRATEGY_INTERNATIONAL_TRA@ ; `string'
PUBLIC	??_C@_0DF@EHEOFEPN@AICITYSTRATEGY_NO_NEED_INTERNATI@ ; `string'
PUBLIC	??_C@_0DC@LCLJFDJM@AICITYSTRATEGY_NEED_INTERNATIONA@ ; `string'
PUBLIC	?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
PUBLIC	??_C@_0DG@EEPLECGP@AICITYSTRATEGY_NO_NEED_INTERNATI@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
PUBLIC	??_C@_0DD@HOLLOEKG@AICITYSTRATEGY_NEED_INTERNATIONA@ ; `string'
PUBLIC	?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity
PUBLIC	??_C@_0BM@FBGEKDFP@AICITYSTRATEGY_GOOD_GP_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity
PUBLIC	??_C@_0CA@IJGDBOAB@AICITYSTRATEGY_KEY_SCIENCE_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen
PUBLIC	??_C@_0CB@MJBNJJHL@AICITYSTRATEGY_MANY_TECHS_STOLEN@ ; `string'
PUBLIC	?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity
PUBLIC	??_C@_0BK@PNCLKHNL@AICITYSTRATEGY_COAST_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity
PUBLIC	??_C@_0BL@FDKNAHIG@AICITYSTRATEGY_JUNGLE_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity
PUBLIC	??_C@_0BJ@NLLKBHIL@AICITYSTRATEGY_HILL_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity
PUBLIC	??_C@_0BL@GNKICLFF@AICITYSTRATEGY_FOREST_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity
PUBLIC	??_C@_0BN@PLODLAAO@AICITYSTRATEGY_MOUNTAIN_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity
PUBLIC	??_C@_0BK@IOOIOOLJ@AICITYSTRATEGY_RIVER_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital
PUBLIC	??_C@_0CA@NNCEJJDF@AICITYSTRATEGY_ORIGINAL_CAPITAL?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty
PUBLIC	??_C@_0CL@HHHGPLCE@AICITYSTRATEGY_MEDIUM_CITY_HIGH_@ ; `string'
PUBLIC	?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet
PUBLIC	??_C@_0BJ@FMFMBFAD@AICITYSTRATEGY_IS_PUPPET?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade
PUBLIC	??_C@_0BO@BLCPKGIA@AICITYSTRATEGY_UNDER_BLOCKADE?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding
PUBLIC	??_C@_0CJ@DDNEONLN@AICITYSTRATEGY_FIRST_PRODUCTION_@ ; `string'
PUBLIC	?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding
PUBLIC	??_C@_0CE@LMKDOHOB@AICITYSTRATEGY_FIRST_FAITH_BUILD@ ; `string'
PUBLIC	?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding
PUBLIC	??_C@_0CD@HEMHCPMD@AICITYSTRATEGY_FIRST_GOLD_BUILDI@ ; `string'
PUBLIC	?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding
PUBLIC	??_C@_0CG@MOOPCMID@AICITYSTRATEGY_FIRST_SCIENCE_BUI@ ; `string'
PUBLIC	?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding
PUBLIC	??_C@_0CG@GAEBDJPP@AICITYSTRATEGY_FIRST_CULTURE_BUI@ ; `string'
PUBLIC	?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency
PUBLIC	??_C@_0DA@IEELANCN@AICITYSTRATEGY_FIRST_CULTURE_BUI@ ; `string'
PUBLIC	?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat
PUBLIC	??_C@_0CE@HFBDFGBB@AICITYSTRATEGY_CAPITAL_UNDER_THR@ ; `string'
PUBLIC	?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler
PUBLIC	??_C@_0CE@MJEFENGK@AICITYSTRATEGY_CAPITAL_NEED_SETT@ ; `string'
PUBLIC	?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility
PUBLIC	??_C@_0CG@OLENHIPE@AICITYSTRATEGY_HAVE_TRAINING_FAC@ ; `string'
PUBLIC	??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
PUBLIC	??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@ ; `string'
PUBLIC	?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement
PUBLIC	??_C@_0CN@MCKCAAFC@AICITYSTRATEGY_ENOUGH_NAVAL_TILE@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement
PUBLIC	??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth
PUBLIC	??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@ ; `string'
PUBLIC	?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers
PUBLIC	??_C@_0CF@OMHBDDIL@AICITYSTRATEGY_ENOUGH_TILE_IMPRO@ ; `string'
PUBLIC	?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers
PUBLIC	??_C@_0CD@DNMPEKPE@AICITYSTRATEGY_WANT_TILE_IMPROVE@ ; `string'
PUBLIC	?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers
PUBLIC	??_C@_0CD@CGFLOLNE@AICITYSTRATEGY_NEED_TILE_IMPROVE@ ; `string'
PUBLIC	?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked
PUBLIC	??_C@_0BK@MGLLCJKP@AICITYSTRATEGY_LANDLOCKED?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity
PUBLIC	??_C@_0BK@NMAPLFLB@AICITYSTRATEGY_LARGE_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity
PUBLIC	??_C@_0BL@GDIAFPO@AICITYSTRATEGY_MEDIUM_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity
PUBLIC	??_C@_0BK@KGICECAD@AICITYSTRATEGY_SMALL_CITY?$AA@ ; `string'
PUBLIC	?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity
PUBLIC	??_C@_0BJ@JBOLMCPJ@AICITYSTRATEGY_TINY_CITY?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DoTurn@CvCityStrategyAI@@QAEXXZ		; CvCityStrategyAI::DoTurn
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
;	COMDAT ??_C@_0BI@OBIIEEEC@CityStrategyCanActivate?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BI@OBIIEEEC@CityStrategyCanActivate?$AA@ DB 'CityStrategyCanActiva'
	DB	'te', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FJDKEHMJ@AICITYSTRATEGY_GOOD_AIRLIFT_CITY@
CONST	SEGMENT
??_C@_0CB@FJDKEHMJ@AICITYSTRATEGY_GOOD_AIRLIFT_CITY@ DB 'AICITYSTRATEGY_G'
	DB	'OOD_AIRLIFT_CITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FBKODDGD@AICITYSTRATEGY_NEED_TOURISM_BUIL@
CONST	SEGMENT
??_C@_0CF@FBKODDGD@AICITYSTRATEGY_NEED_TOURISM_BUIL@ DB 'AICITYSTRATEGY_N'
	DB	'EED_TOURISM_BUILDING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LBPACDHK@AICITYSTRATEGY_NEED_CULTURE_BUIL@
CONST	SEGMENT
??_C@_0CF@LBPACDHK@AICITYSTRATEGY_NEED_CULTURE_BUIL@ DB 'AICITYSTRATEGY_N'
	DB	'EED_CULTURE_BUILDING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MKEELCEJ@AICITYSTRATEGY_INTERNATIONAL_TRA@
CONST	SEGMENT
??_C@_0CK@MKEELCEJ@AICITYSTRATEGY_INTERNATIONAL_TRA@ DB 'AICITYSTRATEGY_I'
	DB	'NTERNATIONAL_TRADE_ORIGIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NDHLDCB@AICITYSTRATEGY_INTERNATIONAL_TRA@
CONST	SEGMENT
??_C@_0CP@NDHLDCB@AICITYSTRATEGY_INTERNATIONAL_TRA@ DB 'AICITYSTRATEGY_IN'
	DB	'TERNATIONAL_TRADE_DESTINATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EHEOFEPN@AICITYSTRATEGY_NO_NEED_INTERNATI@
CONST	SEGMENT
??_C@_0DF@EHEOFEPN@AICITYSTRATEGY_NO_NEED_INTERNATI@ DB 'AICITYSTRATEGY_N'
	DB	'O_NEED_INTERNATIONAL_SEA_TRADE_ROUTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LCLJFDJM@AICITYSTRATEGY_NEED_INTERNATIONA@
CONST	SEGMENT
??_C@_0DC@LCLJFDJM@AICITYSTRATEGY_NEED_INTERNATIONA@ DB 'AICITYSTRATEGY_N'
	DB	'EED_INTERNATIONAL_SEA_TRADE_ROUTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EEPLECGP@AICITYSTRATEGY_NO_NEED_INTERNATI@
CONST	SEGMENT
??_C@_0DG@EEPLECGP@AICITYSTRATEGY_NO_NEED_INTERNATI@ DB 'AICITYSTRATEGY_N'
	DB	'O_NEED_INTERNATIONAL_LAND_TRADE_ROUTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HOLLOEKG@AICITYSTRATEGY_NEED_INTERNATIONA@
CONST	SEGMENT
??_C@_0DD@HOLLOEKG@AICITYSTRATEGY_NEED_INTERNATIONA@ DB 'AICITYSTRATEGY_N'
	DB	'EED_INTERNATIONAL_LAND_TRADE_ROUTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FBGEKDFP@AICITYSTRATEGY_GOOD_GP_CITY?$AA@
CONST	SEGMENT
??_C@_0BM@FBGEKDFP@AICITYSTRATEGY_GOOD_GP_CITY?$AA@ DB 'AICITYSTRATEGY_GO'
	DB	'OD_GP_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IJGDBOAB@AICITYSTRATEGY_KEY_SCIENCE_CITY?$AA@
CONST	SEGMENT
??_C@_0CA@IJGDBOAB@AICITYSTRATEGY_KEY_SCIENCE_CITY?$AA@ DB 'AICITYSTRATEG'
	DB	'Y_KEY_SCIENCE_CITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MJBNJJHL@AICITYSTRATEGY_MANY_TECHS_STOLEN@
CONST	SEGMENT
??_C@_0CB@MJBNJJHL@AICITYSTRATEGY_MANY_TECHS_STOLEN@ DB 'AICITYSTRATEGY_M'
	DB	'ANY_TECHS_STOLEN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PNCLKHNL@AICITYSTRATEGY_COAST_CITY?$AA@
CONST	SEGMENT
??_C@_0BK@PNCLKHNL@AICITYSTRATEGY_COAST_CITY?$AA@ DB 'AICITYSTRATEGY_COAS'
	DB	'T_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FDKNAHIG@AICITYSTRATEGY_JUNGLE_CITY?$AA@
CONST	SEGMENT
??_C@_0BL@FDKNAHIG@AICITYSTRATEGY_JUNGLE_CITY?$AA@ DB 'AICITYSTRATEGY_JUN'
	DB	'GLE_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NLLKBHIL@AICITYSTRATEGY_HILL_CITY?$AA@
CONST	SEGMENT
??_C@_0BJ@NLLKBHIL@AICITYSTRATEGY_HILL_CITY?$AA@ DB 'AICITYSTRATEGY_HILL_'
	DB	'CITY', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GNKICLFF@AICITYSTRATEGY_FOREST_CITY?$AA@
CONST	SEGMENT
??_C@_0BL@GNKICLFF@AICITYSTRATEGY_FOREST_CITY?$AA@ DB 'AICITYSTRATEGY_FOR'
	DB	'EST_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PLODLAAO@AICITYSTRATEGY_MOUNTAIN_CITY?$AA@
CONST	SEGMENT
??_C@_0BN@PLODLAAO@AICITYSTRATEGY_MOUNTAIN_CITY?$AA@ DB 'AICITYSTRATEGY_M'
	DB	'OUNTAIN_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IOOIOOLJ@AICITYSTRATEGY_RIVER_CITY?$AA@
CONST	SEGMENT
??_C@_0BK@IOOIOOLJ@AICITYSTRATEGY_RIVER_CITY?$AA@ DB 'AICITYSTRATEGY_RIVE'
	DB	'R_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NNCEJJDF@AICITYSTRATEGY_ORIGINAL_CAPITAL?$AA@
CONST	SEGMENT
??_C@_0CA@NNCEJJDF@AICITYSTRATEGY_ORIGINAL_CAPITAL?$AA@ DB 'AICITYSTRATEG'
	DB	'Y_ORIGINAL_CAPITAL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HHHGPLCE@AICITYSTRATEGY_MEDIUM_CITY_HIGH_@
CONST	SEGMENT
??_C@_0CL@HHHGPLCE@AICITYSTRATEGY_MEDIUM_CITY_HIGH_@ DB 'AICITYSTRATEGY_M'
	DB	'EDIUM_CITY_HIGH_DIFFICULTY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FMFMBFAD@AICITYSTRATEGY_IS_PUPPET?$AA@
CONST	SEGMENT
??_C@_0BJ@FMFMBFAD@AICITYSTRATEGY_IS_PUPPET?$AA@ DB 'AICITYSTRATEGY_IS_PU'
	DB	'PPET', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLCPKGIA@AICITYSTRATEGY_UNDER_BLOCKADE?$AA@
CONST	SEGMENT
??_C@_0BO@BLCPKGIA@AICITYSTRATEGY_UNDER_BLOCKADE?$AA@ DB 'AICITYSTRATEGY_'
	DB	'UNDER_BLOCKADE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DDNEONLN@AICITYSTRATEGY_FIRST_PRODUCTION_@
CONST	SEGMENT
??_C@_0CJ@DDNEONLN@AICITYSTRATEGY_FIRST_PRODUCTION_@ DB 'AICITYSTRATEGY_F'
	DB	'IRST_PRODUCTION_BUILDING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LMKDOHOB@AICITYSTRATEGY_FIRST_FAITH_BUILD@
CONST	SEGMENT
??_C@_0CE@LMKDOHOB@AICITYSTRATEGY_FIRST_FAITH_BUILD@ DB 'AICITYSTRATEGY_F'
	DB	'IRST_FAITH_BUILDING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HEMHCPMD@AICITYSTRATEGY_FIRST_GOLD_BUILDI@
CONST	SEGMENT
??_C@_0CD@HEMHCPMD@AICITYSTRATEGY_FIRST_GOLD_BUILDI@ DB 'AICITYSTRATEGY_F'
	DB	'IRST_GOLD_BUILDING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MOOPCMID@AICITYSTRATEGY_FIRST_SCIENCE_BUI@
CONST	SEGMENT
??_C@_0CG@MOOPCMID@AICITYSTRATEGY_FIRST_SCIENCE_BUI@ DB 'AICITYSTRATEGY_F'
	DB	'IRST_SCIENCE_BUILDING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GAEBDJPP@AICITYSTRATEGY_FIRST_CULTURE_BUI@
CONST	SEGMENT
??_C@_0CG@GAEBDJPP@AICITYSTRATEGY_FIRST_CULTURE_BUI@ DB 'AICITYSTRATEGY_F'
	DB	'IRST_CULTURE_BUILDING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IEELANCN@AICITYSTRATEGY_FIRST_CULTURE_BUI@
CONST	SEGMENT
??_C@_0DA@IEELANCN@AICITYSTRATEGY_FIRST_CULTURE_BUI@ DB 'AICITYSTRATEGY_F'
	DB	'IRST_CULTURE_BUILDING_EMERGENCY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HFBDFGBB@AICITYSTRATEGY_CAPITAL_UNDER_THR@
CONST	SEGMENT
??_C@_0CE@HFBDFGBB@AICITYSTRATEGY_CAPITAL_UNDER_THR@ DB 'AICITYSTRATEGY_C'
	DB	'APITAL_UNDER_THREAT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MJEFENGK@AICITYSTRATEGY_CAPITAL_NEED_SETT@
CONST	SEGMENT
??_C@_0CE@MJEFENGK@AICITYSTRATEGY_CAPITAL_NEED_SETT@ DB 'AICITYSTRATEGY_C'
	DB	'APITAL_NEED_SETTLER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OLENHIPE@AICITYSTRATEGY_HAVE_TRAINING_FAC@
CONST	SEGMENT
??_C@_0CG@OLENHIPE@AICITYSTRATEGY_HAVE_TRAINING_FAC@ DB 'AICITYSTRATEGY_H'
	DB	'AVE_TRAINING_FACILITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@
CONST	SEGMENT
??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@ DB 'AICITYSTRATEGY_N'
	DB	'EED_IMPROVEMENT_PRODUCTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@
CONST	SEGMENT
??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@ DB 'AICITYSTRATEGY_N'
	DB	'EED_IMPROVEMENT_FOOD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MCKCAAFC@AICITYSTRATEGY_ENOUGH_NAVAL_TILE@
CONST	SEGMENT
??_C@_0CN@MCKCAAFC@AICITYSTRATEGY_ENOUGH_NAVAL_TILE@ DB 'AICITYSTRATEGY_E'
	DB	'NOUGH_NAVAL_TILE_IMPROVEMENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@
CONST	SEGMENT
??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@ DB 'AICITYSTRATEGY_N'
	DB	'EED_NAVAL_TILE_IMPROVEMENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@
CONST	SEGMENT
??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@ DB 'AICITYSTRATEGY_N'
	DB	'EED_NAVAL_GROWTH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OMHBDDIL@AICITYSTRATEGY_ENOUGH_TILE_IMPRO@
CONST	SEGMENT
??_C@_0CF@OMHBDDIL@AICITYSTRATEGY_ENOUGH_TILE_IMPRO@ DB 'AICITYSTRATEGY_E'
	DB	'NOUGH_TILE_IMPROVERS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DNMPEKPE@AICITYSTRATEGY_WANT_TILE_IMPROVE@
CONST	SEGMENT
??_C@_0CD@DNMPEKPE@AICITYSTRATEGY_WANT_TILE_IMPROVE@ DB 'AICITYSTRATEGY_W'
	DB	'ANT_TILE_IMPROVERS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CGFLOLNE@AICITYSTRATEGY_NEED_TILE_IMPROVE@
CONST	SEGMENT
??_C@_0CD@CGFLOLNE@AICITYSTRATEGY_NEED_TILE_IMPROVE@ DB 'AICITYSTRATEGY_N'
	DB	'EED_TILE_IMPROVERS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MGLLCJKP@AICITYSTRATEGY_LANDLOCKED?$AA@
CONST	SEGMENT
??_C@_0BK@MGLLCJKP@AICITYSTRATEGY_LANDLOCKED?$AA@ DB 'AICITYSTRATEGY_LAND'
	DB	'LOCKED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NMAPLFLB@AICITYSTRATEGY_LARGE_CITY?$AA@
CONST	SEGMENT
??_C@_0BK@NMAPLFLB@AICITYSTRATEGY_LARGE_CITY?$AA@ DB 'AICITYSTRATEGY_LARG'
	DB	'E_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GDIAFPO@AICITYSTRATEGY_MEDIUM_CITY?$AA@
CONST	SEGMENT
??_C@_0BL@GDIAFPO@AICITYSTRATEGY_MEDIUM_CITY?$AA@ DB 'AICITYSTRATEGY_MEDI'
	DB	'UM_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KGICECAD@AICITYSTRATEGY_SMALL_CITY?$AA@
CONST	SEGMENT
??_C@_0BK@KGICECAD@AICITYSTRATEGY_SMALL_CITY?$AA@ DB 'AICITYSTRATEGY_SMAL'
	DB	'L_CITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JBOLMCPJ@AICITYSTRATEGY_TINY_CITY?$AA@
CONST	SEGMENT
??_C@_0BJ@JBOLMCPJ@AICITYSTRATEGY_TINY_CITY?$AA@ DB 'AICITYSTRATEGY_TINY_'
	DB	'CITY', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoTurn@CvCityStrategyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$1
__ehfuncinfo$?DoTurn@CvCityStrategyAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoTurn@CvCityStrategyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?DoTurn@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
tv893 = -200						; size = 4
tv882 = -196						; size = 4
tv875 = -192						; size = 4
tv862 = -188						; size = 4
tv1129 = -184						; size = 4
_this$ = -180						; size = 4
$T232131 = -176						; size = 4
$T232127 = -172						; size = 4
$T232126 = -168						; size = 4
$T232114 = -164						; size = 4
$T232113 = -160						; size = 4
$T232098 = -156						; size = 4
$T232086 = -152						; size = 4
$T232082 = -148						; size = 4
$T232081 = -144						; size = 4
$T232077 = -140						; size = 4
$T232073 = -136						; size = 4
$T232069 = -132						; size = 4
$T232068 = -128						; size = 4
$T232064 = -124						; size = 4
$T232063 = -120						; size = 4
$T232059 = -116						; size = 4
$T232055 = -112						; size = 4
$T232054 = -108						; size = 4
_iFlavorMaxValue$226180 = -104				; size = 4
_iFlavorMinValue$226179 = -100				; size = 4
_iNumFlavors$226181 = -96				; size = 4
_iFlavorMaxValue$226167 = -92				; size = 4
_iFlavorMinValue$226166 = -88				; size = 4
_iNumFlavors$226168 = -84				; size = 4
_iFlavorLoop$226164 = -80				; size = 4
_bResult$226150 = -73					; size = 1
_args$226149 = -72					; size = 4
_strStrategyName$226013 = -68				; size = 28
__$ArrayPad$ = -40					; size = 4
_pkScriptSystem$226147 = -36				; size = 4
_bAdoptOrEndStrategy$226154 = -30			; size = 1
_bStrategyShouldBeActive$226009 = -29			; size = 1
_eCityStrategy$225989 = -28				; size = 4
_bTestCityStrategyEnd$226000 = -22			; size = 1
_bTestCityStrategyStart$225993 = -21			; size = 1
_pCityStrategy$225991 = -20				; size = 4
_iCityStrategiesLoop$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?DoTurn@CvCityStrategyAI@@QAEXXZ PROC			; CvCityStrategyAI::DoTurn, COMDAT
; _this$ = ecx

; 1221 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoTurn@CvCityStrategyAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1222 : 	AI_PERF_FORMAT("City-AI-perf.csv", ("CvCityStrategyAI::DoTurn, Turn %03d, %s, %s", GC.getGame().getElapsedGameTurns(), m_pCity->GetPlayer()->getCivilizationShortDescription(), m_pCity->getName().c_str()) );
; 1223 : 
; 1224 : 	int iCityStrategiesLoop = 0;

	mov	DWORD PTR _iCityStrategiesLoop$[ebp], 0

; 1225 : 
; 1226 : 	// Loop through all CityStrategies
; 1227 : 	for(iCityStrategiesLoop = 0; iCityStrategiesLoop < GetAICityStrategies()->GetNumAICityStrategies(); iCityStrategiesLoop++)

	mov	DWORD PTR _iCityStrategiesLoop$[ebp], 0
	jmp	SHORT $LN134@DoTurn
$LN133@DoTurn:
	mov	eax, DWORD PTR _iCityStrategiesLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCityStrategiesLoop$[ebp], eax
$LN134@DoTurn:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ; CvAICityStrategies::GetNumAICityStrategies
	cmp	DWORD PTR _iCityStrategiesLoop$[ebp], eax
	jge	$LN135@DoTurn

; 1228 : 	{
; 1229 : 		AICityStrategyTypes eCityStrategy = (AICityStrategyTypes) iCityStrategiesLoop;

	mov	ecx, DWORD PTR _iCityStrategiesLoop$[ebp]
	mov	DWORD PTR _eCityStrategy$225989[ebp], ecx

; 1230 : 		CvAICityStrategyEntry* pCityStrategy = GetAICityStrategies()->GetEntry(iCityStrategiesLoop);

	mov	edx, DWORD PTR _iCityStrategiesLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	DWORD PTR _pCityStrategy$225991[ebp], eax

; 1231 : 
; 1232 : 		// Minor Civs can't run some Strategies
; 1233 : 		if(GET_PLAYER(GetCity()->getOwner()).isMinorCiv() && pCityStrategy->IsNoMinorCivs())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	DWORD PTR $T232054[ebp], eax
	mov	eax, DWORD PTR $T232054[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T232055[ebp], ecx
	mov	edx, DWORD PTR $T232055[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232059[ebp], edx
	mov	ecx, DWORD PTR $T232059[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN131@DoTurn
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ ; CvAICityStrategyEntry::IsNoMinorCivs
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN131@DoTurn

; 1234 : 		{
; 1235 : 			continue;

	jmp	$LN133@DoTurn
$LN131@DoTurn:

; 1236 : 		}
; 1237 : 
; 1238 : 		bool bTestCityStrategyStart = true;

	mov	BYTE PTR _bTestCityStrategyStart$225993[ebp], 1

; 1239 : 
; 1240 : 		// Do we already have this CityStrategy adopted?
; 1241 : 		if(IsUsingCityStrategy(eCityStrategy))

	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN130@DoTurn

; 1242 : 		{
; 1243 : 			bTestCityStrategyStart = false;

	mov	BYTE PTR _bTestCityStrategyStart$225993[ebp], 0

; 1244 : 		}
; 1245 : 		else

	jmp	$LN129@DoTurn
$LN130@DoTurn:

; 1246 : 		{
; 1247 : 			// Has the prereq Tech necessary?
; 1248 : 			if(pCityStrategy->GetTechPrereq() != NO_TECH && !GET_TEAM(GetCity()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pCityStrategy->GetTechPrereq()))

	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetTechPrereq
	cmp	eax, -1
	je	SHORT $LN128@DoTurn
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR $T232063[ebp], eax
	mov	ecx, DWORD PTR $T232063[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232064[ebp], ecx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetTechPrereq
	push	eax
	mov	ecx, DWORD PTR $T232064[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN128@DoTurn

; 1249 : 			{
; 1250 : 				bTestCityStrategyStart = false;

	mov	BYTE PTR _bTestCityStrategyStart$225993[ebp], 0
$LN128@DoTurn:

; 1251 : 			}
; 1252 : 
; 1253 : 			// Has the Tech which obsoletes this Strategy?
; 1254 : 			if(bTestCityStrategyStart && pCityStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetCity()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pCityStrategy->GetTechObsolete()))

	movzx	eax, BYTE PTR _bTestCityStrategyStart$225993[ebp]
	test	eax, eax
	je	SHORT $LN129@DoTurn
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetTechObsolete
	cmp	eax, -1
	je	SHORT $LN129@DoTurn
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR $T232068[ebp], eax
	mov	ecx, DWORD PTR $T232068[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232069[ebp], ecx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T232069[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN129@DoTurn

; 1255 : 			{
; 1256 : 				bTestCityStrategyStart = false;

	mov	BYTE PTR _bTestCityStrategyStart$225993[ebp], 0
$LN129@DoTurn:

; 1257 : 			}
; 1258 : 		}
; 1259 : 
; 1260 : 		bool bTestCityStrategyEnd = false;

	mov	BYTE PTR _bTestCityStrategyEnd$226000[ebp], 0

; 1261 : 
; 1262 : 		// CityStrategy is active, check to see if we should even try to disable it
; 1263 : 		if(IsUsingCityStrategy(eCityStrategy))

	mov	eax, DWORD PTR _eCityStrategy$225989[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN126@DoTurn

; 1264 : 		{
; 1265 : 			// If Strategy is Permanent we can't ever turn it off
; 1266 : 			if(!pCityStrategy->IsPermanent())

	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ ; CvAICityStrategyEntry::IsPermanent
	movzx	edx, al
	test	edx, edx
	jne	$LN126@DoTurn

; 1267 : 			{
; 1268 : 				if(pCityStrategy->GetCheckTriggerTurnCount() > 0)

	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetCheckTriggerTurnCount
	test	eax, eax
	jle	SHORT $LN124@DoTurn

; 1269 : 				{
; 1270 : 					// Is it a turn where we want to check to see if this Strategy is maintained?
; 1271 : 					if((GC.getGame().getGameTurn() - GetTurnCityStrategyAdopted(eCityStrategy)) % pCityStrategy->GetCheckTriggerTurnCount() == 0)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232073[ebp], eax
	mov	ecx, DWORD PTR $T232073[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _eCityStrategy$225989[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::GetTurnCityStrategyAdopted
	sub	esi, eax
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetCheckTriggerTurnCount
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN124@DoTurn

; 1272 : 					{
; 1273 : 						bTestCityStrategyEnd = true;

	mov	BYTE PTR _bTestCityStrategyEnd$226000[ebp], 1
$LN124@DoTurn:

; 1274 : 					}
; 1275 : 				}
; 1276 : 
; 1277 : 				if(bTestCityStrategyEnd && pCityStrategy->GetMinimumNumTurnsExecuted() > 0)

	movzx	edx, BYTE PTR _bTestCityStrategyEnd$226000[ebp]
	test	edx, edx
	je	SHORT $LN126@DoTurn
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted
	test	eax, eax
	jle	SHORT $LN126@DoTurn

; 1278 : 				{
; 1279 : 					// Has the minimum # of turns passed for this Strategy?
; 1280 : 					if(GC.getGame().getGameTurn() < GetTurnCityStrategyAdopted(eCityStrategy) + pCityStrategy->GetMinimumNumTurnsExecuted())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232077[ebp], eax
	mov	ecx, DWORD PTR $T232077[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _eCityStrategy$225989[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::GetTurnCityStrategyAdopted
	mov	edi, eax
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted
	add	edi, eax
	cmp	esi, edi
	jge	SHORT $LN126@DoTurn

; 1281 : 					{
; 1282 : 						bTestCityStrategyEnd = false;

	mov	BYTE PTR _bTestCityStrategyEnd$226000[ebp], 0
$LN126@DoTurn:

; 1283 : 					}
; 1284 : 				}
; 1285 : 			}
; 1286 : 		}
; 1287 : 
; 1288 : 		// Check CityStrategy Triggers
; 1289 : 		// Functionality and existence of specific CityStrategies is hardcoded here, but data is stored in XML so it's easier to modify
; 1290 : 
; 1291 : 		if(bTestCityStrategyStart || bTestCityStrategyEnd)

	movzx	edx, BYTE PTR _bTestCityStrategyStart$225993[ebp]
	test	edx, edx
	jne	SHORT $LN119@DoTurn
	movzx	eax, BYTE PTR _bTestCityStrategyEnd$226000[ebp]
	test	eax, eax
	je	$LN120@DoTurn
$LN119@DoTurn:

; 1292 : 		{
; 1293 : 			bool bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], 0

; 1294 : 
; 1295 : 			// Has the Tech which obsoletes this Strategy? If so, Strategy should be deactivated regardless of other factors
; 1296 : 			if(pCityStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetCity()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pCityStrategy->GetTechObsolete()))

	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetTechObsolete
	cmp	eax, -1
	je	SHORT $LN118@DoTurn
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR $T232081[ebp], eax
	mov	ecx, DWORD PTR $T232081[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232082[ebp], ecx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T232082[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN118@DoTurn

; 1297 : 			{
; 1298 : 				bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], 0

; 1299 : 			}
; 1300 : 			// Strategy isn't obsolete, so test triggers as normal
; 1301 : 			else

	jmp	$LN117@DoTurn
$LN118@DoTurn:

; 1302 : 			{
; 1303 : 				CvString strStrategyName = (CvString) pCityStrategy->GetType();

	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232086[ebp], eax
	cmp	DWORD PTR $T232086[ebp], 0
	je	SHORT $LN159@DoTurn
	mov	eax, DWORD PTR $T232086[ebp]
	mov	DWORD PTR tv1129[ebp], eax
	jmp	SHORT $LN160@DoTurn
$LN159@DoTurn:
	mov	DWORD PTR tv1129[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN160@DoTurn:
	mov	ecx, DWORD PTR tv1129[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1304 : 
; 1305 : 				// Check all of the CityStrategy Triggers
; 1306 : 				if(strStrategyName == "AICITYSTRATEGY_TINY_CITY")

	push	OFFSET ??_C@_0BJ@JBOLMCPJ@AICITYSTRATEGY_TINY_CITY?$AA@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN116@DoTurn

; 1307 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_TinyCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN116@DoTurn:

; 1308 : 				else if(strStrategyName == "AICITYSTRATEGY_SMALL_CITY")

	push	OFFSET ??_C@_0BK@KGICECAD@AICITYSTRATEGY_SMALL_CITY?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN114@DoTurn

; 1309 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_SmallCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN114@DoTurn:

; 1310 : 				else if(strStrategyName == "AICITYSTRATEGY_MEDIUM_CITY")

	push	OFFSET ??_C@_0BL@GDIAFPO@AICITYSTRATEGY_MEDIUM_CITY?$AA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN112@DoTurn

; 1311 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_MediumCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN112@DoTurn:

; 1312 : 				else if(strStrategyName == "AICITYSTRATEGY_LARGE_CITY")

	push	OFFSET ??_C@_0BK@NMAPLFLB@AICITYSTRATEGY_LARGE_CITY?$AA@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN110@DoTurn

; 1313 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_LargeCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN110@DoTurn:

; 1314 : 				else if(strStrategyName == "AICITYSTRATEGY_LANDLOCKED")

	push	OFFSET ??_C@_0BK@MGLLCJKP@AICITYSTRATEGY_LANDLOCKED?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN108@DoTurn

; 1315 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_Landlocked(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN108@DoTurn:

; 1316 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_TILE_IMPROVERS")

	push	OFFSET ??_C@_0CD@CGFLOLNE@AICITYSTRATEGY_NEED_TILE_IMPROVE@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN106@DoTurn

; 1317 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers(eCityStrategy, GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	call	?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN106@DoTurn:

; 1318 : 				else if(strStrategyName == "AICITYSTRATEGY_WANT_TILE_IMPROVERS")

	push	OFFSET ??_C@_0CD@DNMPEKPE@AICITYSTRATEGY_WANT_TILE_IMPROVE@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN104@DoTurn

; 1319 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers(eCityStrategy, GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	call	?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN104@DoTurn:

; 1320 : 				else if(strStrategyName == "AICITYSTRATEGY_ENOUGH_TILE_IMPROVERS")

	push	OFFSET ??_C@_0CF@OMHBDDIL@AICITYSTRATEGY_ENOUGH_TILE_IMPRO@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN102@DoTurn

; 1321 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers(eCityStrategy, GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	call	?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN102@DoTurn:

; 1322 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_NAVAL_GROWTH")

	push	OFFSET ??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN100@DoTurn

; 1323 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth(eCityStrategy, GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	call	?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN100@DoTurn:

; 1324 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT")

	push	OFFSET ??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN98@DoTurn

; 1325 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN98@DoTurn:

; 1326 : 				else if(strStrategyName == "AICITYSTRATEGY_ENOUGH_NAVAL_TILE_IMPROVEMENT")

	push	OFFSET ??_C@_0CN@MCKCAAFC@AICITYSTRATEGY_ENOUGH_NAVAL_TILE@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN96@DoTurn

; 1327 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN96@DoTurn:

; 1328 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_IMPROVEMENT_FOOD")

	push	OFFSET ??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN94@DoTurn

; 1329 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement(GetCity(), YIELD_FOOD);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN94@DoTurn:

; 1330 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_IMPROVEMENT_PRODUCTION")

	push	OFFSET ??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN92@DoTurn

; 1331 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement(GetCity(), YIELD_PRODUCTION);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN92@DoTurn:

; 1332 : 				else if(strStrategyName == "AICITYSTRATEGY_HAVE_TRAINING_FACILITY")

	push	OFFSET ??_C@_0CG@OLENHIPE@AICITYSTRATEGY_HAVE_TRAINING_FAC@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN90@DoTurn

; 1333 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN90@DoTurn:

; 1334 : 				else if(strStrategyName == "AICITYSTRATEGY_CAPITAL_NEED_SETTLER")

	push	OFFSET ??_C@_0CE@MJEFENGK@AICITYSTRATEGY_CAPITAL_NEED_SETT@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN88@DoTurn

; 1335 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler(eCityStrategy, GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	mov	eax, DWORD PTR _eCityStrategy$225989[ebp]
	push	eax
	call	?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN88@DoTurn:

; 1336 : 				else if(strStrategyName == "AICITYSTRATEGY_CAPITAL_UNDER_THREAT")

	push	OFFSET ??_C@_0CE@HFBDFGBB@AICITYSTRATEGY_CAPITAL_UNDER_THR@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN86@DoTurn

; 1337 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN86@DoTurn:

; 1338 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_CULTURE_BUILDING_EMERGENCY")

	push	OFFSET ??_C@_0DA@IEELANCN@AICITYSTRATEGY_FIRST_CULTURE_BUI@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN84@DoTurn

; 1339 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN84@DoTurn:

; 1340 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_CULTURE_BUILDING")

	push	OFFSET ??_C@_0CG@GAEBDJPP@AICITYSTRATEGY_FIRST_CULTURE_BUI@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN82@DoTurn

; 1341 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN82@DoTurn:

; 1342 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_SCIENCE_BUILDING")

	push	OFFSET ??_C@_0CG@MOOPCMID@AICITYSTRATEGY_FIRST_SCIENCE_BUI@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN80@DoTurn

; 1343 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN80@DoTurn:

; 1344 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_GOLD_BUILDING")

	push	OFFSET ??_C@_0CD@HEMHCPMD@AICITYSTRATEGY_FIRST_GOLD_BUILDI@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN78@DoTurn

; 1345 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN78@DoTurn:

; 1346 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_FAITH_BUILDING")

	push	OFFSET ??_C@_0CE@LMKDOHOB@AICITYSTRATEGY_FIRST_FAITH_BUILD@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN76@DoTurn

; 1347 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN76@DoTurn:

; 1348 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_PRODUCTION_BUILDING")

	push	OFFSET ??_C@_0CJ@DDNEONLN@AICITYSTRATEGY_FIRST_PRODUCTION_@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN74@DoTurn

; 1349 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN74@DoTurn:

; 1350 : 				else if(strStrategyName == "AICITYSTRATEGY_UNDER_BLOCKADE")

	push	OFFSET ??_C@_0BO@BLCPKGIA@AICITYSTRATEGY_UNDER_BLOCKADE?$AA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@DoTurn

; 1351 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN72@DoTurn:

; 1352 : 				else if(strStrategyName == "AICITYSTRATEGY_IS_PUPPET")

	push	OFFSET ??_C@_0BJ@FMFMBFAD@AICITYSTRATEGY_IS_PUPPET?$AA@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN70@DoTurn

; 1353 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN70@DoTurn:

; 1354 : 				else if(strStrategyName == "AICITYSTRATEGY_MEDIUM_CITY_HIGH_DIFFICULTY")

	push	OFFSET ??_C@_0CL@HHHGPLCE@AICITYSTRATEGY_MEDIUM_CITY_HIGH_@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN68@DoTurn

; 1355 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN68@DoTurn:

; 1356 : 				else if(strStrategyName == "AICITYSTRATEGY_ORIGINAL_CAPITAL")

	push	OFFSET ??_C@_0CA@NNCEJJDF@AICITYSTRATEGY_ORIGINAL_CAPITAL?$AA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN66@DoTurn

; 1357 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN66@DoTurn:

; 1358 : 
; 1359 : 				else if(strStrategyName == "AICITYSTRATEGY_RIVER_CITY")

	push	OFFSET ??_C@_0BK@IOOIOOLJ@AICITYSTRATEGY_RIVER_CITY?$AA@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN64@DoTurn

; 1360 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_RiverCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN64@DoTurn:

; 1361 : 				else if(strStrategyName == "AICITYSTRATEGY_MOUNTAIN_CITY")

	push	OFFSET ??_C@_0BN@PLODLAAO@AICITYSTRATEGY_MOUNTAIN_CITY?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN62@DoTurn

; 1362 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_MountainCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN62@DoTurn:

; 1363 : 				else if(strStrategyName == "AICITYSTRATEGY_FOREST_CITY")

	push	OFFSET ??_C@_0BL@GNKICLFF@AICITYSTRATEGY_FOREST_CITY?$AA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN60@DoTurn

; 1364 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_ForestCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN60@DoTurn:

; 1365 : 				else if(strStrategyName == "AICITYSTRATEGY_HILL_CITY")

	push	OFFSET ??_C@_0BJ@NLLKBHIL@AICITYSTRATEGY_HILL_CITY?$AA@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@DoTurn

; 1366 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_HillCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN58@DoTurn:

; 1367 : 				else if(strStrategyName == "AICITYSTRATEGY_JUNGLE_CITY")

	push	OFFSET ??_C@_0BL@FDKNAHIG@AICITYSTRATEGY_JUNGLE_CITY?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN56@DoTurn

; 1368 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_JungleCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN56@DoTurn:

; 1369 : 				else if(strStrategyName == "AICITYSTRATEGY_COAST_CITY")

	push	OFFSET ??_C@_0BK@PNCLKHNL@AICITYSTRATEGY_COAST_CITY?$AA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN54@DoTurn

; 1370 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_CoastCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN54@DoTurn:

; 1371 : 				else if(strStrategyName == "AICITYSTRATEGY_MANY_TECHS_STOLEN")

	push	OFFSET ??_C@_0CB@MJBNJJHL@AICITYSTRATEGY_MANY_TECHS_STOLEN@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN52@DoTurn

; 1372 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN52@DoTurn:

; 1373 : 				else if(strStrategyName == "AICITYSTRATEGY_KEY_SCIENCE_CITY")

	push	OFFSET ??_C@_0CA@IJGDBOAB@AICITYSTRATEGY_KEY_SCIENCE_CITY?$AA@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN50@DoTurn

; 1374 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN50@DoTurn:

; 1375 : 				else if(strStrategyName == "AICITYSTRATEGY_GOOD_GP_CITY")

	push	OFFSET ??_C@_0BM@FBGEKDFP@AICITYSTRATEGY_GOOD_GP_CITY?$AA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@DoTurn

; 1376 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN48@DoTurn:

; 1377 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_INTERNATIONAL_LAND_TRADE_ROUTE")

	push	OFFSET ??_C@_0DD@HOLLOEKG@AICITYSTRATEGY_NEED_INTERNATIONA@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@DoTurn

; 1378 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute(GetCity(), DOMAIN_LAND);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN46@DoTurn:

; 1379 : 				else if(strStrategyName == "AICITYSTRATEGY_NO_NEED_INTERNATIONAL_LAND_TRADE_ROUTE")

	push	OFFSET ??_C@_0DG@EEPLECGP@AICITYSTRATEGY_NO_NEED_INTERNATI@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN44@DoTurn

; 1380 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute(GetCity(), DOMAIN_LAND);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN44@DoTurn:

; 1381 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_INTERNATIONAL_SEA_TRADE_ROUTE")

	push	OFFSET ??_C@_0DC@LCLJFDJM@AICITYSTRATEGY_NEED_INTERNATIONA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN42@DoTurn

; 1382 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute(GetCity(), DOMAIN_SEA);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN42@DoTurn:

; 1383 : 				else if(strStrategyName == "AICITYSTRATEGY_NO_NEED_INTERNATIONAL_SEA_TRADE_ROUTE")

	push	OFFSET ??_C@_0DF@EHEOFEPN@AICITYSTRATEGY_NO_NEED_INTERNATI@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@DoTurn

; 1384 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute(GetCity(), DOMAIN_SEA);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN40@DoTurn:

; 1385 : 				else if(strStrategyName == "AICITYSTRATEGY_INTERNATIONAL_TRADE_DESTINATION")

	push	OFFSET ??_C@_0CP@NDHLDCB@AICITYSTRATEGY_INTERNATIONAL_TRA@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN38@DoTurn

; 1386 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN38@DoTurn:

; 1387 : 				else if(strStrategyName == "AICITYSTRATEGY_INTERNATIONAL_TRADE_ORIGIN")

	push	OFFSET ??_C@_0CK@MKEELCEJ@AICITYSTRATEGY_INTERNATIONAL_TRA@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN36@DoTurn

; 1388 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	$LN115@DoTurn
$LN36@DoTurn:

; 1389 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_CULTURE_BUILDING")

	push	OFFSET ??_C@_0CF@LBPACDHK@AICITYSTRATEGY_NEED_CULTURE_BUIL@
	lea	edx, DWORD PTR _strStrategyName$226013[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN34@DoTurn

; 1390 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	SHORT $LN115@DoTurn
$LN34@DoTurn:

; 1391 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_TOURISM_BUILDING")

	push	OFFSET ??_C@_0CF@FBKODDGD@AICITYSTRATEGY_NEED_TOURISM_BUIL@
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN32@DoTurn

; 1392 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
	jmp	SHORT $LN115@DoTurn
$LN32@DoTurn:

; 1393 : 				else if(strStrategyName == "AICITYSTRATEGY_GOOD_AIRLIFT_CITY")

	push	OFFSET ??_C@_0CB@FJDKEHMJ@AICITYSTRATEGY_GOOD_AIRLIFT_CITY@
	lea	eax, DWORD PTR _strStrategyName$226013[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN115@DoTurn

; 1394 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity(GetCity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	push	eax
	call	?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], al
$LN115@DoTurn:

; 1395 : 
; 1396 : 				// Check Lua hook
; 1397 : 				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T232098[ebp]
	mov	DWORD PTR tv862[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv862[ebp], eax
	mov	ecx, DWORD PTR tv862[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv862[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226147[ebp], eax

; 1398 : 				if(pkScriptSystem && bStrategyShouldBeActive)

	cmp	DWORD PTR _pkScriptSystem$226147[ebp], 0
	je	$LN29@DoTurn
	movzx	ecx, BYTE PTR _bStrategyShouldBeActive$226009[ebp]
	test	ecx, ecx
	je	$LN29@DoTurn

; 1399 : 				{
; 1400 : 					CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226149[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1401 : 					args->Push(iCityStrategiesLoop);

	mov	edx, DWORD PTR _args$226149[ebp]
	mov	DWORD PTR tv875[ebp], edx
	mov	eax, DWORD PTR _iCityStrategiesLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv875[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv875[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1402 : 					args->Push(GetCity()->getOwner());

	mov	ecx, DWORD PTR _args$226149[ebp]
	mov	DWORD PTR tv882[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	DWORD PTR $T232113[ebp], eax
	mov	edx, DWORD PTR $T232113[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T232114[ebp], eax
	mov	ecx, DWORD PTR $T232114[ebp]
	push	ecx
	mov	edx, DWORD PTR tv882[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv882[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1403 : 					args->Push(GetCity()->GetID());

	mov	eax, DWORD PTR _args$226149[ebp]
	mov	DWORD PTR tv893[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ; CvCityStrategyAI::GetCity
	mov	DWORD PTR $T232126[ebp], eax
	mov	ecx, DWORD PTR $T232126[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR $T232127[ebp], edx
	mov	eax, DWORD PTR $T232127[ebp]
	push	eax
	mov	ecx, DWORD PTR tv893[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv893[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1404 : 
; 1405 : 					// Attempt to execute the game events.
; 1406 : 					// Will return false if there are no registered listeners.
; 1407 : 					bool bResult = false;

	mov	BYTE PTR _bResult$226150[ebp], 0

; 1408 : 					if(LuaSupport::CallTestAll(pkScriptSystem, "CityStrategyCanActivate", args.get(), bResult))

	mov	ecx, DWORD PTR _args$226149[ebp]
	mov	DWORD PTR $T232131[ebp], ecx
	lea	edx, DWORD PTR _bResult$226150[ebp]
	push	edx
	mov	eax, DWORD PTR $T232131[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@OBIIEEEC@CityStrategyCanActivate?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$226147[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@DoTurn

; 1409 : 					{
; 1410 : 						// Check the result.
; 1411 : 						if(bResult == false)

	movzx	eax, BYTE PTR _bResult$226150[ebp]
	test	eax, eax
	jne	SHORT $LN28@DoTurn

; 1412 : 						{
; 1413 : 							bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$226009[ebp], 0
$LN28@DoTurn:

; 1414 : 						}
; 1415 : 					}
; 1416 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$226149[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN29@DoTurn:

; 1417 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN117@DoTurn:

; 1418 : 
; 1419 : 			// This variable keeps track of whether or not we should be doing something (i.e. Strategy is active now but should be turned off, OR Strategy is inactive and should be enabled)
; 1420 : 			bool bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$226154[ebp], 0

; 1421 : 
; 1422 : 			// Strategy should be on, and if it's not, turn it on
; 1423 : 			if(bStrategyShouldBeActive)

	movzx	ecx, BYTE PTR _bStrategyShouldBeActive$226009[ebp]
	test	ecx, ecx
	je	SHORT $LN26@DoTurn

; 1424 : 			{
; 1425 : 				if(bTestCityStrategyStart)

	movzx	edx, BYTE PTR _bTestCityStrategyStart$225993[ebp]
	test	edx, edx
	je	SHORT $LN25@DoTurn

; 1426 : 				{
; 1427 : 					bAdoptOrEndStrategy = true;

	mov	BYTE PTR _bAdoptOrEndStrategy$226154[ebp], 1
	jmp	SHORT $LN24@DoTurn
$LN25@DoTurn:

; 1428 : 				}
; 1429 : 				else if(bTestCityStrategyEnd)

	movzx	eax, BYTE PTR _bTestCityStrategyEnd$226000[ebp]
	test	eax, eax
	je	SHORT $LN24@DoTurn

; 1430 : 				{
; 1431 : 					bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$226154[ebp], 0
$LN24@DoTurn:

; 1432 : 				}
; 1433 : 			}
; 1434 : 			// Strategy should be off, and if it's not, turn it off
; 1435 : 			else

	jmp	SHORT $LN22@DoTurn
$LN26@DoTurn:

; 1436 : 			{
; 1437 : 				if(bTestCityStrategyStart)

	movzx	ecx, BYTE PTR _bTestCityStrategyStart$225993[ebp]
	test	ecx, ecx
	je	SHORT $LN21@DoTurn

; 1438 : 				{
; 1439 : 					bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$226154[ebp], 0
	jmp	SHORT $LN22@DoTurn
$LN21@DoTurn:

; 1440 : 				}
; 1441 : 				else if(bTestCityStrategyEnd)

	movzx	edx, BYTE PTR _bTestCityStrategyEnd$226000[ebp]
	test	edx, edx
	je	SHORT $LN22@DoTurn

; 1442 : 				{
; 1443 : 					bAdoptOrEndStrategy = true;

	mov	BYTE PTR _bAdoptOrEndStrategy$226154[ebp], 1
$LN22@DoTurn:

; 1444 : 				}
; 1445 : 			}
; 1446 : 
; 1447 : 			// Flavor propagation
; 1448 : 			if(bAdoptOrEndStrategy)

	movzx	eax, BYTE PTR _bAdoptOrEndStrategy$226154[ebp]
	test	eax, eax
	je	$LN120@DoTurn

; 1449 : 			{
; 1450 : 				int iFlavorLoop;
; 1451 : 
; 1452 : 				// We should adopt this CityStrategy
; 1453 : 				if(bTestCityStrategyStart)

	movzx	ecx, BYTE PTR _bTestCityStrategyStart$225993[ebp]
	test	ecx, ecx
	je	$LN17@DoTurn

; 1454 : 				{
; 1455 : 					SetUsingCityStrategy(eCityStrategy, true);

	push	1
	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::SetUsingCityStrategy

; 1456 : 
; 1457 : 					const int iFlavorMinValue = /*-1000*/ GC.getFLAVOR_MIN_VALUE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1876
	mov	DWORD PTR _iFlavorMinValue$226166[ebp], eax

; 1458 : 					const int iFlavorMaxValue = /*1000*/ GC.getFLAVOR_MAX_VALUE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1880
	mov	DWORD PTR _iFlavorMaxValue$226167[ebp], ecx

; 1459 : 
; 1460 : 					const int iNumFlavors = GC.getNumFlavorTypes();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR _iNumFlavors$226168[ebp], edx

; 1461 : 					for(iFlavorLoop = 0; iFlavorLoop < iNumFlavors; iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226164[ebp], 0
	jmp	SHORT $LN16@DoTurn
$LN15@DoTurn:
	mov	eax, DWORD PTR _iFlavorLoop$226164[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$226164[ebp], eax
$LN16@DoTurn:
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	cmp	ecx, DWORD PTR _iNumFlavors$226168[ebp]
	jge	$LN14@DoTurn

; 1462 : 					{
; 1463 : 						if(pCityStrategy->GetFlavorValue(iFlavorLoop) != 0)

	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetFlavorValue
	test	eax, eax
	je	$LN13@DoTurn

; 1464 : 						{
; 1465 : 							m_piLatestFlavorValues[iFlavorLoop] += pCityStrategy->GetFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetFlavorValue
	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	add	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1466 : 
; 1467 : 							if(m_piLatestFlavorValues[iFlavorLoop] < iFlavorMinValue)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _iFlavorMinValue$226166[ebp]
	jge	SHORT $LN12@DoTurn

; 1468 : 							{
; 1469 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMinValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	eax, DWORD PTR _iFlavorMinValue$226166[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	jmp	SHORT $LN11@DoTurn
$LN12@DoTurn:

; 1470 : 							}
; 1471 : 							else if(m_piLatestFlavorValues[iFlavorLoop] > iFlavorMaxValue)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	ecx, DWORD PTR _iFlavorMaxValue$226167[ebp]
	jle	SHORT $LN11@DoTurn

; 1472 : 							{
; 1473 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMaxValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	edx, DWORD PTR _iFlavorMaxValue$226167[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$LN11@DoTurn:

; 1474 : 							}
; 1475 : 
; 1476 : 							LogFlavors((FlavorTypes) iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$226164[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN13@DoTurn:

; 1477 : 						}
; 1478 : 					}

	jmp	$LN15@DoTurn
$LN14@DoTurn:

; 1479 : 
; 1480 : 					FlavorUpdate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	jmp	$LN120@DoTurn
$LN17@DoTurn:

; 1481 : 				}
; 1482 : 				// End the CityStrategy
; 1483 : 				else if(bTestCityStrategyEnd)

	movzx	ecx, BYTE PTR _bTestCityStrategyEnd$226000[ebp]
	test	ecx, ecx
	je	$LN120@DoTurn

; 1484 : 				{
; 1485 : 					SetUsingCityStrategy(eCityStrategy, false);

	push	0
	mov	edx, DWORD PTR _eCityStrategy$225989[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::SetUsingCityStrategy

; 1486 : 
; 1487 : 					const int iFlavorMinValue = /*-1000*/ GC.getFLAVOR_MIN_VALUE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1876
	mov	DWORD PTR _iFlavorMinValue$226179[ebp], eax

; 1488 : 					const int iFlavorMaxValue = /*1000*/ GC.getFLAVOR_MAX_VALUE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1880
	mov	DWORD PTR _iFlavorMaxValue$226180[ebp], ecx

; 1489 : 
; 1490 : 					const int iNumFlavors = GC.getNumFlavorTypes();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR _iNumFlavors$226181[ebp], edx

; 1491 : 					for(iFlavorLoop = 0; iFlavorLoop < iNumFlavors; iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226164[ebp], 0
	jmp	SHORT $LN7@DoTurn
$LN6@DoTurn:
	mov	eax, DWORD PTR _iFlavorLoop$226164[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$226164[ebp], eax
$LN7@DoTurn:
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	cmp	ecx, DWORD PTR _iNumFlavors$226181[ebp]
	jge	$LN5@DoTurn

; 1492 : 					{
; 1493 : 						if(pCityStrategy->GetFlavorValue(iFlavorLoop) != 0)

	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetFlavorValue
	test	eax, eax
	je	$LN4@DoTurn

; 1494 : 						{
; 1495 : 							m_piLatestFlavorValues[iFlavorLoop] -= pCityStrategy->GetFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityStrategy$225991[ebp]
	call	?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetFlavorValue
	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	ecx, DWORD PTR [esi+edx*4]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1496 : 
; 1497 : 							if(m_piLatestFlavorValues[iFlavorLoop] < iFlavorMinValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _iFlavorMinValue$226179[ebp]
	jge	SHORT $LN3@DoTurn

; 1498 : 							{
; 1499 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMinValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	ecx, DWORD PTR _iFlavorMinValue$226179[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@DoTurn
$LN3@DoTurn:

; 1500 : 							}
; 1501 : 							else if(m_piLatestFlavorValues[iFlavorLoop] > iFlavorMaxValue)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _iFlavorMaxValue$226180[ebp]
	jle	SHORT $LN2@DoTurn

; 1502 : 							{
; 1503 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMaxValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iFlavorLoop$226164[ebp]
	mov	eax, DWORD PTR _iFlavorMaxValue$226180[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN2@DoTurn:

; 1504 : 							}
; 1505 : 
; 1506 : 							LogFlavors((FlavorTypes) iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$226164[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
$LN4@DoTurn:

; 1507 : 						}
; 1508 : 					}

	jmp	$LN6@DoTurn
$LN5@DoTurn:

; 1509 : 
; 1510 : 					FlavorUpdate();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN120@DoTurn:

; 1511 : 				}
; 1512 : 			}
; 1513 : 		}

	jmp	$LN133@DoTurn
$LN135@DoTurn:

; 1514 : 	}
; 1515 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strStrategyName$226013[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _args$226149[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoTurn@CvCityStrategyAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvCityStrategyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvCityStrategyAI@@QAEXXZ ENDP			; CvCityStrategyAI::DoTurn
PUBLIC	?ResetBestYields@CvCityStrategyAI@@QAEXXZ	; CvCityStrategyAI::ResetBestYields
; Function compile flags: /Odtp
;	COMDAT ?ResetBestYields@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiPlots$226197 = -8					; size = 4
_uiYields$226193 = -4					; size = 4
?ResetBestYields@CvCityStrategyAI@@QAEXXZ PROC		; CvCityStrategyAI::ResetBestYields, COMDAT
; _this$ = ecx

; 1518 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1519 : 	for(uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	mov	DWORD PTR _uiYields$226193[ebp], 0
	jmp	SHORT $LN6@ResetBestY
$LN5@ResetBestY:
	mov	eax, DWORD PTR _uiYields$226193[ebp]
	add	eax, 1
	mov	DWORD PTR _uiYields$226193[ebp], eax
$LN6@ResetBestY:
	cmp	DWORD PTR _uiYields$226193[ebp], 6
	jae	SHORT $LN7@ResetBestY

; 1520 : 	{
; 1521 : 		for(uint uiPlots = 0; uiPlots < NUM_CITY_PLOTS - 1; uiPlots++)

	mov	DWORD PTR _uiPlots$226197[ebp], 0
	jmp	SHORT $LN3@ResetBestY
$LN2@ResetBestY:
	mov	ecx, DWORD PTR _uiPlots$226197[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiPlots$226197[ebp], ecx
$LN3@ResetBestY:
	cmp	DWORD PTR _uiPlots$226197[ebp], 36	; 00000024H
	jae	SHORT $LN1@ResetBestY

; 1522 : 		{
; 1523 : 			m_acBestYields[uiYields][uiPlots] = MAX_UNSIGNED_CHAR;

	mov	edx, DWORD PTR _uiYields$226193[ebp]
	imul	edx, 37					; 00000025H
	mov	eax, DWORD PTR _uiPlots$226197[ebp]
	mov	BYTE PTR ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA[edx+eax], 255 ; 000000ffH

; 1524 : 		}

	jmp	SHORT $LN2@ResetBestY
$LN1@ResetBestY:

; 1525 : 
; 1526 : 		m_asBestYieldAverageTimes100[uiYields] = MAX_SHORT;

	mov	ecx, 32767				; 00007fffH
	mov	edx, DWORD PTR _uiYields$226193[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx*2+3672], cx
	jmp	SHORT $LN5@ResetBestY
$LN7@ResetBestY:

; 1527 : 	}
; 1528 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetBestYields@CvCityStrategyAI@@QAEXXZ ENDP		; CvCityStrategyAI::ResetBestYields
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=
PUBLIC	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy
PUBLIC	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??_C@_0BM@LMNIGKOI@CITYSPECIALIZATION_COMMERCE?$AA@ ; `string'
PUBLIC	??_C@_0CA@DCINMCDE@CITYSPECIALIZATION_SETTLER_PUMP?$AA@ ; `string'
PUBLIC	??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	__$ArrayPad$
PUBLIC	?UpdateBestYields@CvCityStrategyAI@@QAEXXZ	; CvCityStrategyAI::UpdateBestYields
EXTRN	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ:PROC ; CvCitySpecializationXMLEntry::GetYieldType
EXTRN	?GetYieldTargetTimes100@CvCitySpecializationXMLEntry@@QBEHW4YieldTypes@@@Z:PROC ; CvCitySpecializationXMLEntry::GetYieldTargetTimes100
EXTRN	?IsDefault@CvCitySpecializationXMLEntry@@QBE_NXZ:PROC ; CvCitySpecializationXMLEntry::IsDefault
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:PROC
EXTRN	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ:PROC ; CvGlobals::getCitySpecializationInfo
EXTRN	__imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ:PROC
EXTRN	?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ:PROC ; CvCityCitizens::GetFocusType
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ:PROC	; CvCity::GetPlayer
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?GetYieldChange@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetYieldChange
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?getMinCity@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getMinCity
EXTRN	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z:PROC ; CvGlobals::getYieldInfo
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z:PROC ; CvCityCitizens::GetCityPlotFromIndex
;	COMDAT ??_C@_0BM@LMNIGKOI@CITYSPECIALIZATION_COMMERCE?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@LMNIGKOI@CITYSPECIALIZATION_COMMERCE?$AA@ DB 'CITYSPECIALIZATIO'
	DB	'N_COMMERCE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DCINMCDE@CITYSPECIALIZATION_SETTLER_PUMP?$AA@
CONST	SEGMENT
??_C@_0CA@DCINMCDE@CITYSPECIALIZATION_SETTLER_PUMP?$AA@ DB 'CITYSPECIALIZ'
	DB	'ATION_SETTLER_PUMP', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
tv384 = -584						; size = 4
tv220 = -580						; size = 4
tv360 = -576						; size = 4
tv336 = -572						; size = 4
_this$ = -568						; size = 4
$T232649 = -536						; size = 4
$T232286 = -252						; size = 4
$T232250 = -248						; size = 4
$T232244 = -244						; size = 4
$T232198 = -208						; size = 4
$T232189 = -204						; size = 4
$T232178 = -200						; size = 4
$T232168 = -196						; size = 4
$T232167 = -189						; size = 1
$T232166 = -188						; size = 4
$T232165 = -184						; size = 4
_iYield$226320 = -180					; size = 4
_ui$226311 = -176					; size = 4
_m_aCitySpecializations$226310 = -172			; size = 16
_pEntry$226302 = -156					; size = 4
_ui$226298 = -152					; size = 4
_aCitySpecializations$226297 = -148			; size = 16
_strLookup$226283 = -132				; size = 28
__$ArrayPad$ = -104					; size = 4
_eCityAIFocusTypes$226282 = -100			; size = 4
_pkBuildingInfo$226276 = -96				; size = 4
_iI$226271 = -92					; size = 4
_eBuilding$226270 = -88					; size = 4
_pYield$226267 = -84					; size = 4
_iCityYieldSum$226266 = -80				; size = 4
_pCityBuildings$226269 = -76				; size = 4
_iSlot$226261 = -72					; size = 4
_iYieldSum$226260 = -68					; size = 4
_iYield$226256 = -64					; size = 4
_iYield$226240 = -60					; size = 4
_eYield$226237 = -56					; size = 4
_iYieldAmount$226239 = -52				; size = 4
_iYield$226233 = -48					; size = 4
_pWorkingCity$226230 = -44				; size = 4
_iPlotLoop$226225 = -40					; size = 4
_iPopulationToEvaluate$ = -36				; size = 4
_pPlot$ = -32						; size = 4
_iSlotsToEvaluate$ = -28				; size = 4
_uiPlotsEvaluated$ = -24				; size = 4
_eSpecialization$ = -20					; size = 4
_pEntry$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?UpdateBestYields@CvCityStrategyAI@@QAEXXZ PROC		; CvCityStrategyAI::UpdateBestYields, COMDAT
; _this$ = ecx

; 1531 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 572				; 0000023cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 	m_eFocusYield = (YieldTypes)NO_YIELD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3696], -1

; 1533 : 
; 1534 : 	ResetBestYields();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetBestYields@CvCityStrategyAI@@QAEXXZ ; CvCityStrategyAI::ResetBestYields

; 1535 : 
; 1536 : 	int iPopulationToEvaluate = min(m_pCity->getPopulation() + 2, NUM_CITY_PLOTS);

	mov	DWORD PTR $T232165[ebp], 37		; 00000025H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	eax, 2
	mov	DWORD PTR $T232166[ebp], eax
	mov	edx, DWORD PTR $T232165[ebp]
	cmp	edx, DWORD PTR $T232166[ebp]
	jge	SHORT $LN55@UpdateBest
	lea	eax, DWORD PTR $T232165[ebp]
	mov	DWORD PTR tv336[ebp], eax
	jmp	SHORT $LN56@UpdateBest
$LN55@UpdateBest:
	lea	ecx, DWORD PTR $T232166[ebp]
	mov	DWORD PTR tv336[ebp], ecx
$LN56@UpdateBest:
	mov	edx, DWORD PTR tv336[ebp]
	mov	DWORD PTR $T232178[ebp], edx
	mov	eax, DWORD PTR $T232178[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iPopulationToEvaluate$[ebp], ecx

; 1537 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 1538 : 	uint uiPlotsEvaluated = 0;

	mov	DWORD PTR _uiPlotsEvaluated$[ebp], 0

; 1539 : 
; 1540 : 	struct ReverseSort
; 1541 : 	{
; 1542 : 		bool operator()(unsigned char ucA, unsigned char ucB)
; 1543 : 		{
; 1544 : 			return ucA > ucB;
; 1545 : 		}
; 1546 : 	};
; 1547 : 
; 1548 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$226225[ebp], 0
	jmp	SHORT $LN47@UpdateBest
$LN46@UpdateBest:
	mov	edx, DWORD PTR _iPlotLoop$226225[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$226225[ebp], edx
$LN47@UpdateBest:
	cmp	DWORD PTR _iPlotLoop$226225[ebp], 37	; 00000025H
	jge	$LN45@UpdateBest

; 1549 : 	{
; 1550 : 		// we want to evaluate the city plot
; 1551 : 		//if (iPlotLoop == CITY_HOME_PLOT)
; 1552 : 		//{
; 1553 : 		//	continue;
; 1554 : 		//}
; 1555 : 
; 1556 : 		pPlot = m_pCity->GetCityCitizens()->GetCityPlotFromIndex(iPlotLoop);

	mov	eax, DWORD PTR _iPlotLoop$226225[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
	mov	DWORD PTR _pPlot$[ebp], eax

; 1557 : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN44@UpdateBest

; 1558 : 		{
; 1559 : 			continue;

	jmp	SHORT $LN46@UpdateBest
$LN44@UpdateBest:

; 1560 : 		}
; 1561 : 
; 1562 : 		CvCity* pWorkingCity = pPlot->getWorkingCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$226230[ebp], eax

; 1563 : 		if(!pWorkingCity || pWorkingCity->GetID() != m_pCity->GetID())

	cmp	DWORD PTR _pWorkingCity$226230[ebp], 0
	je	SHORT $LN42@UpdateBest
	mov	edx, DWORD PTR _pWorkingCity$226230[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR $T232189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR $T232198[ebp], eax
	mov	ecx, DWORD PTR $T232189[ebp]
	cmp	ecx, DWORD PTR $T232198[ebp]
	je	SHORT $LN43@UpdateBest
$LN42@UpdateBest:

; 1564 : 		{
; 1565 : 			continue;

	jmp	SHORT $LN46@UpdateBest
$LN43@UpdateBest:

; 1566 : 		}
; 1567 : 
; 1568 : 		for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$226233[ebp], 0
	jmp	SHORT $LN41@UpdateBest
$LN40@UpdateBest:
	mov	edx, DWORD PTR _iYield$226233[ebp]
	add	edx, 1
	mov	DWORD PTR _iYield$226233[ebp], edx
$LN41@UpdateBest:
	cmp	DWORD PTR _iYield$226233[ebp], 6
	jge	SHORT $LN39@UpdateBest

; 1569 : 		{
; 1570 : 			YieldTypes eYield = (YieldTypes)iYield;

	mov	eax, DWORD PTR _iYield$226233[ebp]
	mov	DWORD PTR _eYield$226237[ebp], eax

; 1571 : 			int iYieldAmount = pPlot->getYield(eYield);

	mov	ecx, DWORD PTR _eYield$226237[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	DWORD PTR _iYieldAmount$226239[ebp], eax

; 1572 : 
; 1573 : 			m_acBestYields[iYield][uiPlotsEvaluated] = iYieldAmount;

	mov	edx, DWORD PTR _iYield$226233[ebp]
	imul	edx, 37					; 00000025H
	mov	eax, DWORD PTR _uiPlotsEvaluated$[ebp]
	mov	cl, BYTE PTR _iYieldAmount$226239[ebp]
	mov	BYTE PTR ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA[edx+eax], cl

; 1574 : 		}

	jmp	SHORT $LN40@UpdateBest
$LN39@UpdateBest:

; 1575 : 		uiPlotsEvaluated++;

	mov	edx, DWORD PTR _uiPlotsEvaluated$[ebp]
	add	edx, 1
	mov	DWORD PTR _uiPlotsEvaluated$[ebp], edx

; 1576 : 	}

	jmp	$LN46@UpdateBest
$LN45@UpdateBest:

; 1577 : 
; 1578 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$226240[ebp], 0
	jmp	SHORT $LN38@UpdateBest
$LN37@UpdateBest:
	mov	eax, DWORD PTR _iYield$226240[ebp]
	add	eax, 1
	mov	DWORD PTR _iYield$226240[ebp], eax
$LN38@UpdateBest:
	cmp	DWORD PTR _iYield$226240[ebp], 6
	jge	SHORT $LN36@UpdateBest

; 1579 : 	{
; 1580 : 		std::stable_sort(m_acBestYields[iYield], m_acBestYields[iYield] + uiPlotsEvaluated, ReverseSort());

	xor	ecx, ecx
	mov	BYTE PTR $T232167[ebp], cl
	movzx	edx, BYTE PTR $T232167[ebp]
	push	edx
	mov	eax, DWORD PTR _iYield$226240[ebp]
	imul	eax, 37					; 00000025H
	mov	ecx, DWORD PTR _uiPlotsEvaluated$[ebp]
	lea	edx, DWORD PTR ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA[eax+ecx]
	push	edx
	mov	eax, DWORD PTR _iYield$226240[ebp]
	imul	eax, 37					; 00000025H
	add	eax, OFFSET ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA ; CvCityStrategyAI::m_acBestYields
	push	eax
	call	??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 12					; 0000000cH

; 1581 : 	}

	jmp	SHORT $LN37@UpdateBest
$LN36@UpdateBest:

; 1582 : 
; 1583 : 	int iSlotsToEvaluate = MIN((int)uiPlotsEvaluated, iPopulationToEvaluate);

	mov	ecx, DWORD PTR _uiPlotsEvaluated$[ebp]
	mov	DWORD PTR $T232168[ebp], ecx
	mov	edx, DWORD PTR _iPopulationToEvaluate$[ebp]
	cmp	edx, DWORD PTR $T232168[ebp]
	jge	SHORT $LN83@UpdateBest
	lea	eax, DWORD PTR _iPopulationToEvaluate$[ebp]
	mov	DWORD PTR tv360[ebp], eax
	jmp	SHORT $LN84@UpdateBest
$LN83@UpdateBest:
	lea	ecx, DWORD PTR $T232168[ebp]
	mov	DWORD PTR tv360[ebp], ecx
$LN84@UpdateBest:
	mov	edx, DWORD PTR tv360[ebp]
	mov	DWORD PTR $T232244[ebp], edx
	mov	eax, DWORD PTR $T232244[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iSlotsToEvaluate$[ebp], ecx

; 1584 : 	CvAssertMsg(iSlotsToEvaluate > 0, "iSlotsToEvaluate is zero, trying to div by 0");
; 1585 : 	if(iSlotsToEvaluate <= 0)

	cmp	DWORD PTR _iSlotsToEvaluate$[ebp], 0
	jg	SHORT $LN35@UpdateBest

; 1586 : 	{
; 1587 : 		return;

	jmp	$LN48@UpdateBest
$LN35@UpdateBest:

; 1588 : 	}
; 1589 : 
; 1590 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$226256[ebp], 0
	jmp	SHORT $LN34@UpdateBest
$LN33@UpdateBest:
	mov	edx, DWORD PTR _iYield$226256[ebp]
	add	edx, 1
	mov	DWORD PTR _iYield$226256[ebp], edx
$LN34@UpdateBest:
	cmp	DWORD PTR _iYield$226256[ebp], 6
	jge	$LN32@UpdateBest

; 1591 : 	{
; 1592 : 		int iYieldSum = 0;

	mov	DWORD PTR _iYieldSum$226260[ebp], 0

; 1593 : 		for(int iSlot = 0; iSlot < iSlotsToEvaluate; iSlot++)

	mov	DWORD PTR _iSlot$226261[ebp], 0
	jmp	SHORT $LN31@UpdateBest
$LN30@UpdateBest:
	mov	eax, DWORD PTR _iSlot$226261[ebp]
	add	eax, 1
	mov	DWORD PTR _iSlot$226261[ebp], eax
$LN31@UpdateBest:
	mov	ecx, DWORD PTR _iSlot$226261[ebp]
	cmp	ecx, DWORD PTR _iSlotsToEvaluate$[ebp]
	jge	SHORT $LN29@UpdateBest

; 1594 : 		{
; 1595 : 			iYieldSum += (m_acBestYields[iYield][iSlot] * 100);

	mov	edx, DWORD PTR _iYield$226256[ebp]
	imul	edx, 37					; 00000025H
	mov	eax, DWORD PTR _iSlot$226261[ebp]
	movzx	ecx, BYTE PTR ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA[edx+eax]
	imul	ecx, 100				; 00000064H
	add	ecx, DWORD PTR _iYieldSum$226260[ebp]
	mov	DWORD PTR _iYieldSum$226260[ebp], ecx

; 1596 : 		}

	jmp	SHORT $LN30@UpdateBest
$LN29@UpdateBest:

; 1597 : 
; 1598 : 		// add in additional food from the city plot and the city buildings that provide food
; 1599 : 		if(iYield == YIELD_FOOD)

	cmp	DWORD PTR _iYield$226256[ebp], 0
	jne	$LN28@UpdateBest

; 1600 : 		{
; 1601 : 			int iCityYieldSum = 0;

	mov	DWORD PTR _iCityYieldSum$226266[ebp], 0

; 1602 : 			iCityYieldSum = m_pCity->plot()->getYield(YIELD_FOOD);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	DWORD PTR _iCityYieldSum$226266[ebp], eax

; 1603 : 			CvYieldInfo* pYield = GC.getYieldInfo(YIELD_FOOD);

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo
	mov	DWORD PTR _pYield$226267[ebp], eax

; 1604 : 			if(pYield)

	cmp	DWORD PTR _pYield$226267[ebp], 0
	je	SHORT $LN27@UpdateBest

; 1605 : 			{
; 1606 : 				iCityYieldSum -= pYield->getMinCity();

	mov	ecx, DWORD PTR _pYield$226267[ebp]
	call	?getMinCity@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMinCity
	mov	ecx, DWORD PTR _iCityYieldSum$226266[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iCityYieldSum$226266[ebp], ecx
$LN27@UpdateBest:

; 1607 : 			}
; 1608 : 
; 1609 : 			CvCityBuildings* pCityBuildings = m_pCity->GetCityBuildings();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	DWORD PTR _pCityBuildings$226269[ebp], eax

; 1610 : 			BuildingTypes eBuilding;
; 1611 : #ifdef AUI_WARNING_FIXES
; 1612 : 			for (uint iI = 0; iI < GC.getNumBuildingInfos(); iI++)
; 1613 : #else
; 1614 : 			for(int iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	DWORD PTR _iI$226271[ebp], 0
	jmp	SHORT $LN26@UpdateBest
$LN25@UpdateBest:
	mov	eax, DWORD PTR _iI$226271[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226271[ebp], eax
$LN26@UpdateBest:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _iI$226271[ebp], eax
	jge	SHORT $LN24@UpdateBest

; 1615 : #endif
; 1616 : 			{
; 1617 : 				eBuilding = (BuildingTypes) iI;

	mov	ecx, DWORD PTR _iI$226271[ebp]
	mov	DWORD PTR _eBuilding$226270[ebp], ecx

; 1618 : 				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$226270[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$226276[ebp], eax

; 1619 : 				if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$226276[ebp], 0
	je	SHORT $LN23@UpdateBest

; 1620 : 				{
; 1621 : 					if(pCityBuildings->GetNumBuilding(eBuilding) > 0)

	mov	eax, DWORD PTR _eBuilding$226270[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCityBuildings$226269[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN23@UpdateBest

; 1622 : 					{
; 1623 : 						iCityYieldSum += pkBuildingInfo->GetYieldChange(iYield);

	mov	ecx, DWORD PTR _iYield$226256[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkBuildingInfo$226276[ebp]
	call	?GetYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChange
	add	eax, DWORD PTR _iCityYieldSum$226266[ebp]
	mov	DWORD PTR _iCityYieldSum$226266[ebp], eax
$LN23@UpdateBest:

; 1624 : 					}
; 1625 : 				}
; 1626 : 			}

	jmp	SHORT $LN25@UpdateBest
$LN24@UpdateBest:

; 1627 : 
; 1628 : 			iYieldSum += iCityYieldSum * 100;

	mov	edx, DWORD PTR _iCityYieldSum$226266[ebp]
	imul	edx, 100				; 00000064H
	add	edx, DWORD PTR _iYieldSum$226260[ebp]
	mov	DWORD PTR _iYieldSum$226260[ebp], edx
$LN28@UpdateBest:

; 1629 : 		}
; 1630 : 
; 1631 : 		m_asBestYieldAverageTimes100[iYield] = iYieldSum / iSlotsToEvaluate;

	mov	eax, DWORD PTR _iYieldSum$226260[ebp]
	cdq
	idiv	DWORD PTR _iSlotsToEvaluate$[ebp]
	mov	ecx, DWORD PTR _iYield$226256[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx*2+3672], ax

; 1632 : 
; 1633 : 		CvAssertMsg(m_asBestYieldAverageTimes100[iYield] < 750, "Crazy high yield");
; 1634 : 	}

	jmp	$LN33@UpdateBest
$LN32@UpdateBest:

; 1635 : 
; 1636 : 	CitySpecializationTypes eSpecialization = m_pCity->GetCityStrategyAI()->GetSpecialization();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	DWORD PTR $T232250[ebp], eax
	mov	ecx, DWORD PTR $T232250[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _eSpecialization$[ebp], edx

; 1637 : 	if(eSpecialization == NO_CITY_SPECIALIZATION)

	cmp	DWORD PTR _eSpecialization$[ebp], -1
	jne	$LN21@UpdateBest

; 1638 : 	{
; 1639 : 		if(m_pCity->GetPlayer()->isHuman())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@UpdateBest

; 1640 : 		{
; 1641 : 			// find a specialization type according to the citizen focus type
; 1642 : 			CityAIFocusTypes eCityAIFocusTypes = m_pCity->GetCityCitizens()->GetFocusType();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ ; CvCityCitizens::GetFocusType
	mov	DWORD PTR _eCityAIFocusTypes$226282[ebp], eax

; 1643 : 
; 1644 : 			CvString strLookup;

	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1645 : 			switch(eCityAIFocusTypes)

	mov	eax, DWORD PTR _eCityAIFocusTypes$226282[ebp]
	mov	DWORD PTR tv220[ebp], eax
	cmp	DWORD PTR tv220[ebp], 0
	je	SHORT $LN17@UpdateBest
	cmp	DWORD PTR tv220[ebp], 2
	je	SHORT $LN16@UpdateBest
	jmp	SHORT $LN18@UpdateBest
$LN17@UpdateBest:

; 1646 : 			{
; 1647 : 			case CITY_AI_FOCUS_TYPE_FOOD:
; 1648 : 				strLookup = "CITYSPECIALIZATION_SETTLER_PUMP";

	mov	ecx, OFFSET ??_C@_0CA@DCINMCDE@CITYSPECIALIZATION_SETTLER_PUMP?$AA@
	test	ecx, ecx
	je	SHORT $LN91@UpdateBest
	push	OFFSET ??_C@_0CA@DCINMCDE@CITYSPECIALIZATION_SETTLER_PUMP?$AA@
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN92@UpdateBest
$LN91@UpdateBest:
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN92@UpdateBest:

; 1649 : 				break;

	jmp	SHORT $LN18@UpdateBest
$LN16@UpdateBest:

; 1650 : 			case CITY_AI_FOCUS_TYPE_GOLD:
; 1651 : 				strLookup = "CITYSPECIALIZATION_COMMERCE";

	mov	edx, OFFSET ??_C@_0BM@LMNIGKOI@CITYSPECIALIZATION_COMMERCE?$AA@
	test	edx, edx
	je	SHORT $LN95@UpdateBest
	push	OFFSET ??_C@_0BM@LMNIGKOI@CITYSPECIALIZATION_COMMERCE?$AA@
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN18@UpdateBest
$LN95@UpdateBest:
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN18@UpdateBest:

; 1652 : 				break;
; 1653 : 			}
; 1654 : 
; 1655 : 			if(!strLookup.IsEmpty())

	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN100@UpdateBest
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	je	SHORT $LN100@UpdateBest
	mov	DWORD PTR tv384[ebp], 0
	jmp	SHORT $LN98@UpdateBest
$LN100@UpdateBest:
	mov	DWORD PTR tv384[ebp], 1
$LN98@UpdateBest:
	movzx	ecx, BYTE PTR tv384[ebp]
	test	ecx, ecx
	jne	$LN15@UpdateBest

; 1656 : 			{
; 1657 : 				std::vector<CvCitySpecializationXMLEntry*> aCitySpecializations = GC.getCitySpecializationInfo();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvGlobals::getCitySpecializationInfo
	push	eax
	lea	ecx, DWORD PTR _aCitySpecializations$226297[ebp]
	call	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1658 : 				for(uint ui = 0; ui < aCitySpecializations.size(); ui++)

	mov	DWORD PTR _ui$226298[ebp], 0
	jmp	SHORT $LN104@UpdateBest
$LN13@UpdateBest:
	mov	edx, DWORD PTR _ui$226298[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$226298[ebp], edx
$LN104@UpdateBest:
	mov	eax, DWORD PTR _aCitySpecializations$226297[ebp+8]
	sub	eax, DWORD PTR _aCitySpecializations$226297[ebp+4]
	sar	eax, 2
	cmp	DWORD PTR _ui$226298[ebp], eax
	jae	SHORT $LN12@UpdateBest

; 1659 : 				{
; 1660 : 					CvCitySpecializationXMLEntry* pEntry = aCitySpecializations[ui];

	mov	ecx, DWORD PTR _aCitySpecializations$226297[ebp+4]
	mov	edx, DWORD PTR _ui$226298[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pEntry$226302[ebp], eax

; 1661 : 					if(pEntry->GetType() == strLookup)

	mov	ecx, DWORD PTR _pEntry$226302[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232286[ebp], eax
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232286[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@UpdateBest

; 1662 : 					{
; 1663 : 						eSpecialization = (CitySpecializationTypes)ui;

	mov	ecx, DWORD PTR _ui$226298[ebp]
	mov	DWORD PTR _eSpecialization$[ebp], ecx

; 1664 : 						break;

	jmp	SHORT $LN12@UpdateBest
$LN11@UpdateBest:

; 1665 : 					}
; 1666 : 				}

	jmp	SHORT $LN13@UpdateBest
$LN12@UpdateBest:

; 1667 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aCitySpecializations$226297[ebp]
	call	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
$LN15@UpdateBest:

; 1668 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN20@UpdateBest:

; 1669 : 
; 1670 : 		// if the human did not have a city ai specialization
; 1671 : 		if(eSpecialization == NO_CITY_SPECIALIZATION)

	cmp	DWORD PTR _eSpecialization$[ebp], -1
	jne	$LN21@UpdateBest

; 1672 : 		{
; 1673 : 			std::vector<CvCitySpecializationXMLEntry*> m_aCitySpecializations;

	lea	ecx, DWORD PTR _m_aCitySpecializations$226310[ebp]
	call	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 1674 : 			m_aCitySpecializations = GC.getCitySpecializationInfo();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvGlobals::getCitySpecializationInfo
	push	eax
	lea	ecx, DWORD PTR _m_aCitySpecializations$226310[ebp]
	call	??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=

; 1675 : 			for(uint ui = 0; ui < m_aCitySpecializations.size(); ui++)

	mov	DWORD PTR _ui$226311[ebp], 0
	jmp	SHORT $LN246@UpdateBest
$LN8@UpdateBest:
	mov	edx, DWORD PTR _ui$226311[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$226311[ebp], edx
$LN246@UpdateBest:
	mov	eax, DWORD PTR _m_aCitySpecializations$226310[ebp+8]
	sub	eax, DWORD PTR _m_aCitySpecializations$226310[ebp+4]
	sar	eax, 2
	cmp	DWORD PTR _ui$226311[ebp], eax
	jae	SHORT $LN7@UpdateBest

; 1676 : 			{
; 1677 : 				if(m_aCitySpecializations[ui]->IsDefault())

	mov	ecx, DWORD PTR _m_aCitySpecializations$226310[ebp+4]
	mov	edx, DWORD PTR _ui$226311[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T232649[ebp], eax
	mov	ecx, DWORD PTR $T232649[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?IsDefault@CvCitySpecializationXMLEntry@@QBE_NXZ ; CvCitySpecializationXMLEntry::IsDefault
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@UpdateBest

; 1678 : 				{
; 1679 : 					eSpecialization = (CitySpecializationTypes)ui;

	mov	eax, DWORD PTR _ui$226311[ebp]
	mov	DWORD PTR _eSpecialization$[ebp], eax

; 1680 : 					break;

	jmp	SHORT $LN7@UpdateBest
$LN6@UpdateBest:

; 1681 : 				}
; 1682 : 			}

	jmp	SHORT $LN8@UpdateBest
$LN7@UpdateBest:

; 1683 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _m_aCitySpecializations$226310[ebp]
	call	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN21@UpdateBest:

; 1684 : 	}
; 1685 : 
; 1686 : 	CvCitySpecializationXMLEntry* pEntry = NULL;

	mov	DWORD PTR _pEntry$[ebp], 0

; 1687 : 	if(eSpecialization != NO_CITY_SPECIALIZATION)

	cmp	DWORD PTR _eSpecialization$[ebp], -1
	je	SHORT $LN5@UpdateBest

; 1688 : 	{
; 1689 : 		pEntry = GC.getCitySpecializationInfo(eSpecialization);

	mov	ecx, DWORD PTR _eSpecialization$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	DWORD PTR _pEntry$[ebp], eax
$LN5@UpdateBest:

; 1690 : 	}
; 1691 : 
; 1692 : 	if(!pEntry)

	cmp	DWORD PTR _pEntry$[ebp], 0
	jne	SHORT $LN4@UpdateBest

; 1693 : 	{
; 1694 : 		return;

	jmp	SHORT $LN48@UpdateBest
$LN4@UpdateBest:

; 1695 : 	}
; 1696 : 
; 1697 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$226320[ebp], 0
	jmp	SHORT $LN3@UpdateBest
$LN2@UpdateBest:
	mov	edx, DWORD PTR _iYield$226320[ebp]
	add	edx, 1
	mov	DWORD PTR _iYield$226320[ebp], edx
$LN3@UpdateBest:
	cmp	DWORD PTR _iYield$226320[ebp], 6
	jge	SHORT $LN1@UpdateBest

; 1698 : 	{
; 1699 : 		m_asYieldDeltaTimes100[iYield] = m_asBestYieldAverageTimes100[iYield] - pEntry->GetYieldTargetTimes100((YieldTypes)iYield);

	mov	eax, DWORD PTR _iYield$226320[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	esi, WORD PTR [ecx+eax*2+3672]
	mov	edx, DWORD PTR _iYield$226320[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntry$[ebp]
	call	?GetYieldTargetTimes100@CvCitySpecializationXMLEntry@@QBEHW4YieldTypes@@@Z ; CvCitySpecializationXMLEntry::GetYieldTargetTimes100
	sub	esi, eax
	mov	eax, DWORD PTR _iYield$226320[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax*2+3684], si

; 1700 : 	}

	jmp	SHORT $LN2@UpdateBest
$LN1@UpdateBest:

; 1701 : 
; 1702 : 	m_eFocusYield = pEntry->GetYieldType();

	mov	ecx, DWORD PTR _pEntry$[ebp]
	call	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ ; CvCitySpecializationXMLEntry::GetYieldType
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3696], eax
$LN48@UpdateBest:

; 1703 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strLookup$226283[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _aCitySpecializations$226297[ebp]
	jmp	??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR _aCitySpecializations$226297[ebp]
	jmp	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _m_aCitySpecializations$226310[ebp]
	jmp	??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$11:
	lea	ecx, DWORD PTR _m_aCitySpecializations$226310[ebp]
	jmp	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-580]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateBestYields@CvCityStrategyAI@@QAEXXZ ENDP		; CvCityStrategyAI::UpdateBestYields
; Function compile flags: /Odtp
;	COMDAT ??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ucA$ = 8						; size = 1
_ucB$ = 12						; size = 1
??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z PROC ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator(), COMDAT
; _this$ = ecx

; 1543 : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1544 : 			return ucA > ucB;

	movzx	eax, BYTE PTR _ucA$[ebp]
	movzx	ecx, BYTE PTR _ucB$[ebp]
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	mov	al, dl

; 1545 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ENDP ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
_TEXT	ENDS
PUBLIC	?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z ; CvCityStrategyAI::GetBestYieldAverageTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eYield$ = 8						; size = 4
?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetBestYieldAverageTimes100, COMDAT
; _this$ = ecx

; 1710 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1711 : 	return m_asBestYieldAverageTimes100[eYield];

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [ecx+eax*2+3672]

; 1712 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetBestYieldAverageTimes100
_TEXT	ENDS
PUBLIC	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldDeltaTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eYield$ = 8						; size = 4
?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetYieldDeltaTimes100, COMDAT
; _this$ = ecx

; 1719 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1720 : 	return m_asYieldDeltaTimes100[eYield];

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [ecx+eax*2+3684]

; 1721 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetYieldDeltaTimes100
_TEXT	ENDS
PUBLIC	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetFocusYield
; Function compile flags: /Odtp
;	COMDAT ?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ PROC ; CvCityStrategyAI::GetFocusYield, COMDAT
; _this$ = ecx

; 1724 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1725 : 	return m_eFocusYield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+3696]

; 1726 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ENDP ; CvCityStrategyAI::GetFocusYield
_TEXT	ENDS
PUBLIC	??_C@_0DL@EDBBPPGC@Gold?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avai@ ; `string'
PUBLIC	??_C@_0DK@NPLFIHOE@Pop?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avail@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z ; CvCityStrategyAI::LogHurry
EXTRN	?getProductionName@CvCity@@QBEPBDXZ:PROC	; CvCity::getProductionName
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0DL@EDBBPPGC@Gold?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avai@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DL@EDBBPPGC@Gold?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avai@ DB 'G'
	DB	'old rushed: %s, Spent: %d, Available: %d, Turns Saved: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NPLFIHOE@Pop?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avail@
CONST	SEGMENT
??_C@_0DK@NPLFIHOE@Pop?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avail@ DB 'P'
	DB	'op rushed: %s, Spent: %d, Available: %d, Turns Saved: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
_TEXT	SEGMENT
tv264 = -436						; size = 4
tv256 = -432						; size = 4
tv275 = -428						; size = 4
tv254 = -424						; size = 4
tv286 = -420						; size = 4
tv252 = -416						; size = 4
tv297 = -412						; size = 4
tv308 = -408						; size = 4
tv145 = -404						; size = 4
tv319 = -400						; size = 4
_this$ = -396						; size = 4
$T232811 = -392						; size = 4
$T232807 = -388						; size = 4
$T232803 = -384						; size = 4
$T232795 = -380						; size = 4
$T232794 = -376						; size = 4
$T232786 = -372						; size = 4
$T232782 = -368						; size = 4
$T232776 = -364						; size = 4
$T232772 = -360						; size = 4
$T232727 = -356						; size = 28
$T232726 = -328						; size = 28
$T232725 = -300						; size = 28
$T232724 = -272						; size = 28
$T232723 = -244						; size = 28
$T232722 = -216						; size = 28
_strOutBuf$226346 = -188				; size = 28
_playerName$226349 = -160				; size = 28
_cityName$226350 = -132					; size = 28
_strDesc$226351 = -104					; size = 28
_pLog$226353 = -76					; size = 4
_strTemp$226348 = -72					; size = 28
_strBaseString$226347 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iHurryType$ = 8					; size = 4
_iHurryAmount$ = 12					; size = 4
_iHurryAmountAvailable$ = 16				; size = 4
_iTurnsSaved$ = 20					; size = 4
?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z PROC ; CvCityStrategyAI::LogHurry, COMDAT
; _this$ = ecx

; 1729 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 424				; 000001a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1730 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN4@LogHurry
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@LogHurry

; 1731 : 	{
; 1732 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226346[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1733 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226347[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1734 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226348[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1735 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226349[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1736 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226350[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1737 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226351[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1738 : 
; 1739 : 		// Find the name of this civ and city
; 1740 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T232772[ebp], ecx
	mov	edx, DWORD PTR $T232772[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232776[ebp], edx
	mov	ecx, DWORD PTR $T232776[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T232782[ebp], eax
	cmp	DWORD PTR $T232782[ebp], 0
	je	SHORT $LN43@LogHurry
	mov	eax, DWORD PTR $T232782[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226349[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN44@LogHurry
$LN43@LogHurry:
	lea	ecx, DWORD PTR _playerName$226349[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN44@LogHurry:

; 1741 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T232722[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv319[ebp], eax
	mov	eax, DWORD PTR tv319[ebp]
	mov	DWORD PTR $T232786[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T232786[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cityName$226350[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232722[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1742 : 
; 1743 : 		// Open the log file
; 1744 : 		FILogFile* pLog;
; 1745 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv145[ebp], eax
	lea	edx, DWORD PTR _cityName$226350[ebp]
	push	edx
	lea	eax, DWORD PTR _playerName$226349[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232723[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv308[ebp], eax
	mov	edx, DWORD PTR tv308[ebp]
	mov	DWORD PTR $T232794[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T232794[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232795[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T232795[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv145[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226353[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232723[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1746 : 
; 1747 : 		// Get the leading info for this line
; 1748 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232803[ebp], ecx
	mov	ecx, DWORD PTR $T232803[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226347[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1749 : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226349[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232724[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv297[ebp], eax
	mov	edx, DWORD PTR tv297[ebp]
	mov	DWORD PTR tv252[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	eax, DWORD PTR _cityName$226350[ebp]
	push	eax
	mov	ecx, DWORD PTR tv252[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232725[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv286[ebp], eax
	mov	eax, DWORD PTR tv286[ebp]
	mov	DWORD PTR tv254[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv254[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232726[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv275[ebp], eax
	mov	eax, DWORD PTR tv275[ebp]
	mov	DWORD PTR tv256[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR tv256[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$226347[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T232726[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T232725[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232724[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1750 : 
; 1751 : 		if(iHurryType == 0)

	cmp	DWORD PTR _iHurryType$[ebp], 0
	jne	SHORT $LN2@LogHurry

; 1752 : 		{
; 1753 : 			strTemp.Format("Pop rushed: %s, Spent: %d, Available: %d, Turns Saved: %d", m_pCity->getProductionName(), iHurryAmount, iHurryAmountAvailable, iTurnsSaved);

	mov	edx, DWORD PTR _iTurnsSaved$[ebp]
	push	edx
	mov	eax, DWORD PTR _iHurryAmountAvailable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iHurryAmount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?getProductionName@CvCity@@QBEPBDXZ	; CvCity::getProductionName
	push	eax
	push	OFFSET ??_C@_0DK@NPLFIHOE@Pop?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avail@
	lea	eax, DWORD PTR _strTemp$226348[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1754 : 		}
; 1755 : 		else

	jmp	SHORT $LN1@LogHurry
$LN2@LogHurry:

; 1756 : 		{
; 1757 : 			strTemp.Format("Gold rushed: %s, Spent: %d, Available: %d, Turns Saved: %d", m_pCity->getProductionName(), iHurryAmount, iHurryAmountAvailable, iTurnsSaved);

	mov	ecx, DWORD PTR _iTurnsSaved$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHurryAmountAvailable$[ebp]
	push	edx
	mov	eax, DWORD PTR _iHurryAmount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?getProductionName@CvCity@@QBEPBDXZ	; CvCity::getProductionName
	push	eax
	push	OFFSET ??_C@_0DL@EDBBPPGC@Gold?5rushed?3?5?$CFs?0?5Spent?3?5?$CFd?0?5Avai@
	lea	edx, DWORD PTR _strTemp$226348[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
$LN1@LogHurry:

; 1758 : 		}
; 1759 : 
; 1760 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226348[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226347[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232727[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv264[ebp], eax
	mov	eax, DWORD PTR tv264[ebp]
	mov	DWORD PTR $T232807[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T232807[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226346[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232727[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1761 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226346[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232811[ebp], eax
	mov	ecx, DWORD PTR $T232811[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226353[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226353[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 1762 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strDesc$226351[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _cityName$226350[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226349[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226348[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226347[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226346[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@LogHurry:

; 1763 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226347[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$2:
	lea	ecx, DWORD PTR _strTemp$226348[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$3:
	lea	ecx, DWORD PTR _playerName$226349[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$4:
	lea	ecx, DWORD PTR _cityName$226350[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$5:
	lea	ecx, DWORD PTR _strDesc$226351[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$6:
	lea	ecx, DWORD PTR $T232722[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$7:
	lea	ecx, DWORD PTR $T232723[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$8:
	lea	ecx, DWORD PTR $T232724[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$9:
	lea	ecx, DWORD PTR $T232725[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$10:
	lea	ecx, DWORD PTR $T232726[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$11:
	lea	ecx, DWORD PTR $T232727[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z ENDP ; CvCityStrategyAI::LogHurry
PUBLIC	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ; CityStrategyAIHelpers::ReweightByTurnsLeft
; Function compile flags: /Odtp
;	COMDAT ?ReweightByCost@CvCityStrategyAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T232885 = -44						; size = 4
_elem$232884 = -40					; size = 16
$T232851 = -24						; size = 4
_iNewWeight$226373 = -20				; size = 4
_iI$226369 = -16					; size = 4
_buildable$ = -12					; size = 12
?ReweightByCost@CvCityStrategyAI@@AAEXXZ PROC		; CvCityStrategyAI::ReweightByCost, COMDAT
; _this$ = ecx

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1771 : 	CvCityBuildable buildable;

	mov	DWORD PTR _buildable$[ebp], 0
	mov	DWORD PTR _buildable$[ebp+4], 0
	mov	DWORD PTR _buildable$[ebp+8], 0

; 1772 : 
; 1773 : 	for(int iI = 0; iI < m_Buildables.size(); iI++)

	mov	DWORD PTR _iI$226369[ebp], 0
	jmp	SHORT $LN3@ReweightBy
$LN2@ReweightBy:
	mov	eax, DWORD PTR _iI$226369[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226369[ebp], eax
$LN3@ReweightBy:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR $T232851[ebp], edx
	mov	eax, DWORD PTR _iI$226369[ebp]
	cmp	eax, DWORD PTR $T232851[ebp]
	jge	$LN4@ReweightBy

; 1774 : 	{
; 1775 : 		buildable = m_Buildables.GetElement(iI);

	mov	ecx, DWORD PTR _iI$226369[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _buildable$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _buildable$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _buildable$[ebp+8], eax

; 1776 : 
; 1777 : 		// Compute the new weight and change it
; 1778 : 		int iNewWeight = CityStrategyAIHelpers::ReweightByTurnsLeft(m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$232884[ebp], 0
	mov	DWORD PTR _elem$232884[ebp+4], 0
	mov	DWORD PTR _elem$232884[ebp+8], 0
	mov	DWORD PTR _elem$232884[ebp+12], 0
	mov	ecx, DWORD PTR _iI$226369[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$232884[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$232884[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$232884[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$232884[ebp+12], edx
	mov	eax, DWORD PTR _elem$232884[ebp+12]
	mov	DWORD PTR $T232885[ebp], eax
	mov	ecx, DWORD PTR _buildable$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T232885[ebp]
	push	edx
	call	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ; CityStrategyAIHelpers::ReweightByTurnsLeft
	add	esp, 8
	mov	DWORD PTR _iNewWeight$226373[ebp], eax

; 1779 : 		m_Buildables.SetWeight(iI, iNewWeight);

	mov	eax, DWORD PTR _iI$226369[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR _iNewWeight$226373[ebp]
	mov	DWORD PTR [edx+eax+12], ecx

; 1780 : 	}

	jmp	$LN2@ReweightBy
$LN4@ReweightBy:

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReweightByCost@CvCityStrategyAI@@AAEXXZ ENDP		; CvCityStrategyAI::ReweightByCost
_TEXT	ENDS
PUBLIC	??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@	; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@ DB 'Flavor, %s, %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$12
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
tv74 = -500						; size = 4
tv306 = -496						; size = 4
tv296 = -492						; size = 4
tv317 = -488						; size = 4
tv294 = -484						; size = 4
tv328 = -480						; size = 4
tv292 = -476						; size = 4
tv339 = -472						; size = 4
tv350 = -468						; size = 4
tv145 = -464						; size = 4
tv361 = -460						; size = 4
_this$ = -456						; size = 4
$T233016 = -452						; size = 4
$T233012 = -448						; size = 4
$T233008 = -444						; size = 4
$T233004 = -440						; size = 4
$T233000 = -436						; size = 4
$T232996 = -432						; size = 4
$T232992 = -428						; size = 4
$T232988 = -424						; size = 4
$T232984 = -420						; size = 4
$T232980 = -416						; size = 4
$T232972 = -412						; size = 4
$T232971 = -408						; size = 4
$T232963 = -404						; size = 4
$T232959 = -400						; size = 4
$T232953 = -396						; size = 4
$T232949 = -392						; size = 4
$T232903 = -388						; size = 28
$T232902 = -360						; size = 28
$T232901 = -332						; size = 28
$T232900 = -304						; size = 28
$T232899 = -276						; size = 28
$T232898 = -248						; size = 28
$T232897 = -220						; size = 28
_iI$226392 = -192					; size = 4
_strOutBuf$226379 = -188				; size = 28
_playerName$226382 = -160				; size = 28
_cityName$226383 = -132					; size = 28
_strDesc$226384 = -104					; size = 28
_pLog$226386 = -76					; size = 4
_strTemp$226381 = -72					; size = 28
_strBaseString$226380 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eFlavor$ = 8						; size = 4
?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z PROC ; CvCityStrategyAI::LogFlavors, COMDAT
; _this$ = ecx

; 1785 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 488				; 000001e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1786 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogFlavors
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@LogFlavors

; 1787 : 	{
; 1788 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1789 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226380[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1790 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226381[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1791 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226382[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1792 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226383[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1793 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226384[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1794 : 
; 1795 : 		// Find the name of this civ and city
; 1796 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T232949[ebp], ecx
	mov	edx, DWORD PTR $T232949[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232953[ebp], edx
	mov	ecx, DWORD PTR $T232953[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T232959[ebp], eax
	cmp	DWORD PTR $T232959[ebp], 0
	je	SHORT $LN47@LogFlavors
	mov	eax, DWORD PTR $T232959[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226382[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN48@LogFlavors
$LN47@LogFlavors:
	lea	ecx, DWORD PTR _playerName$226382[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN48@LogFlavors:

; 1797 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T232897[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv361[ebp], eax
	mov	eax, DWORD PTR tv361[ebp]
	mov	DWORD PTR $T232963[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T232963[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cityName$226383[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232897[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1798 : 
; 1799 : 		// Open the log file
; 1800 : 		FILogFile* pLog;
; 1801 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv145[ebp], eax
	lea	edx, DWORD PTR _cityName$226383[ebp]
	push	edx
	lea	eax, DWORD PTR _playerName$226382[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232898[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv350[ebp], eax
	mov	edx, DWORD PTR tv350[ebp]
	mov	DWORD PTR $T232971[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T232971[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232972[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T232972[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv145[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226386[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232898[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1802 : 
; 1803 : 		// Get the leading info for this line
; 1804 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232980[ebp], ecx
	mov	ecx, DWORD PTR $T232980[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226380[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1805 : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226382[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232899[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv339[ebp], eax
	mov	edx, DWORD PTR tv339[ebp]
	mov	DWORD PTR tv292[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	eax, DWORD PTR _cityName$226383[ebp]
	push	eax
	mov	ecx, DWORD PTR tv292[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232900[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv328[ebp], eax
	mov	eax, DWORD PTR tv328[ebp]
	mov	DWORD PTR tv294[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv294[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232901[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv317[ebp], eax
	mov	eax, DWORD PTR tv317[ebp]
	mov	DWORD PTR tv296[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR tv296[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$226380[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T232901[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T232900[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232899[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1806 : 
; 1807 : 		// Dump out the setting for each flavor
; 1808 : 		if(eFlavor == NO_FLAVOR)

	cmp	DWORD PTR _eFlavor$[ebp], -1
	jne	$LN5@LogFlavors

; 1809 : 		{
; 1810 : 			for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	mov	DWORD PTR _iI$226392[ebp], 0
	jmp	SHORT $LN4@LogFlavors
$LN3@LogFlavors:
	mov	edx, DWORD PTR _iI$226392[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$226392[ebp], edx
$LN4@LogFlavors:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T232984[ebp], eax
	mov	ecx, DWORD PTR _iI$226392[ebp]
	cmp	ecx, DWORD PTR $T232984[ebp]
	jge	$LN2@LogFlavors

; 1811 : 			{
; 1812 : 				// Only dump if non-zero
; 1813 : 				//		if (m_piLatestFlavorValues[iI] > 0)
; 1814 : 				{
; 1815 : 					strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes((FlavorTypes)iI).GetCString(), m_piLatestFlavorValues[iI]);

	mov	edx, DWORD PTR _iI$226392[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T232988[ebp], edx
	mov	ecx, DWORD PTR $T232988[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232992[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iI$226392[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR $T232992[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@
	lea	edx, DWORD PTR _strTemp$226381[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1816 : 					strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226381[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226380[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232902[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv306[ebp], eax
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR $T232996[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T232996[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232902[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1817 : 					pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233000[ebp], eax
	mov	ecx, DWORD PTR $T233000[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226386[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226386[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 1818 : 				}
; 1819 : 			}

	jmp	$LN3@LogFlavors
$LN2@LogFlavors:

; 1820 : 		}
; 1821 : 		else

	jmp	$LN1@LogFlavors
$LN5@LogFlavors:

; 1822 : 		{
; 1823 : 			strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes(eFlavor).GetCString(), m_piLatestFlavorValues[eFlavor]);

	mov	eax, DWORD PTR _eFlavor$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T233004[ebp], eax
	mov	ecx, DWORD PTR $T233004[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233008[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _eFlavor$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR $T233008[ebp]
	push	edx
	push	OFFSET ??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$226381[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1824 : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$226381[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$226380[ebp]
	push	edx
	lea	eax, DWORD PTR $T232903[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T233012[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T233012[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T232903[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1825 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233016[ebp], eax
	mov	edx, DWORD PTR $T233016[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$226386[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$226386[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8
$LN1@LogFlavors:

; 1826 : 		}
; 1827 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strDesc$226384[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _cityName$226383[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226382[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226381[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226380[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogFlavors:

; 1828 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226379[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226380[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$226381[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$226382[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$4:
	lea	ecx, DWORD PTR _cityName$226383[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$5:
	lea	ecx, DWORD PTR _strDesc$226384[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$6:
	lea	ecx, DWORD PTR $T232897[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$7:
	lea	ecx, DWORD PTR $T232898[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$8:
	lea	ecx, DWORD PTR $T232899[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$9:
	lea	ecx, DWORD PTR $T232900[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$10:
	lea	ecx, DWORD PTR $T232901[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$11:
	lea	ecx, DWORD PTR $T232902[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$12:
	lea	ecx, DWORD PTR $T232903[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-492]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z ENDP ; CvCityStrategyAI::LogFlavors
PUBLIC	??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z:PROC ; CvGlobals::getAICityStrategyInfo
;	COMDAT ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@ DB '%s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
_TEXT	SEGMENT
tv234 = -344						; size = 4
tv252 = -340						; size = 4
tv232 = -336						; size = 4
tv266 = -332						; size = 4
tv230 = -328						; size = 4
tv297 = -324						; size = 4
tv95 = -320						; size = 4
tv132 = -316						; size = 4
tv268 = -312						; size = 4
_this$ = -308						; size = 4
$T233123 = -304						; size = 4
$T233105 = -300						; size = 4
$T233097 = -296						; size = 4
$T233096 = -292						; size = 4
$T233092 = -288						; size = 4
$T233083 = -284						; size = 4
$T233079 = -280						; size = 4
$T233053 = -276						; size = 28
$T233052 = -248						; size = 28
$T233051 = -220						; size = 28
$T233050 = -192						; size = 28
_strTemp$226419 = -164					; size = 28
_strOutBuf$226407 = -136				; size = 28
_playerName$226409 = -108				; size = 28
_cityName$226410 = -80					; size = 28
_pLog$226412 = -52					; size = 4
_pStrategyEntry$226417 = -48				; size = 4
_strBaseString$226408 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z PROC ; CvCityStrategyAI::LogStrategy, COMDAT
; _this$ = ecx

; 1832 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1833 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@LogStrateg
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@LogStrateg

; 1834 : 	{
; 1835 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226407[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1836 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226408[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1837 : 
; 1838 : 		// Find the name of this civ and city
; 1839 : 		CvString playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233079[ebp], ecx
	mov	edx, DWORD PTR $T233079[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233083[ebp], edx
	mov	ecx, DWORD PTR $T233083[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233092[ebp], eax
	cmp	DWORD PTR $T233092[ebp], 0
	je	SHORT $LN28@LogStrateg
	mov	eax, DWORD PTR $T233092[ebp]
	mov	DWORD PTR tv268[ebp], eax
	jmp	SHORT $LN29@LogStrateg
$LN28@LogStrateg:
	mov	DWORD PTR tv268[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN29@LogStrateg:
	mov	ecx, DWORD PTR tv268[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$226409[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1840 : 		CvString cityName = m_pCity->getName();

	lea	edx, DWORD PTR _cityName$226410[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1841 : 
; 1842 : 		// Open the log file
; 1843 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv132[ebp], eax
	lea	ecx, DWORD PTR _cityName$226410[ebp]
	push	ecx
	lea	edx, DWORD PTR _playerName$226409[ebp]
	push	edx
	lea	eax, DWORD PTR $T233050[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR $T233096[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T233096[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233097[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T233097[ebp]
	push	edx
	mov	eax, DWORD PTR tv132[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226412[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233050[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1844 : 
; 1845 : 		// Get the leading info for this line
; 1846 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233105[ebp], ecx
	mov	ecx, DWORD PTR $T233105[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226408[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1847 : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226409[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233051[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv297[ebp], eax
	mov	edx, DWORD PTR tv297[ebp]
	mov	DWORD PTR tv230[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	eax, DWORD PTR _cityName$226410[ebp]
	push	eax
	mov	ecx, DWORD PTR tv230[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233052[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv266[ebp], eax
	mov	eax, DWORD PTR tv266[ebp]
	mov	DWORD PTR tv232[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv232[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233053[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv252[ebp], eax
	mov	eax, DWORD PTR tv252[ebp]
	mov	DWORD PTR tv234[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR tv234[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$226408[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T233053[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233052[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233051[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1848 : 
; 1849 : 		strOutBuf = strBaseString;

	lea	edx, DWORD PTR _strBaseString$226408[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$226407[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1850 : 
; 1851 : 		// Strategy Info
; 1852 : 		CvAICityStrategyEntry* pStrategyEntry = GC.getAICityStrategyInfo(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z ; CvGlobals::getAICityStrategyInfo
	mov	DWORD PTR _pStrategyEntry$226417[ebp], eax

; 1853 : 		if(pStrategyEntry != NULL)

	cmp	DWORD PTR _pStrategyEntry$226417[ebp], 0
	je	SHORT $LN1@LogStrateg

; 1854 : 		{
; 1855 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226419[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 1856 : 			strTemp.Format("%s, %d", pStrategyEntry->GetType(), bValue);

	movzx	ecx, BYTE PTR _bValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pStrategyEntry$226417[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	lea	edx, DWORD PTR _strTemp$226419[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1857 : 			strOutBuf += strTemp;

	lea	eax, DWORD PTR _strTemp$226419[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226407[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1858 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$226419[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogStrateg:

; 1859 : 
; 1860 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226407[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233123[ebp], eax
	mov	ecx, DWORD PTR $T233123[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226412[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226412[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 1861 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cityName$226410[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _playerName$226409[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226408[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226407[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@LogStrateg:

; 1862 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226407[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226408[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _playerName$226409[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$3:
	lea	ecx, DWORD PTR _cityName$226410[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$4:
	lea	ecx, DWORD PTR $T233050[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T233051[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$6:
	lea	ecx, DWORD PTR $T233052[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T233053[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$8:
	lea	ecx, DWORD PTR _strTemp$226419[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ENDP ; CvCityStrategyAI::LogStrategy
PUBLIC	??_C@_0BG@LJHGAMDH@Army?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BL@DOEGPDA@Operation?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BE@JJFOFBD@Process?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BE@EJIMFEEB@Project?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BB@IFOCDAEE@Unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BF@HFOGPLHO@Building?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z:PROC ; CvGlobals::getProcessInfo
EXTRN	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z:PROC ; CvProjectXMLEntries::GetEntry
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
;	COMDAT ??_C@_0BG@LJHGAMDH@Army?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BG@LJHGAMDH@Army?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ DB 'Army un'
	DB	'it, %s, %d, %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOEGPDA@Operation?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@DOEGPDA@Operation?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ DB 'Ope'
	DB	'ration unit, %s, %d, %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JJFOFBD@Process?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@JJFOFBD@Process?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ DB 'Process, %s'
	DB	', %d, %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJIMFEEB@Project?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@EJIMFEEB@Project?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ DB 'Project, %'
	DB	's, %d, %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IFOCDAEE@Unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@IFOCDAEE@Unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ DB 'Unit, %s, %d,'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HFOGPLHO@Building?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@HFOGPLHO@Building?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@ DB 'Building,'
	DB	' %s, %d, %d', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
_TEXT	SEGMENT
tv406 = -628						; size = 4
tv210 = -624						; size = 4
tv398 = -620						; size = 4
tv417 = -616						; size = 4
tv396 = -612						; size = 4
tv428 = -608						; size = 4
tv394 = -604						; size = 4
tv439 = -600						; size = 4
tv450 = -596						; size = 4
tv145 = -592						; size = 4
tv461 = -588						; size = 4
_this$ = -584						; size = 4
$T233459 = -580						; size = 4
$T233455 = -576						; size = 4
$T233448 = -572						; size = 4
_elem$233440 = -568					; size = 16
$T233426 = -552						; size = 4
$T233414 = -548						; size = 4
_elem$233406 = -544					; size = 16
$T233392 = -528						; size = 4
$T233380 = -524						; size = 4
_elem$233372 = -520					; size = 16
$T233358 = -504						; size = 4
$T233346 = -500						; size = 4
_elem$233338 = -496					; size = 16
$T233324 = -480						; size = 4
$T233312 = -476						; size = 4
_elem$233304 = -472					; size = 16
$T233290 = -456						; size = 4
$T233278 = -452						; size = 4
_elem$233270 = -448					; size = 16
$T233256 = -432						; size = 4
$T233235 = -428						; size = 4
$T233230 = -424						; size = 4
$T233222 = -420						; size = 4
$T233221 = -416						; size = 4
$T233213 = -412						; size = 4
$T233209 = -408						; size = 4
$T233203 = -404						; size = 4
$T233199 = -400						; size = 4
$T233154 = -396						; size = 28
$T233153 = -368						; size = 28
$T233152 = -340						; size = 28
$T233151 = -312						; size = 28
$T233150 = -284						; size = 28
$T233149 = -256						; size = 28
_pEntry$226468 = -228					; size = 4
_pEntry$226464 = -224					; size = 4
_pProcess$226459 = -220					; size = 4
_pEntry$226455 = -216					; size = 4
_pEntry$226451 = -212					; size = 4
_pEntry$226447 = -208					; size = 4
_buildable$226441 = -204				; size = 12
_iI$226437 = -192					; size = 4
_strOutBuf$226425 = -188				; size = 28
_playerName$226428 = -160				; size = 28
_cityName$226429 = -132					; size = 28
_strDesc$226430 = -104					; size = 28
_pLog$226432 = -76					; size = 4
_strTemp$226427 = -72					; size = 28
_strBaseString$226426 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ PROC	; CvCityStrategyAI::LogPossibleBuilds, COMDAT
; _this$ = ecx

; 1866 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 616				; 00000268H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1867 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN19@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@LogPossibl

; 1868 : 	{
; 1869 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226425[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1870 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226426[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1871 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226427[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1872 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226428[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1873 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226429[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1874 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1875 : 
; 1876 : 		// Find the name of this civ and city
; 1877 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233199[ebp], ecx
	mov	edx, DWORD PTR $T233199[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233203[ebp], edx
	mov	ecx, DWORD PTR $T233203[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233209[ebp], eax
	cmp	DWORD PTR $T233209[ebp], 0
	je	SHORT $LN58@LogPossibl
	mov	eax, DWORD PTR $T233209[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226428[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN59@LogPossibl
$LN58@LogPossibl:
	lea	ecx, DWORD PTR _playerName$226428[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN59@LogPossibl:

; 1878 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T233149[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv461[ebp], eax
	mov	eax, DWORD PTR tv461[ebp]
	mov	DWORD PTR $T233213[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T233213[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cityName$226429[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233149[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1879 : 
; 1880 : 		// Open the log file
; 1881 : 		FILogFile* pLog;
; 1882 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv145[ebp], eax
	lea	edx, DWORD PTR _cityName$226429[ebp]
	push	edx
	lea	eax, DWORD PTR _playerName$226428[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233150[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv450[ebp], eax
	mov	edx, DWORD PTR tv450[ebp]
	mov	DWORD PTR $T233221[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233221[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233222[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T233222[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv145[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226432[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233150[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1883 : 
; 1884 : 		// Get the leading info for this line
; 1885 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233230[ebp], ecx
	mov	ecx, DWORD PTR $T233230[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226426[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1886 : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226428[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233151[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv439[ebp], eax
	mov	edx, DWORD PTR tv439[ebp]
	mov	DWORD PTR tv394[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	eax, DWORD PTR _cityName$226429[ebp]
	push	eax
	mov	ecx, DWORD PTR tv394[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233152[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv428[ebp], eax
	mov	eax, DWORD PTR tv428[ebp]
	mov	DWORD PTR tv396[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv396[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233153[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv417[ebp], eax
	mov	eax, DWORD PTR tv417[ebp]
	mov	DWORD PTR tv398[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR tv398[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$226426[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T233153[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T233152[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233151[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1887 : 
; 1888 : 		// Dump out the weight of each buildable item
; 1889 : 		for(int iI = 0; iI < m_Buildables.size(); iI++)

	mov	DWORD PTR _iI$226437[ebp], 0
	jmp	SHORT $LN17@LogPossibl
$LN16@LogPossibl:
	mov	edx, DWORD PTR _iI$226437[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$226437[ebp], edx
$LN17@LogPossibl:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR $T233235[ebp], ecx
	mov	edx, DWORD PTR _iI$226437[ebp]
	cmp	edx, DWORD PTR $T233235[ebp]
	jge	$LN15@LogPossibl

; 1890 : 		{
; 1891 : 			CvCityBuildable buildable = m_Buildables.GetElement(iI);

	mov	eax, DWORD PTR _iI$226437[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _buildable$226441[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _buildable$226441[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _buildable$226441[ebp+8], edx

; 1892 : 
; 1893 : 			switch(buildable.m_eBuildableType)

	mov	eax, DWORD PTR _buildable$226441[ebp]
	mov	DWORD PTR tv210[ebp], eax
	mov	ecx, DWORD PTR tv210[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv210[ebp], ecx
	cmp	DWORD PTR tv210[ebp], 5
	ja	$LN13@LogPossibl
	mov	edx, DWORD PTR tv210[ebp]
	jmp	DWORD PTR $LN200@LogPossibl[edx*4]
$LN12@LogPossibl:

; 1894 : 			{
; 1895 : 			case CITY_BUILDABLE_BUILDING:
; 1896 : 			{
; 1897 : 				CvBuildingEntry* pEntry = GC.GetGameBuildings()->GetEntry(buildable.m_iIndex);

	mov	eax, DWORD PTR _buildable$226441[ebp+4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226447[ebp], eax

; 1898 : 				if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226447[ebp], 0
	je	$LN11@LogPossibl

; 1899 : 				{
; 1900 : 					strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226447[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233256[ebp], eax
	cmp	DWORD PTR $T233256[ebp], 0
	je	SHORT $LN84@LogPossibl
	mov	ecx, DWORD PTR $T233256[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN85@LogPossibl
$LN84@LogPossibl:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN85@LogPossibl:

; 1901 : 					strTemp.Format("Building, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$233270[ebp], 0
	mov	DWORD PTR _elem$233270[ebp+4], 0
	mov	DWORD PTR _elem$233270[ebp+8], 0
	mov	DWORD PTR _elem$233270[ebp+12], 0
	mov	edx, DWORD PTR _iI$226437[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _elem$233270[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$233270[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _elem$233270[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _elem$233270[ebp+12], eax
	mov	ecx, DWORD PTR _elem$233270[ebp+12]
	mov	DWORD PTR $T233278[ebp], ecx
	mov	edx, DWORD PTR _buildable$226441[ebp+8]
	push	edx
	mov	eax, DWORD PTR $T233278[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BF@HFOGPLHO@Building?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$226427[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN11@LogPossibl:

; 1902 : 				}
; 1903 : 			}
; 1904 : 			break;

	jmp	$LN13@LogPossibl
$LN10@LogPossibl:

; 1905 : 			case CITY_BUILDABLE_UNIT:
; 1906 : 			{
; 1907 : 				CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	mov	edx, DWORD PTR _buildable$226441[ebp+4]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226451[ebp], eax

; 1908 : 				if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226451[ebp], 0
	je	$LN9@LogPossibl

; 1909 : 				{
; 1910 : 					strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226451[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233290[ebp], eax
	cmp	DWORD PTR $T233290[ebp], 0
	je	SHORT $LN100@LogPossibl
	mov	eax, DWORD PTR $T233290[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN101@LogPossibl
$LN100@LogPossibl:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN101@LogPossibl:

; 1911 : 					strTemp.Format("Unit, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$233304[ebp], 0
	mov	DWORD PTR _elem$233304[ebp+4], 0
	mov	DWORD PTR _elem$233304[ebp+8], 0
	mov	DWORD PTR _elem$233304[ebp+12], 0
	mov	ecx, DWORD PTR _iI$226437[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$233304[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$233304[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$233304[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$233304[ebp+12], edx
	mov	eax, DWORD PTR _elem$233304[ebp+12]
	mov	DWORD PTR $T233312[ebp], eax
	mov	ecx, DWORD PTR _buildable$226441[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T233312[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BB@IFOCDAEE@Unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$226427[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN9@LogPossibl:

; 1912 : 				}
; 1913 : 			}
; 1914 : 			break;

	jmp	$LN13@LogPossibl
$LN8@LogPossibl:

; 1915 : 			case CITY_BUILDABLE_PROJECT:
; 1916 : 			{
; 1917 : 				CvProjectEntry* pEntry = GC.GetGameProjects()->GetEntry(buildable.m_iIndex);

	mov	ecx, DWORD PTR _buildable$226441[ebp+4]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ; CvProjectXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226455[ebp], eax

; 1918 : 				if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226455[ebp], 0
	je	$LN7@LogPossibl

; 1919 : 				{
; 1920 : 					strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226455[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233324[ebp], eax
	cmp	DWORD PTR $T233324[ebp], 0
	je	SHORT $LN116@LogPossibl
	mov	edx, DWORD PTR $T233324[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN117@LogPossibl
$LN116@LogPossibl:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN117@LogPossibl:

; 1921 : 					strTemp.Format("Project, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$233338[ebp], 0
	mov	DWORD PTR _elem$233338[ebp+4], 0
	mov	DWORD PTR _elem$233338[ebp+8], 0
	mov	DWORD PTR _elem$233338[ebp+12], 0
	mov	eax, DWORD PTR _iI$226437[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _elem$233338[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _elem$233338[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _elem$233338[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _elem$233338[ebp+12], ecx
	mov	edx, DWORD PTR _elem$233338[ebp+12]
	mov	DWORD PTR $T233346[ebp], edx
	mov	eax, DWORD PTR _buildable$226441[ebp+8]
	push	eax
	mov	ecx, DWORD PTR $T233346[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BE@EJIMFEEB@Project?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
	lea	edx, DWORD PTR _strTemp$226427[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN7@LogPossibl:

; 1922 : 				}
; 1923 : 			}
; 1924 : 			break;

	jmp	$LN13@LogPossibl
$LN6@LogPossibl:

; 1925 : 			case CITY_BUILDABLE_PROCESS:
; 1926 : 			{
; 1927 : 				CvProcessInfo* pProcess = GC.getProcessInfo((ProcessTypes)buildable.m_iIndex);

	mov	eax, DWORD PTR _buildable$226441[ebp+4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z ; CvGlobals::getProcessInfo
	mov	DWORD PTR _pProcess$226459[ebp], eax

; 1928 : 				if (pProcess != NULL)

	cmp	DWORD PTR _pProcess$226459[ebp], 0
	je	$LN5@LogPossibl

; 1929 : 				{
; 1930 : 					strDesc = pProcess->GetDescription();

	mov	ecx, DWORD PTR _pProcess$226459[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233358[ebp], eax
	cmp	DWORD PTR $T233358[ebp], 0
	je	SHORT $LN132@LogPossibl
	mov	ecx, DWORD PTR $T233358[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN133@LogPossibl
$LN132@LogPossibl:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN133@LogPossibl:

; 1931 : 					strTemp.Format("Process, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$233372[ebp], 0
	mov	DWORD PTR _elem$233372[ebp+4], 0
	mov	DWORD PTR _elem$233372[ebp+8], 0
	mov	DWORD PTR _elem$233372[ebp+12], 0
	mov	edx, DWORD PTR _iI$226437[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _elem$233372[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$233372[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _elem$233372[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _elem$233372[ebp+12], eax
	mov	ecx, DWORD PTR _elem$233372[ebp+12]
	mov	DWORD PTR $T233380[ebp], ecx
	mov	edx, DWORD PTR _buildable$226441[ebp+8]
	push	edx
	mov	eax, DWORD PTR $T233380[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BE@JJFOFBD@Process?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$226427[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN5@LogPossibl:

; 1932 : 				}
; 1933 : 			}
; 1934 : 			break;

	jmp	$LN13@LogPossibl
$LN4@LogPossibl:

; 1935 : 			case CITY_BUILDABLE_UNIT_FOR_OPERATION:
; 1936 : 			{
; 1937 : 				CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	mov	edx, DWORD PTR _buildable$226441[ebp+4]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226464[ebp], eax

; 1938 : 				if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226464[ebp], 0
	je	$LN3@LogPossibl

; 1939 : 				{
; 1940 : 					strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226464[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233392[ebp], eax
	cmp	DWORD PTR $T233392[ebp], 0
	je	SHORT $LN148@LogPossibl
	mov	eax, DWORD PTR $T233392[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN149@LogPossibl
$LN148@LogPossibl:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN149@LogPossibl:

; 1941 : 					strTemp.Format("Operation unit, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$233406[ebp], 0
	mov	DWORD PTR _elem$233406[ebp+4], 0
	mov	DWORD PTR _elem$233406[ebp+8], 0
	mov	DWORD PTR _elem$233406[ebp+12], 0
	mov	ecx, DWORD PTR _iI$226437[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$233406[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$233406[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$233406[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$233406[ebp+12], edx
	mov	eax, DWORD PTR _elem$233406[ebp+12]
	mov	DWORD PTR $T233414[ebp], eax
	mov	ecx, DWORD PTR _buildable$226441[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T233414[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BL@DOEGPDA@Operation?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$226427[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN3@LogPossibl:

; 1942 : 				}
; 1943 : 			}
; 1944 : 			break;

	jmp	$LN13@LogPossibl
$LN2@LogPossibl:

; 1945 : 			case CITY_BUILDABLE_UNIT_FOR_ARMY:
; 1946 : 			{
; 1947 : 				CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	mov	ecx, DWORD PTR _buildable$226441[ebp+4]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226468[ebp], eax

; 1948 : 				if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226468[ebp], 0
	je	$LN13@LogPossibl

; 1949 : 				{
; 1950 : 					strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226468[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233426[ebp], eax
	cmp	DWORD PTR $T233426[ebp], 0
	je	SHORT $LN164@LogPossibl
	mov	edx, DWORD PTR $T233426[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN165@LogPossibl
$LN164@LogPossibl:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN165@LogPossibl:

; 1951 : 					strTemp.Format("Army unit, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	mov	DWORD PTR _elem$233440[ebp], 0
	mov	DWORD PTR _elem$233440[ebp+4], 0
	mov	DWORD PTR _elem$233440[ebp+8], 0
	mov	DWORD PTR _elem$233440[ebp+12], 0
	mov	eax, DWORD PTR _iI$226437[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _elem$233440[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _elem$233440[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _elem$233440[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _elem$233440[ebp+12], ecx
	mov	edx, DWORD PTR _elem$233440[ebp+12]
	mov	DWORD PTR $T233448[ebp], edx
	mov	eax, DWORD PTR _buildable$226441[ebp+8]
	push	eax
	mov	ecx, DWORD PTR $T233448[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BG@LJHGAMDH@Army?5unit?0?5?$CFs?0?5?$CFd?0?5?$CFd?$AA@
	lea	edx, DWORD PTR _strTemp$226427[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN13@LogPossibl:

; 1952 : 				}
; 1953 : 			}
; 1954 : 			break;
; 1955 : 			}
; 1956 : 			strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226427[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226426[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233154[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv406[ebp], eax
	mov	eax, DWORD PTR tv406[ebp]
	mov	DWORD PTR $T233455[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T233455[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226425[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233154[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1957 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226425[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233459[ebp], eax
	mov	ecx, DWORD PTR $T233459[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226432[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226432[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 1958 : 		}

	jmp	$LN16@LogPossibl
$LN15@LogPossibl:

; 1959 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _cityName$226429[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226428[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226427[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226426[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226425[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@LogPossibl:

; 1960 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN200@LogPossibl:
	DD	$LN12@LogPossibl
	DD	$LN10@LogPossibl
	DD	$LN8@LogPossibl
	DD	$LN6@LogPossibl
	DD	$LN4@LogPossibl
	DD	$LN2@LogPossibl
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$226425[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$226426[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$226427[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$226428[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _cityName$226429[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strDesc$226430[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T233149[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T233150[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T233151[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR $T233152[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR $T233153[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$11:
	lea	ecx, DWORD PTR $T233154[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-620]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ ENDP	; CvCityStrategyAI::LogPossibleBuilds
PUBLIC	??_C@_0CN@LNEGKJCA@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Do?5not?5rus@ ; `string'
PUBLIC	??_C@_0DC@MAPDDKOP@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Rush?5if?5po@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getSeed@CvRandom@@QBEKXZ:PROC			; CvRandom::getSeed
EXTRN	?getJonRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getJonRand
;	COMDAT ??_C@_0CN@LNEGKJCA@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Do?5not?5rus@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CN@LNEGKJCA@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Do?5not?5rus@ DB 'S'
	DB	'EED: %d, CHOSEN: %s, Do not rush, TURNS: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MAPDDKOP@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Rush?5if?5po@
CONST	SEGMENT
??_C@_0DC@MAPDDKOP@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Rush?5if?5po@ DB 'S'
	DB	'EED: %d, CHOSEN: %s, Rush if possible, TURNS: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
_TEXT	SEGMENT
tv338 = -480						; size = 4
tv173 = -476						; size = 4
tv330 = -472						; size = 4
tv349 = -468						; size = 4
tv328 = -464						; size = 4
tv360 = -460						; size = 4
tv326 = -456						; size = 4
tv371 = -452						; size = 4
tv382 = -448						; size = 4
tv145 = -444						; size = 4
tv393 = -440						; size = 4
_this$ = -436						; size = 4
$T233627 = -432						; size = 4
$T233623 = -428						; size = 4
$T233619 = -424						; size = 4
$T233615 = -420						; size = 4
$T233611 = -416						; size = 4
$T233602 = -412						; size = 4
$T233593 = -408						; size = 4
$T233584 = -404						; size = 4
$T233575 = -400						; size = 4
$T233567 = -396						; size = 4
$T233566 = -392						; size = 4
$T233558 = -388						; size = 4
$T233554 = -384						; size = 4
$T233548 = -380						; size = 4
$T233544 = -376						; size = 4
$T233499 = -372						; size = 28
$T233498 = -344						; size = 28
$T233497 = -316						; size = 28
$T233496 = -288						; size = 28
$T233495 = -260						; size = 28
$T233494 = -232						; size = 28
_pEntry$226504 = -204					; size = 4
_pEntry$226501 = -200					; size = 4
_pEntry$226498 = -196					; size = 4
_pEntry$226495 = -192					; size = 4
_strOutBuf$226478 = -188				; size = 28
_playerName$226481 = -160				; size = 28
_cityName$226482 = -132					; size = 28
_strDesc$226483 = -104					; size = 28
_pLog$226485 = -76					; size = 4
_strTemp$226480 = -72					; size = 28
_strBaseString$226479 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_buildable$ = 8						; size = 12
_bRush$ = 20						; size = 1
?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z PROC ; CvCityStrategyAI::LogCityProduction, COMDAT
; _this$ = ecx

; 1968 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1969 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN14@LogCityPro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN14@LogCityPro

; 1970 : 	{
; 1971 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226478[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1972 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226479[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1973 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226480[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1974 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226481[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1975 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226482[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1976 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1977 : 
; 1978 : 		// Find the name of this civ and city
; 1979 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233544[ebp], ecx
	mov	edx, DWORD PTR $T233544[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233548[ebp], edx
	mov	ecx, DWORD PTR $T233548[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233554[ebp], eax
	cmp	DWORD PTR $T233554[ebp], 0
	je	SHORT $LN53@LogCityPro
	mov	eax, DWORD PTR $T233554[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226481[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN54@LogCityPro
$LN53@LogCityPro:
	lea	ecx, DWORD PTR _playerName$226481[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN54@LogCityPro:

; 1980 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T233494[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv393[ebp], eax
	mov	eax, DWORD PTR tv393[ebp]
	mov	DWORD PTR $T233558[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T233558[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cityName$226482[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233494[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1981 : 
; 1982 : 		FILogFile* pLog;
; 1983 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv145[ebp], eax
	lea	edx, DWORD PTR _cityName$226482[ebp]
	push	edx
	lea	eax, DWORD PTR _playerName$226481[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233495[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv382[ebp], eax
	mov	edx, DWORD PTR tv382[ebp]
	mov	DWORD PTR $T233566[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233566[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233567[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T233567[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv145[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226485[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233495[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1984 : 
; 1985 : 		// Get the leading info for this line
; 1986 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233575[ebp], ecx
	mov	ecx, DWORD PTR $T233575[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226479[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1987 : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226481[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233496[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv371[ebp], eax
	mov	edx, DWORD PTR tv371[ebp]
	mov	DWORD PTR tv326[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	eax, DWORD PTR _cityName$226482[ebp]
	push	eax
	mov	ecx, DWORD PTR tv326[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233497[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv360[ebp], eax
	mov	eax, DWORD PTR tv360[ebp]
	mov	DWORD PTR tv328[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv328[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233498[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv349[ebp], eax
	mov	eax, DWORD PTR tv349[ebp]
	mov	DWORD PTR tv330[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR tv330[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$226479[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T233498[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T233497[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233496[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1988 : 
; 1989 : 		switch(buildable.m_eBuildableType)

	mov	edx, DWORD PTR _buildable$[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR tv173[ebp]
	sub	eax, 1
	mov	DWORD PTR tv173[ebp], eax
	cmp	DWORD PTR tv173[ebp], 5
	ja	$LN11@LogCityPro
	mov	ecx, DWORD PTR tv173[ebp]
	jmp	DWORD PTR $LN119@LogCityPro[ecx*4]
$LN10@LogCityPro:

; 1990 : 		{
; 1991 : 		case CITY_BUILDABLE_BUILDING:
; 1992 : 		{
; 1993 : 			CvBuildingEntry* pEntry = GC.GetGameBuildings()->GetEntry(buildable.m_iIndex);

	mov	edx, DWORD PTR _buildable$[ebp+4]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226495[ebp], eax

; 1994 : 			if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226495[ebp], 0
	je	SHORT $LN9@LogCityPro

; 1995 : 			{
; 1996 : 				strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226495[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233584[ebp], eax
	cmp	DWORD PTR $T233584[ebp], 0
	je	SHORT $LN71@LogCityPro
	mov	eax, DWORD PTR $T233584[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN9@LogCityPro
$LN71@LogCityPro:
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN9@LogCityPro:

; 1997 : 			}
; 1998 : 		}
; 1999 : 		break;

	jmp	$LN11@LogCityPro
$LN8@LogCityPro:

; 2000 : 		case CITY_BUILDABLE_UNIT:
; 2001 : 		case CITY_BUILDABLE_UNIT_FOR_OPERATION:
; 2002 : 		case CITY_BUILDABLE_UNIT_FOR_ARMY:
; 2003 : 		{
; 2004 : 			CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	mov	ecx, DWORD PTR _buildable$[ebp+4]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226498[ebp], eax

; 2005 : 			if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226498[ebp], 0
	je	SHORT $LN7@LogCityPro

; 2006 : 			{
; 2007 : 				strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226498[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233593[ebp], eax
	cmp	DWORD PTR $T233593[ebp], 0
	je	SHORT $LN77@LogCityPro
	mov	edx, DWORD PTR $T233593[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN7@LogCityPro
$LN77@LogCityPro:
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN7@LogCityPro:

; 2008 : 
; 2009 : 			}
; 2010 : 		}
; 2011 : 		break;

	jmp	$LN11@LogCityPro
$LN6@LogCityPro:

; 2012 : 		case CITY_BUILDABLE_PROJECT:
; 2013 : 		{
; 2014 : 			CvProjectEntry* pEntry = GC.GetGameProjects()->GetEntry(buildable.m_iIndex);

	mov	eax, DWORD PTR _buildable$[ebp+4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ; CvProjectXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$226501[ebp], eax

; 2015 : 			if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$226501[ebp], 0
	je	SHORT $LN5@LogCityPro

; 2016 : 			{
; 2017 : 				strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226501[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233602[ebp], eax
	cmp	DWORD PTR $T233602[ebp], 0
	je	SHORT $LN83@LogCityPro
	mov	ecx, DWORD PTR $T233602[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN5@LogCityPro
$LN83@LogCityPro:
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN5@LogCityPro:

; 2018 : 
; 2019 : 			}
; 2020 : 		}
; 2021 : 		break;

	jmp	SHORT $LN11@LogCityPro
$LN4@LogCityPro:

; 2022 : 		case CITY_BUILDABLE_PROCESS:
; 2023 : 		{
; 2024 : 			CvProcessInfo* pEntry = GC.getProcessInfo((ProcessTypes)buildable.m_iIndex);

	mov	edx, DWORD PTR _buildable$[ebp+4]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z ; CvGlobals::getProcessInfo
	mov	DWORD PTR _pEntry$226504[ebp], eax

; 2025 : 			if (pEntry != NULL)

	cmp	DWORD PTR _pEntry$226504[ebp], 0
	je	SHORT $LN11@LogCityPro

; 2026 : 			{
; 2027 : 				strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$226504[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233611[ebp], eax
	cmp	DWORD PTR $T233611[ebp], 0
	je	SHORT $LN89@LogCityPro
	mov	eax, DWORD PTR $T233611[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN11@LogCityPro
$LN89@LogCityPro:
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN11@LogCityPro:

; 2028 : 			}
; 2029 : 		}
; 2030 : 		break;
; 2031 : 		}
; 2032 : 
; 2033 : 		if(bRush)

	movzx	ecx, BYTE PTR _bRush$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@LogCityPro

; 2034 : 		{
; 2035 : 			strTemp.Format("SEED: %d, CHOSEN: %s, Rush if possible, TURNS: %d", GC.getGame().getJonRand().getSeed(), strDesc.c_str(), buildable.m_iTurnsToConstruct);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233615[ebp], edx
	mov	eax, DWORD PTR _buildable$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR $T233615[ebp]
	call	?getJonRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getJonRand
	mov	ecx, eax
	call	?getSeed@CvRandom@@QBEKXZ		; CvRandom::getSeed
	push	eax
	push	OFFSET ??_C@_0DC@MAPDDKOP@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Rush?5if?5po@
	lea	ecx, DWORD PTR _strTemp$226480[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2036 : 		}
; 2037 : 		else

	jmp	SHORT $LN1@LogCityPro
$LN2@LogCityPro:

; 2038 : 		{
; 2039 : 			strTemp.Format("SEED: %d, CHOSEN: %s, Do not rush, TURNS: %d", GC.getGame().getJonRand().getSeed(), strDesc.c_str(), buildable.m_iTurnsToConstruct);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233619[ebp], edx
	mov	eax, DWORD PTR _buildable$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR $T233619[ebp]
	call	?getJonRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getJonRand
	mov	ecx, eax
	call	?getSeed@CvRandom@@QBEKXZ		; CvRandom::getSeed
	push	eax
	push	OFFSET ??_C@_0CN@LNEGKJCA@SEED?3?5?$CFd?0?5CHOSEN?3?5?$CFs?0?5Do?5not?5rus@
	lea	ecx, DWORD PTR _strTemp$226480[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN1@LogCityPro:

; 2040 : 		}
; 2041 : 
; 2042 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$226480[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$226479[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233499[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv338[ebp], eax
	mov	edx, DWORD PTR tv338[ebp]
	mov	DWORD PTR $T233623[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T233623[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226478[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233499[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2043 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226478[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233627[ebp], eax
	mov	eax, DWORD PTR $T233627[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226485[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226485[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 2044 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _cityName$226482[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$226481[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$226480[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$226479[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$226478[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@LogCityPro:

; 2045 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN119@LogCityPro:
	DD	$LN10@LogCityPro
	DD	$LN8@LogCityPro
	DD	$LN6@LogCityPro
	DD	$LN4@LogCityPro
	DD	$LN8@LogCityPro
	DD	$LN8@LogCityPro
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226478[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226479[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$2:
	lea	ecx, DWORD PTR _strTemp$226480[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$3:
	lea	ecx, DWORD PTR _playerName$226481[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$4:
	lea	ecx, DWORD PTR _cityName$226482[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$5:
	lea	ecx, DWORD PTR _strDesc$226483[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$6:
	lea	ecx, DWORD PTR $T233494[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$7:
	lea	ecx, DWORD PTR $T233495[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$8:
	lea	ecx, DWORD PTR $T233496[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$9:
	lea	ecx, DWORD PTR $T233497[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$10:
	lea	ecx, DWORD PTR $T233498[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$11:
	lea	ecx, DWORD PTR $T233499[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z ENDP ; CvCityStrategyAI::LogCityProduction
PUBLIC	??_C@_0CC@DKMMOBEI@NEW?5SPECIALIZATION?3?5Yield?5Type?5?$DN@ ; `string'
PUBLIC	??_C@_0BA@CMNFFBKM@General?5Economy?$AA@	; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CC@DKMMOBEI@NEW?5SPECIALIZATION?3?5Yield?5Type?5?$DN@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CC@DKMMOBEI@NEW?5SPECIALIZATION?3?5Yield?5Type?5?$DN@ DB 'NEW SPEC'
	DB	'IALIZATION: Yield Type = ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CMNFFBKM@General?5Economy?$AA@
CONST	SEGMENT
??_C@_0BA@CMNFFBKM@General?5Economy?$AA@ DB 'General Economy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
tv258 = -428						; size = 4
tv290 = -424						; size = 4
tv357 = -420						; size = 4
tv318 = -416						; size = 4
tv253 = -412						; size = 4
tv301 = -408						; size = 4
tv251 = -404						; size = 4
tv316 = -400						; size = 4
tv249 = -396						; size = 4
tv355 = -392						; size = 4
tv89 = -388						; size = 4
tv94 = -384						; size = 4
tv269 = -380						; size = 4
_this$ = -376						; size = 4
$T233762 = -372						; size = 4
$T233742 = -368						; size = 4
$T233716 = -364						; size = 4
$T233704 = -360						; size = 4
$T233703 = -356						; size = 4
$T233699 = -352						; size = 4
$T233690 = -348						; size = 4
$T233686 = -344						; size = 4
$T233666 = -340						; size = 28
$T233665 = -312						; size = 28
$T233664 = -284						; size = 28
$T233663 = -256						; size = 28
$T233662 = -228						; size = 28
_pYieldInfo$226534 = -200				; size = 4
_eYieldType$226529 = -196				; size = 4
_strYieldString$226530 = -192				; size = 28
_strTemp$226536 = -164					; size = 28
_playerName$226517 = -136				; size = 28
_cityName$226518 = -108					; size = 28
_strOutBuf$226526 = -80					; size = 28
_pCitySpecializationInfo$226527 = -52			; size = 4
_pLog$226520 = -48					; size = 4
_strBaseString$226522 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eSpecialization$ = 8					; size = 4
?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::LogSpecializationChange, COMDAT
; _this$ = ecx

; 2048 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 416				; 000001a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2049 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN6@LogSpecial
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@LogSpecial

; 2050 : 	{
; 2051 : 		// Find the name of this civ and city
; 2052 : 		CvString playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233686[ebp], ecx
	mov	edx, DWORD PTR $T233686[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233690[ebp], edx
	mov	ecx, DWORD PTR $T233690[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233699[ebp], eax
	cmp	DWORD PTR $T233699[ebp], 0
	je	SHORT $LN27@LogSpecial
	mov	eax, DWORD PTR $T233699[ebp]
	mov	DWORD PTR tv269[ebp], eax
	jmp	SHORT $LN28@LogSpecial
$LN27@LogSpecial:
	mov	DWORD PTR tv269[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@LogSpecial:
	mov	ecx, DWORD PTR tv269[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$226517[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2053 : 		CvString cityName = m_pCity->getName();

	lea	edx, DWORD PTR _cityName$226518[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2054 : 
; 2055 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv94[ebp], eax
	lea	ecx, DWORD PTR _cityName$226518[ebp]
	push	ecx
	lea	edx, DWORD PTR _playerName$226517[ebp]
	push	edx
	lea	eax, DWORD PTR $T233662[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv89[ebp], eax
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T233703[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T233703[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233704[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T233704[ebp]
	push	edx
	mov	eax, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226520[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T233662[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2056 : 
; 2057 : 		// Get the leading info for this line
; 2058 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226522[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2059 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233716[ebp], ecx
	mov	ecx, DWORD PTR $T233716[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$226522[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2060 : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$226517[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233663[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv355[ebp], eax
	mov	edx, DWORD PTR tv355[ebp]
	mov	DWORD PTR tv249[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	eax, DWORD PTR _cityName$226518[ebp]
	push	eax
	mov	ecx, DWORD PTR tv249[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233664[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv316[ebp], eax
	mov	eax, DWORD PTR tv316[ebp]
	mov	DWORD PTR tv251[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv251[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233665[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv301[ebp], eax
	mov	eax, DWORD PTR tv301[ebp]
	mov	DWORD PTR tv253[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR tv253[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$226522[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233665[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233664[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233663[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2061 : 
; 2062 : 		CvString strOutBuf = strBaseString;

	lea	edx, DWORD PTR _strBaseString$226522[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$226526[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 2063 : 
; 2064 : 		CvCitySpecializationXMLEntry* pCitySpecializationInfo = GC.getCitySpecializationInfo(eSpecialization);

	mov	eax, DWORD PTR _eSpecialization$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	DWORD PTR _pCitySpecializationInfo$226527[ebp], eax

; 2065 : 		if(pCitySpecializationInfo != NULL)

	cmp	DWORD PTR _pCitySpecializationInfo$226527[ebp], 0
	je	$LN4@LogSpecial

; 2066 : 		{
; 2067 : 			const YieldTypes eYieldType = pCitySpecializationInfo->GetYieldType();

	mov	ecx, DWORD PTR _pCitySpecializationInfo$226527[ebp]
	call	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ ; CvCitySpecializationXMLEntry::GetYieldType
	mov	DWORD PTR _eYieldType$226529[ebp], eax

; 2068 : 
; 2069 : 			CvString strYieldString = "Unknown";

	mov	ecx, OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
	test	ecx, ecx
	je	SHORT $LN45@LogSpecial
	mov	DWORD PTR tv318[ebp], OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
	jmp	SHORT $LN46@LogSpecial
$LN45@LogSpecial:
	mov	DWORD PTR tv318[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@LogSpecial:
	mov	edx, DWORD PTR tv318[ebp]
	push	edx
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 2070 : 			if(eYieldType == NO_YIELD)

	cmp	DWORD PTR _eYieldType$226529[ebp], -1
	jne	SHORT $LN3@LogSpecial

; 2071 : 			{
; 2072 : 				strYieldString = "General Economy";

	mov	eax, OFFSET ??_C@_0BA@CMNFFBKM@General?5Economy?$AA@
	test	eax, eax
	je	SHORT $LN49@LogSpecial
	push	OFFSET ??_C@_0BA@CMNFFBKM@General?5Economy?$AA@
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN50@LogSpecial
$LN49@LogSpecial:
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN50@LogSpecial:

; 2073 : 			}
; 2074 : 			else

	jmp	SHORT $LN2@LogSpecial
$LN3@LogSpecial:

; 2075 : 			{
; 2076 : 				CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYieldType);

	mov	ecx, DWORD PTR _eYieldType$226529[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo
	mov	DWORD PTR _pYieldInfo$226534[ebp], eax

; 2077 : 				if(pYieldInfo != NULL)

	cmp	DWORD PTR _pYieldInfo$226534[ebp], 0
	je	SHORT $LN2@LogSpecial

; 2078 : 				{
; 2079 : 					strYieldString = pYieldInfo->GetDescription();

	mov	ecx, DWORD PTR _pYieldInfo$226534[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233742[ebp], eax
	cmp	DWORD PTR $T233742[ebp], 0
	je	SHORT $LN55@LogSpecial
	mov	edx, DWORD PTR $T233742[ebp]
	push	edx
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN2@LogSpecial
$LN55@LogSpecial:
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN2@LogSpecial:

; 2080 : 				}
; 2081 : 			}
; 2082 : 
; 2083 : 			CvString strTemp = "NEW SPECIALIZATION: Yield Type = ";

	mov	eax, OFFSET ??_C@_0CC@DKMMOBEI@NEW?5SPECIALIZATION?3?5Yield?5Type?5?$DN@
	test	eax, eax
	je	SHORT $LN60@LogSpecial
	mov	DWORD PTR tv357[ebp], OFFSET ??_C@_0CC@DKMMOBEI@NEW?5SPECIALIZATION?3?5Yield?5Type?5?$DN@
	jmp	SHORT $LN61@LogSpecial
$LN60@LogSpecial:
	mov	DWORD PTR tv357[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN61@LogSpecial:
	mov	ecx, DWORD PTR tv357[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226536[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 2084 : 			strOutBuf += strTemp + strYieldString;

	lea	edx, DWORD PTR _strYieldString$226530[ebp]
	push	edx
	lea	eax, DWORD PTR _strTemp$226536[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233666[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv290[ebp], eax
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR tv258[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	eax, DWORD PTR tv258[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226526[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T233666[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2085 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _strTemp$226536[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@LogSpecial:

; 2086 : 
; 2087 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226526[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233762[ebp], eax
	mov	ecx, DWORD PTR $T233762[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226520[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226520[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 2088 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strOutBuf$226526[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strBaseString$226522[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cityName$226518[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _playerName$226517[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@LogSpecial:

; 2089 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$0:
	lea	ecx, DWORD PTR _playerName$226517[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$1:
	lea	ecx, DWORD PTR _cityName$226518[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$2:
	lea	ecx, DWORD PTR $T233662[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$3:
	lea	ecx, DWORD PTR _strBaseString$226522[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$4:
	lea	ecx, DWORD PTR $T233663[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$5:
	lea	ecx, DWORD PTR $T233664[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$6:
	lea	ecx, DWORD PTR $T233665[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$7:
	lea	ecx, DWORD PTR _strOutBuf$226526[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$8:
	lea	ecx, DWORD PTR _strYieldString$226530[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$9:
	lea	ecx, DWORD PTR _strTemp$226536[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$10:
	lea	ecx, DWORD PTR $T233666[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-420]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::LogSpecializationChange
EXTRN	___libm_sse2_pow:PROC
; Function compile flags: /Odtp
;	COMDAT ?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z
_TEXT	SEGMENT
$T233794 = -32						; size = 4
$T233790 = -28						; size = 4
_fAdditionalTurnCostFactor$ = -24			; size = 8
_fWeightDivisor$ = -16					; size = 8
_fTotalCostFactor$ = -8					; size = 8
_iOriginalWeight$ = 8					; size = 4
_iTurnsLeft$ = 12					; size = 4
?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z PROC ; CityStrategyAIHelpers::ReweightByTurnsLeft, COMDAT

; 2100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2101 : 	// 10 turns will add 0.02; 80 turns will add 0.16
; 2102 : 	double fAdditionalTurnCostFactor = GC.getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT() * iTurnsLeft;	// 0.004

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8000
	movss	DWORD PTR $T233790[ebp], xmm0
	cvtsi2ss xmm0, DWORD PTR _iTurnsLeft$[ebp]
	mulss	xmm0, DWORD PTR $T233790[ebp]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _fAdditionalTurnCostFactor$[ebp], xmm0

; 2103 : 	double fTotalCostFactor = GC.getAI_PRODUCTION_WEIGHT_BASE_MOD() + fAdditionalTurnCostFactor;	// 0.15

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8004
	movss	DWORD PTR $T233794[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T233794[ebp]
	addsd	xmm0, QWORD PTR _fAdditionalTurnCostFactor$[ebp]
	movsd	QWORD PTR _fTotalCostFactor$[ebp], xmm0

; 2104 : 	double fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);

	cvtsi2sd xmm0, DWORD PTR _iTurnsLeft$[ebp]
	movsd	xmm1, QWORD PTR _fTotalCostFactor$[ebp]
	call	___libm_sse2_pow
	movsd	QWORD PTR _fWeightDivisor$[ebp], xmm0

; 2105 : 
; 2106 : 	/* Commented out for now: useful debug code for tweaking the exact effect of this function
; 2107 : 
; 2108 : 	iTurnsLeft = 10;
; 2109 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2110 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2111 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2112 : 
; 2113 : 	iTurnsLeft = 20;
; 2114 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2115 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2116 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2117 : 
; 2118 : 	iTurnsLeft = 40;
; 2119 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2120 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2121 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2122 : 
; 2123 : 	iTurnsLeft = 80;
; 2124 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2125 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2126 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);*/
; 2127 : 
; 2128 : 	return int(double(iOriginalWeight) / fWeightDivisor);

	cvtsi2sd xmm0, DWORD PTR _iOriginalWeight$[ebp]
	divsd	xmm0, QWORD PTR _fWeightDivisor$[ebp]
	cvttsd2si eax, xmm0

; 2129 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ENDP ; CityStrategyAIHelpers::ReweightByTurnsLeft
_TEXT	ENDS
PUBLIC	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
; Function compile flags: /Odtp
;	COMDAT ?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T233814 = -32						; size = 4
$T233810 = -28						; size = 4
$T233801 = -24						; size = 4
_iStrategyFlavorMod$226559 = -20			; size = 4
_iPersonalityFlavor$226558 = -16			; size = 4
_eFlavor$226556 = -12					; size = 4
_iFlavorLoop$226552 = -8				; size = 4
_iWeightThresholdModifier$ = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::GetWeightThresholdModifier, COMDAT

; 2133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2134 : 	int iWeightThresholdModifier = 0;

	mov	DWORD PTR _iWeightThresholdModifier$[ebp], 0

; 2135 : 
; 2136 : 	// Look at all Flavors for the Player & this Strategy
; 2137 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226552[ebp], 0
	jmp	SHORT $LN3@GetWeightT
$LN2@GetWeightT:
	mov	eax, DWORD PTR _iFlavorLoop$226552[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$226552[ebp], eax
$LN3@GetWeightT:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T233801[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$226552[ebp]
	cmp	edx, DWORD PTR $T233801[ebp]
	jge	SHORT $LN1@GetWeightT

; 2138 : 	{
; 2139 : 		FlavorTypes eFlavor = (FlavorTypes) iFlavorLoop;

	mov	eax, DWORD PTR _iFlavorLoop$226552[ebp]
	mov	DWORD PTR _eFlavor$226556[ebp], eax

; 2140 : 		int iPersonalityFlavor = GET_PLAYER(pCity->getOwner()).GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T233810[ebp], edx
	mov	eax, DWORD PTR $T233810[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233814[ebp], eax
	mov	ecx, DWORD PTR _eFlavor$226556[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233814[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iPersonalityFlavor$226558[ebp], eax

; 2141 : 		int iStrategyFlavorMod = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy)->GetPersonalityFlavorThresholdMod(eFlavor);

	mov	edx, DWORD PTR _eFlavor$226556[ebp]
	push	edx
	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	ecx, eax
	call	?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod
	mov	DWORD PTR _iStrategyFlavorMod$226559[ebp], eax

; 2142 : 
; 2143 : 		iWeightThresholdModifier += (iPersonalityFlavor * iStrategyFlavorMod);

	mov	ecx, DWORD PTR _iPersonalityFlavor$226558[ebp]
	imul	ecx, DWORD PTR _iStrategyFlavorMod$226559[ebp]
	add	ecx, DWORD PTR _iWeightThresholdModifier$[ebp]
	mov	DWORD PTR _iWeightThresholdModifier$[ebp], ecx

; 2144 : 	}

	jmp	$LN2@GetWeightT
$LN1@GetWeightT:

; 2145 : 
; 2146 : 	return iWeightThresholdModifier;

	mov	eax, DWORD PTR _iWeightThresholdModifier$[ebp]

; 2147 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::GetWeightThresholdModifier
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T233820 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity, COMDAT

; 2151 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2152 : 	// City Population is too low, don't build Settlers yet
; 2153 : 	if(pCity->getPopulation() < GC.getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD())	// Just size 1

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2320
	mov	DWORD PTR $T233820[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233820[ebp]
	jge	SHORT $LN1@IsTestCity

; 2154 : 	{
; 2155 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity
$LN1@IsTestCity:

; 2156 : 	}
; 2157 : 
; 2158 : 	return false;

	xor	al, al
$LN2@IsTestCity:

; 2159 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T233830 = -8						; size = 4
$T233826 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity, COMDAT

; 2163 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2164 : 	// City Population is too low, don't build Settlers yet
; 2165 : 	if(pCity->getPopulation() >= GC.getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD() &&   // 2 to 4
; 2166 : 	        pCity->getPopulation() < GC.getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2320
	mov	DWORD PTR $T233826[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233826[ebp]
	jl	SHORT $LN1@IsTestCity@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2324
	mov	DWORD PTR $T233830[ebp], ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233830[ebp]
	jge	SHORT $LN1@IsTestCity@2

; 2167 : 	{
; 2168 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@2
$LN1@IsTestCity@2:

; 2169 : 	}
; 2170 : 
; 2171 : 	return false;

	xor	al, al
$LN2@IsTestCity@2:

; 2172 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity
_TEXT	ENDS
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T233840 = -8						; size = 4
$T233836 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity, COMDAT

; 2176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2177 : 	// Never consider the capital to be a medium city (so with late game starts at least one city retains high flavors for SPACESHIP, etc.)
; 2178 : 	if (pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@IsTestCity@3

; 2179 : 	{
; 2180 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsTestCity@3
$LN2@IsTestCity@3:

; 2181 : 	}
; 2182 : 
; 2183 : 	// City Population is getting larger, increase science
; 2184 : 	if(pCity->getPopulation() >= GC.getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD() &&   // 5 to 11
; 2185 : 	        pCity->getPopulation() < GC.getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2324
	mov	DWORD PTR $T233836[ebp], ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233836[ebp]
	jl	SHORT $LN1@IsTestCity@3
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2328
	mov	DWORD PTR $T233840[ebp], edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233840[ebp]
	jge	SHORT $LN1@IsTestCity@3

; 2186 : 	{
; 2187 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@3
$LN1@IsTestCity@3:

; 2188 : 	}
; 2189 : 
; 2190 : 	return false;

	xor	al, al
$LN3@IsTestCity@3:

; 2191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T233846 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity, COMDAT

; 2195 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2196 : 	// City Population is very large, really boost science
; 2197 : 	if(pCity->getPopulation() >= GC.getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD())	// 12+

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2328
	mov	DWORD PTR $T233846[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233846[ebp]
	jl	SHORT $LN1@IsTestCity@4

; 2198 : 	{
; 2199 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@4
$LN1@IsTestCity@4:

; 2200 : 	}
; 2201 : 
; 2202 : 	return false;

	xor	al, al
$LN2@IsTestCity@4:

; 2203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity
_TEXT	ENDS
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked, COMDAT

; 2207 : {

	push	ebp
	mov	ebp, esp

; 2208 : 	// If this City isn't adjacent to a body of water big enough to be "Ocean" then we consider it landlocked
; 2209 : 	if(!pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@5

; 2210 : 	{
; 2211 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@5
$LN1@IsTestCity@5:

; 2212 : 	}
; 2213 : 
; 2214 : 	return false;

	xor	al, al
$LN2@IsTestCity@5:

; 2215 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked
_TEXT	ENDS
PUBLIC	??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@ ; `string'
EXTRN	?getTrainPercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getTrainPercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ:PROC ; CvPlayer::countCitiesFeatureSurrounded
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
;	COMDAT ??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@ DB 'MILITARYAISTRATE'
	DB	'GY_ERADICATE_BARBARIANS', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
tv76 = -80						; size = 4
$T233892 = -76						; size = 4
$T233888 = -72						; size = 4
$T233879 = -68						; size = 4
$T233872 = -64						; size = 4
$T233868 = -60						; size = 4
$T233861 = -56						; size = 4
$T233852 = -52						; size = 4
$T233851 = -48						; size = 4
_iDesperateTurn$226610 = -44				; size = 4
_eStrategyKillBarbs$226600 = -40			; size = 4
_pMilitaryAI$226599 = -36				; size = 4
_iNumCities$226593 = -32				; size = 4
_iCurrentNumCities$ = -28				; size = 4
_iNumWorkers$ = -24					; size = 4
_iLastTurnWorkerDisbanded$ = -20			; size = 4
_pCityStrategy$ = -16					; size = 4
_iModdedNumWorkers$ = -12				; size = 4
_iModdedNumCities$ = -8					; size = 4
_kPlayer$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers, COMDAT

; 2219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2220 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233861[ebp], ecx
	mov	edx, DWORD PTR $T233861[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 2221 : #ifdef AUI_CITYSTRATEGY_DONT_EMPHASIZE_WORKERS_IF_NO_MILITARY
; 2222 : 	if (kPlayer.getNumMilitaryUnits() - kPlayer.GetNumUnitsWithUnitAI(UNITAI_EXPLORE) <= 0)
; 2223 : 	{
; 2224 : 		return false;
; 2225 : 	}
; 2226 : #endif
; 2227 : 	int iCurrentNumCities = kPlayer.getNumCities();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iCurrentNumCities$[ebp], eax

; 2228 : 
; 2229 : 	int iLastTurnWorkerDisbanded = kPlayer.GetEconomicAI()->GetLastTurnWorkerDisbanded();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T233868[ebp], eax
	mov	eax, DWORD PTR $T233868[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _iLastTurnWorkerDisbanded$[ebp], ecx

; 2230 : #ifdef AUI_CITYSTRATEGY_FIX_TILE_IMPROVERS_LAST_DISBAND_WORKER_TURN_SCALE
; 2231 : 	if (iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 25 * GC.getGame().getEstimateEndTurn() / 500)
; 2232 : #else
; 2233 : 	if(iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 25)

	cmp	DWORD PTR _iLastTurnWorkerDisbanded$[ebp], 0
	jl	SHORT $LN12@IsTestCity@6
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233872[ebp], edx
	mov	ecx, DWORD PTR $T233872[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR _iLastTurnWorkerDisbanded$[ebp]
	cmp	eax, 25					; 00000019H
	jg	SHORT $LN12@IsTestCity@6

; 2234 : #endif
; 2235 : 	{
; 2236 : 		return false;

	xor	al, al
	jmp	$LN13@IsTestCity@6
$LN12@IsTestCity@6:

; 2237 : 	}
; 2238 : 
; 2239 : 	int iNumWorkers = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumWorkers$[ebp], eax

; 2240 : 	// If it's a minor with at least 1 worker per city, always return false
; 2241 : 	if(kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@IsTestCity@6

; 2242 : 	{
; 2243 : 		if(iNumWorkers >= iCurrentNumCities)

	mov	ecx, DWORD PTR _iNumWorkers$[ebp]
	cmp	ecx, DWORD PTR _iCurrentNumCities$[ebp]
	jl	SHORT $LN10@IsTestCity@6

; 2244 : 			return false;

	xor	al, al
	jmp	$LN13@IsTestCity@6
$LN10@IsTestCity@6:

; 2245 : 	}
; 2246 : 	else

	jmp	SHORT $LN9@IsTestCity@6
$LN11@IsTestCity@6:

; 2247 : 	{
; 2248 : 		int iNumCities = max(1, (iCurrentNumCities * 3) / 4);

	mov	eax, DWORD PTR _iCurrentNumCities$[ebp]
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR $T233851[ebp], eax
	mov	DWORD PTR $T233852[ebp], 1
	mov	edx, DWORD PTR $T233852[ebp]
	cmp	edx, DWORD PTR $T233851[ebp]
	jge	SHORT $LN27@IsTestCity@6
	lea	eax, DWORD PTR $T233851[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN28@IsTestCity@6
$LN27@IsTestCity@6:
	lea	ecx, DWORD PTR $T233852[ebp]
	mov	DWORD PTR tv76[ebp], ecx
$LN28@IsTestCity@6:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T233879[ebp], edx
	mov	eax, DWORD PTR $T233879[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumCities$226593[ebp], ecx

; 2249 : 		if(iNumWorkers >= iNumCities)

	mov	edx, DWORD PTR _iNumWorkers$[ebp]
	cmp	edx, DWORD PTR _iNumCities$226593[ebp]
	jl	SHORT $LN8@IsTestCity@6

; 2250 : 			return false;

	xor	al, al
	jmp	$LN13@IsTestCity@6
$LN8@IsTestCity@6:

; 2251 : 		// If we're losing at war, return false
; 2252 : 		if(kPlayer.GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	SHORT $LN9@IsTestCity@6

; 2253 : 			return false;

	xor	al, al
	jmp	$LN13@IsTestCity@6
$LN9@IsTestCity@6:

; 2254 : 	}
; 2255 : 
; 2256 : 	// If we're under attack from Barbs and have 1 or fewer Cities and no credible defense then training more Workers will only hurt us
; 2257 : 	if(iCurrentNumCities <= 1)

	cmp	DWORD PTR _iCurrentNumCities$[ebp], 1
	jg	SHORT $LN6@IsTestCity@6

; 2258 : 	{
; 2259 : 		CvMilitaryAI* pMilitaryAI =kPlayer.GetMilitaryAI();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR _pMilitaryAI$226599[ebp], eax

; 2260 : 		MilitaryAIStrategyTypes eStrategyKillBarbs = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_ERADICATE_BARBARIANS");

	push	0
	push	OFFSET ??_C@_0CI@KLGEGGDE@MILITARYAISTRATEGY_ERADICATE_BAR@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyKillBarbs$226600[ebp], eax

; 2261 : 		if(eStrategyKillBarbs != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyKillBarbs$226600[ebp], -1
	je	SHORT $LN6@IsTestCity@6

; 2262 : 		{
; 2263 : 			if(pMilitaryAI->IsUsingStrategy(eStrategyKillBarbs))

	mov	eax, DWORD PTR _eStrategyKillBarbs$226600[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMilitaryAI$226599[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IsTestCity@6

; 2264 : 			{
; 2265 : 				return false;

	xor	al, al
	jmp	$LN13@IsTestCity@6
$LN6@IsTestCity@6:

; 2266 : 			}
; 2267 : 		}
; 2268 : 	}
; 2269 : 
; 2270 : 	CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	DWORD PTR _pCityStrategy$[ebp], eax

; 2271 : 
; 2272 : 	int iModdedNumWorkers = iNumWorkers* /*67*/ pCityStrategy->GetWeightThreshold() / 100;

	mov	ecx, DWORD PTR _pCityStrategy$[ebp]
	call	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
	imul	eax, DWORD PTR _iNumWorkers$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iModdedNumWorkers$[ebp], eax

; 2273 : 	int iModdedNumCities = iCurrentNumCities + kPlayer.countCitiesFeatureSurrounded();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ ; CvPlayer::countCitiesFeatureSurrounded
	add	eax, DWORD PTR _iCurrentNumCities$[ebp]
	mov	DWORD PTR _iModdedNumCities$[ebp], eax

; 2274 : 
; 2275 : 	// We have fewer than we think we should, or we have none at all
; 2276 : 	if(iModdedNumWorkers <= iModdedNumCities || iModdedNumWorkers == 0)

	mov	edx, DWORD PTR _iModdedNumWorkers$[ebp]
	cmp	edx, DWORD PTR _iModdedNumCities$[ebp]
	jle	SHORT $LN2@IsTestCity@6
	cmp	DWORD PTR _iModdedNumWorkers$[ebp], 0
	jne	SHORT $LN3@IsTestCity@6
$LN2@IsTestCity@6:

; 2277 : 	{
; 2278 : 		// If we don't have any Workers by turn 30 we really need to get moving
; 2279 : 		int iDesperateTurn = /*30*/ GC.getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2340
	mov	DWORD PTR _iDesperateTurn$226610[ebp], eax

; 2280 : 
; 2281 : 		iDesperateTurn *= GC.getGame().getGameSpeedInfo().getTrainPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233888[ebp], ecx
	mov	ecx, DWORD PTR $T233888[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getTrainPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getTrainPercent
	imul	eax, DWORD PTR _iDesperateTurn$226610[ebp]
	mov	DWORD PTR _iDesperateTurn$226610[ebp], eax

; 2282 : 		iDesperateTurn /= 100;

	mov	eax, DWORD PTR _iDesperateTurn$226610[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iDesperateTurn$226610[ebp], eax

; 2283 : 
; 2284 : 		if(GC.getGame().getElapsedGameTurns() > iDesperateTurn)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233892[ebp], edx
	mov	ecx, DWORD PTR $T233892[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, DWORD PTR _iDesperateTurn$226610[ebp]
	jle	SHORT $LN3@IsTestCity@6

; 2285 : 			return true;

	mov	al, 1
	jmp	SHORT $LN13@IsTestCity@6
$LN3@IsTestCity@6:

; 2286 : 	}
; 2287 : 
; 2288 : 	return false;

	xor	al, al
$LN13@IsTestCity@6:

; 2289 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers
_TEXT	ENDS
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T233987 = -144						; size = 4
$T233975 = -140						; size = 4
$T233966 = -136						; size = 4
$T233962 = -132						; size = 4
$T233953 = -128						; size = 4
$T233944 = -124						; size = 4
$T233940 = -120						; size = 4
$T233936 = -116						; size = 4
$T233927 = -112						; size = 4
$T233923 = -108						; size = 4
$T233914 = -104						; size = 4
$T233910 = -100						; size = 4
$T233903 = -96						; size = 4
_pkImprovementInfo$226654 = -92				; size = 4
_eImprovement$226651 = -88				; size = 4
_eBuild$226647 = -84					; size = 4
_pkBuildInfo$226649 = -80				; size = 4
_eCorrectImprovement$226641 = -76			; size = 4
_eCorrectBuild$226642 = -72				; size = 4
_eResource$226639 = -68					; size = 4
_iBuildIndex$226643 = -64				; size = 4
_iPlotLoop$226632 = -60					; size = 4
_iWeightThresholdModifier$226627 = -56			; size = 4
_iNumImprovedResources$226631 = -52			; size = 4
_iPerCityThreshold$226628 = -48				; size = 4
_pLoopPlot$226629 = -44					; size = 4
_iNumResources$226630 = -40				; size = 4
_iNumSettlers$226664 = -36				; size = 4
_pCityStrategy$226626 = -32				; size = 4
_bManyUnimproveResources$226661 = -25			; size = 1
_iMultiplier$226662 = -24				; size = 4
_iNumBuilders$226624 = -20				; size = 4
_iWeightThreshold$226665 = -16				; size = 4
_iNumWorkers$ = -12					; size = 4
_iLastTurnWorkerDisbanded$ = -8				; size = 4
_kPlayer$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers, COMDAT

; 2293 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H

; 2294 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233903[ebp], ecx
	mov	edx, DWORD PTR $T233903[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 2295 : #ifdef AUI_CITYSTRATEGY_DONT_EMPHASIZE_WORKERS_IF_NO_MILITARY
; 2296 : 	if (kPlayer.getNumMilitaryUnits() - kPlayer.GetNumUnitsWithUnitAI(UNITAI_EXPLORE) <= 0)
; 2297 : 	{
; 2298 : 		return false;
; 2299 : 	}
; 2300 : #endif
; 2301 : 	int iLastTurnWorkerDisbanded = kPlayer.GetEconomicAI()->GetLastTurnWorkerDisbanded();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T233910[ebp], eax
	mov	eax, DWORD PTR $T233910[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _iLastTurnWorkerDisbanded$[ebp], ecx

; 2302 : #ifdef AUI_CITYSTRATEGY_FIX_TILE_IMPROVERS_LAST_DISBAND_WORKER_TURN_SCALE
; 2303 : 	if (iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10 * GC.getGame().getEstimateEndTurn() / 500)
; 2304 : #else
; 2305 : 	if(iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10)

	cmp	DWORD PTR _iLastTurnWorkerDisbanded$[ebp], 0
	jl	SHORT $LN41@IsTestCity@7
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233914[ebp], edx
	mov	ecx, DWORD PTR $T233914[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR _iLastTurnWorkerDisbanded$[ebp]
	cmp	eax, 10					; 0000000aH
	jg	SHORT $LN41@IsTestCity@7

; 2306 : #endif
; 2307 : 	{
; 2308 : 		return false;

	xor	al, al
	jmp	$LN27@IsTestCity@7

; 2309 : 	}
; 2310 : 
; 2311 : 	if(!GET_PLAYER(pCity->getOwner()).isMinorCiv())

$LN41@IsTestCity@7:
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233923[ebp], ecx
	mov	edx, DWORD PTR $T233923[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233927[ebp], edx
	mov	ecx, DWORD PTR $T233927[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@IsTestCity@7

; 2312 : 	{
; 2313 : 		// If we're losing at war, return false
; 2314 : 		if(GET_PLAYER(pCity->getOwner()).GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T233936[ebp], edx
	mov	eax, DWORD PTR $T233936[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233940[ebp], eax
	mov	ecx, DWORD PTR $T233940[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	SHORT $LN25@IsTestCity@7

; 2315 : 			return false;

	xor	al, al
	jmp	$LN27@IsTestCity@7
$LN25@IsTestCity@7:

; 2316 : 	}
; 2317 : 
; 2318 : 	int iNumWorkers = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumWorkers$[ebp], eax

; 2319 : 	if(iNumWorkers >= ((kPlayer.getNumCities() *  3) / 2) + 1)

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	imul	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	cmp	DWORD PTR _iNumWorkers$[ebp], eax
	jl	SHORT $LN23@IsTestCity@7

; 2320 : 		return false;

	xor	al, al
	jmp	$LN27@IsTestCity@7
$LN23@IsTestCity@7:

; 2321 : 
; 2322 : 	// If we're under attack from Barbs and have 1 or fewer cities then training more Workers will only hurt us
; 2323 : 	//if (kPlayer.getNumCities() <= 1)
; 2324 : 	//{
; 2325 : 	//	MilitaryAIStrategyTypes eStrategyKillBarbs = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_ERADICATE_BARBARIANS");
; 2326 : 	//	if (eStrategyKillBarbs != NO_MILITARYAISTRATEGY)
; 2327 : 	//	{
; 2328 : 	//		if (GET_PLAYER(pCity->getOwner()).GetMilitaryAI()->IsUsingStrategy(eStrategyKillBarbs))
; 2329 : 	//			return false;
; 2330 : 	//	}
; 2331 : 	//}
; 2332 : 
; 2333 : 	// Don't get desperate for training a Builder here unless the City is at least of a certain size
; 2334 : 	if(pCity->getPopulation() >= /*2*/ GC.getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2344
	mov	DWORD PTR $T233944[ebp], ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR $T233944[ebp]
	jl	$LN22@IsTestCity@7

; 2335 : 	{
; 2336 : 		int iNumBuilders = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumBuilders$226624[ebp], eax

; 2337 : 
; 2338 : 		// If we don't even have 1 builder on map or in a queue, turn this on immediately
; 2339 : 		if(iNumBuilders < 1)

	cmp	DWORD PTR _iNumBuilders$226624[ebp], 1
	jge	SHORT $LN21@IsTestCity@7

; 2340 : 		{
; 2341 : 			return true;

	mov	al, 1
	jmp	$LN27@IsTestCity@7
$LN21@IsTestCity@7:

; 2342 : 		}
; 2343 : 
; 2344 : 		CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	DWORD PTR _pCityStrategy$226626[ebp], eax

; 2345 : 
; 2346 : 		int iWeightThresholdModifier = CityStrategyAIHelpers::GetWeightThresholdModifier(eStrategy, pCity);	// 2 Extra Weight per TILE_IMPROVEMENT Flavor

	mov	eax, DWORD PTR _pCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$226627[ebp], eax

; 2347 : 		int iPerCityThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 40

	mov	ecx, DWORD PTR _pCityStrategy$226626[ebp]
	call	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$226627[ebp]
	mov	DWORD PTR _iPerCityThreshold$226628[ebp], eax

; 2348 : 
; 2349 : 		// Look at all Tiles this City could potentially work to see if there are any Water Resources that could be improved
; 2350 : 		CvPlot* pLoopPlot;
; 2351 : 		int iNumResources = 0;

	mov	DWORD PTR _iNumResources$226630[ebp], 0

; 2352 : 		int iNumImprovedResources = 0;

	mov	DWORD PTR _iNumImprovedResources$226631[ebp], 0

; 2353 : 
; 2354 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$226632[ebp], 0
	jmp	SHORT $LN20@IsTestCity@7
$LN19@IsTestCity@7:
	mov	edx, DWORD PTR _iPlotLoop$226632[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$226632[ebp], edx
$LN20@IsTestCity@7:
	cmp	DWORD PTR _iPlotLoop$226632[ebp], 37	; 00000025H
	jge	$LN18@IsTestCity@7

; 2355 : 		{
; 2356 : 			pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T233953[ebp], ecx
	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T233962[ebp], eax
	mov	ecx, DWORD PTR _iPlotLoop$226632[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233953[ebp]
	push	edx
	mov	eax, DWORD PTR $T233962[ebp]
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$226629[ebp], eax

; 2357 : 
; 2358 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$226629[ebp], 0
	je	$LN17@IsTestCity@7

; 2359 : 			{
; 2360 : 				if(pLoopPlot->getOwner() == pCity->getOwner())

	mov	ecx, DWORD PTR _pLoopPlot$226629[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T233966[ebp], edx
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233975[ebp], ecx
	mov	edx, DWORD PTR $T233966[ebp]
	cmp	edx, DWORD PTR $T233975[ebp]
	jne	$LN17@IsTestCity@7

; 2361 : 				{
; 2362 : 					if(!pLoopPlot->isWater())

	mov	eax, DWORD PTR _pLoopPlot$226629[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN17@IsTestCity@7

; 2363 : 					{
; 2364 : 						ResourceTypes eResource = pLoopPlot->getResourceType(kPlayer.getTeam());

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233987[ebp], eax
	mov	eax, DWORD PTR $T233987[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$226629[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$226639[ebp], eax

; 2365 : 						if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$226639[ebp], -1
	jne	SHORT $LN14@IsTestCity@7

; 2366 : 						{
; 2367 : 							continue;

	jmp	$LN19@IsTestCity@7
$LN14@IsTestCity@7:

; 2368 : 						}
; 2369 : 
; 2370 : 						// loop through the build types to find one that we can use
; 2371 : 						ImprovementTypes eCorrectImprovement = NO_IMPROVEMENT;

	mov	DWORD PTR _eCorrectImprovement$226641[ebp], -1

; 2372 : 						BuildTypes eCorrectBuild = NO_BUILD;

	mov	DWORD PTR _eCorrectBuild$226642[ebp], -1

; 2373 : #ifdef AUI_WARNING_FIXES
; 2374 : 						for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2375 : #else
; 2376 : 						int iBuildIndex;
; 2377 : 						for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$226643[ebp], 0
	jmp	SHORT $LN13@IsTestCity@7
$LN12@IsTestCity@7:
	mov	ecx, DWORD PTR _iBuildIndex$226643[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBuildIndex$226643[ebp], ecx
$LN13@IsTestCity@7:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$226643[ebp], eax
	jge	SHORT $LN11@IsTestCity@7

; 2378 : #endif
; 2379 : 						{
; 2380 : 							const BuildTypes eBuild = static_cast<BuildTypes>(iBuildIndex);

	mov	edx, DWORD PTR _iBuildIndex$226643[ebp]
	mov	DWORD PTR _eBuild$226647[ebp], edx

; 2381 : 							CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	eax, DWORD PTR _eBuild$226647[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$226649[ebp], eax

; 2382 : 							if(pkBuildInfo)

	cmp	DWORD PTR _pkBuildInfo$226649[ebp], 0
	je	SHORT $LN10@IsTestCity@7

; 2383 : 							{
; 2384 : 								const ImprovementTypes eImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();

	mov	ecx, DWORD PTR _pkBuildInfo$226649[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$226651[ebp], eax

; 2385 : 
; 2386 : 								// if this is the improvement we're looking for
; 2387 : 								if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$226651[ebp], -1
	je	SHORT $LN10@IsTestCity@7

; 2388 : 								{
; 2389 : 									CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$226651[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$226654[ebp], eax

; 2390 : 									if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$226654[ebp], 0
	je	SHORT $LN10@IsTestCity@7

; 2391 : 									{
; 2392 : 										if(pkImprovementInfo->IsImprovementResourceTrade(eResource))

	mov	edx, DWORD PTR _eResource$226639[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkImprovementInfo$226654[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@IsTestCity@7

; 2393 : 										{
; 2394 : 											eCorrectBuild = eBuild;

	mov	ecx, DWORD PTR _eBuild$226647[ebp]
	mov	DWORD PTR _eCorrectBuild$226642[ebp], ecx

; 2395 : 											eCorrectImprovement = eImprovement;

	mov	edx, DWORD PTR _eImprovement$226651[ebp]
	mov	DWORD PTR _eCorrectImprovement$226641[ebp], edx

; 2396 : 											break;

	jmp	SHORT $LN11@IsTestCity@7
$LN10@IsTestCity@7:

; 2397 : 										}
; 2398 : 									}
; 2399 : 								}
; 2400 : 							}
; 2401 : 
; 2402 : 						}

	jmp	SHORT $LN12@IsTestCity@7
$LN11@IsTestCity@7:

; 2403 : 
; 2404 : 						// no valid build found
; 2405 : 						if(eCorrectBuild == NO_BUILD || eCorrectImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eCorrectBuild$226642[ebp], -1
	je	SHORT $LN5@IsTestCity@7
	cmp	DWORD PTR _eCorrectImprovement$226641[ebp], -1
	jne	SHORT $LN6@IsTestCity@7
$LN5@IsTestCity@7:

; 2406 : 						{
; 2407 : 							continue;

	jmp	$LN19@IsTestCity@7
$LN6@IsTestCity@7:

; 2408 : 						}
; 2409 : 
; 2410 : 
; 2411 : 						// if we can't build the improvement for the resource, continue!
; 2412 : 						if(!kPlayer.canBuild(pLoopPlot, eCorrectBuild, false, false))

	push	1
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _eCorrectBuild$226642[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$226629[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@IsTestCity@7

; 2413 : 						{
; 2414 : 							if(pLoopPlot->getImprovementType() == eCorrectImprovement)

	mov	ecx, DWORD PTR _pLoopPlot$226629[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eCorrectImprovement$226641[ebp]
	jne	SHORT $LN3@IsTestCity@7

; 2415 : 							{
; 2416 : 								iNumImprovedResources++;

	mov	eax, DWORD PTR _iNumImprovedResources$226631[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumImprovedResources$226631[ebp], eax

; 2417 : 								iNumResources++;

	mov	ecx, DWORD PTR _iNumResources$226630[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumResources$226630[ebp], ecx
$LN3@IsTestCity@7:

; 2418 : 							}
; 2419 : 
; 2420 : 							continue;

	jmp	$LN19@IsTestCity@7
$LN4@IsTestCity@7:

; 2421 : 						}
; 2422 : 
; 2423 : 						iNumResources++;

	mov	edx, DWORD PTR _iNumResources$226630[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumResources$226630[ebp], edx
$LN17@IsTestCity@7:

; 2424 : 					}
; 2425 : 				}
; 2426 : 			}
; 2427 : 		}

	jmp	$LN19@IsTestCity@7
$LN18@IsTestCity@7:

; 2428 : 
; 2429 : 		bool bManyUnimproveResources = (2 * (iNumResources - iNumImprovedResources)) > iNumResources;

	mov	eax, DWORD PTR _iNumResources$226630[ebp]
	sub	eax, DWORD PTR _iNumImprovedResources$226631[ebp]
	shl	eax, 1
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iNumResources$226630[ebp]
	setg	cl
	mov	BYTE PTR _bManyUnimproveResources$226661[ebp], cl

; 2430 : 		int iMultiplier = kPlayer.getNumCities();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iMultiplier$226662[ebp], eax

; 2431 : 		iMultiplier += kPlayer.countCitiesFeatureSurrounded();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ ; CvPlayer::countCitiesFeatureSurrounded
	add	eax, DWORD PTR _iMultiplier$226662[ebp]
	mov	DWORD PTR _iMultiplier$226662[ebp], eax

; 2432 : 		if(bManyUnimproveResources)

	movzx	edx, BYTE PTR _bManyUnimproveResources$226661[ebp]
	test	edx, edx
	je	SHORT $LN2@IsTestCity@7

; 2433 : 			iMultiplier += 1;

	mov	eax, DWORD PTR _iMultiplier$226662[ebp]
	add	eax, 1
	mov	DWORD PTR _iMultiplier$226662[ebp], eax
$LN2@IsTestCity@7:

; 2434 : 
; 2435 : 		int iNumSettlers = kPlayer.GetNumUnitsWithUnitAI(UNITAI_SETTLE, true, false);

	push	0
	push	1
	push	1
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumSettlers$226664[ebp], eax

; 2436 : 		iMultiplier += iNumSettlers;

	mov	ecx, DWORD PTR _iMultiplier$226662[ebp]
	add	ecx, DWORD PTR _iNumSettlers$226664[ebp]
	mov	DWORD PTR _iMultiplier$226662[ebp], ecx

; 2437 : 
; 2438 : 		int iWeightThreshold = (iPerCityThreshold * iMultiplier);

	mov	edx, DWORD PTR _iPerCityThreshold$226628[ebp]
	imul	edx, DWORD PTR _iMultiplier$226662[ebp]
	mov	DWORD PTR _iWeightThreshold$226665[ebp], edx

; 2439 : 
; 2440 : 		//Do we want more Builders?
; 2441 : 		if((iNumBuilders * 100) < iWeightThreshold)

	mov	eax, DWORD PTR _iNumBuilders$226624[ebp]
	imul	eax, 100				; 00000064H
	cmp	eax, DWORD PTR _iWeightThreshold$226665[ebp]
	jge	SHORT $LN22@IsTestCity@7

; 2442 : 		{
; 2443 : 			// slewis - need to check to see if training another worker will put us below the -10 threshold.
; 2444 : 			// slewis - todo: move -10 to a xml value
; 2445 : 			return (kPlayer.calculateGoldRate() > -10);

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	xor	ecx, ecx
	cmp	eax, -10				; fffffff6H
	setg	cl
	mov	al, cl
	jmp	SHORT $LN27@IsTestCity@7
$LN22@IsTestCity@7:

; 2446 : 
; 2447 : 			// Also want to check and see if we have enough happiness to support another builder
; 2448 : 			//int iBuilderUnhappiness = 0;
; 2449 : 			//int iBuildersInGame = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, false, false);
; 2450 : 			//if (iBuildersInGame > 0)
; 2451 : 			//{
; 2452 : 			//	CvUnit *pLoopUnit;
; 2453 : 			//	int iLoop;
; 2454 : 			//	for (pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))
; 2455 : 			//	{
; 2456 : 			//		if (pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)
; 2457 : 			//		{
; 2458 : 			//			break;
; 2459 : 			//		}
; 2460 : 			//	}
; 2461 : 			//	if (pLoopUnit)
; 2462 : 			//	{
; 2463 : 			//		iBuilderUnhappiness = pLoopUnit->getUnitInfo().GetUnhappiness();
; 2464 : 			//	}
; 2465 : 			//}
; 2466 : 
; 2467 : 			//return (kPlayer.GetExcessHappiness()) >= (iNumBuilders - iBuildersInGame + 1) * iBuilderUnhappiness;
; 2468 : 		}
; 2469 : 	}
; 2470 : 
; 2471 : 	return false;

	xor	al, al
$LN27@IsTestCity@7:

; 2472 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T234022 = -56						; size = 4
$T234018 = -52						; size = 4
$T234009 = -48						; size = 4
$T234005 = -44						; size = 4
$T233998 = -40						; size = 4
_eNeedImproversStrategy$ = -36				; size = 4
_iWeightThresholdModifier$ = -32			; size = 4
_iPerCityThreshold$ = -28				; size = 4
_iLastTurnWorkerDisbanded$ = -24			; size = 4
_pCityStrategy$ = -20					; size = 4
_iModdedNumCities$ = -16				; size = 4
_kPlayer$ = -12						; size = 4
_iNumBuilders$ = -8					; size = 4
_iWeightThreshold$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers, COMDAT

; 2476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi

; 2477 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T233998[ebp], ecx
	mov	edx, DWORD PTR $T233998[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 2478 : #ifdef AUI_CITYSTRATEGY_DONT_EMPHASIZE_WORKERS_IF_NO_MILITARY
; 2479 : 	if (kPlayer.getNumMilitaryUnits() - kPlayer.GetNumUnitsWithUnitAI(UNITAI_EXPLORE) <= 0)
; 2480 : 	{
; 2481 : 		return true;
; 2482 : 	}
; 2483 : #endif
; 2484 : 	int iLastTurnWorkerDisbanded = kPlayer.GetEconomicAI()->GetLastTurnWorkerDisbanded();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T234005[ebp], eax
	mov	eax, DWORD PTR $T234005[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _iLastTurnWorkerDisbanded$[ebp], ecx

; 2485 : #ifdef AUI_CITYSTRATEGY_FIX_TILE_IMPROVERS_LAST_DISBAND_WORKER_TURN_SCALE
; 2486 : 	if (iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10 * GC.getGame().getEstimateEndTurn() / 500)
; 2487 : #else
; 2488 : 	if(iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10)

	cmp	DWORD PTR _iLastTurnWorkerDisbanded$[ebp], 0
	jl	SHORT $LN6@IsTestCity@8
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234009[ebp], edx
	mov	ecx, DWORD PTR $T234009[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR _iLastTurnWorkerDisbanded$[ebp]
	cmp	eax, 10					; 0000000aH
	jg	SHORT $LN6@IsTestCity@8

; 2489 : #endif
; 2490 : 	{
; 2491 : 		return true;

	mov	al, 1
	jmp	$LN7@IsTestCity@8
$LN6@IsTestCity@8:

; 2492 : 	}
; 2493 : 
; 2494 : 	AICityStrategyTypes eNeedImproversStrategy = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_TILE_IMPROVERS");

	push	0
	push	OFFSET ??_C@_0CD@CGFLOLNE@AICITYSTRATEGY_NEED_TILE_IMPROVE@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eNeedImproversStrategy$[ebp], eax

; 2495 : 
; 2496 : #ifdef AUI_WARNING_FIXES
; 2497 : 	if (eNeedImproversStrategy != NO_AICITYSTRATEGY)
; 2498 : #else
; 2499 : 	if(eNeedImproversStrategy != NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eNeedImproversStrategy$[ebp], -1
	je	SHORT $LN5@IsTestCity@8

; 2500 : #endif
; 2501 : 	{
; 2502 : 		if(pCity->GetCityStrategyAI()->IsUsingCityStrategy(eNeedImproversStrategy))

	mov	eax, DWORD PTR _eNeedImproversStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@IsTestCity@8

; 2503 : 			return false;

	xor	al, al
	jmp	$LN7@IsTestCity@8
$LN5@IsTestCity@8:

; 2504 : 	}
; 2505 : 
; 2506 : 	int iNumBuilders = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumBuilders$[ebp], eax

; 2507 : 
; 2508 : 	// If it's a minor with at least 1 worker per city, always return true
; 2509 : 	if(GET_PLAYER(pCity->getOwner()).isMinorCiv())

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T234018[ebp], eax
	mov	ecx, DWORD PTR $T234018[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234022[ebp], ecx
	mov	ecx, DWORD PTR $T234022[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@IsTestCity@8

; 2510 : 	{
; 2511 : 		if(iNumBuilders >= kPlayer.getNumCities())

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	DWORD PTR _iNumBuilders$[ebp], eax
	jl	SHORT $LN3@IsTestCity@8

; 2512 : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@IsTestCity@8
$LN3@IsTestCity@8:

; 2513 : 	}
; 2514 : 
; 2515 : 	CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	DWORD PTR _pCityStrategy$[ebp], eax

; 2516 : 
; 2517 : 	int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pCity);	// 10 Extra Weight per TILE_IMPROVEMENT Flavor

	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$[ebp], eax

; 2518 : 	int iPerCityThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 100

	mov	ecx, DWORD PTR _pCityStrategy$[ebp]
	call	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$[ebp]
	mov	DWORD PTR _iPerCityThreshold$[ebp], eax

; 2519 : 
; 2520 : 	int iModdedNumCities = kPlayer.getNumCities() + kPlayer.countCitiesFeatureSurrounded();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	esi, eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ ; CvPlayer::countCitiesFeatureSurrounded
	add	esi, eax
	mov	DWORD PTR _iModdedNumCities$[ebp], esi

; 2521 : 	int iWeightThreshold = (iPerCityThreshold * iModdedNumCities);

	mov	eax, DWORD PTR _iPerCityThreshold$[ebp]
	imul	eax, DWORD PTR _iModdedNumCities$[ebp]
	mov	DWORD PTR _iWeightThreshold$[ebp], eax

; 2522 : 
; 2523 : 	// Average Player wants no more than 1.50 Builders per City [150 Weight is Average; range is 100 to 200]
; 2524 : 	if((iNumBuilders * 100) >= iWeightThreshold)

	mov	ecx, DWORD PTR _iNumBuilders$[ebp]
	imul	ecx, 100				; 00000064H
	cmp	ecx, DWORD PTR _iWeightThreshold$[ebp]
	jl	SHORT $LN1@IsTestCity@8

; 2525 : 	{
; 2526 : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@IsTestCity@8
$LN1@IsTestCity@8:

; 2527 : 	}
; 2528 : 
; 2529 : 	return false;

	xor	al, al
$LN7@IsTestCity@8:

; 2530 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T234055 = -44						; size = 4
$T234046 = -40						; size = 4
$T234042 = -36						; size = 4
$T234033 = -32						; size = 4
_iWeightThresholdModifier$226704 = -28			; size = 4
_pCityStrategy$226703 = -24				; size = 4
_iWeightThreshold$226705 = -20				; size = 4
_iPlotLoop$226694 = -16					; size = 4
_iNumTotalWorkablePlots$ = -12				; size = 4
_pLoopPlot$ = -8					; size = 4
_iNumOceanPlots$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth, COMDAT

; 2534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2535 : 	int iNumOceanPlots = 0;

	mov	DWORD PTR _iNumOceanPlots$[ebp], 0

; 2536 : 	int iNumTotalWorkablePlots = 0;

	mov	DWORD PTR _iNumTotalWorkablePlots$[ebp], 0

; 2537 : 
; 2538 : 	CvPlot* pLoopPlot;
; 2539 : 
; 2540 : 	// Look at all Tiles this City could potentially work
; 2541 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$226694[ebp], 0
	jmp	SHORT $LN9@IsTestCity@9
$LN8@IsTestCity@9:
	mov	eax, DWORD PTR _iPlotLoop$226694[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoop$226694[ebp], eax
$LN9@IsTestCity@9:
	cmp	DWORD PTR _iPlotLoop$226694[ebp], 37	; 00000025H
	jge	$LN7@IsTestCity@9

; 2542 : 	{
; 2543 : 		pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T234033[ebp], edx
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T234042[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$226694[ebp]
	push	edx
	mov	eax, DWORD PTR $T234033[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234042[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2544 : 
; 2545 : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN6@IsTestCity@9

; 2546 : 		{
; 2547 : 			if(pLoopPlot->getOwner() == pCity->getOwner())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T234046[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T234055[ebp], edx
	mov	eax, DWORD PTR $T234046[ebp]
	cmp	eax, DWORD PTR $T234055[ebp]
	jne	SHORT $LN6@IsTestCity@9

; 2548 : 			{
; 2549 : 				if(!pLoopPlot->isCity())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@IsTestCity@9

; 2550 : 				{
; 2551 : 					iNumTotalWorkablePlots++;

	mov	edx, DWORD PTR _iNumTotalWorkablePlots$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumTotalWorkablePlots$[ebp], edx

; 2552 : 
; 2553 : 					if(pLoopPlot->isWater() && !pLoopPlot->isLake())

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN6@IsTestCity@9
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@IsTestCity@9

; 2554 : 					{
; 2555 : 						iNumOceanPlots++;;

	mov	edx, DWORD PTR _iNumOceanPlots$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumOceanPlots$[ebp], edx
$LN6@IsTestCity@9:

; 2556 : 					}
; 2557 : 				}
; 2558 : 			}
; 2559 : 		}
; 2560 : 	}

	jmp	$LN8@IsTestCity@9
$LN7@IsTestCity@9:

; 2561 : 
; 2562 : 	if(iNumTotalWorkablePlots > 0)

	cmp	DWORD PTR _iNumTotalWorkablePlots$[ebp], 0
	jle	SHORT $LN2@IsTestCity@9

; 2563 : 	{
; 2564 : 		CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	DWORD PTR _pCityStrategy$226703[ebp], eax

; 2565 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pCity);	// -1 Weight per NAVAL_GROWTH Flavor

	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$226704[ebp], eax

; 2566 : 		int iWeightThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 40

	mov	ecx, DWORD PTR _pCityStrategy$226703[ebp]
	call	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$226704[ebp]
	mov	DWORD PTR _iWeightThreshold$226705[ebp], eax

; 2567 : 
; 2568 : 		// If at least 35% (Average Player) of a City's workable Tiles are low-food Water then we really should be building a Harbor
; 2569 : 		// [35 Weight is Average; range is 30 to 40]
; 2570 : 		if((iNumOceanPlots * 100) / iNumTotalWorkablePlots >= iWeightThreshold)

	mov	eax, DWORD PTR _iNumOceanPlots$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iNumTotalWorkablePlots$[ebp]
	cmp	eax, DWORD PTR _iWeightThreshold$226705[ebp]
	jl	SHORT $LN2@IsTestCity@9

; 2571 : 		{
; 2572 : 			return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestCity@9
$LN2@IsTestCity@9:

; 2573 : 		}
; 2574 : 	}
; 2575 : 
; 2576 : 	return false;

	xor	al, al
$LN10@IsTestCity@9:

; 2577 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth
_TEXT	ENDS
EXTRN	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z:PROC ; CvCityCitizens::IsCanWork
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234112 = -40						; size = 4
$T234108 = -36						; size = 4
$T234096 = -32						; size = 4
$T234087 = -28						; size = 4
$T234083 = -24						; size = 4
$T234074 = -20						; size = 4
_iPlotLoop$226712 = -16					; size = 4
_iNumWaterTileImprovers$ = -12				; size = 4
_iNumUnimprovedWaterResources$ = -8			; size = 4
_pLoopPlot$ = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement, COMDAT

; 2581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 2582 : 	int iNumUnimprovedWaterResources = 0;

	mov	DWORD PTR _iNumUnimprovedWaterResources$[ebp], 0

; 2583 : 
; 2584 : 	CvPlot* pLoopPlot;
; 2585 : 
; 2586 : 	// Look at all Tiles this City could potentially work to see if there are any Water Resources that could be improved
; 2587 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$226712[ebp], 0
	jmp	SHORT $LN9@IsTestCity@10
$LN8@IsTestCity@10:
	mov	eax, DWORD PTR _iPlotLoop$226712[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoop$226712[ebp], eax
$LN9@IsTestCity@10:
	cmp	DWORD PTR _iPlotLoop$226712[ebp], 37	; 00000025H
	jge	$LN30@IsTestCity@10

; 2588 : 	{
; 2589 : 		pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T234074[ebp], edx
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T234083[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$226712[ebp]
	push	edx
	mov	eax, DWORD PTR $T234074[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234083[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2590 : 
; 2591 : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN6@IsTestCity@10

; 2592 : 		{
; 2593 : 			if(pLoopPlot->getOwner() == pCity->getOwner())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T234087[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T234096[ebp], edx
	mov	eax, DWORD PTR $T234087[ebp]
	cmp	eax, DWORD PTR $T234096[ebp]
	jne	SHORT $LN6@IsTestCity@10

; 2594 : 			{
; 2595 : 				if(pLoopPlot->isWater())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IsTestCity@10

; 2596 : 				{
; 2597 : 					// Only look at Tiles THIS City can use; Prevents issue where two Cities can look at the same tile the same turn and both want Workboats for it; By the time this Strategy is called for a City another City isn't guaranteed to have popped it's previous order and registered that it's now training a Workboat! :(
; 2598 : 					if(pCity->GetCityCitizens()->IsCanWork(pLoopPlot))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsTestCity@10

; 2599 : 					{
; 2600 : 						// Does this Tile already have a Resource, and if so, is it already improved?
; 2601 : 						if(pLoopPlot->getResourceType() != NO_RESOURCE && pLoopPlot->getImprovementType() == NO_IMPROVEMENT)

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN6@IsTestCity@10
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN6@IsTestCity@10

; 2602 : 						{
; 2603 : 							iNumUnimprovedWaterResources++;

	mov	ecx, DWORD PTR _iNumUnimprovedWaterResources$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumUnimprovedWaterResources$[ebp], ecx
$LN6@IsTestCity@10:

; 2604 : 						}
; 2605 : 					}
; 2606 : 				}
; 2607 : 			}
; 2608 : 		}
; 2609 : 	}

	jmp	$LN8@IsTestCity@10

; 2610 : 
; 2611 : 	int iNumWaterTileImprovers = GET_PLAYER(pCity->getOwner()).GetNumUnitsWithUnitAI(UNITAI_WORKER_SEA, true, true);

$LN30@IsTestCity@10:
	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T234108[ebp], eax
	mov	ecx, DWORD PTR $T234108[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234112[ebp], ecx
	push	1
	push	1
	push	17					; 00000011H
	mov	ecx, DWORD PTR $T234112[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumWaterTileImprovers$[ebp], eax

; 2612 : 
; 2613 : 	// Are there more Water Resources we can build an Improvement on than we have Naval Tile Improvers?
; 2614 : 	if(iNumUnimprovedWaterResources > iNumWaterTileImprovers)

	mov	edx, DWORD PTR _iNumUnimprovedWaterResources$[ebp]
	cmp	edx, DWORD PTR _iNumWaterTileImprovers$[ebp]
	jle	SHORT $LN1@IsTestCity@10

; 2615 : 	{
; 2616 : #ifdef AI_WORKER_EMBARKED_FIX
; 2617 : 		if ( iNumWaterTileImprovers >= 1 )
; 2618 : 		{
; 2619 : 			return false;
; 2620 : 		}
; 2621 : 		else {
; 2622 : 		return true;
; 2623 : 		}
; 2624 : #else
; 2625 : 		return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestCity@10
$LN1@IsTestCity@10:

; 2626 : #endif
; 2627 : 	}
; 2628 : 
; 2629 : 	return false;

	xor	al, al
$LN10@IsTestCity@10:

; 2630 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_eStrategyNeedNavalTileImprovement$ = -4		; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement, COMDAT

; 2634 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2635 : 	AICityStrategyTypes eStrategyNeedNavalTileImprovement = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT");

	push	0
	push	OFFSET ??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyNeedNavalTileImprovement$[ebp], eax

; 2636 : 
; 2637 : #ifdef AUI_WARNING_FIXES
; 2638 : 	if (eStrategyNeedNavalTileImprovement != NO_AICITYSTRATEGY)
; 2639 : #else
; 2640 : 	if(eStrategyNeedNavalTileImprovement != NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eStrategyNeedNavalTileImprovement$[ebp], -1
	je	SHORT $LN2@IsTestCity@11

; 2641 : #endif
; 2642 : 	{
; 2643 : 		if(!pCity->GetCityStrategyAI()->IsUsingCityStrategy(eStrategyNeedNavalTileImprovement))

	mov	eax, DWORD PTR _eStrategyNeedNavalTileImprovement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@IsTestCity@11

; 2644 : 		{
; 2645 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@11
$LN2@IsTestCity@11:

; 2646 : 		}
; 2647 : 	}
; 2648 : #ifdef AI_WORKER_EMBARKED_FIX
; 2649 : 	int iX = pCity->getX(); int iY = pCity->getY(); CvPlayerAI& iOwner = GET_PLAYER(pCity->getOwner());
; 2650 : 
; 2651 : 	int iNumWorkersHere = 0;
; 2652 : 	int iCanImprove = 0;
; 2653 : 	for (int iCityPlotLoop = 0; iCityPlotLoop < RING5_PLOTS; iCityPlotLoop++)
; 2654 : 	{
; 2655 : 		CvPlot* pLoopPlot = plotCity(iX, iY, iCityPlotLoop);
; 2656 : 
; 2657 : 		// Invalid plot or not owned by this player
; 2658 : 		if (pLoopPlot == NULL || pLoopPlot->getOwner() != pCity->getOwner())
; 2659 : 		{
; 2660 : 			continue;
; 2661 : 		}
; 2662 : 		//No improved, no impassable, water only.
; 2663 : 		if(pLoopPlot->getImprovementType() == NO_IMPROVEMENT && !pLoopPlot->isImpassable() && pLoopPlot->isWater())
; 2664 : 		{
; 2665 : 			CvUnit* pLoopUnit;
; 2666 : 			for(int iUnitLoop = 0; iUnitLoop < pLoopPlot->getNumUnits(); iUnitLoop++)
; 2667 : 			{
; 2668 : 				//Workers nearby?
; 2669 : 				pLoopUnit = pLoopPlot->getUnitByIndex(iUnitLoop);
; 2670 : 				if(pLoopUnit != NULL && pLoopUnit->getOwner() == pCity->GetID() && pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER_SEA)
; 2671 : 				{
; 2672 : 					iNumWorkersHere++;
; 2673 : 				}
; 2674 : 			}
; 2675 : 			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
; 2676 : 			{
; 2677 : 				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
; 2678 : 				if(!pkBuildInfo)
; 2679 : 				{
; 2680 : 					continue;
; 2681 : 				}
; 2682 : 				ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo((BuildTypes) iI)->getImprovement();
; 2683 : 				if(eImprovement != NO_IMPROVEMENT)
; 2684 : 				{
; 2685 : 					CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
; 2686 : 					if(pkEntry->IsCreatedByGreatPerson())
; 2687 : 						continue;
; 2688 : 				}
; 2689 : 
; 2690 : 				//Valid right now with any worker valid build?
; 2691 : 				if(GET_PLAYER(pCity->getOwner()).canBuild(pLoopPlot, (BuildTypes)iI))
; 2692 : 				{
; 2693 : 					iCanImprove++;
; 2694 : 					break;
; 2695 : 				}
; 2696 : 			}
; 2697 : 		}
; 2698 : 	}
; 2699 : 	//No tiles to improve?
; 2700 : 	if(iCanImprove <= 0)
; 2701 : 	{
; 2702 : 		return true;
; 2703 : 	}
; 2704 : 	//Enough workers already here? 1:1 ratio is good ratio.
; 2705 : 	if(iNumWorkersHere > iCanImprove)
; 2706 : 	{
; 2707 : 		return true;
; 2708 : 	}
; 2709 : #endif
; 2710 : 
; 2711 : 	return false;

	xor	al, al
$LN3@IsTestCity@11:

; 2712 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_yield$ = 12						; size = 4
?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement, COMDAT

; 2716 : {

	push	ebp
	mov	ebp, esp

; 2717 : 	if(pCity->GetCityStrategyAI()->GetDeficientYield() == yield)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetDeficientYield
	cmp	eax, DWORD PTR _yield$[ebp]
	jne	SHORT $LN1@IsTestCity@12

; 2718 : 	{
; 2719 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@12
$LN1@IsTestCity@12:

; 2720 : 	}
; 2721 : 
; 2722 : 	return false;

	xor	al, al
$LN2@IsTestCity@12:

; 2723 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
_TEXT	ENDS
EXTRN	?getDomainFreeExperience@CvCity@@QBEHW4DomainTypes@@@Z:PROC ; CvCity::getDomainFreeExperience
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility, COMDAT

; 2727 : {

	push	ebp
	mov	ebp, esp

; 2728 : 	if(pCity->getDomainFreeExperience(DOMAIN_LAND) > 0)

	push	2
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getDomainFreeExperience@CvCity@@QBEHW4DomainTypes@@@Z ; CvCity::getDomainFreeExperience
	test	eax, eax
	jle	SHORT $LN1@IsTestCity@13

; 2729 : 	{
; 2730 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@13
$LN1@IsTestCity@13:

; 2731 : 	}
; 2732 : 
; 2733 : 	return false;

	xor	al, al
$LN2@IsTestCity@13:

; 2734 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility
_TEXT	ENDS
PUBLIC	??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@ ; `string'
;	COMDAT ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@ DB 'MILITARYAISTRATE'
	DB	'GY_WAR_MOBILIZATION', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T234140 = -52						; size = 4
$T234136 = -48						; size = 4
$T234129 = -44						; size = 4
_eUnderThreat$226750 = -40				; size = 4
_eMilStrategy$226754 = -36				; size = 4
_iWeightThresholdModifier$226759 = -32			; size = 4
_iGameTurn$226761 = -28					; size = 4
_pCityStrategy$226758 = -24				; size = 4
_iWeightThreshold$226760 = -20				; size = 4
_iCitiesPlusSettlers$226748 = -16			; size = 4
_iSettlersOnMapOrBuild$226747 = -12			; size = 4
_iNumCities$226746 = -8					; size = 4
_kPlayer$226744 = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler, COMDAT

; 2738 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2739 : 	if(pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	$LN10@IsTestCity@14

; 2740 : 	{
; 2741 : 		CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T234129[ebp], edx
	mov	eax, DWORD PTR $T234129[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226744[ebp], eax

; 2742 : 
; 2743 : 		if(!kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$226744[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN10@IsTestCity@14

; 2744 : 		{
; 2745 : 			int iNumCities = kPlayer.getNumCities();

	mov	ecx, DWORD PTR _kPlayer$226744[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iNumCities$226746[ebp], eax

; 2746 : 			int iSettlersOnMapOrBuild = kPlayer.GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _kPlayer$226744[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iSettlersOnMapOrBuild$226747[ebp], eax

; 2747 : 			int iCitiesPlusSettlers = iNumCities + iSettlersOnMapOrBuild;

	mov	edx, DWORD PTR _iNumCities$226746[ebp]
	add	edx, DWORD PTR _iSettlersOnMapOrBuild$226747[ebp]
	mov	DWORD PTR _iCitiesPlusSettlers$226748[ebp], edx

; 2748 : 
; 2749 : 			if((iCitiesPlusSettlers) < 3)

	cmp	DWORD PTR _iCitiesPlusSettlers$226748[ebp], 3
	jge	$LN10@IsTestCity@14

; 2750 : 			{
; 2751 : 
; 2752 : 				AICityStrategyTypes eUnderThreat = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_CAPITAL_UNDER_THREAT");

	push	0
	push	OFFSET ??_C@_0CE@HFBDFGBB@AICITYSTRATEGY_CAPITAL_UNDER_THR@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eUnderThreat$226750[ebp], eax

; 2753 : 				if(eUnderThreat != NO_AICITYSTRATEGY)

	cmp	DWORD PTR _eUnderThreat$226750[ebp], -1
	je	SHORT $LN7@IsTestCity@14

; 2754 : 				{
; 2755 : 					if(GC.getGame().getGameTurn() > 50 && pCity->GetCityStrategyAI()->IsUsingCityStrategy(eUnderThreat))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234136[ebp], eax
	mov	ecx, DWORD PTR $T234136[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN7@IsTestCity@14
	mov	ecx, DWORD PTR _eUnderThreat$226750[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@IsTestCity@14

; 2756 : 					{
; 2757 : 						return false;

	xor	al, al
	jmp	$LN11@IsTestCity@14
$LN7@IsTestCity@14:

; 2758 : 					}
; 2759 : 				}
; 2760 : 
; 2761 : 				MilitaryAIStrategyTypes eMilStrategy = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_WAR_MOBILIZATION");

	push	0
	push	OFFSET ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eMilStrategy$226754[ebp], eax

; 2762 : 				if(eMilStrategy != NO_MILITARYAISTRATEGY && kPlayer.GetMilitaryAI()->IsUsingStrategy(eMilStrategy))

	cmp	DWORD PTR _eMilStrategy$226754[ebp], -1
	je	SHORT $LN5@IsTestCity@14
	mov	eax, DWORD PTR _eMilStrategy$226754[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226744[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@IsTestCity@14

; 2763 : 				{
; 2764 : 					// this is very risky, if this war fails, the civ lost the entire game as they have no backup plan
; 2765 : 					return false;

	xor	al, al
	jmp	$LN11@IsTestCity@14
$LN5@IsTestCity@14:

; 2766 : 				}
; 2767 : 
; 2768 : 				CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
	mov	ecx, eax
	call	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
	mov	DWORD PTR _pCityStrategy$226758[ebp], eax

; 2769 : 				int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pCity);	// -10 per EXPANSION, +2 per DEFENSE

	mov	eax, DWORD PTR _pCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$226759[ebp], eax

; 2770 : 				int iWeightThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 130

	mov	ecx, DWORD PTR _pCityStrategy$226758[ebp]
	call	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$226759[ebp]
	mov	DWORD PTR _iWeightThreshold$226760[ebp], eax

; 2771 : 
; 2772 : 				int iGameTurn = GC.getGame().getGameTurn();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234140[ebp], edx
	mov	ecx, DWORD PTR $T234140[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGameTurn$226761[ebp], eax

; 2773 : 				if((iCitiesPlusSettlers == 1 && (iGameTurn * 4) > iWeightThreshold) ||
; 2774 : 					(iCitiesPlusSettlers == 2 && (iGameTurn * 2) > iWeightThreshold) || 
; 2775 : 					(iCitiesPlusSettlers == 3 && iGameTurn > iWeightThreshold) )

	cmp	DWORD PTR _iCitiesPlusSettlers$226748[ebp], 1
	jne	SHORT $LN2@IsTestCity@14
	mov	eax, DWORD PTR _iGameTurn$226761[ebp]
	shl	eax, 2
	cmp	eax, DWORD PTR _iWeightThreshold$226760[ebp]
	jg	SHORT $LN3@IsTestCity@14
$LN2@IsTestCity@14:
	cmp	DWORD PTR _iCitiesPlusSettlers$226748[ebp], 2
	jne	SHORT $LN1@IsTestCity@14
	mov	ecx, DWORD PTR _iGameTurn$226761[ebp]
	shl	ecx, 1
	cmp	ecx, DWORD PTR _iWeightThreshold$226760[ebp]
	jg	SHORT $LN3@IsTestCity@14
$LN1@IsTestCity@14:
	cmp	DWORD PTR _iCitiesPlusSettlers$226748[ebp], 3
	jne	SHORT $LN10@IsTestCity@14
	mov	edx, DWORD PTR _iGameTurn$226761[ebp]
	cmp	edx, DWORD PTR _iWeightThreshold$226760[ebp]
	jle	SHORT $LN10@IsTestCity@14
$LN3@IsTestCity@14:

; 2776 : 				{
; 2777 : 					return true;

	mov	al, 1
	jmp	SHORT $LN11@IsTestCity@14
$LN10@IsTestCity@14:

; 2778 : 				}
; 2779 : 			}
; 2780 : 		}
; 2781 : 	}
; 2782 : 
; 2783 : 	return false;

	xor	al, al
$LN11@IsTestCity@14:

; 2784 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler
_TEXT	ENDS
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
EXTRN	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z:PROC ; CvMilitaryAI::GetMostThreatenedCity
EXTRN	?getAtWarCount@CvTeam@@QBEH_N@Z:PROC		; CvTeam::getAtWarCount
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234167 = -24						; size = 4
$T234163 = -20						; size = 4
$T234151 = -16						; size = 4
_pMostThreatened$226773 = -12				; size = 4
_bAtPeace$226771 = -5					; size = 1
_kPlayer$226770 = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat, COMDAT

; 2788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2789 : 	if (pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	$LN3@IsTestCity@15

; 2790 : 	{
; 2791 : 		CvPlayer &kPlayer = GET_PLAYER(pCity->getOwner());

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T234151[ebp], edx
	mov	eax, DWORD PTR $T234151[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226770[ebp], eax

; 2792 : 
; 2793 : 		bool bAtPeace = GET_TEAM(kPlayer.getTeam()).getAtWarCount(false) == 0;

	mov	ecx, DWORD PTR _kPlayer$226770[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234163[ebp], eax
	mov	eax, DWORD PTR $T234163[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234167[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T234167[ebp]
	call	?getAtWarCount@CvTeam@@QBEH_N@Z		; CvTeam::getAtWarCount
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	BYTE PTR _bAtPeace$226771[ebp], al

; 2794 : 
; 2795 : 		if (!bAtPeace && !kPlayer.isMinorCiv())

	movzx	ecx, BYTE PTR _bAtPeace$226771[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@IsTestCity@15
	mov	ecx, DWORD PTR _kPlayer$226770[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@IsTestCity@15

; 2796 : 		{
; 2797 : 			CvCity *pMostThreatened = kPlayer.GetMilitaryAI()->GetMostThreatenedCity();

	push	0
	mov	ecx, DWORD PTR _kPlayer$226770[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
	mov	DWORD PTR _pMostThreatened$226773[ebp], eax

; 2798 : 			if (pMostThreatened == pCity && pMostThreatened->getThreatValue() > 200)

	mov	eax, DWORD PTR _pMostThreatened$226773[ebp]
	cmp	eax, DWORD PTR _pCity$[ebp]
	jne	SHORT $LN3@IsTestCity@15
	mov	ecx, DWORD PTR _pMostThreatened$226773[ebp]
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	cmp	eax, 200				; 000000c8H
	jle	SHORT $LN3@IsTestCity@15

; 2799 : 			{
; 2800 : 				return true;

	mov	al, 1
	jmp	SHORT $LN4@IsTestCity@15
$LN3@IsTestCity@15:

; 2801 : 			}
; 2802 : 		}
; 2803 : 	}
; 2804 : 
; 2805 : 	return false;

	xor	al, al
$LN4@IsTestCity@15:

; 2806 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat
_TEXT	ENDS
EXTRN	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ:PROC ; CvCity::GetJONSCulturePerTurnFromBuildings
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding, COMDAT

; 2810 : {

	push	ebp
	mov	ebp, esp

; 2811 : 	if(pCity->GetJONSCulturePerTurnFromBuildings() <= 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetJONSCulturePerTurnFromBuildings
	test	eax, eax
	jg	SHORT $LN2@IsTestCity@16

; 2812 : 	{
; 2813 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@16
$LN2@IsTestCity@16:

; 2814 : 	}
; 2815 : 
; 2816 : 	if(pCity->isCapital() && pCity->GetJONSCulturePerTurnFromBuildings() <= 1)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestCity@16
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetJONSCulturePerTurnFromBuildings
	cmp	eax, 1
	jg	SHORT $LN1@IsTestCity@16

; 2817 : 	{
; 2818 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@16
$LN1@IsTestCity@16:

; 2819 : 	}
; 2820 : 
; 2821 : 	return false;

	xor	al, al
$LN3@IsTestCity@16:

; 2822 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency, COMDAT

; 2826 : {

	push	ebp
	mov	ebp, esp

; 2827 : 	if(pCity->getPopulation() >= 5 && pCity->GetJONSCulturePerTurnFromBuildings() <= 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 5
	jl	SHORT $LN1@IsTestCity@17
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetJONSCulturePerTurnFromBuildings
	test	eax, eax
	jg	SHORT $LN1@IsTestCity@17

; 2828 : 	{
; 2829 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@17
$LN1@IsTestCity@17:

; 2830 : 	}
; 2831 : 
; 2832 : 	return false;

	xor	al, al
$LN2@IsTestCity@17:

; 2833 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding, COMDAT

; 2837 : {

	push	ebp
	mov	ebp, esp

; 2838 : 	if(pCity->getPopulation() >= 4 && pCity->GetYieldPerPopTimes100(YIELD_SCIENCE) == 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jl	SHORT $LN1@IsTestCity@18
	push	3
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetYieldPerPopTimes100@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::GetYieldPerPopTimes100
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@18

; 2839 : 	{
; 2840 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@18
$LN1@IsTestCity@18:

; 2841 : 	}
; 2842 : 
; 2843 : 	return false;

	xor	al, al
$LN2@IsTestCity@18:

; 2844 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding
_TEXT	ENDS
EXTRN	?getYieldRateModifier@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getYieldRateModifier
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding, COMDAT

; 2848 : {

	push	ebp
	mov	ebp, esp

; 2849 : 	if(pCity->getPopulation() >= 4 && pCity->getYieldRateModifier(YIELD_GOLD) == 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jl	SHORT $LN1@IsTestCity@19
	push	2
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getYieldRateModifier@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getYieldRateModifier
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@19

; 2850 : 	{
; 2851 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@19
$LN1@IsTestCity@19:

; 2852 : 	}
; 2853 : 
; 2854 : 	return false;

	xor	al, al
$LN2@IsTestCity@19:

; 2855 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding
_TEXT	ENDS
EXTRN	?GetBaseYieldRateFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::GetBaseYieldRateFromBuildings
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding, COMDAT

; 2859 : {

	push	ebp
	mov	ebp, esp

; 2860 : 	if(pCity->getPopulation() >= 4 && pCity->GetBaseYieldRateFromBuildings(YIELD_PRODUCTION) == 0 && pCity->getYieldRateModifier(YIELD_PRODUCTION) == 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jl	SHORT $LN1@IsTestCity@20
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetBaseYieldRateFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::GetBaseYieldRateFromBuildings
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@20
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getYieldRateModifier@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getYieldRateModifier
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@20

; 2861 : 	{
; 2862 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@20
$LN1@IsTestCity@20:

; 2863 : 	}
; 2864 : 
; 2865 : 	return false;

	xor	al, al
$LN2@IsTestCity@20:

; 2866 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding
_TEXT	ENDS
PUBLIC	??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@		; `string'
EXTRN	?HasCreatedPantheon@CvPlayerReligions@@QBE_NXZ:PROC ; CvPlayerReligions::HasCreatedPantheon
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
EXTRN	?GetFaithPerTurnFromBuildings@CvCity@@QBEHXZ:PROC ; CvCity::GetFaithPerTurnFromBuildings
;	COMDAT ??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@ DB 'FLAVOR_RELIGION', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234188 = -16						; size = 4
_iReligionFlavor$ = -12					; size = 4
_eFlavor$ = -8						; size = 4
_kPlayer$ = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding, COMDAT

; 2870 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2871 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T234188[ebp], ecx
	mov	edx, DWORD PTR $T234188[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 2872 : 	FlavorTypes eFlavor = (FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION");

	push	0
	push	OFFSET ??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eFlavor$[ebp], eax

; 2873 : 
; 2874 : 	int iReligionFlavor = kPlayer.GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	eax, DWORD PTR _eFlavor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iReligionFlavor$[ebp], eax

; 2875 : 
; 2876 : 	if(pCity->GetFaithPerTurnFromBuildings() > 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetFaithPerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetFaithPerTurnFromBuildings
	test	eax, eax
	jle	SHORT $LN5@IsTestCity@21

; 2877 : 	{
; 2878 : 		return false;

	xor	al, al
	jmp	SHORT $LN6@IsTestCity@21
$LN5@IsTestCity@21:

; 2879 : 	}
; 2880 : 
; 2881 : 	// Need population of 2 before worrying about this
; 2882 : 	if(pCity->getPopulation() < 2)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 2
	jge	SHORT $LN4@IsTestCity@21

; 2883 : 	{
; 2884 : 		return false;

	xor	al, al
	jmp	SHORT $LN6@IsTestCity@21
$LN4@IsTestCity@21:

; 2885 : 	}
; 2886 : 
; 2887 : 	// Turn on if high religion flavor (doesn't need to be as high if already has a pantheon)
; 2888 : 	if((iReligionFlavor > 4 && kPlayer.GetReligions()->HasCreatedPantheon()) || iReligionFlavor > 6)

	cmp	DWORD PTR _iReligionFlavor$[ebp], 4
	jle	SHORT $LN1@IsTestCity@21
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasCreatedPantheon@CvPlayerReligions@@QBE_NXZ ; CvPlayerReligions::HasCreatedPantheon
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@IsTestCity@21
$LN1@IsTestCity@21:
	cmp	DWORD PTR _iReligionFlavor$[ebp], 6
	jle	SHORT $LN3@IsTestCity@21
$LN2@IsTestCity@21:

; 2889 : 	{
; 2890 : 		return true;

	mov	al, 1
	jmp	SHORT $LN6@IsTestCity@21
$LN3@IsTestCity@21:

; 2891 : 	}
; 2892 : 
; 2893 : 	return false;

	xor	al, al
$LN6@IsTestCity@21:

; 2894 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding
_TEXT	ENDS
EXTRN	?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ:PROC ; CvCityCitizens::IsAnyPlotBlockaded
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade, COMDAT

; 2898 : {

	push	ebp
	mov	ebp, esp

; 2899 : 	if(pCity->GetCityCitizens()->IsAnyPlotBlockaded()/* && !pCity->IsHasBuildingThatAllowsRangeStrike()*/)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ ; CvCityCitizens::IsAnyPlotBlockaded
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestCity@22

; 2900 : 	{
; 2901 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@22
$LN1@IsTestCity@22:

; 2902 : 	}
; 2903 : 
; 2904 : 	return false;

	xor	al, al
$LN2@IsTestCity@22:

; 2905 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet, COMDAT

; 2909 : {

	push	ebp
	mov	ebp, esp

; 2910 : 	if(pCity->IsPuppet())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestCity@23

; 2911 : 	{
; 2912 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@23
$LN1@IsTestCity@23:

; 2913 : 	}
; 2914 : 
; 2915 : 	return false;

	xor	al, al
$LN2@IsTestCity@23:

; 2916 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234206 = -12						; size = 4
$T234205 = -8						; size = 4
$T234201 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty, COMDAT

; 2920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2921 : 	if(pCity->getPopulation() >= 5 && GC.getGame().getHandicapInfo().GetID() > 4)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 5
	jl	SHORT $LN1@IsTestCity@24
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234201[ebp], eax
	mov	ecx, DWORD PTR $T234201[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T234205[ebp], eax
	mov	ecx, DWORD PTR $T234205[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T234206[ebp], edx
	cmp	DWORD PTR $T234206[ebp], 4
	jle	SHORT $LN1@IsTestCity@24

; 2922 : 	{
; 2923 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@24
$LN1@IsTestCity@24:

; 2924 : 	}
; 2925 : 
; 2926 : 	return false;

	xor	al, al
$LN2@IsTestCity@24:

; 2927 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty
_TEXT	ENDS
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital, COMDAT

; 2931 : {

	push	ebp
	mov	ebp, esp

; 2932 : 	if(pCity->IsOriginalCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestCity@25

; 2933 : 	{
; 2934 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@25
$LN1@IsTestCity@25:

; 2935 : 	}
; 2936 : 
; 2937 : 	return false;

	xor	al, al
$LN2@IsTestCity@25:

; 2938 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234214 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity, COMDAT

; 2943 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2944 : 	if(pCity->plot()->isRiver())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T234214[ebp], eax
	mov	eax, DWORD PTR $T234214[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@IsTestCity@26

; 2945 : 	{
; 2946 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@26
$LN1@IsTestCity@26:

; 2947 : 	}
; 2948 : 
; 2949 : 	return false;

	xor	al, al
$LN2@IsTestCity@26:

; 2950 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234336 = -104						; size = 4
$T234224 = -32						; size = 4
$T234220 = -28						; size = 4
_pLoopPlot$226843 = -24					; size = 4
_iDY$226839 = -20					; size = 4
_iDX$226835 = -16					; size = 4
_iRange$ = -12						; size = 4
_pPlot$ = -8						; size = 4
_iNumHills$ = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity, COMDAT

; 2954 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H

; 2955 : 	// scan the nearby tiles to see if there are at least two hills in the vicinity
; 2956 : 	const int iRange = 2;

	mov	DWORD PTR _iRange$[ebp], 2

; 2957 : 	int iNumHills = 0;

	mov	DWORD PTR _iNumHills$[ebp], 0

; 2958 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax

; 2959 : 
; 2960 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2961 : 	int iMaxDX, iDX;
; 2962 : 	CvPlot* pLoopPlot;
; 2963 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 2964 : 	{
; 2965 : 		iMaxDX = iRange - MAX(0, iDY);
; 2966 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2967 : 		{
; 2968 : 			// No need for range check because loops are set up properly
; 2969 : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 2970 : #else
; 2971 : 	for(int iDX = -iRange; iDX <= iRange; iDX++)

	mov	DWORD PTR _iDX$226835[ebp], -2		; fffffffeH
	jmp	SHORT $LN9@IsTestCity@27
$LN8@IsTestCity@27:
	mov	eax, DWORD PTR _iDX$226835[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$226835[ebp], eax
$LN9@IsTestCity@27:
	cmp	DWORD PTR _iDX$226835[ebp], 2
	jg	$LN7@IsTestCity@27

; 2972 : 	{
; 2973 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	mov	DWORD PTR _iDY$226839[ebp], -2		; fffffffeH
	jmp	SHORT $LN6@IsTestCity@27
$LN5@IsTestCity@27:
	mov	ecx, DWORD PTR _iDY$226839[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$226839[ebp], ecx
$LN6@IsTestCity@27:
	cmp	DWORD PTR _iDY$226839[ebp], 2
	jg	SHORT $LN4@IsTestCity@27

; 2974 : 		{
; 2975 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T234220[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T234224[ebp], edx
	push	2
	mov	eax, DWORD PTR _iDY$226839[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$226835[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234220[ebp]
	push	edx
	mov	eax, DWORD PTR $T234224[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$226843[ebp], eax

; 2976 : #endif
; 2977 : 			if(pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$226843[ebp], 0
	je	SHORT $LN3@IsTestCity@27

; 2978 : 			{
; 2979 : 				if(pLoopPlot->isHills() && pLoopPlot->getOwner() == pPlot->getOwner())

	mov	ecx, DWORD PTR _pLoopPlot$226843[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	sub	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@IsTestCity@27
	mov	ecx, DWORD PTR _pLoopPlot$226843[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T234336[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T234336[ebp], ecx
	jne	SHORT $LN3@IsTestCity@27

; 2980 : 				{
; 2981 : 					iNumHills++;

	mov	edx, DWORD PTR _iNumHills$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumHills$[ebp], edx

; 2982 : 					if(iNumHills > 1)

	cmp	DWORD PTR _iNumHills$[ebp], 1
	jle	SHORT $LN3@IsTestCity@27

; 2983 : 					{
; 2984 : 						return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestCity@27
$LN3@IsTestCity@27:

; 2985 : 					}
; 2986 : 				}
; 2987 : 			}
; 2988 : 		}

	jmp	$LN5@IsTestCity@27
$LN4@IsTestCity@27:

; 2989 : 	}

	jmp	$LN8@IsTestCity@27
$LN7@IsTestCity@27:

; 2990 : 
; 2991 : 	return false;

	xor	al, al
$LN10@IsTestCity@27:

; 2992 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T234594 = -56						; size = 4
$T234549 = -52						; size = 4
$T234536 = -48						; size = 4
$T234532 = -44						; size = 4
$T234518 = -40						; size = 4
$T234514 = -33						; size = 1
$T234503 = -32						; size = 4
$T234499 = -25						; size = 1
_iMapY$234590 = -24					; size = 4
_iMapX$234589 = -20					; size = 4
$T234492 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234492[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T234594[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T234492[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T234499[ebp], dl
	mov	eax, DWORD PTR $T234492[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234503[ebp], ecx
	movzx	edx, BYTE PTR $T234499[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T234503[ebp]
	add	edx, DWORD PTR $T234503[ebp]
	mov	DWORD PTR _iMapX$234589[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T234503[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T234503[ebp]
	mov	DWORD PTR _iMapX$234589[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$234589[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T234492[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T234514[ebp], al
	mov	ecx, DWORD PTR $T234492[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234518[ebp], edx
	movzx	eax, BYTE PTR $T234514[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T234518[ebp]
	add	edx, DWORD PTR $T234518[ebp]
	mov	DWORD PTR _iMapY$234590[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T234518[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T234518[ebp]
	mov	DWORD PTR _iMapY$234590[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$234590[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$234589[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T234492[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234532[ebp], ecx
	mov	edx, DWORD PTR _iMapX$234589[ebp]
	cmp	edx, DWORD PTR $T234532[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$234590[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T234492[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T234536[ebp], ecx
	mov	edx, DWORD PTR _iMapY$234590[ebp]
	cmp	edx, DWORD PTR $T234536[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T234492[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234549[ebp], ecx
	mov	edx, DWORD PTR _iMapY$234590[ebp]
	imul	edx, DWORD PTR $T234549[ebp]
	add	edx, DWORD PTR _iMapX$234589[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T234492[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T234594[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T234594[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T234604 = -20						; size = 4
$T234600 = -16						; size = 4
_pAdjacentPlot$226855 = -12				; size = 4
_iDirectionLoop$226851 = -8				; size = 4
_pPlot$ = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity, COMDAT

; 2996 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 2997 : 	// scan the nearby tiles to see if there is a mountain close enough to build an observatory
; 2998 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax

; 2999 : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)

	mov	DWORD PTR _iDirectionLoop$226851[ebp], 0
	jmp	SHORT $LN5@IsTestCity@28
$LN4@IsTestCity@28:
	mov	eax, DWORD PTR _iDirectionLoop$226851[ebp]
	add	eax, 1
	mov	DWORD PTR _iDirectionLoop$226851[ebp], eax
$LN5@IsTestCity@28:
	cmp	DWORD PTR _iDirectionLoop$226851[ebp], 6
	jge	SHORT $LN3@IsTestCity@28

; 3000 : 	{
; 3001 : 		CvPlot* pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T234600[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T234604[ebp], ecx
	mov	edx, DWORD PTR _iDirectionLoop$226851[ebp]
	push	edx
	mov	eax, DWORD PTR $T234600[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234604[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$226855[ebp], eax

; 3002 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$226855[ebp], 0
	je	SHORT $LN2@IsTestCity@28

; 3003 : 		{
; 3004 : 			if(pAdjacentPlot->isMountain())

	mov	edx, DWORD PTR _pAdjacentPlot$226855[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsTestCity@28

; 3005 : 			{
; 3006 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@IsTestCity@28
$LN2@IsTestCity@28:

; 3007 : 			}
; 3008 : 		}
; 3009 : 	}

	jmp	SHORT $LN4@IsTestCity@28
$LN3@IsTestCity@28:

; 3010 : 
; 3011 : 
; 3012 : 	return false;

	xor	al, al
$LN6@IsTestCity@28:

; 3013 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T235021 = -80						; size = 4
$T234976 = -76						; size = 4
$T234963 = -72						; size = 4
$T234959 = -68						; size = 4
$T234945 = -64						; size = 4
$T234941 = -57						; size = 1
$T234930 = -56						; size = 4
$T234926 = -49						; size = 1
_iMapY$235020 = -48					; size = 4
_iMapX$235019 = -44					; size = 4
$T234919 = -40						; size = 4
$T234895 = -36						; size = 4
$T234858 = -32						; size = 4
$T234846 = -28						; size = 4
$T234842 = -21						; size = 1
$T234831 = -20						; size = 4
$T234827 = -13						; size = 1
_iMapY$234894 = -12					; size = 4
_iMapX$234893 = -8					; size = 4
$T234820 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234820[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T234895[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T234820[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T234827[ebp], dl
	mov	eax, DWORD PTR $T234820[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234831[ebp], ecx
	movzx	edx, BYTE PTR $T234827[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T234831[ebp]
	add	edx, DWORD PTR $T234831[ebp]
	mov	DWORD PTR _iMapX$234893[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T234831[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T234831[ebp]
	mov	DWORD PTR _iMapX$234893[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$234893[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T234820[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T234842[ebp], al
	mov	ecx, DWORD PTR $T234820[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234846[ebp], edx
	movzx	eax, BYTE PTR $T234842[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T234846[ebp]
	add	edx, DWORD PTR $T234846[ebp]
	mov	DWORD PTR _iMapY$234894[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T234846[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T234846[ebp]
	mov	DWORD PTR _iMapY$234894[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$234894[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$234894[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$234893[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234820[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T234820[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T234858[ebp], eax
	mov	ecx, DWORD PTR _iMapY$234894[ebp]
	imul	ecx, DWORD PTR $T234858[ebp]
	add	ecx, DWORD PTR _iMapX$234893[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T234820[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T234895[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T234895[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234919[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T235021[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T234919[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T234926[ebp], dl
	mov	eax, DWORD PTR $T234919[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234930[ebp], ecx
	movzx	edx, BYTE PTR $T234926[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T234930[ebp]
	add	edx, DWORD PTR $T234930[ebp]
	mov	DWORD PTR _iMapX$235019[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T234930[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T234930[ebp]
	mov	DWORD PTR _iMapX$235019[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$235019[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T234919[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T234941[ebp], al
	mov	ecx, DWORD PTR $T234919[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234945[ebp], edx
	movzx	eax, BYTE PTR $T234941[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T234945[ebp]
	add	edx, DWORD PTR $T234945[ebp]
	mov	DWORD PTR _iMapY$235020[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T234945[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T234945[ebp]
	mov	DWORD PTR _iMapY$235020[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$235020[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$235019[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T234919[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234959[ebp], ecx
	mov	edx, DWORD PTR _iMapX$235019[ebp]
	cmp	edx, DWORD PTR $T234959[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$235020[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T234919[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T234963[ebp], ecx
	mov	edx, DWORD PTR _iMapY$235020[ebp]
	cmp	edx, DWORD PTR $T234963[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T234919[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234976[ebp], ecx
	mov	edx, DWORD PTR _iMapY$235020[ebp]
	imul	edx, DWORD PTR $T234976[ebp]
	add	edx, DWORD PTR _iMapX$235019[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T234919[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T235021[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T235021[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235149 = -108						; size = 4
_f$235142 = -101					; size = 1
$T235031 = -32						; size = 4
$T235027 = -28						; size = 4
_pLoopPlot$226873 = -24					; size = 4
_iDY$226869 = -20					; size = 4
_iDX$226865 = -16					; size = 4
_iRange$ = -12						; size = 4
_pPlot$ = -8						; size = 4
_iNumForests$ = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity, COMDAT

; 3017 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3018 : 	// scan the nearby tiles to see if there are at least two forests in the vicinity
; 3019 : 	const int iRange = 2;

	mov	DWORD PTR _iRange$[ebp], 2

; 3020 : 	int iNumForests = 0;

	mov	DWORD PTR _iNumForests$[ebp], 0

; 3021 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax

; 3022 : 
; 3023 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 3024 : 	int iMaxDX, iDX;
; 3025 : 	CvPlot* pLoopPlot;
; 3026 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 3027 : 	{
; 3028 : 		iMaxDX = iRange - MAX(0, iDY);
; 3029 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 3030 : 		{
; 3031 : 			// No need for range check because loops are set up properly
; 3032 : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 3033 : #else
; 3034 : 	for(int iDX = -iRange; iDX <= iRange; iDX++)

	mov	DWORD PTR _iDX$226865[ebp], -2		; fffffffeH
	jmp	SHORT $LN9@IsTestCity@29
$LN8@IsTestCity@29:
	mov	eax, DWORD PTR _iDX$226865[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$226865[ebp], eax
$LN9@IsTestCity@29:
	cmp	DWORD PTR _iDX$226865[ebp], 2
	jg	$LN7@IsTestCity@29

; 3035 : 	{
; 3036 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	mov	DWORD PTR _iDY$226869[ebp], -2		; fffffffeH
	jmp	SHORT $LN6@IsTestCity@29
$LN5@IsTestCity@29:
	mov	ecx, DWORD PTR _iDY$226869[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$226869[ebp], ecx
$LN6@IsTestCity@29:
	cmp	DWORD PTR _iDY$226869[ebp], 2
	jg	SHORT $LN4@IsTestCity@29

; 3037 : 		{
; 3038 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T235027[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T235031[ebp], edx
	push	2
	mov	eax, DWORD PTR _iDY$226869[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$226865[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235027[ebp]
	push	edx
	mov	eax, DWORD PTR $T235031[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$226873[ebp], eax

; 3039 : #endif
; 3040 : 			if(pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$226873[ebp], 0
	je	SHORT $LN3@IsTestCity@29

; 3041 : 			{
; 3042 : 				// FEATURE_FOREST seems dubious to me...
; 3043 : 				if(pLoopPlot->getFeatureType() == FEATURE_FOREST && pLoopPlot->getOwner() == pPlot->getOwner())

	mov	ecx, DWORD PTR _pLoopPlot$226873[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$235142[ebp], dl
	movsx	eax, BYTE PTR _f$235142[ebp]
	cmp	eax, 5
	jne	SHORT $LN3@IsTestCity@29
	mov	ecx, DWORD PTR _pLoopPlot$226873[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T235149[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T235149[ebp], ecx
	jne	SHORT $LN3@IsTestCity@29

; 3044 : 				{
; 3045 : 					iNumForests++;

	mov	edx, DWORD PTR _iNumForests$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumForests$[ebp], edx

; 3046 : 					if(iNumForests > 1)

	cmp	DWORD PTR _iNumForests$[ebp], 1
	jle	SHORT $LN3@IsTestCity@29

; 3047 : 					{
; 3048 : 						return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestCity@29
$LN3@IsTestCity@29:

; 3049 : 					}
; 3050 : 				}
; 3051 : 			}
; 3052 : 		}

	jmp	$LN5@IsTestCity@29
$LN4@IsTestCity@29:

; 3053 : 	}

	jmp	$LN8@IsTestCity@29
$LN7@IsTestCity@29:

; 3054 : 
; 3055 : 	return false;

	xor	al, al
$LN10@IsTestCity@29:

; 3056 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235280 = -108						; size = 4
_f$235273 = -101					; size = 1
$T235162 = -32						; size = 4
$T235158 = -28						; size = 4
_pLoopPlot$226891 = -24					; size = 4
_iDY$226887 = -20					; size = 4
_iDX$226883 = -16					; size = 4
_iNumJungles$ = -12					; size = 4
_iRange$ = -8						; size = 4
_pPlot$ = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity, COMDAT

; 3060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3061 : 	// scan the nearby tiles to see if there are at least two jungles in the vicinity
; 3062 : 	const int iRange = 2;

	mov	DWORD PTR _iRange$[ebp], 2

; 3063 : 	int iNumJungles = 0;

	mov	DWORD PTR _iNumJungles$[ebp], 0

; 3064 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax

; 3065 : 
; 3066 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 3067 : 	int iMaxDX, iDX;
; 3068 : 	CvPlot* pLoopPlot;
; 3069 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 3070 : 	{
; 3071 : 		iMaxDX = iRange - MAX(0, iDY);
; 3072 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 3073 : 		{
; 3074 : 			// No need for range check because loops are set up properly
; 3075 : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 3076 : #else
; 3077 : 	for(int iDX = -iRange; iDX <= iRange; iDX++)

	mov	DWORD PTR _iDX$226883[ebp], -2		; fffffffeH
	jmp	SHORT $LN9@IsTestCity@30
$LN8@IsTestCity@30:
	mov	eax, DWORD PTR _iDX$226883[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$226883[ebp], eax
$LN9@IsTestCity@30:
	cmp	DWORD PTR _iDX$226883[ebp], 2
	jg	$LN7@IsTestCity@30

; 3078 : 	{
; 3079 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	mov	DWORD PTR _iDY$226887[ebp], -2		; fffffffeH
	jmp	SHORT $LN6@IsTestCity@30
$LN5@IsTestCity@30:
	mov	ecx, DWORD PTR _iDY$226887[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$226887[ebp], ecx
$LN6@IsTestCity@30:
	cmp	DWORD PTR _iDY$226887[ebp], 2
	jg	SHORT $LN4@IsTestCity@30

; 3080 : 		{
; 3081 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T235158[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T235162[ebp], edx
	push	2
	mov	eax, DWORD PTR _iDY$226887[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$226883[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235158[ebp]
	push	edx
	mov	eax, DWORD PTR $T235162[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$226891[ebp], eax

; 3082 : #endif
; 3083 : 			if(pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$226891[ebp], 0
	je	SHORT $LN3@IsTestCity@30

; 3084 : 			{
; 3085 : 				// FEATURE_JUNGLE seems dubious to me...
; 3086 : 				if(pLoopPlot->getFeatureType() == FEATURE_JUNGLE && pLoopPlot->getOwner() == pPlot->getOwner())

	mov	ecx, DWORD PTR _pLoopPlot$226891[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$235273[ebp], dl
	movsx	eax, BYTE PTR _f$235273[ebp]
	cmp	eax, 1
	jne	SHORT $LN3@IsTestCity@30
	mov	ecx, DWORD PTR _pLoopPlot$226891[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T235280[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T235280[ebp], ecx
	jne	SHORT $LN3@IsTestCity@30

; 3087 : 				{
; 3088 : 					iNumJungles++;

	mov	edx, DWORD PTR _iNumJungles$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumJungles$[ebp], edx

; 3089 : 					if(iNumJungles > 1)

	cmp	DWORD PTR _iNumJungles$[ebp], 1
	jle	SHORT $LN3@IsTestCity@30

; 3090 : 					{
; 3091 : 						return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestCity@30
$LN3@IsTestCity@30:

; 3092 : 					}
; 3093 : 				}
; 3094 : 			}
; 3095 : 		}

	jmp	$LN5@IsTestCity@30
$LN4@IsTestCity@30:

; 3096 : 	}

	jmp	$LN8@IsTestCity@30
$LN7@IsTestCity@30:

; 3097 : 
; 3098 : 	return false;

	xor	al, al
$LN10@IsTestCity@30:

; 3099 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity
_TEXT	ENDS
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity, COMDAT

; 3104 : {

	push	ebp
	mov	ebp, esp

; 3105 : 	if(pCity->plot()->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestCity@31

; 3106 : 	{
; 3107 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@31
$LN1@IsTestCity@31:

; 3108 : 	}
; 3109 : 
; 3110 : 	return false;

	xor	al, al
$LN2@IsTestCity@31:

; 3111 : }

	pop	ebp
	ret	0
?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity
_TEXT	ENDS
PUBLIC	??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@	; `string'
PUBLIC	__real@00000000
EXTRN	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ:PROC ; CvCity::GetCityEspionage
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
;	COMDAT ??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\farray.h
CONST	SEGMENT
??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@ DB 'FLAVOR_ESPIONAGE', 00H ; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235311 = -48						; size = 4
$T235307 = -44						; size = 4
$T235303 = -40						; size = 4
$T235299 = -36						; size = 4
_eFlavor$226913 = -32					; size = 4
_iFlavor$226909 = -28					; size = 4
_eFlavorEspionage$226908 = -24				; size = 4
_ePlayer$ = -20						; size = 4
_pCityEspionage$ = -16					; size = 4
_pEspionageAI$ = -12					; size = 4
_iTurnsOfEspionage$ = -8				; size = 4
_fRatio$ = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen, COMDAT

; 3114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 3115 : 	PlayerTypes ePlayer = pCity->getOwner();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3116 : 	CvEspionageAI* pEspionageAI = GET_PLAYER(ePlayer).GetEspionageAI();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235299[ebp], edx
	mov	ecx, DWORD PTR $T235299[ebp]
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	DWORD PTR _pEspionageAI$[ebp], eax

; 3117 : 	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	DWORD PTR _pCityEspionage$[ebp], eax

; 3118 : 	float fRatio = 0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fRatio$[ebp], xmm0

; 3119 : 	int iTurnsOfEspionage = GC.getGame().getGameTurn() - pEspionageAI->m_iTurnEspionageStarted;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235303[ebp], eax
	mov	ecx, DWORD PTR $T235303[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _pEspionageAI$[ebp]
	sub	eax, DWORD PTR [ecx+736]
	mov	DWORD PTR _iTurnsOfEspionage$[ebp], eax

; 3120 : 	if (pEspionageAI->m_iTurnEspionageStarted != 0)

	mov	edx, DWORD PTR _pEspionageAI$[ebp]
	cmp	DWORD PTR [edx+736], 0
	je	SHORT $LN7@IsTestCity@32

; 3121 : 	{
; 3122 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;

	mov	DWORD PTR _eFlavorEspionage$226908[ebp], -1

; 3123 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$226909[ebp], 0
	jmp	SHORT $LN6@IsTestCity@32
$LN5@IsTestCity@32:
	mov	eax, DWORD PTR _iFlavor$226909[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavor$226909[ebp], eax
$LN6@IsTestCity@32:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T235307[ebp], ecx
	mov	edx, DWORD PTR _iFlavor$226909[ebp]
	cmp	edx, DWORD PTR $T235307[ebp]
	jge	SHORT $LN4@IsTestCity@32

; 3124 : 		{
; 3125 : 			FlavorTypes eFlavor = (FlavorTypes)iFlavor;

	mov	eax, DWORD PTR _iFlavor$226909[ebp]
	mov	DWORD PTR _eFlavor$226913[ebp], eax

; 3126 : 			if (GC.getFlavorTypes(eFlavor) == "FLAVOR_ESPIONAGE")

	mov	ecx, DWORD PTR _eFlavor$226913[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T235311[ebp], ecx
	push	OFFSET ??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@
	mov	edx, DWORD PTR $T235311[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@IsTestCity@32

; 3127 : 			{
; 3128 : 				eFlavorEspionage = eFlavor;

	mov	ecx, DWORD PTR _eFlavor$226913[ebp]
	mov	DWORD PTR _eFlavorEspionage$226908[ebp], ecx
$LN3@IsTestCity@32:

; 3129 : 			}
; 3130 : 		}

	jmp	SHORT $LN5@IsTestCity@32
$LN4@IsTestCity@32:

; 3131 : 		CvAssertMsg(eFlavorEspionage != NO_FLAVOR, "Could not find espionage flavor!");
; 3132 : 		
; 3133 : 		fRatio = pCityEspionage->m_aiNumTimesCityRobbed[ePlayer] / (float)(iTurnsOfEspionage);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	mov	eax, DWORD PTR _pCityEspionage$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+edx*4+708]
	cvtsi2ss xmm1, DWORD PTR _iTurnsOfEspionage$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fRatio$[ebp], xmm0
$LN7@IsTestCity@32:

; 3134 : 	}
; 3135 : 
; 3136 : 	if (fRatio > 0.0)

	cvtss2sd xmm0, DWORD PTR _fRatio$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN2@IsTestCity@32

; 3137 : 	{
; 3138 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@IsTestCity@32

; 3139 : 	}
; 3140 : 	else

	jmp	SHORT $LN1@IsTestCity@32
$LN2@IsTestCity@32:

; 3141 : 	{
; 3142 : 		return false;

	xor	al, al
$LN1@IsTestCity@32:

; 3143 : 	}
; 3144 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen
_TEXT	ENDS
PUBLIC	__real@3d4ccccd
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
;	COMDAT __real@3d4ccccd
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235359 = -72						; size = 4
$T235355 = -68						; size = 4
$T235351 = -64						; size = 4
$T235347 = -60						; size = 4
$T235343 = -56						; size = 4
$T235331 = -52						; size = 4
$T235327 = -48						; size = 4
_eFlavor$226941 = -44					; size = 4
_iFlavor$226937 = -40					; size = 4
_fCutOff$226946 = -36					; size = 4
_eFlavorEspionage$226936 = -32				; size = 4
_fRatio$226944 = -28					; size = 4
_iCityScienceOutput$ = -24				; size = 4
_ePlayer$ = -20						; size = 4
_iNumOtherCities$ = -16					; size = 4
_pLoopCity$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_iNumBetterScienceCities$ = -4				; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity, COMDAT

; 3147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 3148 : 	if (GET_PLAYER(pCity->getOwner()).GetEspionageAI()->m_iTurnEspionageStarted == -1)

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T235327[ebp], ecx
	mov	edx, DWORD PTR $T235327[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235331[ebp], edx
	mov	ecx, DWORD PTR $T235331[ebp]
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	cmp	DWORD PTR [eax+736], -1
	jne	SHORT $LN14@IsTestCity@33

; 3149 : 	{
; 3150 : 		return false;

	xor	al, al
	jmp	$LN1@IsTestCity@33
$LN14@IsTestCity@33:

; 3151 : 	}
; 3152 : 
; 3153 : 	PlayerTypes ePlayer = pCity->getOwner();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3154 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 3155 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[ebp], 0

; 3156 : 	int iNumBetterScienceCities = 0;

	mov	DWORD PTR _iNumBetterScienceCities$[ebp], 0

; 3157 : 	int iNumOtherCities = 0;

	mov	DWORD PTR _iNumOtherCities$[ebp], 0

; 3158 : 	int iCityScienceOutput = pCity->getYieldRateTimes100(YIELD_SCIENCE, false);

	push	0
	push	3
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	DWORD PTR _iCityScienceOutput$[ebp], eax

; 3159 : 
; 3160 : 	for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235343[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235343[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN13@IsTestCity@33
$LN12@IsTestCity@33:
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235347[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235347[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN13@IsTestCity@33:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN11@IsTestCity@33

; 3161 : 	{
; 3162 : 		iNumOtherCities++;

	mov	eax, DWORD PTR _iNumOtherCities$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumOtherCities$[ebp], eax

; 3163 : 		// don't evaluate ourselves
; 3164 : 		if (pLoopCity == pCity)

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	cmp	ecx, DWORD PTR _pCity$[ebp]
	jne	SHORT $LN10@IsTestCity@33

; 3165 : 		{
; 3166 : 			continue;

	jmp	SHORT $LN12@IsTestCity@33
$LN10@IsTestCity@33:

; 3167 : 		}
; 3168 : 
; 3169 : 		if (pLoopCity->getYieldRateTimes100(YIELD_SCIENCE, false) > iCityScienceOutput)

	push	0
	push	3
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cmp	eax, DWORD PTR _iCityScienceOutput$[ebp]
	jle	SHORT $LN9@IsTestCity@33

; 3170 : 		{
; 3171 : 			iNumBetterScienceCities++;

	mov	edx, DWORD PTR _iNumBetterScienceCities$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumBetterScienceCities$[ebp], edx
$LN9@IsTestCity@33:

; 3172 : 		}
; 3173 : 	}

	jmp	SHORT $LN12@IsTestCity@33
$LN11@IsTestCity@33:

; 3174 : 
; 3175 : 	if (iNumOtherCities > 0)

	cmp	DWORD PTR _iNumOtherCities$[ebp], 0
	jle	$LN8@IsTestCity@33

; 3176 : 	{
; 3177 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;

	mov	DWORD PTR _eFlavorEspionage$226936[ebp], -1

; 3178 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$226937[ebp], 0
	jmp	SHORT $LN7@IsTestCity@33
$LN6@IsTestCity@33:
	mov	eax, DWORD PTR _iFlavor$226937[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavor$226937[ebp], eax
$LN7@IsTestCity@33:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T235351[ebp], ecx
	mov	edx, DWORD PTR _iFlavor$226937[ebp]
	cmp	edx, DWORD PTR $T235351[ebp]
	jge	SHORT $LN5@IsTestCity@33

; 3179 : 		{
; 3180 : 			FlavorTypes eFlavor = (FlavorTypes)iFlavor;

	mov	eax, DWORD PTR _iFlavor$226937[ebp]
	mov	DWORD PTR _eFlavor$226941[ebp], eax

; 3181 : 			if (GC.getFlavorTypes(eFlavor) == "FLAVOR_ESPIONAGE")

	mov	ecx, DWORD PTR _eFlavor$226941[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T235355[ebp], ecx
	push	OFFSET ??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@
	mov	edx, DWORD PTR $T235355[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsTestCity@33

; 3182 : 			{
; 3183 : 				eFlavorEspionage = eFlavor;

	mov	ecx, DWORD PTR _eFlavor$226941[ebp]
	mov	DWORD PTR _eFlavorEspionage$226936[ebp], ecx
$LN4@IsTestCity@33:

; 3184 : 			}
; 3185 : 		}

	jmp	SHORT $LN6@IsTestCity@33
$LN5@IsTestCity@33:

; 3186 : 		CvAssertMsg(eFlavorEspionage != NO_FLAVOR, "Could not find espionage flavor!");
; 3187 : 
; 3188 : 		float fRatio = iNumBetterScienceCities / (float)iNumOtherCities;

	cvtsi2ss xmm0, DWORD PTR _iNumBetterScienceCities$[ebp]
	cvtsi2ss xmm1, DWORD PTR _iNumOtherCities$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fRatio$226944[ebp], xmm0

; 3189 : 		float fCutOff = (0.05f * GET_PLAYER(ePlayer).GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavorEspionage));

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235359[ebp], edx
	mov	eax, DWORD PTR _eFlavorEspionage$226936[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235359[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _fCutOff$226946[ebp], xmm0

; 3190 : 
; 3191 : 		if (fRatio < fCutOff)

	movss	xmm0, DWORD PTR _fCutOff$226946[ebp]
	comiss	xmm0, DWORD PTR _fRatio$226944[ebp]
	jbe	SHORT $LN3@IsTestCity@33

; 3192 : 		{
; 3193 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsTestCity@33

; 3194 : 		}
; 3195 : 		else

	jmp	SHORT $LN2@IsTestCity@33
$LN3@IsTestCity@33:

; 3196 : 		{
; 3197 : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsTestCity@33
$LN2@IsTestCity@33:

; 3198 : 		}
; 3199 : 	}
; 3200 : 	else

	jmp	SHORT $LN1@IsTestCity@33
$LN8@IsTestCity@33:

; 3201 : 	{
; 3202 : 		return false;

	xor	al, al
$LN1@IsTestCity@33:

; 3203 : 	}
; 3204 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity
_TEXT	ENDS
PUBLIC	??_C@_0BD@EAEEACNP@UNITCLASS_ENGINEER?$AA@	; `string'
PUBLIC	??_C@_0BD@GIKGAGAO@UNITCLASS_MERCHANT?$AA@	; `string'
PUBLIC	??_C@_0BD@BKOELLOP@UNITCLASS_MUSICIAN?$AA@	; `string'
PUBLIC	??_C@_0BB@ILPBPHBP@UNITCLASS_ARTIST?$AA@	; `string'
PUBLIC	??_C@_0BB@PLANPKNO@UNITCLASS_WRITER?$AA@	; `string'
PUBLIC	??_C@_0BE@NHLKBGBE@UNITCLASS_SCIENTIST?$AA@	; `string'
EXTRN	?getGreatEngineerRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatEngineerRateModifier
EXTRN	?getGreatMerchantRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatMerchantRateModifier
EXTRN	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::calculateTotalYield
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?getGreatMusicianRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatMusicianRateModifier
EXTRN	?getGreatArtistRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatArtistRateModifier
EXTRN	?getGreatWriterRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatWriterRateModifier
EXTRN	?getGreatScientistRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatScientistRateModifier
EXTRN	?getGreatPeopleRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatPeopleRateModifier
EXTRN	?getGreatPeopleRateModifier@CvCity@@QBEHXZ:PROC	; CvCity::getGreatPeopleRateModifier
EXTRN	?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z:PROC ; CvCityCitizens::GetBuildingGreatPeopleRateChanges
EXTRN	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getGreatPeopleRateChange
EXTRN	?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z:PROC ; CvCityCitizens::GetSpecialistCount
EXTRN	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getGreatPeopleUnitClass
EXTRN	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z:PROC ; CvGlobals::getSpecialistInfo
EXTRN	?getNumSpecialistInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSpecialistInfos
;	COMDAT ??_C@_0BD@EAEEACNP@UNITCLASS_ENGINEER?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
CONST	SEGMENT
??_C@_0BD@EAEEACNP@UNITCLASS_ENGINEER?$AA@ DB 'UNITCLASS_ENGINEER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIKGAGAO@UNITCLASS_MERCHANT?$AA@
CONST	SEGMENT
??_C@_0BD@GIKGAGAO@UNITCLASS_MERCHANT?$AA@ DB 'UNITCLASS_MERCHANT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BKOELLOP@UNITCLASS_MUSICIAN?$AA@
CONST	SEGMENT
??_C@_0BD@BKOELLOP@UNITCLASS_MUSICIAN?$AA@ DB 'UNITCLASS_MUSICIAN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILPBPHBP@UNITCLASS_ARTIST?$AA@
CONST	SEGMENT
??_C@_0BB@ILPBPHBP@UNITCLASS_ARTIST?$AA@ DB 'UNITCLASS_ARTIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PLANPKNO@UNITCLASS_WRITER?$AA@
CONST	SEGMENT
??_C@_0BB@PLANPKNO@UNITCLASS_WRITER?$AA@ DB 'UNITCLASS_WRITER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NHLKBGBE@UNITCLASS_SCIENTIST?$AA@
CONST	SEGMENT
??_C@_0BE@NHLKBGBE@UNITCLASS_SCIENTIST?$AA@ DB 'UNITCLASS_SCIENTIST', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235368 = -40						; size = 4
$T235367 = -36						; size = 4
_iProductionToGreatMusiciansModifier$226982 = -32	; size = 4
_iMod$226966 = -28					; size = 4
_iCount$226963 = -24					; size = 4
_iGPPChange$226964 = -20				; size = 4
_eSpecialist$226958 = -16				; size = 4
_pkSpecialistInfo$226960 = -12				; size = 4
_iSpecialistLoop$226954 = -8				; size = 4
_iTotalGPPChange$ = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity, COMDAT

; 3208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 3209 : 	// if this city is producing at least 8 GP points a turn (since most GP mod buildings increase by 25% this will yield 2 extra GP points a turn)
; 3210 : 
; 3211 : 	int iTotalGPPChange = 0;

	mov	DWORD PTR _iTotalGPPChange$[ebp], 0

; 3212 : 
; 3213 : #ifdef AUI_WARNING_FIXES
; 3214 : 	for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 3215 : #else
; 3216 : 	for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	mov	DWORD PTR _iSpecialistLoop$226954[ebp], 0
	jmp	SHORT $LN19@IsTestCity@34
$LN18@IsTestCity@34:
	mov	eax, DWORD PTR _iSpecialistLoop$226954[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpecialistLoop$226954[ebp], eax
$LN19@IsTestCity@34:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	DWORD PTR _iSpecialistLoop$226954[ebp], eax
	jge	$LN17@IsTestCity@34

; 3217 : #endif
; 3218 : 	{
; 3219 : 		const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);

	mov	ecx, DWORD PTR _iSpecialistLoop$226954[ebp]
	mov	DWORD PTR _eSpecialist$226958[ebp], ecx

; 3220 : 		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	mov	edx, DWORD PTR _eSpecialist$226958[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
	mov	DWORD PTR _pkSpecialistInfo$226960[ebp], eax

; 3221 : 		if(pkSpecialistInfo)

	cmp	DWORD PTR _pkSpecialistInfo$226960[ebp], 0
	je	$LN16@IsTestCity@34

; 3222 : 		{
; 3223 : 			// Does this Specialist spawn a GP?
; 3224 : 			if (pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, -1
	je	$LN16@IsTestCity@34

; 3225 : 			{
; 3226 : 				int iCount = pCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);

	mov	eax, DWORD PTR _eSpecialist$226958[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistCount
	mov	DWORD PTR _iCount$226963[ebp], eax

; 3227 : 
; 3228 : 				// GPP from Specialists
; 3229 : 				int iGPPChange = pkSpecialistInfo->getGreatPeopleRateChange() * iCount * 100;

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleRateChange
	imul	eax, DWORD PTR _iCount$226963[ebp]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iGPPChange$226964[ebp], eax

; 3230 : 
; 3231 : 				// GPP from Buildings
; 3232 : 				iGPPChange += pCity->GetCityCitizens()->GetBuildingGreatPeopleRateChanges(eSpecialist) * 100;

	mov	ecx, DWORD PTR _eSpecialist$226958[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetBuildingGreatPeopleRateChanges
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iGPPChange$226964[ebp]
	mov	DWORD PTR _iGPPChange$226964[ebp], eax

; 3233 : 
; 3234 : 				if (iGPPChange > 0)

	cmp	DWORD PTR _iGPPChange$226964[ebp], 0
	jle	$LN16@IsTestCity@34

; 3235 : 				{
; 3236 : 					int iMod = 0;

	mov	DWORD PTR _iMod$226966[ebp], 0

; 3237 : 
; 3238 : 					// City mod
; 3239 : 					iMod += pCity->getGreatPeopleRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getGreatPeopleRateModifier@CvCity@@QBEHXZ ; CvCity::getGreatPeopleRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax

; 3240 : 
; 3241 : 					// Player mod
; 3242 : 					iMod += pCity->GetPlayer()->getGreatPeopleRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatPeopleRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatPeopleRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax

; 3243 : 
; 3244 : 					// Trait mod to this specific class
; 3245 : 					if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BE@NHLKBGBE@UNITCLASS_SCIENTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN13@IsTestCity@34

; 3246 : 					{
; 3247 : 						iMod += pCity->GetPlayer()->GetPlayerTraits()->GetGreatScientistRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T235367[ebp], eax
	mov	edx, DWORD PTR $T235367[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T235368[ebp], eax
	mov	ecx, DWORD PTR _iMod$226966[ebp]
	add	ecx, DWORD PTR $T235368[ebp]
	mov	DWORD PTR _iMod$226966[ebp], ecx

; 3248 : 						iMod += pCity->GetPlayer()->getGreatScientistRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatScientistRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatScientistRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax
	jmp	$LN12@IsTestCity@34
$LN13@IsTestCity@34:

; 3249 : 					}
; 3250 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BB@PLANPKNO@UNITCLASS_WRITER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN11@IsTestCity@34

; 3251 : 					{
; 3252 : 						iMod += pCity->GetPlayer()->getGreatWriterRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatWriterRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatWriterRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax
	jmp	$LN12@IsTestCity@34
$LN11@IsTestCity@34:

; 3253 : 					}					
; 3254 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BB@ILPBPHBP@UNITCLASS_ARTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN9@IsTestCity@34

; 3255 : 					{
; 3256 : 						iMod += pCity->GetPlayer()->getGreatArtistRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatArtistRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatArtistRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax
	jmp	$LN12@IsTestCity@34
$LN9@IsTestCity@34:

; 3257 : 					}					
; 3258 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BD@BKOELLOP@UNITCLASS_MUSICIAN?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN7@IsTestCity@34

; 3259 : 					{
; 3260 : 						iMod += pCity->GetPlayer()->getGreatMusicianRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatMusicianRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMusicianRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax

; 3261 : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 3262 : 						int iProductionToGreatMusiciansModifier = pCity->GetPlayer()->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	DWORD PTR _iProductionToGreatMusiciansModifier$226982[ebp], eax

; 3263 : 						if (iProductionToGreatMusiciansModifier > 0)

	cmp	DWORD PTR _iProductionToGreatMusiciansModifier$226982[ebp], 0
	jle	SHORT $LN6@IsTestCity@34

; 3264 : 						{
; 3265 : 							iMod += pCity->GetPlayer()->calculateTotalYield(YIELD_PRODUCTION) * iProductionToGreatMusiciansModifier / 100;

	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	imul	eax, DWORD PTR _iProductionToGreatMusiciansModifier$226982[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax
$LN6@IsTestCity@34:

; 3266 : 						}
; 3267 : #endif
; 3268 : 					}

	jmp	SHORT $LN12@IsTestCity@34
$LN7@IsTestCity@34:

; 3269 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BD@GIKGAGAO@UNITCLASS_MERCHANT?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN4@IsTestCity@34

; 3270 : 					{
; 3271 : 						iMod += pCity->GetPlayer()->getGreatMerchantRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatMerchantRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMerchantRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax
	jmp	SHORT $LN12@IsTestCity@34
$LN4@IsTestCity@34:

; 3272 : 					}
; 3273 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))

	mov	ecx, DWORD PTR _pkSpecialistInfo$226960[ebp]
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BD@EAEEACNP@UNITCLASS_ENGINEER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN12@IsTestCity@34

; 3274 : 					{
; 3275 : 						iMod += pCity->GetPlayer()->getGreatEngineerRateModifier();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatEngineerRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatEngineerRateModifier
	add	eax, DWORD PTR _iMod$226966[ebp]
	mov	DWORD PTR _iMod$226966[ebp], eax
$LN12@IsTestCity@34:

; 3276 : 					}
; 3277 : 
; 3278 : 					iGPPChange *= (100 + iMod);

	mov	edx, DWORD PTR _iMod$226966[ebp]
	add	edx, 100				; 00000064H
	imul	edx, DWORD PTR _iGPPChange$226964[ebp]
	mov	DWORD PTR _iGPPChange$226964[ebp], edx

; 3279 : 					iGPPChange /= 100;

	mov	eax, DWORD PTR _iGPPChange$226964[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGPPChange$226964[ebp], eax

; 3280 : 
; 3281 : 					iTotalGPPChange += iGPPChange;

	mov	edx, DWORD PTR _iTotalGPPChange$[ebp]
	add	edx, DWORD PTR _iGPPChange$226964[ebp]
	mov	DWORD PTR _iTotalGPPChange$[ebp], edx
$LN16@IsTestCity@34:

; 3282 : 				}
; 3283 : 			}
; 3284 : 		}
; 3285 : 	}

	jmp	$LN18@IsTestCity@34
$LN17@IsTestCity@34:

; 3286 : 
; 3287 : 	if (iTotalGPPChange >= 800)

	cmp	DWORD PTR _iTotalGPPChange$[ebp], 800	; 00000320H
	jl	SHORT $LN1@IsTestCity@34

; 3288 : 	{
; 3289 : 		return true;

	mov	al, 1
	jmp	SHORT $LN20@IsTestCity@34
$LN1@IsTestCity@34:

; 3290 : 	}
; 3291 : 
; 3292 : 	return false;

	xor	al, al
$LN20@IsTestCity@34:

; 3293 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity
_TEXT	ENDS
EXTRN	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z:PROC ; CvPlayerTrade::GetNumPotentialConnections
EXTRN	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z:PROC ; CvPlayerTrade::GetNumTradeRoutesRemaining
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z
_TEXT	SEGMENT
$T235382 = -12						; size = 4
_ePlayer$ = -8						; size = 4
_pTrade$ = -4						; size = 4
_pCity$ = 8						; size = 4
_eDomain$ = 12						; size = 4
?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute, COMDAT

; 3296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3297 : 	PlayerTypes ePlayer = pCity->getOwner();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3298 : 	CvPlayerTrade* pTrade = GET_PLAYER(ePlayer).GetTrade();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235382[ebp], edx
	mov	ecx, DWORD PTR $T235382[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3299 : 
; 3300 : 	if (pTrade->GetNumTradeRoutesRemaining(false) <= 0)

	push	0
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesRemaining
	test	eax, eax
	jg	SHORT $LN2@IsTestCity@35

; 3301 : 	{
; 3302 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsTestCity@35
$LN2@IsTestCity@35:

; 3303 : 	}
; 3304 : 
; 3305 : 	if (pTrade->GetNumPotentialConnections(pCity, eDomain) <= 0)

	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ; CvPlayerTrade::GetNumPotentialConnections
	test	eax, eax
	jg	SHORT $LN1@IsTestCity@35

; 3306 : 	{
; 3307 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsTestCity@35
$LN1@IsTestCity@35:

; 3308 : 	}
; 3309 : 
; 3310 : 	return true;

	mov	al, 1
$LN3@IsTestCity@35:

; 3311 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z
_TEXT	SEGMENT
$T235396 = -12						; size = 4
_ePlayer$ = -8						; size = 4
_pTrade$ = -4						; size = 4
_pCity$ = 8						; size = 4
_eDomain$ = 12						; size = 4
?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute, COMDAT

; 3314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3315 : 	PlayerTypes ePlayer = pCity->getOwner();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3316 : 	CvPlayerTrade* pTrade = GET_PLAYER(ePlayer).GetTrade();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235396[ebp], edx
	mov	ecx, DWORD PTR $T235396[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3317 : 
; 3318 : 	if (pTrade->GetNumTradeRoutesRemaining(false) <= 0)

	push	0
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesRemaining
	test	eax, eax
	jg	SHORT $LN2@IsTestCity@36

; 3319 : 	{
; 3320 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@36
$LN2@IsTestCity@36:

; 3321 : 	}
; 3322 : 
; 3323 : 	if (pTrade->GetNumPotentialConnections(pCity, eDomain) <= 0)

	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ; CvPlayerTrade::GetNumPotentialConnections
	test	eax, eax
	jg	SHORT $LN1@IsTestCity@36

; 3324 : 	{
; 3325 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@36
$LN1@IsTestCity@36:

; 3326 : 	}
; 3327 : 
; 3328 : 	return false;

	xor	al, al
$LN3@IsTestCity@36:

; 3329 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
_TEXT	ENDS
EXTRN	?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z:PROC ; CvGameTrade::GetNumTimesDestinationCity
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235402 = -8						; size = 4
_iNumTimesDestination$ = -4				; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination, COMDAT

; 3332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3333 : 	int iNumTimesDestination = GC.getGame().GetGameTrade()->GetNumTimesDestinationCity(pCity, true);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235402[ebp], eax
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235402[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesDestinationCity
	mov	DWORD PTR _iNumTimesDestination$[ebp], eax

; 3334 : 	if (iNumTimesDestination >= 2)

	cmp	DWORD PTR _iNumTimesDestination$[ebp], 2
	jl	SHORT $LN2@IsTestCity@37

; 3335 : 	{
; 3336 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@37

; 3337 : 	}
; 3338 : 	else

	jmp	SHORT $LN3@IsTestCity@37
$LN2@IsTestCity@37:

; 3339 : 	{
; 3340 : 		return false;

	xor	al, al
$LN3@IsTestCity@37:

; 3341 : 	}
; 3342 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination
_TEXT	ENDS
EXTRN	?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z:PROC ; CvGameTrade::GetNumTimesOriginCity
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235408 = -8						; size = 4
_iNumTimesOrigin$ = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin, COMDAT

; 3345 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3346 : 	int iNumTimesOrigin = GC.getGame().GetGameTrade()->GetNumTimesOriginCity(pCity, true);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235408[ebp], eax
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235408[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesOriginCity
	mov	DWORD PTR _iNumTimesOrigin$[ebp], eax

; 3347 : 	if (iNumTimesOrigin >= 2)

	cmp	DWORD PTR _iNumTimesOrigin$[ebp], 2
	jl	SHORT $LN2@IsTestCity@38

; 3348 : 	{
; 3349 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@38

; 3350 : 	}
; 3351 : 	else

	jmp	SHORT $LN3@IsTestCity@38
$LN2@IsTestCity@38:

; 3352 : 	{
; 3353 : 		return false;

	xor	al, al
$LN3@IsTestCity@38:

; 3354 : 	}	
; 3355 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin
_TEXT	ENDS
EXTRN	?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z:PROC ; CvPlayerCulture::GetNumGreatWorkSlots
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ:PROC ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding
EXTRN	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ:PROC ; CvCity::GetCityCulture
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235419 = -16						; size = 4
_iSlotsOpen$227027 = -12				; size = 4
_eSlotType$ = -8					; size = 4
_kPlayer$ = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding, COMDAT

; 3358 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3359 : 	CvPlayer &kPlayer = GET_PLAYER(pCity->getOwner());

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T235419[ebp], ecx
	mov	edx, DWORD PTR $T235419[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 3360 : 
; 3361 : 	GreatWorkSlotType eSlotType = pCity->GetCityCulture()->GetSlotTypeFirstAvailableCultureBuilding();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding
	mov	DWORD PTR _eSlotType$[ebp], eax

; 3362 : 
; 3363 : 	if (eSlotType != NO_GREAT_WORK_SLOT)

	cmp	DWORD PTR _eSlotType$[ebp], -1
	je	SHORT $LN2@IsTestCity@39

; 3364 : 	{
; 3365 : 		int iSlotsOpen = kPlayer.GetCulture()->GetNumGreatWorkSlots(eSlotType);

	mov	eax, DWORD PTR _eSlotType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumGreatWorkSlots
	mov	DWORD PTR _iSlotsOpen$227027[ebp], eax

; 3366 : 
; 3367 : 		if (iSlotsOpen <= 2)

	cmp	DWORD PTR _iSlotsOpen$227027[ebp], 2
	jg	SHORT $LN2@IsTestCity@39

; 3368 : 		{
; 3369 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestCity@39
$LN2@IsTestCity@39:

; 3370 : 		}
; 3371 : 	}
; 3372 : 
; 3373 : 	return false;

	xor	al, al
$LN3@IsTestCity@39:

; 3374 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding
_TEXT	ENDS
EXTRN	?GetBaseTourism@CvCityCulture@@QAEHXZ:PROC	; CvCityCulture::GetBaseTourism
EXTRN	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ:PROC ; CvCityCulture::GetCultureFromImprovements
EXTRN	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ:PROC ; CvCityCulture::GetCultureFromNaturalWonders
EXTRN	?GetCultureFromWonders@CvCityCulture@@QBEHXZ:PROC ; CvCityCulture::GetCultureFromWonders
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_iTourismValue$ = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding, COMDAT

; 3377 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3378 : 	int iTourismValue = 0;

	mov	DWORD PTR _iTourismValue$[ebp], 0

; 3379 : #ifdef AUI_WARNING_FIXES
; 3380 : 	const CvCityCulture* pCityCulture = pCity->GetCityCulture();
; 3381 : 	iTourismValue += pCityCulture->GetCultureFromWonders();
; 3382 : 	iTourismValue += pCityCulture->GetCultureFromNaturalWonders();
; 3383 : 	iTourismValue += pCityCulture->GetCultureFromImprovements();
; 3384 : 	iTourismValue += pCityCulture->GetBaseTourism();
; 3385 : #else
; 3386 : 	iTourismValue += pCity->GetCityCulture()->GetCultureFromWonders();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetCultureFromWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromWonders
	add	eax, DWORD PTR _iTourismValue$[ebp]
	mov	DWORD PTR _iTourismValue$[ebp], eax

; 3387 : 	iTourismValue += pCity->GetCityCulture()->GetCultureFromNaturalWonders();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromNaturalWonders
	add	eax, DWORD PTR _iTourismValue$[ebp]
	mov	DWORD PTR _iTourismValue$[ebp], eax

; 3388 : 	iTourismValue += pCity->GetCityCulture()->GetCultureFromImprovements();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromImprovements
	add	eax, DWORD PTR _iTourismValue$[ebp]
	mov	DWORD PTR _iTourismValue$[ebp], eax

; 3389 : 	iTourismValue += pCity->GetCityCulture()->GetBaseTourism();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetBaseTourism@CvCityCulture@@QAEHXZ	; CvCityCulture::GetBaseTourism
	add	eax, DWORD PTR _iTourismValue$[ebp]
	mov	DWORD PTR _iTourismValue$[ebp], eax

; 3390 : #endif
; 3391 : 
; 3392 : 	if (iTourismValue > 10)

	cmp	DWORD PTR _iTourismValue$[ebp], 10	; 0000000aH
	jle	SHORT $LN1@IsTestCity@40

; 3393 : 	{
; 3394 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestCity@40
$LN1@IsTestCity@40:

; 3395 : 	}
; 3396 : 
; 3397 : 	return false;

	xor	al, al
$LN2@IsTestCity@40:

; 3398 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Odtp
;	COMDAT ?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T235474 = -28						; size = 4
$T235465 = -24						; size = 4
$T235456 = -20						; size = 4
$T235447 = -16						; size = 4
$T235435 = -12						; size = 4
_pCapital$ = -8						; size = 4
_kPlayer$ = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity, COMDAT

; 3401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	esi

; 3402 : #ifdef AUI_WARNING_FIXES
; 3403 : 	if (!pCity)
; 3404 : 		return false;
; 3405 : #endif
; 3406 : 	if (pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@IsTestCity@41

; 3407 : 	{
; 3408 : 		return true;

	mov	al, 1
	jmp	$LN4@IsTestCity@41

; 3409 : 	}
; 3410 : 
; 3411 : 	CvPlayer &kPlayer = GET_PLAYER(pCity->getOwner());

$LN8@IsTestCity@41:
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T235435[ebp], edx
	mov	eax, DWORD PTR $T235435[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 3412 : 	CvCity *pCapital = kPlayer.getCapitalCity();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapital$[ebp], eax

; 3413 : #ifdef AUI_WARNING_FIXES
; 3414 : 	if (!pCapital)
; 3415 : 		return false;
; 3416 : 	if (pCity->getArea() != pCapital->getArea())
; 3417 : #else
; 3418 : 	if (pCity && pCity->getArea() != pCapital->getArea())

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN14@IsTestCity@41
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	esi, eax
	mov	ecx, DWORD PTR _pCapital$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	esi, eax
	je	SHORT $LN14@IsTestCity@41

; 3419 : #endif
; 3420 : 	{
; 3421 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@IsTestCity@41

; 3422 : 	}
; 3423 : 
; 3424 : 	if (plotDistance (pCity->getX(), pCity->getY(), pCapital->getX(), pCapital->getY()) > 20)

$LN14@IsTestCity@41:
	mov	ecx, DWORD PTR _pCapital$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T235447[ebp], edx
	mov	eax, DWORD PTR _pCapital$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T235456[ebp], ecx
	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T235465[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T235474[ebp], edx
	mov	eax, DWORD PTR $T235447[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235456[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235465[ebp]
	push	edx
	mov	eax, DWORD PTR $T235474[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN1@IsTestCity@41

; 3425 : 	{
; 3426 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@IsTestCity@41
$LN1@IsTestCity@41:

; 3427 : 	}
; 3428 : 
; 3429 : 	return false;

	xor	al, al
$LN4@IsTestCity@41:

; 3430 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T235642 = -80						; size = 4
$T235616 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T235616[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T235616[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T235616[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T235642[ebp], edx
	mov	eax, DWORD PTR $T235642[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T235666 = -16						; size = 4
$T235658 = -12						; size = 4
$T235654 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T235654[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235658[ebp], ecx
	movzx	edx, BYTE PTR $T235654[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T235658[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T235658[ebp]
	mov	DWORD PTR $T235666[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T235658[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T235658[ebp]
	mov	DWORD PTR $T235666[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T235666[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T235666[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T235687 = -16						; size = 4
$T235679 = -12						; size = 4
$T235675 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T235675[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T235679[ebp], ecx
	movzx	edx, BYTE PTR $T235675[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T235679[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T235679[ebp]
	mov	DWORD PTR $T235687[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T235679[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T235679[ebp]
	mov	DWORD PTR $T235687[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T235687[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T235687[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T235786 = -32						; size = 4
$T235779 = -28						; size = 4
_elem$227100 = -24					; size = 16
_i$227096 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 		int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	mov	DWORD PTR _i$227096[ebp], 0
	jmp	SHORT $LN3@GetTotalWe
$LN2@GetTotalWe:
	mov	eax, DWORD PTR _i$227096[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227096[ebp], eax
$LN3@GetTotalWe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235779[ebp], edx
	mov	eax, DWORD PTR _i$227096[ebp]
	cmp	eax, DWORD PTR $T235779[ebp]
	jae	SHORT $LN1@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];

	mov	ecx, DWORD PTR _i$227096[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T235786[ebp], ecx
	mov	eax, DWORD PTR $T235786[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$227100[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$227100[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$227100[ebp+8], eax
	mov	ecx, DWORD PTR $T235786[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _elem$227100[ebp+12], edx

; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	add	eax, DWORD PTR _elem$227100[ebp+12]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 96   : 		}

	jmp	SHORT $LN2@GetTotalWe
$LN1@GetTotalWe:

; 97   : 
; 98   : 		return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 99   : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T235816 = -44						; size = 4
$T235812 = -40						; size = 4
$T235796 = -36						; size = 4
$T235792 = -32						; size = 4
_iTotalTopChoicesWeight$ = -28				; size = 4
_iChoice$ = -24						; size = 4
_i$ = -20						; size = 4
_elem$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_iNumChoices$ = 12					; size = 4
_rndFcn$ = 16						; size = 4
_szRollName$ = 20					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235792[ebp], ecx
	mov	edx, DWORD PTR _iNumChoices$[ebp]
	cmp	edx, DWORD PTR $T235792[ebp]
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235796[ebp], ecx
	mov	edx, DWORD PTR $T235796[ebp]
	mov	DWORD PTR _iNumChoices$[ebp], edx
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	mov	DWORD PTR _elem$[ebp], 0
	mov	DWORD PTR _elem$[ebp+4], 0
	mov	DWORD PTR _elem$[ebp+8], 0
	mov	DWORD PTR _elem$[ebp+12], 0

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], 0

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ChooseFrom
$LN6@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ChooseFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN5@ChooseFrom

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _elem$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _elem$[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _elem$[ebp+12], eax

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	add	ecx, DWORD PTR _elem$[ebp+12]
	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], ecx

; 240  : 		}

	jmp	SHORT $LN6@ChooseFrom
$LN5@ChooseFrom:

; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235812[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T235816[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235816[ebp]
	call	DWORD PTR $T235812[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ChooseFrom
$LN3@ChooseFrom:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN2@ChooseFrom

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$[ebp+12], edx

; 249  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+12]
	mov	DWORD PTR _iChoice$[ebp], eax

; 250  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseFrom

; 251  : 			{
; 252  : 				return elem.m_Element;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _elem$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN9@ChooseFrom
$LN1@ChooseFrom:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN3@ChooseFrom
$LN2@ChooseFrom:

; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _elem$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@ChooseFrom:

; 260  : 	};

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T235857 = -30						; size = 1
$T235844 = -29						; size = 1
$T235840 = -28						; size = 4
$T235833 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T235857[ebp]
	mov	DWORD PTR $T235833[ebp], eax
	lea	ecx, DWORD PTR $T235844[ebp]
	mov	DWORD PTR $T235840[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -208						; size = 4
tv148 = -204						; size = 4
tv172 = -200						; size = 4
_this$ = -196						; size = 4
$T236019 = -164						; size = 4
$T236018 = -160						; size = 4
$T236017 = -156						; size = 4
$T236007 = -152						; size = 4
$T236006 = -148						; size = 4
__Cat$236014 = -143					; size = 1
$T236012 = -142						; size = 1
$T236011 = -141						; size = 1
$T235986 = -140						; size = 4
$T235977 = -136						; size = 4
$T235946 = -48						; size = 4
$T235942 = -42						; size = 1
$T235929 = -41						; size = 1
$T235925 = -40						; size = 4
$T235918 = -32						; size = 4
$T235909 = -28						; size = 4
$T235908 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T235942[ebp]
	mov	DWORD PTR $T235918[ebp], eax
	lea	ecx, DWORD PTR $T235929[ebp]
	mov	DWORD PTR $T235925[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T235946[ebp], eax
	mov	ecx, DWORD PTR $T235946[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T235977[ebp], ecx
	mov	edx, DWORD PTR $T235977[ebp]
	mov	DWORD PTR $T235908[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235986[ebp], ecx
	mov	edx, DWORD PTR $T235986[ebp]
	mov	DWORD PTR $T235909[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236019[ebp], ecx
	mov	edx, DWORD PTR $T235908[ebp]
	mov	DWORD PTR $T236018[ebp], edx
	mov	eax, DWORD PTR $T235909[ebp]
	mov	DWORD PTR $T236017[ebp], eax
	mov	ecx, DWORD PTR $T236019[ebp]
	mov	DWORD PTR $T236007[ebp], ecx
	mov	edx, DWORD PTR $T236017[ebp]
	mov	DWORD PTR $T236006[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T236011[ebp], al
	mov	cl, BYTE PTR __Cat$236014[ebp]
	mov	BYTE PTR $T236012[ebp], cl
	movzx	edx, BYTE PTR $T236011[ebp]
	push	edx
	movzx	eax, BYTE PTR $T236012[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236007[ebp]
	push	edx
	mov	eax, DWORD PTR $T236018[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236006[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
PUBLIC	?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv224 = -308						; size = 4
_this$ = -304						; size = 4
$T236401 = -300						; size = 4
$T236400 = -296						; size = 4
$T236399 = -292						; size = 4
$T236345 = -176						; size = 4
$T236341 = -172						; size = 4
$T236340 = -168						; size = 4
$T236336 = -164						; size = 4
$T236335 = -160						; size = 4
$T236324 = -156						; size = 4
$T236323 = -152						; size = 4
__Cat$236332 = -146					; size = 1
$T236329 = -145						; size = 1
$T236304 = -144						; size = 4
$T236303 = -140						; size = 4
$T236251 = -84						; size = 4
$T236244 = -80						; size = 4
$T236233 = -76						; size = 4
$T236232 = -72						; size = 4
__Cat$236241 = -68					; size = 1
$T236238 = -67						; size = 1
$T236188 = -40						; size = 4
$T236159 = -36						; size = 4
$T236143 = -32						; size = 4
$T236172 = -28						; size = 4
$T236171 = -24						; size = 4
$T236170 = -20						; size = 4
$T236169 = -16						; size = 4
$T236168 = -12						; size = 4
__Ptr$227276 = -8					; size = 4
__Ptr$227266 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236143[ebp], edx
	mov	eax, DWORD PTR $T236143[ebp]
	mov	DWORD PTR $T236169[ebp], eax
	mov	ecx, DWORD PTR $T236169[ebp]
	mov	DWORD PTR $T236168[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236159[ebp], eax
	mov	ecx, DWORD PTR $T236159[ebp]
	mov	DWORD PTR $T236171[ebp], ecx
	mov	edx, DWORD PTR $T236171[ebp]
	mov	DWORD PTR $T236170[ebp], edx
	mov	eax, DWORD PTR $T236168[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236170[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236172[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator
$LN8@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T236188[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR $T236188[ebp], edx
	ja	SHORT $LN6@operator

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$227266[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236244[ebp], ecx
	mov	edx, DWORD PTR $T236244[ebp]
	mov	DWORD PTR $T236233[ebp], edx
	mov	eax, DWORD PTR __Ptr$227266[ebp]
	mov	DWORD PTR $T236232[ebp], eax
	mov	cl, BYTE PTR __Cat$236241[ebp]
	mov	BYTE PTR $T236238[ebp], cl

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	$LN9@operator
$LN6@operator:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T236251[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN55@operator
	mov	DWORD PTR tv224[ebp], 0
	jmp	SHORT $LN53@operator
$LN55@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv224[ebp], eax
$LN53@operator:
	mov	ecx, DWORD PTR $T236251[ebp]
	cmp	ecx, DWORD PTR tv224[ebp]
	ja	$LN4@operator

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR __Ptr$227276[ebp], ecx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Ptr$227276[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236304[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236303[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T236304[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236303[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$227276[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator
$LN4@operator:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@operator

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236336[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236335[ebp], eax
	mov	ecx, DWORD PTR $T236336[ebp]
	mov	DWORD PTR $T236324[ebp], ecx
	mov	edx, DWORD PTR $T236335[ebp]
	mov	DWORD PTR $T236323[ebp], edx
	mov	al, BYTE PTR __Cat$236332[ebp]
	mov	BYTE PTR $T236329[ebp], al

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T236341[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236340[ebp], edx
	mov	eax, DWORD PTR $T236340[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T236345[ebp], eax
	mov	ecx, DWORD PTR $T236345[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@operator

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236401[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T236400[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236399[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236401[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236400[ebp]
	push	edx
	mov	eax, DWORD PTR $T236399[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@operator:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T236506 = -52						; size = 4
$T236495 = -48						; size = 4
$T236494 = -44						; size = 4
__Cat$236503 = -40					; size = 1
$T236500 = -39						; size = 1
__Ptr$227322 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$227322[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236506[ebp], edx
	mov	eax, DWORD PTR $T236506[ebp]
	mov	DWORD PTR $T236495[ebp], eax
	mov	ecx, DWORD PTR __Ptr$227322[ebp]
	mov	DWORD PTR $T236494[ebp], ecx
	mov	dl, BYTE PTR __Cat$236503[ebp]
	mov	BYTE PTR $T236500[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$227322[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ; std::_Allocate<CvAICityStrategyEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$236521 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$236521[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$236521[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$236521[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ; std::_Allocate<CvAICityStrategyEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T236587 = -28						; size = 4
$T236586 = -24						; size = 4
$T236582 = -20						; size = 4
$T236581 = -16						; size = 4
$T236570 = -12						; size = 4
$T236569 = -8						; size = 4
__Cat$236576 = -2					; size = 1
$T236573 = -1						; size = 1
?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236582[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236581[ebp], ecx
	mov	edx, DWORD PTR $T236582[ebp]
	mov	DWORD PTR $T236570[ebp], edx
	mov	eax, DWORD PTR $T236581[ebp]
	mov	DWORD PTR $T236569[ebp], eax
	mov	cl, BYTE PTR __Cat$236576[ebp]
	mov	BYTE PTR $T236573[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T236587[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236586[ebp], eax
	mov	ecx, DWORD PTR $T236586[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T236600 = -20						; size = 4
_pRet$236597 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 225			; 000000e1H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236600[ebp], edx
	cmp	DWORD PTR $T236600[ebp], 225		; 000000e1H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T236600[ebp]
	shl	eax, 4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$236597[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T236600[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$236597[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 225			; 000000e1H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$236597[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T236631 = -24						; size = 4
$T236630 = -20						; size = 4
_i$236623 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236631[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T236630[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$236623[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$236623[ebp]
	add	eax, 1
	mov	DWORD PTR _i$236623[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$236623[ebp]
	cmp	ecx, DWORD PTR $T236631[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T236630[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T236630[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T236644 = -8						; size = 4
$T236643 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+3612], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T236644[ebp], ecx
	je	SHORT $LN4@push_back
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T236644[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T236644[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T236644[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T236643[ebp], edx

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv157[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvCitySpecializationXMLEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$236712 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$236712[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$236712[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$236712[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvCitySpecializationXMLEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T236776 = -28						; size = 4
$T236775 = -24						; size = 4
$T236771 = -20						; size = 4
$T236770 = -16						; size = 4
$T236759 = -12						; size = 4
$T236758 = -8						; size = 4
__Cat$236766 = -2					; size = 1
$T236763 = -1						; size = 1
?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236771[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236770[ebp], ecx
	mov	edx, DWORD PTR $T236771[ebp]
	mov	DWORD PTR $T236759[ebp], edx
	mov	eax, DWORD PTR $T236770[ebp]
	mov	DWORD PTR $T236758[ebp], eax
	mov	cl, BYTE PTR __Cat$236766[ebp]
	mov	BYTE PTR $T236763[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T236776[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236775[ebp], eax
	mov	ecx, DWORD PTR $T236775[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T236780 = -80						; size = 28
$T236779 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T236780[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236779[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T236779[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T236780[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236779[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T236779[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T236779[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T236780[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T236780[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T236779[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T236863 = -44						; size = 4
$T236862 = -40						; size = 4
_i$236857 = -36						; size = 4
$T236841 = -32						; size = 4
$T236834 = -28						; size = 4
_pRet$236830 = -24					; size = 4
$T236824 = -20						; size = 4
$T236823 = -16						; size = 4
_i$227523 = -12						; size = 4
_uiNewSize$227515 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227515[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227515[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227515[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236834[ebp], ecx
	cmp	DWORD PTR $T236834[ebp], 225		; 000000e1H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T236834[ebp]
	shl	edx, 4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$236830[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236834[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$236830[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 225			; 000000e1H
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$236830[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227523[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$227523[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227523[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227523[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227523[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T236824[ebp], edx
	je	SHORT $LN12@GrowSize
	mov	eax, DWORD PTR _i$227523[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T236841[ebp], eax
	mov	edx, DWORD PTR $T236841[ebp]
	mov	eax, DWORD PTR $T236824[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T236824[ebp]
	mov	ecx, DWORD PTR $T236841[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T236824[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T236823[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236863[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T236862[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$236857[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$236857[ebp]
	add	edx, 1
	mov	DWORD PTR _i$236857[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$236857[ebp]
	cmp	eax, DWORD PTR $T236863[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T236862[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T236862[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+3612], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T236959 = -52						; size = 4
$T236948 = -48						; size = 4
$T236947 = -44						; size = 4
__Cat$236955 = -40					; size = 1
$T236952 = -39						; size = 1
__Ptr$227577 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$227577[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236959[ebp], edx
	mov	eax, DWORD PTR $T236959[ebp]
	mov	DWORD PTR $T236948[ebp], eax
	mov	ecx, DWORD PTR __Ptr$227577[ebp]
	mov	DWORD PTR $T236947[ebp], ecx
	mov	dl, BYTE PTR __Cat$236955[ebp]
	mov	BYTE PTR $T236952[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$227577[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T236963 = -80						; size = 28
$T236962 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T236963[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236962[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T236962[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T236963[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236962[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T236962[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T236962[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T236963[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T236963[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T236962[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$227664 = -18					; size = 1
_tValue$227659 = -17					; size = 1
_iType$227657 = -16					; size = 4
_bValid$227656 = -9					; size = 1
_iI$227652 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$227652[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$227652[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227652[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$227652[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$227656[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$227657[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$227657[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$227659[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$227657[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iType$227657[ebp]
	mov	dl, BYTE PTR _tValue$227659[ebp]
	mov	BYTE PTR [ecx], dl
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	eax, BYTE PTR _bValid$227656[ebp]
	test	eax, eax
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	ecx, DWORD PTR _tValue$227664[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_tValue$227679 = -24					; size = 4
_tValue$227674 = -20					; size = 4
_iType$227672 = -16					; size = 4
_bValid$227671 = -9					; size = 1
_iI$227667 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$227667[ebp], 0
	jmp	SHORT $LN7@ReadHashed@2
$LN6@ReadHashed@2:
	mov	ecx, DWORD PTR _iI$227667[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227667[ebp], ecx
$LN7@ReadHashed@2:
	mov	edx, DWORD PTR _iI$227667[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@2

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$227671[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$227672[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$227672[ebp], -1
	je	SHORT $LN4@ReadHashed@2

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$227674[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$227672[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@2

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _iType$227672[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _tValue$227674[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN3@ReadHashed@2:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@2
$LN4@ReadHashed@2:

; 264  : 		else if(!bValid)

	movzx	ecx, BYTE PTR _bValid$227671[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed@2

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$227679[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed@2:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@2
$LN8@ReadHashed@2:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4AICityStrategyTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_eType$227692 = -8					; size = 4
_iI$227688 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$227688[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$227688[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227688[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$227688[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$227688[ebp]
	mov	DWORD PTR _eType$227692[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$227692[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4AICityStrategyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iI$227688[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$227700 = -8					; size = 4
_iI$227696 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$227696[ebp], 0
	jmp	SHORT $LN4@WriteHashe@2
$LN3@WriteHashe@2:
	mov	ecx, DWORD PTR _iI$227696[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227696[ebp], ecx
$LN4@WriteHashe@2:
	mov	edx, DWORD PTR _iI$227696[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@2

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$227696[ebp]
	mov	DWORD PTR _eType$227700[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$227700[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4AICityStrategyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$227696[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@2:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@2
$LN5@WriteHashe@2:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2030 : FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 

	push	ebp
	mov	ebp, esp

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2032 : }

	pop	ebp
	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3570 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN2@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H
$LN2@stable_sor:

; 3577 : 		}
; 3578 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T237224 = -26						; size = 1
$T237223 = -25						; size = 1
$T237222 = -24						; size = 4
$T237221 = -20						; size = 4
__Off$237218 = -16					; size = 4
__Result$237219 = -12					; size = 4
__Cat$237210 = -4					; size = 1
$T237206 = -3						; size = 1
$T237205 = -2						; size = 1
$T237204 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T237204[ebp], al
	mov	cl, BYTE PTR __Cat$237210[ebp]
	mov	BYTE PTR $T237205[ebp], cl
	mov	dl, BYTE PTR $T237204[ebp]
	mov	BYTE PTR $T237224[ebp], dl
	mov	al, BYTE PTR $T237206[ebp]
	mov	BYTE PTR $T237223[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237222[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237221[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T237221[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$237218[ebp], eax
	mov	ecx, DWORD PTR __Off$237218[ebp]
	mov	edx, DWORD PTR $T237222[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$237219[ebp], eax
	cmp	DWORD PTR __Off$237218[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$237218[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T237221[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$237218[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T237222[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$237219[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T237247 = -26						; size = 1
$T237246 = -25						; size = 1
$T237245 = -24						; size = 4
$T237244 = -20						; size = 4
__Off$237241 = -16					; size = 4
__Result$237242 = -12					; size = 4
__Cat$237233 = -4					; size = 1
$T237229 = -3						; size = 1
$T237228 = -2						; size = 1
$T237227 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T237227[ebp], al
	mov	cl, BYTE PTR __Cat$237233[ebp]
	mov	BYTE PTR $T237228[ebp], cl
	mov	dl, BYTE PTR $T237227[ebp]
	mov	BYTE PTR $T237247[ebp], dl
	mov	al, BYTE PTR $T237229[ebp]
	mov	BYTE PTR $T237246[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237245[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237244[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T237244[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$237241[ebp], eax
	mov	ecx, DWORD PTR __Off$237241[ebp]
	mov	edx, DWORD PTR $T237245[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$237242[ebp], eax
	cmp	DWORD PTR __Off$237241[ebp], 0
	jle	SHORT $LN8@unchecked_@2
	mov	ecx, DWORD PTR __Off$237241[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T237244[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$237241[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T237245[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	mov	eax, DWORD PTR __Result$237242[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T237254 = -16						; size = 4
$T237250 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvAICityStrategyEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T237254[ebp], 0
	lea	eax, DWORD PTR $T237254[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237250[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T237250[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237250[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvAICityStrategyEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T237268 = -16						; size = 4
$T237264 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvCitySpecializationXMLEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T237268[ebp], 0
	lea	eax, DWORD PTR $T237268[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237264[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T237264[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237264[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCitySpecializationXMLEntry *>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@E@std@@QAE@XZ		; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
PUBLIC	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0
__ehfuncinfo$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T237376 = -112						; size = 4
__Next$237384 = -108					; size = 4
$T237293 = -48						; size = 4
$T237289 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3561 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3562 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237289[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T237289[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T237293[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T237293[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H

; 3565 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$237384[ebp], eax
	jmp	SHORT $LN62@Stable_sor
$LN61@Stable_sor:
	mov	ecx, DWORD PTR __Next$237384[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$237384[ebp], ecx
$LN62@Stable_sor:
	mov	edx, DWORD PTR __Next$237384[ebp]
	cmp	edx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor
	jmp	SHORT $LN61@Stable_sor
$LN60@Stable_sor:
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T237376[ebp], eax
	mov	ecx, DWORD PTR $T237376[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z
_TEXT	SEGMENT
$T237520 = -136						; size = 4
__Mid$228123 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$228123[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$228123[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 4
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$228123[ebp+4]
	sar	edx, 4
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$228123[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$228123[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228123[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$228123[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 4
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T237520[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T237520[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T237520[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T237520[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 4
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T237520[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 4
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T237520[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z
_TEXT	SEGMENT
$T237606 = -21						; size = 1
$T237605 = -20						; size = 4
$T237604 = -16						; size = 4
__Result$237602 = -12					; size = 4
__Count$237601 = -8					; size = 4
__Cat$237597 = -3					; size = 1
$T237593 = -2						; size = 1
$T237592 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T237592[ebp], al
	mov	cl, BYTE PTR __Cat$237597[ebp]
	mov	BYTE PTR $T237593[ebp], cl
	mov	dl, BYTE PTR $T237592[ebp]
	mov	BYTE PTR $T237606[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237605[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237604[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T237604[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$237601[ebp], edx
	mov	eax, DWORD PTR __Count$237601[ebp]
	mov	ecx, DWORD PTR $T237605[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$237602[ebp], edx
	cmp	DWORD PTR __Count$237601[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$237601[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T237604[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$237601[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T237605[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$237602[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Temp_iterator@E@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237615 = -8						; size = 4
__Next$228322 = -4					; size = 4
??1?$_Temp_iterator@E@std@@QAE@XZ PROC			; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$228322[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$228322[ebp]
	add	eax, 1
	mov	DWORD PTR __Next$228322[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$228322[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237615[ebp], ecx
	mov	edx, DWORD PTR $T237615[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@E@std@@QAE@XZ ENDP			; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ		; std::_Temp_iterator<unsigned char>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__Count2$228393 = -8					; size = 4
__Mid$228394 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H

; 3530 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
	add	esp, 16					; 00000010H

; 3532 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$228393[ebp], eax

; 3535 : 		_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228394[ebp], eax

; 3536 : 		std::advance(_Mid, _Count2);

	mov	ecx, DWORD PTR __Mid$228394[ebp]
	add	ecx, DWORD PTR __Count2$228393[ebp]
	mov	DWORD PTR __Mid$228394[ebp], ecx

; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	DWORD PTR __Count2$228393[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$228393[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$228394[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$228393[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$228394[ebp]
	push	edx
	call	??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$228393[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228394[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Count2$228393[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228394[ebp]
	push	eax
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H
$LN1@Stable_sor@2:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$228393[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$228393[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228394[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH
$LN5@Stable_sor@2:

; 3552 : 		}
; 3553 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
$T237966 = -180						; size = 4
__Tmp$237964 = -176					; size = 16
$T237946 = -160						; size = 4
$T237945 = -156						; size = 4
__Tmp$237943 = -152					; size = 16
$T237925 = -136						; size = 4
__Tmp$237923 = -132					; size = 16
$T237905 = -116						; size = 4
$T237904 = -112						; size = 4
__Tmp$237902 = -108					; size = 16
$T237884 = -92						; size = 4
$T237883 = -88						; size = 4
__Tmp$237881 = -84					; size = 16
$T237860 = -68						; size = 4
$T237859 = -64						; size = 4
__Tmp$237857 = -60					; size = 16
$T237833 = -44						; size = 4
__Tmp$237831 = -40					; size = 16
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	cdq
	sub	eax, edx
	sar	eax, 1
	shl	eax, 4
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	$LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T237833[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T237833[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T237833[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$237831[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237831[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$237831[ebp+8], ecx
	mov	edx, DWORD PTR $T237833[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$237831[ebp+12], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR $T237833[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Tmp$237831[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$237831[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$237831[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$237831[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Glast$[ebp], edx
$LN14@Unguarded_:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [ecx-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN55@Unguarded_
	jmp	$LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx-4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T237860[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237859[ebp], ecx
	mov	edx, DWORD PTR $T237859[ebp]
	cmp	edx, DWORD PTR $T237860[ebp]
	je	SHORT $LN10@Unguarded_
	mov	eax, DWORD PTR $T237859[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$237857[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$237857[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$237857[ebp+8], eax
	mov	ecx, DWORD PTR $T237859[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$237857[ebp+12], edx
	mov	eax, DWORD PTR $T237860[ebp]
	mov	ecx, DWORD PTR $T237859[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T237860[ebp]
	mov	edx, DWORD PTR __Tmp$237857[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$237857[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$237857[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$237857[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T237884[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237883[ebp], ecx
	mov	edx, DWORD PTR $T237883[ebp]
	cmp	edx, DWORD PTR $T237884[ebp]
	je	SHORT $LN5@Unguarded_
	mov	eax, DWORD PTR $T237883[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$237881[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$237881[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$237881[ebp+8], eax
	mov	ecx, DWORD PTR $T237883[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$237881[ebp+12], edx
	mov	eax, DWORD PTR $T237884[ebp]
	mov	ecx, DWORD PTR $T237883[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T237884[ebp]
	mov	edx, DWORD PTR __Tmp$237881[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$237881[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$237881[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$237881[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T237905[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237904[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T237904[ebp]
	cmp	eax, DWORD PTR $T237905[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T237904[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$237902[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237902[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$237902[ebp+8], ecx
	mov	edx, DWORD PTR $T237904[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$237902[ebp+12], eax
	mov	ecx, DWORD PTR $T237905[ebp]
	mov	edx, DWORD PTR $T237904[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T237905[ebp]
	mov	eax, DWORD PTR __Tmp$237902[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$237902[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$237902[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$237902[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237925[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR $T237925[ebp]
	je	SHORT $LN2@Unguarded_
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$237923[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$237923[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$237923[ebp+8], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$237923[ebp+12], ecx
	mov	edx, DWORD PTR $T237925[ebp]
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T237925[ebp]
	mov	ecx, DWORD PTR __Tmp$237923[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$237923[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$237923[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$237923[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	eax, DWORD PTR __Plast$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], eax
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T237946[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237945[ebp], edx
	mov	eax, DWORD PTR $T237945[ebp]
	cmp	eax, DWORD PTR $T237946[ebp]
	je	SHORT $LN87@Unguarded_
	mov	ecx, DWORD PTR $T237945[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$237943[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237943[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$237943[ebp+8], ecx
	mov	edx, DWORD PTR $T237945[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$237943[ebp+12], eax
	mov	ecx, DWORD PTR $T237946[ebp]
	mov	edx, DWORD PTR $T237945[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T237946[ebp]
	mov	eax, DWORD PTR __Tmp$237943[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$237943[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$237943[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$237943[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	$LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T237966[ebp], eax
	mov	ecx, DWORD PTR $T237966[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T237966[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$237964[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$237964[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$237964[ebp+8], edx
	mov	eax, DWORD PTR $T237966[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$237964[ebp+12], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR $T237966[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR __Tmp$237964[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$237964[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$237964[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$237964[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN94@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Gfirst$[ebp], eax
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv94 = -36						; size = 4
$T238013 = -32						; size = 4
$T238006 = -28						; size = 4
__Vptr$238012 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238013[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$238012[ebp], edx
	mov	eax, DWORD PTR __Vptr$238012[ebp]
	mov	DWORD PTR $T238006[ebp], eax
	cmp	DWORD PTR $T238006[ebp], 0
	je	SHORT $LN26@Uninit_cop
	mov	ecx, DWORD PTR $T238006[ebp]
	mov	edx, DWORD PTR $T238013[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T238006[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop
$LN26@Uninit_cop:
	mov	DWORD PTR tv94[ebp], 0
$LN22@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z ; std::get_temporary_buffer<unsigned char>
; Function compile flags: /Odtp
;	COMDAT ?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$228602 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ PROC		; std::_Temp_iterator<unsigned char>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$228602[ebp]
	push	ecx
	call	??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z ; std::get_temporary_buffer<unsigned char>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228602[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228602[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228602[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228602[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ ENDP		; std::_Temp_iterator<unsigned char>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
tv144 = -208						; size = 4
$T238319 = -77						; size = 1
$T238133 = -76						; size = 4
$T238129 = -72						; size = 4
$T238092 = -48						; size = 4
$T238071 = -28						; size = 4
$T238044 = -20						; size = 4
__Chunk$228677 = -16					; size = 4
__Midn$228675 = -12					; size = 4
__Nleft$228671 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$228671[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$228671[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$228671[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$228671[ebp], 32	; 00000020H
	jl	SHORT $LN22@Buffered_m

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midn$228675[ebp], eax

; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);

	mov	ecx, DWORD PTR __Midn$228675[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Midn$228675[ebp], ecx

; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	edx, DWORD PTR __Midn$228675[ebp]
	mov	DWORD PTR $T238071[ebp], edx
	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238071[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
	add	esp, 16					; 00000010H

; 3510 : 		_Mid = _Midn;

	mov	eax, DWORD PTR __Midn$228675[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3511 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

$LN22@Buffered_m:
	push	0
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
	add	esp, 16					; 00000010H

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$228677[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	ecx, DWORD PTR __Chunk$228677[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$228677[ebp], ecx
$LN3@Buffered_m:
	mov	edx, DWORD PTR __Chunk$228677[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$228677[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T238044[ebp], esp
	mov	DWORD PTR $T238092[ebp], edx
	mov	eax, DWORD PTR $T238092[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T238092[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T238092[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T238092[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T238092[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T238092[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 40					; 00000028H

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Chunk$228677[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$228677[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238129[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T238133[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238319[ebp], dl
	movzx	eax, BYTE PTR $T238319[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$228677[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238129[ebp]
	push	edx
	mov	eax, DWORD PTR $T238133[ebp]
	push	eax
	call	??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH

; 3520 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z ; std::_Buffered_rotate<unsigned char *,int,unsigned char>
PUBLIC	??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
tv228 = -296						; size = 4
tv227 = -292						; size = 4
tv224 = -288						; size = 4
tv223 = -284						; size = 4
$T238574 = -212						; size = 4
$T238556 = -205						; size = 1
$T238555 = -204						; size = 4
$T238554 = -200						; size = 4
$T238492 = -168						; size = 4
$T238474 = -161						; size = 1
$T238473 = -160						; size = 4
$T238472 = -156						; size = 4
$T238446 = -150						; size = 1
$T238445 = -149						; size = 1
$T238440 = -148						; size = 4
$T238436 = -144						; size = 4
$T238421 = -140						; size = 4
__Next$238429 = -136					; size = 4
$T238413 = -132						; size = 4
$T238400 = -117						; size = 1
$T238399 = -116						; size = 4
$T238398 = -112						; size = 4
$T238397 = -108						; size = 4
$T238393 = -102						; size = 1
$T238392 = -101						; size = 1
$T238382 = -100						; size = 4
$T238378 = -96						; size = 4
$T238363 = -92						; size = 4
__Next$238371 = -88					; size = 4
$T238355 = -84						; size = 4
__Tmp$238341 = -69					; size = 1
$T238326 = -68						; size = 20
$T238325 = -48						; size = 4
$T238324 = -44						; size = 20
$T238323 = -24						; size = 4
__Firstn$228755 = -20					; size = 4
__Count2n$228758 = -16					; size = 4
__Midn$228779 = -12					; size = 4
__Lastn$228756 = -8					; size = 4
__Count1n$228757 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	ecx, DWORD PTR __First$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Tmp$238341[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	cl, BYTE PTR __Tmp$238341[ebp]
	mov	BYTE PTR [eax], cl
$LN8@Buffered_m@2:

; 2894 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	edx, DWORD PTR __Count1$[ebp]
	cmp	edx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T238323[ebp], esp
	mov	DWORD PTR $T238355[ebp], edx
	mov	eax, DWORD PTR $T238355[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T238355[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T238355[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T238355[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T238355[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T238355[ebp]
	mov	DWORD PTR tv223[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238324[ebp]
	push	ecx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv224[ebp], eax
	cmp	DWORD PTR $T238324[ebp], 0
	je	SHORT $LN34@Buffered_m@2
	mov	edx, DWORD PTR $T238324[ebp]
	mov	DWORD PTR __Next$238371[ebp], edx
	jmp	SHORT $LN32@Buffered_m@2
$LN31@Buffered_m@2:
	mov	eax, DWORD PTR __Next$238371[ebp]
	add	eax, 1
	mov	DWORD PTR __Next$238371[ebp], eax
$LN32@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$238371[ebp]
	cmp	ecx, DWORD PTR $T238324[ebp+8]
	je	SHORT $LN30@Buffered_m@2
	jmp	SHORT $LN31@Buffered_m@2
$LN30@Buffered_m@2:
	mov	edx, DWORD PTR $T238324[ebp]
	mov	DWORD PTR $T238363[ebp], edx
	mov	eax, DWORD PTR $T238363[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238378[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238382[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T238400[ebp], cl
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238399[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T238398[ebp], eax
	mov	ecx, DWORD PTR $T238382[ebp]
	mov	DWORD PTR $T238397[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238392[ebp], dl
	movzx	eax, BYTE PTR $T238392[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T238393[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T238400[ebp]
	push	edx
	mov	eax, DWORD PTR $T238399[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238398[ebp]
	push	edx
	mov	eax, DWORD PTR $T238378[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238397[ebp]
	push	ecx
	call	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T238325[ebp], esp
	mov	DWORD PTR $T238413[ebp], ecx
	mov	edx, DWORD PTR $T238413[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T238413[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T238413[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T238413[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T238413[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T238413[ebp]
	mov	DWORD PTR tv227[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T238326[ebp]
	push	eax
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv228[ebp], eax
	cmp	DWORD PTR $T238326[ebp], 0
	je	SHORT $LN61@Buffered_m@2
	mov	ecx, DWORD PTR $T238326[ebp]
	mov	DWORD PTR __Next$238429[ebp], ecx
	jmp	SHORT $LN59@Buffered_m@2
$LN58@Buffered_m@2:
	mov	edx, DWORD PTR __Next$238429[ebp]
	add	edx, 1
	mov	DWORD PTR __Next$238429[ebp], edx
$LN59@Buffered_m@2:
	mov	eax, DWORD PTR __Next$238429[ebp]
	cmp	eax, DWORD PTR $T238326[ebp+8]
	je	SHORT $LN57@Buffered_m@2
	jmp	SHORT $LN58@Buffered_m@2
$LN57@Buffered_m@2:
	mov	ecx, DWORD PTR $T238326[ebp]
	mov	DWORD PTR $T238421[ebp], ecx
	mov	edx, DWORD PTR $T238421[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN61@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238436[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T238440[ebp], edx
	mov	al, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T238446[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T238445[ebp], cl
	movzx	edx, BYTE PTR $T238445[ebp]
	push	edx
	movzx	eax, BYTE PTR $T238446[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238436[ebp]
	push	edx
	mov	eax, DWORD PTR $T238440[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH

; 2906 : 		}
; 2907 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	mov	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$228757[ebp], eax
	mov	DWORD PTR __Count2n$228758[ebp], 0

; 2914 : 			_Firstn = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$228755[ebp], ecx

; 2915 : 			std::advance(_Firstn, _Count1n);

	mov	edx, DWORD PTR __Firstn$228755[ebp]
	add	edx, DWORD PTR __Count1n$228757[ebp]
	mov	DWORD PTR __Firstn$228755[ebp], edx

; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	al, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T238474[ebp], al
	mov	ecx, DWORD PTR __Firstn$228755[ebp]
	mov	DWORD PTR $T238473[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T238472[ebp], edx
	push	0
	movzx	eax, BYTE PTR $T238474[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238473[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T238472[ebp]
	push	eax
	call	??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H
	mov	DWORD PTR $T238472[ebp], eax
	mov	ecx, DWORD PTR $T238472[ebp]
	mov	DWORD PTR __Lastn$228756[ebp], ecx

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T238492[ebp], edx
	mov	eax, DWORD PTR __Lastn$228756[ebp]
	sub	eax, DWORD PTR $T238492[ebp]
	add	eax, DWORD PTR __Count2n$228758[ebp]
	mov	DWORD PTR __Count2n$228758[ebp], eax

; 2918 : 			}
; 2919 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$228757[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$228758[ebp], eax

; 2922 : 			_Lastn = _Mid;

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$228756[ebp], ecx

; 2923 : 			std::advance(_Lastn, _Count2n);

	mov	edx, DWORD PTR __Lastn$228756[ebp]
	add	edx, DWORD PTR __Count2n$228758[ebp]
	mov	DWORD PTR __Lastn$228756[ebp], edx

; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	al, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T238556[ebp], al
	mov	ecx, DWORD PTR __Lastn$228756[ebp]
	mov	DWORD PTR $T238555[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238554[ebp], edx
	push	0
	movzx	eax, BYTE PTR $T238556[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238555[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T238554[ebp]
	push	eax
	call	??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H
	mov	DWORD PTR $T238554[ebp], eax
	mov	ecx, DWORD PTR $T238554[ebp]
	mov	DWORD PTR __Firstn$228755[ebp], ecx

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238574[ebp], edx
	mov	eax, DWORD PTR __Firstn$228755[ebp]
	sub	eax, DWORD PTR $T238574[ebp]
	add	eax, DWORD PTR __Count1n$228757[ebp]
	mov	DWORD PTR __Count1n$228757[ebp], eax
$LN1@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$228758[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1$[ebp]
	sub	eax, DWORD PTR __Count1n$228757[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$228756[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$228755[ebp]
	push	eax
	call	??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z ; std::_Buffered_rotate<unsigned char *,int,unsigned char>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$228779[ebp], eax

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$228758[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1n$228757[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$228779[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$228755[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$[ebp]
	sub	ecx, DWORD PTR __Count2n$228758[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1$[ebp]
	sub	edx, DWORD PTR __Count1n$228757[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$228756[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$228779[ebp]
	push	edx
	call	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH
$LN10@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
__Step$228794 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$228794[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$228794[ebp]
	shl	ecx, 1
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$228794[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Step$228794[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$228794[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$228794[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$228794[ebp]
	shl	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$228794[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$228794[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z
_TEXT	SEGMENT
$T238935 = -20						; size = 4
$T238934 = -16						; size = 4
__Hole$228812 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$228812[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$228812[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$228812[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$228812[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$228812[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238935[ebp], edx
	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T238934[ebp], esp
	mov	eax, DWORD PTR $T238935[ebp]
	mov	ecx, DWORD PTR $T238934[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T238934[ebp]
	mov	edx, DWORD PTR $T238935[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __Bottom$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Hole$228812[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
$T239005 = -60						; size = 4
$T239004 = -56						; size = 4
$T238988 = -50						; size = 1
$T238987 = -49						; size = 1
$T238986 = -48						; size = 4
$T238985 = -44						; size = 4
$T238984 = -40						; size = 4
__Cat$238994 = -32					; size = 1
$T238992 = -31						; size = 1
$T238991 = -30						; size = 1
$T238990 = -29						; size = 1
__First1$228853 = -28					; size = 4
__Val$228843 = -24					; size = 16
__Next1$228842 = -8					; size = 4
__Next$228838 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$228838[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$228838[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$228838[ebp], edx
	mov	eax, DWORD PTR __Next$228838[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$228838[ebp]
	mov	DWORD PTR __Next1$228842[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$228838[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$228843[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$228843[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$228843[ebp+8], edx
	mov	eax, DWORD PTR __Next$228838[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Val$228843[ebp+12], ecx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$228843[ebp+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, DWORD PTR __Next1$228842[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next1$228842[ebp], eax
	mov	ecx, DWORD PTR __Next1$228842[ebp]
	mov	DWORD PTR $T239005[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239004[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T238990[ebp], al
	mov	cl, BYTE PTR __Cat$238994[ebp]
	mov	BYTE PTR $T238991[ebp], cl
	mov	dl, BYTE PTR $T238990[ebp]
	mov	BYTE PTR $T238988[ebp], dl
	mov	al, BYTE PTR $T238992[ebp]
	mov	BYTE PTR $T238987[ebp], al
	mov	ecx, DWORD PTR $T239005[ebp]
	mov	DWORD PTR $T238986[ebp], ecx
	mov	edx, DWORD PTR __Next$228838[ebp]
	mov	DWORD PTR $T238985[ebp], edx
	mov	eax, DWORD PTR $T239004[ebp]
	mov	DWORD PTR $T238984[ebp], eax
$LN22@Insertion_:
	mov	ecx, DWORD PTR $T238984[ebp]
	cmp	ecx, DWORD PTR $T238985[ebp]
	je	SHORT $LN15@Insertion_
	mov	edx, DWORD PTR $T238985[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T238985[ebp], edx
	mov	eax, DWORD PTR $T238986[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T238986[ebp], eax
	mov	ecx, DWORD PTR $T238985[ebp]
	mov	edx, DWORD PTR $T238986[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$228843[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$228843[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Val$228843[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$228843[ebp+12]
	mov	DWORD PTR [edx+12], ecx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$228842[ebp]
	mov	DWORD PTR __First1$228853[ebp], edx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	eax, DWORD PTR __First1$228853[ebp]
	mov	DWORD PTR __Next1$228842[ebp], eax
$LN3@Insertion_:
	mov	ecx, DWORD PTR __First1$228853[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __First1$228853[ebp], ecx
	mov	edx, DWORD PTR __First1$228853[ebp]
	mov	eax, DWORD PTR __Val$228843[ebp+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	eax, DWORD PTR __First1$228853[ebp]
	mov	ecx, DWORD PTR __Next1$228842[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Next1$228842[ebp]
	mov	edx, DWORD PTR __Val$228843[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$228843[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$228843[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$228843[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z
_TEXT	SEGMENT
$T239015 = -20						; size = 4
$T239011 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z PROC ; std::get_temporary_buffer<unsigned char>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 1
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T239015[ebp], 0
	lea	eax, DWORD PTR $T239015[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239011[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T239011[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T239011[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z ENDP ; std::get_temporary_buffer<unsigned char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z
_TEXT	SEGMENT
$T239060 = -52						; size = 4
$T239059 = -48						; size = 4
$T239042 = -42						; size = 1
$T239041 = -41						; size = 1
$T239040 = -40						; size = 4
$T239039 = -36						; size = 4
__Off$239054 = -32					; size = 4
__Result$239055 = -28					; size = 4
__Cat$239048 = -20					; size = 1
$T239046 = -19						; size = 1
$T239045 = -18						; size = 1
$T239044 = -17						; size = 1
__First1$228911 = -16					; size = 4
__Val$228901 = -9					; size = 1
__Next1$228900 = -8					; size = 4
__Next$228896 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z PROC ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$228896[ebp], ecx
$LN7@Insertion_@2:
	mov	edx, DWORD PTR __Next$228896[ebp]
	add	edx, 1
	mov	DWORD PTR __Next$228896[ebp], edx
	mov	eax, DWORD PTR __Next$228896[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$228896[ebp]
	mov	DWORD PTR __Next1$228900[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$228896[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Val$228901[ebp], al

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	movzx	eax, BYTE PTR __Val$228901[ebp]
	push	eax
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Insertion_@2

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$228900[ebp]
	add	edx, 1
	mov	DWORD PTR __Next1$228900[ebp], edx
	mov	eax, DWORD PTR __Next1$228900[ebp]
	mov	DWORD PTR $T239060[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239059[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239044[ebp], dl
	mov	al, BYTE PTR __Cat$239048[ebp]
	mov	BYTE PTR $T239045[ebp], al
	mov	cl, BYTE PTR $T239044[ebp]
	mov	BYTE PTR $T239042[ebp], cl
	mov	dl, BYTE PTR $T239046[ebp]
	mov	BYTE PTR $T239041[ebp], dl
	mov	eax, DWORD PTR $T239060[ebp]
	mov	DWORD PTR $T239040[ebp], eax
	mov	ecx, DWORD PTR $T239059[ebp]
	mov	DWORD PTR $T239039[ebp], ecx
	mov	edx, DWORD PTR __Next$228896[ebp]
	sub	edx, DWORD PTR $T239039[ebp]
	mov	DWORD PTR __Off$239054[ebp], edx
	mov	eax, DWORD PTR $T239040[ebp]
	sub	eax, DWORD PTR __Off$239054[ebp]
	mov	DWORD PTR __Result$239055[ebp], eax
	cmp	DWORD PTR __Off$239054[ebp], 0
	jle	SHORT $LN11@Insertion_@2
	mov	ecx, DWORD PTR __Off$239054[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239039[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$239054[ebp]
	push	eax
	mov	ecx, DWORD PTR __Result$239055[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN11@Insertion_@2:

; 3133 : 				*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	al, BYTE PTR __Val$228901[ebp]
	mov	BYTE PTR [edx], al

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	ecx, DWORD PTR __Next1$228900[ebp]
	mov	DWORD PTR __First1$228911[ebp], ecx

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@2
$LN2@Insertion_@2:
	mov	edx, DWORD PTR __First1$228911[ebp]
	mov	DWORD PTR __Next1$228900[ebp], edx
$LN3@Insertion_@2:
	mov	eax, DWORD PTR __First1$228911[ebp]
	sub	eax, 1
	mov	DWORD PTR __First1$228911[ebp], eax
	mov	ecx, DWORD PTR __First1$228911[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	movzx	eax, BYTE PTR __Val$228901[ebp]
	push	eax
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Insertion_@2

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __Next1$228900[ebp]
	mov	eax, DWORD PTR __First1$228911[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN2@Insertion_@2
$LN1@Insertion_@2:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$228900[ebp]
	mov	al, BYTE PTR __Val$228901[ebp]
	mov	BYTE PTR [edx], al
$LN4@Insertion_@2:

; 3142 : 				}
; 3143 : 			}

	jmp	$LN7@Insertion_@2
$LN9@Insertion_@2:

; 3144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ENDP ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
tv94 = -160						; size = 4
$T239208 = -156						; size = 4
__Next$239216 = -152					; size = 4
$T239075 = -24						; size = 4
$T239064 = -20						; size = 4
$T239063 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5285 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T239063[ebp], al
	movzx	ecx, BYTE PTR $T239063[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Chunk$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T239064[ebp], esp
	mov	DWORD PTR $T239075[ebp], edx
	mov	eax, DWORD PTR $T239075[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T239075[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T239075[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T239075[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T239075[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T239075[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 44					; 0000002cH

; 5287 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$239216[ebp], eax
	jmp	SHORT $LN73@Unchecked_
$LN72@Unchecked_:
	mov	ecx, DWORD PTR __Next$239216[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$239216[ebp], ecx
$LN73@Unchecked_:
	mov	edx, DWORD PTR __Next$239216[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN71@Unchecked_
	jmp	SHORT $LN72@Unchecked_
$LN71@Unchecked_:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T239208[ebp], eax
	mov	ecx, DWORD PTR $T239208[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T239261 = -40						; size = 4
__Next$239269 = -36					; size = 4
$T239253 = -32						; size = 4
__Cat$239239 = -25					; size = 1
$T239235 = -24						; size = 4
$T239231 = -20						; size = 4
$T239230 = -15						; size = 1
$T239229 = -14						; size = 1
$T239228 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z PROC ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T239235[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T239228[ebp], al
	mov	cl, BYTE PTR __Cat$239239[ebp]
	mov	BYTE PTR $T239229[ebp], cl
	movzx	edx, BYTE PTR $T239228[ebp]
	push	edx
	movzx	eax, BYTE PTR $T239229[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T239230[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T239231[ebp], esp
	mov	DWORD PTR $T239253[ebp], edx
	mov	eax, DWORD PTR $T239253[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T239253[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T239253[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T239253[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T239253[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T239253[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T239235[ebp]
	or	ecx, 1
	mov	DWORD PTR $T239235[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_@4
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$239269[ebp], edx
	jmp	SHORT $LN17@unchecked_@4
$LN16@unchecked_@4:
	mov	eax, DWORD PTR __Next$239269[ebp]
	add	eax, 1
	mov	DWORD PTR __Next$239269[ebp], eax
$LN17@unchecked_@4:
	mov	ecx, DWORD PTR __Next$239269[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_@4
	jmp	SHORT $LN16@unchecked_@4
$LN15@unchecked_@4:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T239261[ebp], edx
	mov	eax, DWORD PTR $T239261[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_@4:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ENDP ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
PUBLIC	??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z		; std::_Rotate<unsigned char *,int,unsigned char>
PUBLIC	??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
PUBLIC	??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z
_TEXT	SEGMENT
tv178 = -224						; size = 4
tv177 = -220						; size = 4
tv174 = -216						; size = 4
tv173 = -212						; size = 4
$T239518 = -204						; size = 4
$T239504 = -197						; size = 1
$T239503 = -196						; size = 4
$T239508 = -189						; size = 1
$T239483 = -188						; size = 4
$T239482 = -184						; size = 4
$T239465 = -178						; size = 1
$T239464 = -177						; size = 1
$T239463 = -176						; size = 4
$T239462 = -172						; size = 4
__Off$239478 = -168					; size = 4
__Result$239479 = -164					; size = 4
__Cat$239472 = -156					; size = 1
$T239470 = -155						; size = 1
$T239469 = -154						; size = 1
$T239468 = -153						; size = 1
$T239443 = -152						; size = 4
$T239439 = -148						; size = 4
$T239435 = -144						; size = 4
$T239434 = -140						; size = 4
__Cat$239428 = -132					; size = 1
$T239426 = -131						; size = 1
$T239425 = -130						; size = 1
$T239424 = -129						; size = 1
$T239399 = -128						; size = 4
__Next$239407 = -124					; size = 4
$T239391 = -120						; size = 4
$T239378 = -108						; size = 4
$T239377 = -104						; size = 4
__Cat$239371 = -96					; size = 1
$T239369 = -95						; size = 1
$T239368 = -94						; size = 1
$T239367 = -93						; size = 1
$T239353 = -92						; size = 4
$T239349 = -88						; size = 4
$T239345 = -84						; size = 4
$T239344 = -80						; size = 4
__Cat$239339 = -72					; size = 1
$T239337 = -71						; size = 1
$T239336 = -70						; size = 1
$T239335 = -69						; size = 1
$T239309 = -68						; size = 4
__Next$239317 = -64					; size = 4
$T239301 = -60						; size = 4
$T239284 = -48						; size = 20
$T239283 = -28						; size = 4
$T239282 = -24						; size = 20
$T239281 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z PROC ; std::_Buffered_rotate<unsigned char *,int,unsigned char>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T239281[ebp], esp
	mov	DWORD PTR $T239301[ebp], eax
	mov	ecx, DWORD PTR $T239301[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T239301[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T239301[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T239301[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T239301[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T239301[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239282[ebp]
	push	edx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T239282[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T239282[ebp]
	mov	DWORD PTR __Next$239317[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$239317[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$239317[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$239317[ebp]
	cmp	edx, DWORD PTR $T239282[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T239282[ebp]
	mov	DWORD PTR $T239309[ebp], eax
	mov	ecx, DWORD PTR $T239309[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239345[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T239344[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T239335[ebp], cl
	mov	dl, BYTE PTR __Cat$239339[ebp]
	mov	BYTE PTR $T239336[ebp], dl
	movzx	eax, BYTE PTR $T239335[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T239336[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239337[ebp]
	push	edx
	mov	eax, DWORD PTR $T239345[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239344[ebp]
	push	edx
	call	??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239349[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239353[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T239378[ebp], eax
	mov	ecx, DWORD PTR $T239353[ebp]
	mov	DWORD PTR $T239377[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239367[ebp], dl
	mov	al, BYTE PTR __Cat$239371[ebp]
	mov	BYTE PTR $T239368[ebp], al
	movzx	ecx, BYTE PTR $T239367[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239368[ebp]
	push	edx
	movzx	eax, BYTE PTR $T239369[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239378[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239349[ebp]
	push	edx
	mov	eax, DWORD PTR $T239377[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T239283[ebp], esp
	mov	DWORD PTR $T239391[ebp], eax
	mov	ecx, DWORD PTR $T239391[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T239391[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T239391[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T239391[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T239391[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T239391[ebp]
	mov	DWORD PTR tv177[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239284[ebp]
	push	edx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T239284[ebp], 0
	je	SHORT $LN59@Buffered_r
	mov	eax, DWORD PTR $T239284[ebp]
	mov	DWORD PTR __Next$239407[ebp], eax
	jmp	SHORT $LN57@Buffered_r
$LN56@Buffered_r:
	mov	ecx, DWORD PTR __Next$239407[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$239407[ebp], ecx
$LN57@Buffered_r:
	mov	edx, DWORD PTR __Next$239407[ebp]
	cmp	edx, DWORD PTR $T239284[ebp+8]
	je	SHORT $LN55@Buffered_r
	jmp	SHORT $LN56@Buffered_r
$LN55@Buffered_r:
	mov	eax, DWORD PTR $T239284[ebp]
	mov	DWORD PTR $T239399[ebp], eax
	mov	ecx, DWORD PTR $T239399[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN59@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T239435[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239434[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T239424[ebp], cl
	mov	dl, BYTE PTR __Cat$239428[ebp]
	mov	BYTE PTR $T239425[ebp], dl
	movzx	eax, BYTE PTR $T239424[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T239425[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239426[ebp]
	push	edx
	mov	eax, DWORD PTR $T239435[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239434[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239439[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239443[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239483[ebp], eax
	mov	ecx, DWORD PTR $T239443[ebp]
	mov	DWORD PTR $T239482[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239468[ebp], dl
	mov	al, BYTE PTR __Cat$239472[ebp]
	mov	BYTE PTR $T239469[ebp], al
	mov	cl, BYTE PTR $T239468[ebp]
	mov	BYTE PTR $T239465[ebp], cl
	mov	dl, BYTE PTR $T239470[ebp]
	mov	BYTE PTR $T239464[ebp], dl
	mov	eax, DWORD PTR $T239483[ebp]
	mov	DWORD PTR $T239463[ebp], eax
	mov	ecx, DWORD PTR $T239482[ebp]
	mov	DWORD PTR $T239462[ebp], ecx
	mov	edx, DWORD PTR $T239439[ebp]
	sub	edx, DWORD PTR $T239462[ebp]
	mov	DWORD PTR __Off$239478[ebp], edx
	mov	eax, DWORD PTR $T239463[ebp]
	add	eax, DWORD PTR __Off$239478[ebp]
	mov	DWORD PTR __Result$239479[ebp], eax
	cmp	DWORD PTR __Off$239478[ebp], 0
	jle	SHORT $LN75@Buffered_r
	mov	ecx, DWORD PTR __Off$239478[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239462[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$239478[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239463[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN75@Buffered_r:
	mov	eax, DWORD PTR __Result$239479[ebp]
	jmp	SHORT $LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239518[ebp], edx
	mov	eax, DWORD PTR $T239518[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN97@Buffered_r
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN97@Buffered_r
	mov	dl, BYTE PTR $T239508[ebp]
	mov	BYTE PTR $T239504[ebp], dl
	mov	eax, DWORD PTR $T239518[ebp]
	mov	DWORD PTR $T239503[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T239503[ebp]
	push	eax
	call	??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z	; std::_Rotate<unsigned char *,int,unsigned char>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN97@Buffered_r:
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, DWORD PTR __Count2$[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z ENDP ; std::_Buffered_rotate<unsigned char *,int,unsigned char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
__Tmp$239600 = -48					; size = 16
__Tmp$239578 = -32					; size = 16
__Tmp$239556 = -16					; size = 16
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$239556[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$239556[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$239556[ebp+8], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$239556[ebp+12], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Tmp$239556[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$239556[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$239556[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$239556[ebp+12]
	mov	DWORD PTR [ecx+12], eax

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$239578[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$239578[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$239578[ebp+8], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$239578[ebp+12], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __Tmp$239578[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$239578[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$239578[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$239578[ebp+12]
	mov	DWORD PTR [edx+12], ecx

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$239600[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$239600[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$239600[ebp+8], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$239600[ebp+12], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$239600[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$239600[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$239600[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$239600[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z
_TEXT	SEGMENT
$T239627 = -40						; size = 4
$T239626 = -36						; size = 16
__Idx$239621 = -20					; size = 4
$T239613 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR __Idx$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __First$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [esi+eax+12]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Idx$[ebp], ecx
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	edx, DWORD PTR __Idx$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Hole$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	sub	edx, 1
	shl	edx, 4
	add	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Hole$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	eax, DWORD PTR __Bottom$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Hole$[ebp], eax
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	ecx, DWORD PTR $T239626[ebp]
	mov	DWORD PTR $T239613[ebp], ecx
	mov	edx, DWORD PTR $T239613[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Val$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T239613[ebp]
	mov	edx, DWORD PTR __Val$[ebp+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T239627[ebp], eax
	mov	eax, DWORD PTR $T239627[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$239621[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T239627[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$239621[ebp], eax
$LN14@Adjust_hea:
	mov	ecx, DWORD PTR __Top$[ebp]
	cmp	ecx, DWORD PTR $T239627[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$239621[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T239626[ebp+12]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN12@Adjust_hea
	mov	ecx, DWORD PTR __Idx$239621[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR $T239627[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Idx$239621[ebp]
	mov	DWORD PTR $T239627[ebp], edx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	eax, DWORD PTR $T239627[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T239626[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T239626[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T239626[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T239626[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv187 = -180						; size = 4
tv186 = -176						; size = 4
tv182 = -172						; size = 4
tv181 = -168						; size = 4
tv177 = -164						; size = 4
tv176 = -160						; size = 4
$T239789 = -156						; size = 4
__Next$239797 = -152					; size = 4
$T239770 = -148						; size = 4
__Next$239778 = -144					; size = 4
$T239762 = -140						; size = 4
$T239725 = -132						; size = 4
__Next$239733 = -128					; size = 4
$T239717 = -124						; size = 4
$T239697 = -120						; size = 4
__Next$239705 = -116					; size = 4
$T239689 = -112						; size = 4
$T239685 = -108						; size = 4
$T239635 = -100						; size = 20
$T239634 = -80						; size = 4
$T239633 = -76						; size = 20
$T239632 = -56						; size = 4
$T239631 = -52						; size = 20
$T239630 = -32						; size = 4
__Mid1$229379 = -28					; size = 4
__Mid2$229360 = -24					; size = 4
__Mid1$229359 = -20					; size = 4
__Chunk2$229355 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$229355[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$229355[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$229355[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$229359[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Mid1$229359[ebp]
	add	ecx, DWORD PTR __Chunk$[ebp]
	mov	DWORD PTR __Mid1$229359[ebp], ecx

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$229359[ebp]
	mov	DWORD PTR __Mid2$229360[ebp], edx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Mid2$229360[ebp]
	add	eax, DWORD PTR __Chunk$[ebp]
	mov	DWORD PTR __Mid2$229360[ebp], eax

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T239630[ebp], esp
	mov	DWORD PTR $T239685[ebp], edx
	mov	eax, DWORD PTR $T239685[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T239685[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T239685[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T239685[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T239685[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T239685[ebp]
	mov	DWORD PTR tv176[ebp], eax
	mov	ecx, DWORD PTR __Mid2$229360[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$229359[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$229359[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239631[ebp]
	push	edx
	call	??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv177[ebp], eax
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T239689[ebp], eax
	mov	ecx, DWORD PTR $T239689[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	cmp	DWORD PTR $T239631[ebp], 0
	je	SHORT $LN37@Chunked_me
	mov	eax, DWORD PTR $T239631[ebp]
	mov	DWORD PTR __Next$239705[ebp], eax
	jmp	SHORT $LN35@Chunked_me
$LN34@Chunked_me:
	mov	ecx, DWORD PTR __Next$239705[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$239705[ebp], ecx
$LN35@Chunked_me:
	mov	edx, DWORD PTR __Next$239705[ebp]
	cmp	edx, DWORD PTR $T239631[ebp+8]
	je	SHORT $LN33@Chunked_me
	jmp	SHORT $LN34@Chunked_me
$LN33@Chunked_me:
	mov	eax, DWORD PTR $T239631[ebp]
	mov	DWORD PTR $T239697[ebp], eax
	mov	ecx, DWORD PTR $T239697[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me:

; 3443 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$229360[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3444 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T239632[ebp], esp
	mov	DWORD PTR $T239717[ebp], ecx
	mov	edx, DWORD PTR $T239717[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T239717[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T239717[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T239717[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T239717[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T239717[ebp]
	mov	DWORD PTR tv181[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239633[ebp]
	push	edx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR $T239633[ebp], 0
	je	SHORT $LN51@Chunked_me
	mov	eax, DWORD PTR $T239633[ebp]
	mov	DWORD PTR __Next$239733[ebp], eax
	jmp	SHORT $LN49@Chunked_me
$LN48@Chunked_me:
	mov	ecx, DWORD PTR __Next$239733[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$239733[ebp], ecx
$LN49@Chunked_me:
	mov	edx, DWORD PTR __Next$239733[ebp]
	cmp	edx, DWORD PTR $T239633[ebp+8]
	je	SHORT $LN47@Chunked_me
	jmp	SHORT $LN48@Chunked_me
$LN47@Chunked_me:
	mov	eax, DWORD PTR $T239633[ebp]
	mov	DWORD PTR $T239725[ebp], eax
	mov	ecx, DWORD PTR $T239725[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me:

; 3448 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$229379[ebp], edx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	eax, DWORD PTR __Mid1$229379[ebp]
	add	eax, DWORD PTR __Chunk$[ebp]
	mov	DWORD PTR __Mid1$229379[ebp], eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T239634[ebp], esp
	mov	DWORD PTR $T239762[ebp], edx
	mov	eax, DWORD PTR $T239762[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T239762[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T239762[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T239762[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T239762[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T239762[ebp]
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$229379[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$229379[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239635[ebp]
	push	edx
	call	??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv187[ebp], eax
	cmp	DWORD PTR $T239635[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	eax, DWORD PTR $T239635[ebp]
	mov	DWORD PTR __Next$239778[ebp], eax
	jmp	SHORT $LN69@Chunked_me
$LN68@Chunked_me:
	mov	ecx, DWORD PTR __Next$239778[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$239778[ebp], ecx
$LN69@Chunked_me:
	mov	edx, DWORD PTR __Next$239778[ebp]
	cmp	edx, DWORD PTR $T239635[ebp+8]
	je	SHORT $LN67@Chunked_me
	jmp	SHORT $LN68@Chunked_me
$LN67@Chunked_me:
	mov	eax, DWORD PTR $T239635[ebp]
	mov	DWORD PTR $T239770[ebp], eax
	mov	ecx, DWORD PTR $T239770[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$239797[ebp], edx
	jmp	SHORT $LN79@Chunked_me
$LN78@Chunked_me:
	mov	eax, DWORD PTR __Next$239797[ebp]
	add	eax, 1
	mov	DWORD PTR __Next$239797[ebp], eax
$LN79@Chunked_me:
	mov	ecx, DWORD PTR __Next$239797[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me
	jmp	SHORT $LN78@Chunked_me
$LN77@Chunked_me:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T239789[ebp], edx
	mov	eax, DWORD PTR $T239789[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240068 = -200						; size = 4
$T240067 = -196						; size = 4
$T240066 = -192						; size = 4
$T240065 = -188						; size = 4
$T240060 = -112						; size = 1
$T240059 = -111						; size = 1
$T239952 = -108						; size = 4
$T239951 = -104						; size = 4
$T239934 = -98						; size = 1
$T239933 = -97						; size = 1
$T239932 = -96						; size = 4
$T239931 = -92						; size = 4
__Off$239947 = -88					; size = 4
__Result$239948 = -84					; size = 4
__Cat$239941 = -76					; size = 1
$T239939 = -75						; size = 1
$T239938 = -74						; size = 1
$T239937 = -73						; size = 1
$T239912 = -72						; size = 4
$T239911 = -68						; size = 4
$T239910 = -64						; size = 4
$T239909 = -60						; size = 4
$T239908 = -56						; size = 4
$T239903 = -22						; size = 1
$T239902 = -21						; size = 1
__Mid1$229391 = -16					; size = 4
__Mid2$229388 = -12					; size = 4
__Mid1$229387 = -8					; size = 4
__Chunk2$229383 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$229383[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$229383[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$229383[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$229387[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Mid1$229387[ebp]
	add	ecx, DWORD PTR __Chunk$[ebp]
	mov	DWORD PTR __Mid1$229387[ebp], ecx

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$229387[ebp]
	mov	DWORD PTR __Mid2$229388[ebp], edx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Mid2$229388[ebp]
	add	eax, DWORD PTR __Chunk$[ebp]
	mov	DWORD PTR __Mid2$229388[ebp], eax

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T239912[ebp], ecx
	mov	edx, DWORD PTR __Mid2$229388[ebp]
	mov	DWORD PTR $T239911[ebp], edx
	mov	eax, DWORD PTR __Mid1$229387[ebp]
	mov	DWORD PTR $T239910[ebp], eax
	mov	ecx, DWORD PTR __Mid1$229387[ebp]
	mov	DWORD PTR $T239909[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239908[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T239902[ebp], al
	movzx	ecx, BYTE PTR $T239902[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239903[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239912[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239911[ebp]
	push	edx
	mov	eax, DWORD PTR $T239910[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239909[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239908[ebp]
	push	edx
	call	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], eax

; 3443 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$229388[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3444 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T239952[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239951[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T239937[ebp], cl
	mov	dl, BYTE PTR __Cat$239941[ebp]
	mov	BYTE PTR $T239938[ebp], dl
	mov	al, BYTE PTR $T239937[ebp]
	mov	BYTE PTR $T239934[ebp], al
	mov	cl, BYTE PTR $T239939[ebp]
	mov	BYTE PTR $T239933[ebp], cl
	mov	edx, DWORD PTR $T239952[ebp]
	mov	DWORD PTR $T239932[ebp], edx
	mov	eax, DWORD PTR $T239951[ebp]
	mov	DWORD PTR $T239931[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T239931[ebp]
	mov	DWORD PTR __Off$239947[ebp], ecx
	mov	edx, DWORD PTR $T239932[ebp]
	add	edx, DWORD PTR __Off$239947[ebp]
	mov	DWORD PTR __Result$239948[ebp], edx
	cmp	DWORD PTR __Off$239947[ebp], 0
	jle	SHORT $LN43@Chunked_me@2
	mov	eax, DWORD PTR __Off$239947[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239931[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$239947[ebp]
	push	edx
	mov	eax, DWORD PTR $T239932[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN43@Chunked_me@2:

; 3448 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$229391[ebp], ecx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	edx, DWORD PTR __Mid1$229391[ebp]
	add	edx, DWORD PTR __Chunk$[ebp]
	mov	DWORD PTR __Mid1$229391[ebp], edx

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240068[ebp], eax
	mov	ecx, DWORD PTR __Mid1$229391[ebp]
	mov	DWORD PTR $T240067[ebp], ecx
	mov	edx, DWORD PTR __Mid1$229391[ebp]
	mov	DWORD PTR $T240066[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240065[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240059[ebp], cl
	movzx	edx, BYTE PTR $T240059[ebp]
	push	edx
	movzx	eax, BYTE PTR $T240060[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240068[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240067[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240066[ebp]
	push	edx
	mov	eax, DWORD PTR $T240065[ebp]
	push	eax
	call	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
$LN6@Chunked_me@2:

; 3454 : 		}
; 3455 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z	; std::_Temp_iterator<unsigned char>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240112 = -36						; size = 4
__Next$240120 = -32					; size = 4
$T240073 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T240073[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z ; std::_Temp_iterator<unsigned char>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T240073[ebp]
	or	eax, 1
	mov	DWORD PTR $T240073[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN31@Copy_opt
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$240120[ebp], ecx
	jmp	SHORT $LN29@Copy_opt
$LN28@Copy_opt:
	mov	edx, DWORD PTR __Next$240120[ebp]
	add	edx, 1
	mov	DWORD PTR __Next$240120[ebp], edx
$LN29@Copy_opt:
	mov	eax, DWORD PTR __Next$240120[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN27@Copy_opt
	jmp	SHORT $LN28@Copy_opt
$LN27@Copy_opt:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240112[ebp], ecx
	mov	edx, DWORD PTR $T240112[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240211 = -72						; size = 4
$T240210 = -68						; size = 4
$T240193 = -62						; size = 1
$T240192 = -61						; size = 1
$T240191 = -60						; size = 4
$T240190 = -56						; size = 4
__Off$240206 = -52					; size = 4
__Result$240207 = -48					; size = 4
__Cat$240200 = -40					; size = 1
$T240198 = -39						; size = 1
$T240197 = -38						; size = 1
$T240196 = -37						; size = 1
$T240171 = -36						; size = 4
$T240170 = -32						; size = 4
$T240153 = -26						; size = 1
$T240152 = -25						; size = 1
$T240151 = -24						; size = 4
$T240150 = -20						; size = 4
__Off$240166 = -16					; size = 4
__Result$240167 = -12					; size = 4
__Cat$240160 = -4					; size = 1
$T240158 = -3						; size = 1
$T240157 = -2						; size = 1
$T240156 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First1$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR __First2$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 1
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge
$LN2@Merge:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 1
	mov	DWORD PTR __First1$[ebp], eax
$LN1@Merge:
	jmp	SHORT $LN4@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240171[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T240170[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T240156[ebp], al
	mov	cl, BYTE PTR __Cat$240160[ebp]
	mov	BYTE PTR $T240157[ebp], cl
	mov	dl, BYTE PTR $T240156[ebp]
	mov	BYTE PTR $T240153[ebp], dl
	mov	al, BYTE PTR $T240158[ebp]
	mov	BYTE PTR $T240152[ebp], al
	mov	ecx, DWORD PTR $T240171[ebp]
	mov	DWORD PTR $T240151[ebp], ecx
	mov	edx, DWORD PTR $T240170[ebp]
	mov	DWORD PTR $T240150[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	sub	eax, DWORD PTR $T240150[ebp]
	mov	DWORD PTR __Off$240166[ebp], eax
	mov	ecx, DWORD PTR $T240151[ebp]
	add	ecx, DWORD PTR __Off$240166[ebp]
	mov	DWORD PTR __Result$240167[ebp], ecx
	cmp	DWORD PTR __Off$240166[ebp], 0
	jle	SHORT $LN8@Merge
	mov	edx, DWORD PTR __Off$240166[ebp]
	push	edx
	mov	eax, DWORD PTR $T240150[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$240166[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240151[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Merge:
	mov	eax, DWORD PTR __Result$240167[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240211[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T240210[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T240196[ebp], al
	mov	cl, BYTE PTR __Cat$240200[ebp]
	mov	BYTE PTR $T240197[ebp], cl
	mov	dl, BYTE PTR $T240196[ebp]
	mov	BYTE PTR $T240193[ebp], dl
	mov	al, BYTE PTR $T240198[ebp]
	mov	BYTE PTR $T240192[ebp], al
	mov	ecx, DWORD PTR $T240211[ebp]
	mov	DWORD PTR $T240191[ebp], ecx
	mov	edx, DWORD PTR $T240210[ebp]
	mov	DWORD PTR $T240190[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	sub	eax, DWORD PTR $T240190[ebp]
	mov	DWORD PTR __Off$240206[ebp], eax
	mov	ecx, DWORD PTR $T240191[ebp]
	add	ecx, DWORD PTR __Off$240206[ebp]
	mov	DWORD PTR __Result$240207[ebp], ecx
	cmp	DWORD PTR __Off$240206[ebp], 0
	jle	SHORT $LN17@Merge
	mov	edx, DWORD PTR __Off$240206[ebp]
	push	edx
	mov	eax, DWORD PTR $T240190[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$240206[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240191[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN17@Merge:
	mov	eax, DWORD PTR __Result$240207[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240293 = -72						; size = 4
$T240292 = -68						; size = 4
$T240275 = -62						; size = 1
$T240274 = -61						; size = 1
$T240273 = -60						; size = 4
$T240272 = -56						; size = 4
__Off$240287 = -52					; size = 4
__Result$240288 = -48					; size = 4
__Cat$240281 = -40					; size = 1
$T240279 = -39						; size = 1
$T240278 = -38						; size = 1
$T240277 = -37						; size = 1
$T240253 = -36						; size = 4
$T240252 = -32						; size = 4
$T240235 = -26						; size = 1
$T240234 = -25						; size = 1
$T240233 = -24						; size = 4
$T240232 = -20						; size = 4
__Off$240247 = -16					; size = 4
__Result$240248 = -12					; size = 4
__Cat$240241 = -4					; size = 1
$T240239 = -3						; size = 1
$T240238 = -2						; size = 1
$T240237 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
$LN8@Merge_back:

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240253[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T240252[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T240237[ebp], al
	mov	cl, BYTE PTR __Cat$240241[ebp]
	mov	BYTE PTR $T240238[ebp], cl
	mov	dl, BYTE PTR $T240237[ebp]
	mov	BYTE PTR $T240235[ebp], dl
	mov	al, BYTE PTR $T240239[ebp]
	mov	BYTE PTR $T240234[ebp], al
	mov	ecx, DWORD PTR $T240253[ebp]
	mov	DWORD PTR $T240233[ebp], ecx
	mov	edx, DWORD PTR $T240252[ebp]
	mov	DWORD PTR $T240232[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	sub	eax, DWORD PTR $T240232[ebp]
	mov	DWORD PTR __Off$240247[ebp], eax
	mov	ecx, DWORD PTR $T240233[ebp]
	sub	ecx, DWORD PTR __Off$240247[ebp]
	mov	DWORD PTR __Result$240248[ebp], ecx
	cmp	DWORD PTR __Off$240247[ebp], 0
	jle	SHORT $LN11@Merge_back
	mov	edx, DWORD PTR __Off$240247[ebp]
	push	edx
	mov	eax, DWORD PTR $T240232[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$240247[ebp]
	push	ecx
	mov	edx, DWORD PTR __Result$240248[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN11@Merge_back:
	mov	eax, DWORD PTR __Result$240248[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	mov	eax, DWORD PTR __First2$[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240293[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T240292[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T240277[ebp], al
	mov	cl, BYTE PTR __Cat$240281[ebp]
	mov	BYTE PTR $T240278[ebp], cl
	mov	dl, BYTE PTR $T240277[ebp]
	mov	BYTE PTR $T240275[ebp], dl
	mov	al, BYTE PTR $T240279[ebp]
	mov	BYTE PTR $T240274[ebp], al
	mov	ecx, DWORD PTR $T240293[ebp]
	mov	DWORD PTR $T240273[ebp], ecx
	mov	edx, DWORD PTR $T240292[ebp]
	mov	DWORD PTR $T240272[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	sub	eax, DWORD PTR $T240272[ebp]
	mov	DWORD PTR __Off$240287[ebp], eax
	mov	ecx, DWORD PTR $T240273[ebp]
	sub	ecx, DWORD PTR __Off$240287[ebp]
	mov	DWORD PTR __Result$240288[ebp], ecx
	cmp	DWORD PTR __Off$240287[ebp], 0
	jle	SHORT $LN20@Merge_back
	mov	edx, DWORD PTR __Off$240287[ebp]
	push	edx
	mov	eax, DWORD PTR $T240272[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$240287[ebp]
	push	ecx
	mov	edx, DWORD PTR __Result$240288[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN20@Merge_back:
	mov	eax, DWORD PTR __Result$240288[ebp]
	jmp	SHORT $LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	eax, DWORD PTR __Last1$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Last1$[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Last2$[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR __Last1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Last2$[ebp]
	add	edx, 1
	mov	DWORD PTR __Last2$[ebp], edx

; 2847 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR __Last1$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Last1$[ebp], ecx
$LN5@Merge_back:
	jmp	$LN8@Merge_back
$LN9@Merge_back:

; 2849 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z
_TEXT	SEGMENT
$T240313 = -20						; size = 4
__Count2$229441 = -12					; size = 4
__Mid$229442 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z PROC ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2288 : 	{	// find first element not before _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2292 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240313[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T240313[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$229441[ebp], eax

; 2296 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$229442[ebp], edx

; 2297 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Mid$229442[ebp]
	add	eax, DWORD PTR __Count2$229441[ebp]
	mov	DWORD PTR __Mid$229442[ebp], eax

; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Mid$229442[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$229442[ebp]
	add	eax, 1
	mov	DWORD PTR __Mid$229442[ebp], eax
	mov	ecx, DWORD PTR __Mid$229442[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$229441[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$229441[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Lower_boun:

; 2304 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2305 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2306 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ENDP ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z
_TEXT	SEGMENT
$T240350 = -20						; size = 4
__Count2$229450 = -12					; size = 4
__Mid$229451 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z PROC ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2359 : 	{	// find first element that _Val is before, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2363 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240350[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T240350[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$229450[ebp], eax

; 2367 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$229451[ebp], edx

; 2368 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Mid$229451[ebp]
	add	eax, DWORD PTR __Count2$229450[ebp]
	mov	DWORD PTR __Mid$229451[ebp], eax

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	ecx, DWORD PTR __Mid$229451[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$229451[ebp]
	add	eax, 1
	mov	DWORD PTR __Mid$229451[ebp], eax
	mov	ecx, DWORD PTR __Mid$229451[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$229450[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$229450[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Upper_boun:

; 2375 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2376 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2377 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ENDP ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
$T240413 = -76						; size = 16
$T240384 = -20						; size = 4
$T240378 = -12						; size = 4
$T240377 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T240378[ebp], eax
	lea	ecx, DWORD PTR $T240413[ebp]
	mov	DWORD PTR $T240377[ebp], ecx
	mov	edx, DWORD PTR $T240378[ebp]
	mov	eax, DWORD PTR $T240377[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T240377[ebp]
	mov	ecx, DWORD PTR $T240378[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T240384[ebp], esp
	mov	ecx, DWORD PTR $T240384[ebp]
	mov	edx, DWORD PTR $T240413[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T240413[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T240413[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR $T240384[ebp]
	mov	ecx, DWORD PTR $T240413[ebp+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, 16					; 00000010H
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 4
	push	edx
	push	0
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z
_TEXT	SEGMENT
tv94 = -20						; size = 4
_this$ = -16						; size = 4
$T240426 = -12						; size = 4
__Vptr$240424 = -8					; size = 4
__Ptr$229541 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z PROC		; std::_Temp_iterator<unsigned char>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@4

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+4], eax

; 565  : 		else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Ptr$229541[ebp], edx

; 569  : 			_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$229541[ebp]
	mov	DWORD PTR __Vptr$240424[ebp], eax
	mov	ecx, DWORD PTR __Vptr$240424[ebp]
	mov	DWORD PTR $T240426[ebp], ecx
	cmp	DWORD PTR $T240426[ebp], 0
	je	SHORT $LN7@operator@4
	mov	edx, DWORD PTR $T240426[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR $T240426[ebp]
	mov	DWORD PTR tv94[ebp], edx
	jmp	SHORT $LN5@operator@4
$LN7@operator@4:
	mov	DWORD PTR tv94[ebp], 0
$LN5@operator@4:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator@4:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z ENDP		; std::_Temp_iterator<unsigned char>::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Result$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0
__ehfuncinfo$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T240463 = -40						; size = 4
__Next$240471 = -36					; size = 4
$T240455 = -32						; size = 4
$T240441 = -24						; size = 4
$T240437 = -20						; size = 4
$T240436 = -14						; size = 1
$T240435 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T240441[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T240435[ebp], al
	movzx	ecx, BYTE PTR $T240435[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T240436[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T240437[ebp], esp
	mov	DWORD PTR $T240455[ebp], ecx
	mov	edx, DWORD PTR $T240455[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T240455[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T240455[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T240455[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T240455[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T240455[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>
	add	esp, 52					; 00000034H
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR $T240441[ebp]
	or	edx, 1
	mov	DWORD PTR $T240441[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@5
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$240471[ebp], eax
	jmp	SHORT $LN15@unchecked_@5
$LN14@unchecked_@5:
	mov	ecx, DWORD PTR __Next$240471[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$240471[ebp], ecx
$LN15@unchecked_@5:
	mov	edx, DWORD PTR __Next$240471[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@5
	jmp	SHORT $LN14@unchecked_@5
$LN13@unchecked_@5:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240463[ebp], eax
	mov	ecx, DWORD PTR $T240463[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@5:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@2:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv165 = -112						; size = 4
tv164 = -108						; size = 4
tv160 = -104						; size = 4
tv159 = -100						; size = 4
$T240584 = -96						; size = 4
__Next$240592 = -92					; size = 4
$T240576 = -88						; size = 4
$T240556 = -84						; size = 4
__Next$240564 = -80					; size = 4
$T240548 = -76						; size = 4
$T240544 = -72						; size = 4
$T240493 = -44						; size = 4
$T240487 = -40						; size = 4
$T240486 = -36						; size = 20
$T240485 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T240493[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@2:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR __First1$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z ; std::_Temp_iterator<unsigned char>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 1
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge@2

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN28@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z ; std::_Temp_iterator<unsigned char>::operator=
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 1
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@2:
	jmp	SHORT $LN5@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T240485[ebp], esp
	mov	DWORD PTR $T240544[ebp], edx
	mov	eax, DWORD PTR $T240544[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T240544[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T240544[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T240544[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T240544[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T240544[ebp]
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T240486[ebp]
	push	eax
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR $T240548[ebp], ecx
	mov	edx, DWORD PTR $T240548[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T240486[ebp], 0
	je	SHORT $LN50@Merge@2
	mov	ecx, DWORD PTR $T240486[ebp]
	mov	DWORD PTR __Next$240564[ebp], ecx
	jmp	SHORT $LN48@Merge@2
$LN47@Merge@2:
	mov	edx, DWORD PTR __Next$240564[ebp]
	add	edx, 1
	mov	DWORD PTR __Next$240564[ebp], edx
$LN48@Merge@2:
	mov	eax, DWORD PTR __Next$240564[ebp]
	cmp	eax, DWORD PTR $T240486[ebp+8]
	je	SHORT $LN46@Merge@2
	jmp	SHORT $LN47@Merge@2
$LN46@Merge@2:
	mov	ecx, DWORD PTR $T240486[ebp]
	mov	DWORD PTR $T240556[ebp], ecx
	mov	edx, DWORD PTR $T240556[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T240487[ebp], esp
	mov	DWORD PTR $T240576[ebp], eax
	mov	ecx, DWORD PTR $T240576[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T240576[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T240576[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T240576[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T240576[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T240576[ebp]
	mov	DWORD PTR tv164[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv165[ebp], eax
	mov	edx, DWORD PTR $T240493[ebp]
	or	edx, 1
	mov	DWORD PTR $T240493[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN64@Merge@2
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$240592[ebp], eax
	jmp	SHORT $LN62@Merge@2
$LN61@Merge@2:
	mov	ecx, DWORD PTR __Next$240592[ebp]
	add	ecx, 1
	mov	DWORD PTR __Next$240592[ebp], ecx
$LN62@Merge@2:
	mov	edx, DWORD PTR __Next$240592[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN60@Merge@2
	jmp	SHORT $LN61@Merge@2
$LN60@Merge@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T240584[ebp], eax
	mov	ecx, DWORD PTR $T240584[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN64@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z
_TEXT	SEGMENT
tv84 = -40						; size = 4
tv76 = -36						; size = 4
__Hole$229666 = -32					; size = 4
__Holeval$229668 = -25					; size = 1
__Next1$229669 = -24					; size = 4
__Next$229667 = -20					; size = 4
__Tmp$229661 = -16					; size = 4
__Factor$229657 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z PROC		; std::_Rotate<unsigned char *,int,unsigned char>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$229657[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$229657[ebp], 0
	je	SHORT $LN7@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$229657[ebp]
	mov	DWORD PTR __Tmp$229661[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$229657[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$229661[ebp]
	mov	DWORD PTR __Factor$229657[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate
$LN7@Rotate:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	cmp	DWORD PTR __Count$[ebp], edx
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Hole$229666[ebp], ecx

; 1695 : 			_RanIt _Next = _Hole;

	mov	edx, DWORD PTR __Hole$229666[ebp]
	mov	DWORD PTR __Next$229667[ebp], edx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	eax, DWORD PTR __Hole$229666[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR __Holeval$229668[ebp], cl

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Next$229667[ebp]
	add	edx, DWORD PTR __Shift$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	ecx, DWORD PTR __Next$229667[ebp]
	add	ecx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
$LN12@Rotate:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR __Next1$229669[ebp], edx
$LN2@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	mov	eax, DWORD PTR __Next1$229669[ebp]
	cmp	eax, DWORD PTR __Hole$229666[ebp]
	je	SHORT $LN1@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	ecx, DWORD PTR __Next$229667[ebp]
	mov	edx, DWORD PTR __Next1$229669[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 1701 : 				_Next = _Next1;

	mov	ecx, DWORD PTR __Next1$229669[ebp]
	mov	DWORD PTR __Next$229667[ebp], ecx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Next1$229669[ebp]
	cmp	DWORD PTR __Shift$[ebp], edx
	jge	SHORT $LN13@Rotate
	mov	eax, DWORD PTR __Next1$229669[ebp]
	add	eax, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __Next1$229669[ebp]
	mov	edx, DWORD PTR __Shift$[ebp]
	sub	edx, ecx
	add	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Next1$229669[ebp], eax

; 1704 : 				}

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Next$229667[ebp]
	mov	dl, BYTE PTR __Holeval$229668[ebp]
	mov	BYTE PTR [ecx], dl

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z ENDP		; std::_Rotate<unsigned char *,int,unsigned char>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T240648 = -2092					; size = 4
$T240647 = -2088					; size = 4
$T240646 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T240646[ebp], eax
	mov	ecx, DWORD PTR $T240646[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T240647[ebp], eax
	mov	eax, DWORD PTR $T240647[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T240648[ebp], eax
	mov	ecx, DWORD PTR $T240648[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T240659 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240659[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T240659[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T240671 = -8						; size = 4
$T240667 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240667[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T240667[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T240671[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T240671[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
